Welcome to Coda Radio, Jupiter Broadcasting's weekly talk show exploring the art and business
of software development and related technologies.
My name is Wes and I am just so lucky to be joined with that sorcerer of software, the
one, the only, Mr. Michael Dominic.
You just sound so much better than Chris.
Oh, that's right I do.
I'm so flattered.
You sound pretty good today too.
Thanks, sir.
What planet do you find yourself on?
Oh, well, the swamps of Riverview, Florida as usual.
Me and Jar Jar.
Yeah, you guys are just best buds down there, it seems like.
Just best buds.
You let them play in your pool, you're hanging out, you're smoking cigars together.
It's a wild scene.
That's right.
That's right.
Well, thank you for having me here with you today, Mike.
Chris is still away, but that can't stop us.
There's code to talk about.
Can't stop the code.
Heck, no.
Well, maybe you can though.
We've got some feedback to start off the show.
It starts off pretty strong.
Yeah, they're coming in pretty hot here.
So Joe writes in and I'm going to read it, but first I'd like to summarize it.
Joe would like to know what the hell is wrong with me.
I haven't really read this yet, but I want to know too.
So Joe says blah, I'm not sure I get that part.
Why.NET?
It's a dead end.
It doesn't have support on any other systems.
Yes, technically it has had Xamarin, but let's be realistic.
There's no good front end for Linux.
Not true anymore, but we'll get to it.
I have known about Qt for a long time.
Back when he did more C++ programming, I looked at various ways to do cross-platform development.
He avoids Qt, he says, because the license now in C++ is using WX widgets, which actually
a few other people have recommended and I'll talk about it in a minute.
Nowadays he's a Java programmer and yeah, I'm summarizing this a little long, but he
says JavaScript looks like a spaghetti nightmare from the 70s.
The man does not mince words.
You have to respect him.
I appreciate that.
Yeah, props, Joe, props.
And I mean, that's right.
I mean, it does look like that.
Yeah, it really does.
So point by point, right?
Oh, and he says go Pats for the football season, which really undercuts the rest of
your email.
Just don't mention that you're a Patriots fan.
So simple answer, right?
The product I am launching next week, yay, and Linux, but mostly Windows.
So.NET's a pretty natural choice.
The aerospace industry tends to love them some Microsoft.
Right?
Yeah.
I mean, if you already have support for the runtime there, you should reintroduce your
product real quick there.
You cut out for a split second.
So it's launching next week, so I can't say anything about it yet.
Ah, yeah, okay.
We just missed a tiny bit.
But you said it mostly runs on, you're mostly targeting Windows?
Yeah, yeah.
I think like about like nine out of 10 installs are going to be Windows.
Got it.
Okay, interesting.
In terms of Q, yeah, that was a, Wes, have you taken a look at Q in a while?
No, you know, honestly, it's been a couple of years since I've really, you know, gotten
down and ready and had a new project that I was playing with it.
Yeah, yeah.
I was looking at it recently, and I just got tripped up on the licensing.
That seems especially complicated if you're not just playing solely in the open source
world.
Yeah, it is.
Yeah, and we had an episode on the whole LGPL, and then it being by component was pretty
confusing.
So does that mean that you've kind of just, is that written off for you now?
Not a path you're going to be?
Yeah, it's written off for now.
Got it, yeah.
Just exploring other ways to accomplish the same thing.
Yeah, the pricing to be compliant with the license was going to be just way too high.
So yeah, you know, everybody loves Java, not trying to knock Java.
I know Wes is a big Java fan, right?
You know, I have nothing against Java.
I don't want to build certain things with it, but as a building block to build big systems,
it's come a long way.
I like the newer Javas as well when you have, you know, a little more functional influence.
That's a much more pleasant language.
Yeah, yeah.
So yeah, I appreciate the email, Joe, and a lot about Wes, unless you have anything
else here on WX widgets.
I did look at it.
I don't, I have not used it yet, so I can't really speak to.
No, I can't either, although I guess I've seen a lot of things written in it.
I don't know if they were beautiful, but if you just want to go for a functional, seems
like it's certainly up to the task.
There you go.
So next on the docket, a similar comment I got on YouTube and a Twitter question.
Quite a lot was, why not Tornado FX?
Are you familiar with this at all?
Oh no, what's Tornado FX?
This is actually keeping in line with Joe's Java mentioned.
This is a version of Java FX that uses Kotlin.
Oh, okay.
Well that, that sounds pretty nice actually.
It, yeah, it does look pretty, pretty sexy if I say so myself, but it's a little too
new for me to want to ship in a production project.
Right.
I mean, Kotlin itself isn't really that old yet, and yeah, it seems like this product,
it's moving pretty quickly.
But oh yeah, as they say here, not yet compatible with Java 9 or 10 yet.
So yeah, clearly there's some stabilizing to do.
Yeah.
There's some weirdness with Kotlin and different Java versions, as I've learned the hard way.
Really?
That's actually, I had not heard that complaint before.
I've almost always heard pleasant things about Kotlin so far.
Yeah.
Well, I don't think it's currently true, but when Java 10 came out, it was actually not
compatible with Kotlin.
Oh yeah.
Okay.
I suppose there's always bound to be, bound to be a little leg when you have big changes
underneath.
Yeah, exactly.
It can't be easy, Mike.
This is software.
What are you, what are you thinking over there?
What?
I'm sorry.
I'm just, I'm just, you know, I'm just lost.
Yeah, that's right.
Well, so last I heard you had done something terrible to your phone.
Is that, is it still in a state of disrepair?
It is still in a state of disrepair because I refuse to pay the exorbitant 200 and something
dollars Apple wants for screen replacement.
Oh, ouch.
Yeah, that's a, that'll burn a hole in your pocket real quick.
So speaking of losing money, Fortnite, 15 million downloads by sidestepping the Google
Play Store on Android.
Wow.
Woo wee.
That is, I'm impressed.
That's got it.
I'm impressed.
That's got to be significant, significant revenue loss there for Google.
Right?
I mean, yeah, they're pulling a pretty big cut from, you'd presume a lot of those would
have come through them otherwise.
Yeah.
And with a 30% every in-app purchase.
Do you, would this work, would this strategy work for a less popular application?
I mean, obviously Fortnite has a ton of momentum in mind.
People already know about it.
They don't need discoverability really on the store and they just, you know, and they're
already motivated to download it.
Yeah.
Would this work for something like, could you go around the Play Store and have any
kind of this success?
No, no.
No.
And actually we should mention that for a few days there, Fortnite actually was the
victim of a man in the middle attack where, yeah, people were getting infected APKs and
Google very publicly pointed it out in, right?
But I guess this is what happens when you skip on all our niceties.
Circumvent the app store.
It's certainly interesting though.
Yeah.
That 30% cut feels, you know, very outmoded.
It really kind of feels pretty steep.
It really is.
Yeah.
And it's like, it adds to the weird walled garden effect and it doesn't, you know, that's
useful what they do, but 30%, you know, like a standard, a more standard listing fee.
Seems like it would just encourage more and better apps on the ecosystem anyway.
One more financially sustainable for the developers, even if they are just doing advertising or
support.
Yeah, exactly.
So tell me about Loom.
This is your thing.
Yeah.
Oh yeah.
So let's just move right along.
Cause we've got a, you know, this show, it's gotta, it's gotta move.
So Mike, we were just talking about JavaScript, right?
And well, it's funny because a lot of people liked node because of the concurrency story,
right?
It could, it could do, you know, 10, 10 X connections.
It could scale those connections and had that event loop built right in.
But the downside is of course you've got asynchronous JavaScript, which can just be a big old mess
of callbacks.
Right?
I don't know.
What's your, where do you fall?
What do you usually do when you need, you know, concurrent software?
What's your tool set?
Oh, it depends on the language.
I mean, if I'm in.net or really anything else that supports a sync away, I tend to lean
on that.
Um, but yeah, in JavaScript I'm, I'm living in callback hell.
Okay.
That, that makes sense.
Um, how do you like async await over in the.net world?
I like it.
It so it's a really, it's a really big, my opinion is a huge abstraction and well 99%
of the time I think it's great.
It saves me from, you know, just having really ugly looking code that's hard to maintain
every once in a while you get like weird edge cases where you accidentally lock something
up or things don't finish the way you think they're going to finish.
Oh yeah.
And then you have some bad concurrency states and everything goes to hell.
Yeah.
Cause what it's doing is every time you, you type the await keyword and it compiles, it's
actually generating a bunch of code behind that.
And it's, it's, so it's not like, it's not removing the need for crazy callbacks and
concurrent.
Right.
It just, the compiler like makes you a state machine to do all of that for you.
Exactly.
Yeah, exactly.
Well, we can dive into it later if we want, but Clojure's got this similar mechanism.
There's is just shipped as a macro, the go macro, which will implement basically the
same idea.
Um, so that's, so that's one way of people that people deal with it, right?
So we have, you've got like bear callbacks, um, promises are being seen a lot these days,
which sort of revise it up one level.
At least then you've got something you can, you know, hold in a variable you can interact
with.
Uh, it's a little more than just waiting, knowing it's sitting in the queue to be executed
somewhere in the runtime.
And then you've got compiler options where the compiler or a macro or something can help
you manage some of the complexity.
But we've got a link in the show notes for a great article that talks about what color
is your function and that, that a synchronicity can leak throughout your code base and anytime
you touch it, you sort of start to feel it.
Project Loom is trying to solve some of that by going one level deeper and trying to fix
it at the runtime.
So one thing that, uh, you know, a number of languages that are thought of as good for
concurrency like Go or Erlang, well, they've got some lightweight threads and that's something
Java, there was, there was proposals way back in the day, but it really has never been there.
And we just have to rely on either async callbacks in Java or regular old blocking calls.
Obviously that has problems scaling, enter project loom and fibers, which are lightweight
threads you can use as if they were just OS threads.
The JVM will manage running those on actual physical cores on OS threads for you.
Interesting.
So have you, have you been able to use this yet?
I've played with, uh, so it looks like the, there was previously a project called Quasar,
which did this already, but basically looked at the generated byte code and did some, some
introspecting and changing and modifying of it on the fly to achieve the same effect because
it wasn't supported upstream in the JVM.
That the person behind that project is now working for Oracle and working on project
loom as well with some other researchers, of course.
So I've used that earlier incarnation a little bit, not in production or anything too serious,
but it was neat.
And I have played with, uh, well, I've mostly played with Elixir, but I've used the beam
VM, uh, which has similar lightweight threads.
They call them processes over there.
Interesting, interesting.
And remind me, I don't want to let you off the hook cause you mentioned Elixir.
So I have to hear the pitch for Elixir, but what I didn't understand from reading this
was it looks like it's still calling OS, uh, threads on the, underneath it all, right?
Yes, it does.
Okay.
Uh, but it can implement, it's basically taking the, um, like the parking that happens in
that state machine.
Um, we were talking about for like async await, uh, it's taking that and being able to do
it at the runtime layer.
So once you're running on these lightweight threads, it can figure out that you're blocked
waiting for some IO and it'll just park that, it'll schedule it off a real OS thread.
And then once that input's received, it can put it back on the thread and then mostly
it's going to be built, I think just on top of the regular fork join.
So they've just got the scheduling layer on top.
Layer on top.
Right.
And theoretically being the JVM, you would avoid any weird issues with like different
threadings on different OS's being.
Yeah, you would hope that the VM would have that abstraction there for you.
Right.
Looks to scan at windows 10 because thanks guys.
Yeah, exactly.
So this was just appealing for me because it seems like a pretty clean, if you, if they
get it right, it seems like a nice thing to be able to build upon because instead of having
to, you know, have either just like you can do a thread, let's say you're making some
long running HTTP request.
If you put each of those on the thread, well that'll just only scale so far.
And that's why a lot of people have been driven to asynchronous APIs in the first place.
With this you get the best of both worlds.
You can write your code.
It looks like it's just regular blocking code and in some sense it is, it's just managed
below that layer for you.
So you can have a green thread per HTTP request and you don't have to care about it and it'll
just handle all the scheduling so that they execute in the order they need to.
Wow.
We are living in a world of asynchronous abstraction glory.
I know, right?
So this is probably a long way off to actually see it in production and in production JVM
on your servers.
But I'm glad that it's happening because, you know, the JVM, it just remains so popular.
So many places use it.
It's, it is a powerhouse.
It's got some of the best just in time compiling out there.
So many man hours have been used for it.
Not everyone loves it.
It's kind of weird, especially when you're dealing with, I don't know, weird class path
construction or the way it handles certificates, which are just absolutely deplore.
Yeah.
Either way, it's fast and it's been battle tested over a lot of years.
So if we can get even better concurrency primitives on it, there's a huge amount of programmers
that stand to benefit.
Oh yeah.
No, I could, yeah, for large scale JV Java based applications, that would be pretty significant.
Absolutely.
So you mentioned Elixir.
So elevator pitch me, what are you doing in Elixir and why Elixir?
I made a couple of toy projects.
I haven't done anything too serious.
I'd always just been curious about the beam VM.
It has an interesting history coming out of the telecommunications industry and Ericsson
in particular.
And it's been widely respected in like VoIP circles for running a lot of those hardware
appliances and software projects and being scalable and low latency.
Elixir is, well, Erlang came out, the first version was actually just in prologue.
So it has weird prologue like syntax, which is not everyone's piece of cake.
I can understand that.
Elixir is a new language that sits on top of the beam VM, inherits a lot from Erlang,
is inspired by Erlang, but it comes with a friendlier, more, they call it Ruby inspired.
It's not really like Ruby, but it's got the basic sort of syntax, you know, if you squint
at the screen, it looks like Ruby and it's a lot more traditional.
It's also just a little more, Erlang's great, but it came out of the late 80s, 90s, that
era is when it first saw a lot of its growth.
So it's just a bit dated.
Elixir has a lot more niceties, more like a literal syntax for different sort of data
structures, more just sugar, I would say.
Okay.
So it's in a lot of ways like a modernized.
Yeah.
Yep.
I would say so.
You know, there's anyone who loves both those languages would have a, that would be, should
be shouting at us right now because there's a lot more intricacies for that and there's
a large community with a lot of history that I can't capture in a 10 second spiel.
But yes, they share a lot of that same background and they fit really well for those same things.
So famously like Erlang runs the WhatsApp servers and it works really well for that
because you can get lots of, lots of simultaneous connections.
All of the just like, yeah, they have a weird stack.
It's FreeBSD and Erlang.
So both kind of secret weapons, I guess, and they have big honking.
There's always those BSD guys at the show, right, at the trade show.
There has to be.
Yeah.
And it's, you know, it's part of the community.
And so they got these big honking BSD servers running Erlang and just getting millions of
concurrent connections to them.
And you know, they're not necessarily like, the beam is not as fast for computational
things as the JVM is.
But if you're just doing like message passaging, some web sockets, maybe is a use this sees
a lot where you want low latency, fast response, and just to shove some signaling data through
rather than like a big pipe of real data beams your guy.
Very cool.
Yeah.
I was actually just at a dev meetup and there was like three guys just like hunched over
their MacBooks.
Yes, they were MacBooks.
And just I walked up and said, hey, what are you guys working on?
Oh, we're doing something in Elixir.
I said, what?
Why?
You know, cause you go to these things, 90% of the people that are like making websites
or iOS apps, right?
Totally.
Yeah.
Yeah.
None of it's like crazy.
Just run of the mill software projects.
Yeah.
Run of the mill normal stuff.
But yeah, I keep hearing about it and I keep trying to figure out what the actual use case
I've heard the view over IP thing before.
I didn't know about what's out there.
That's pretty cool.
Yeah.
I think the other thing about Elixir, which maybe makes it a good story for people just
getting into it is it does have a lot of those nice primitives.
It's got a good functional programming story, mutabilities there.
It also has great documentation and the creator of the language, I think his name's Jose Valim.
He's just, he's awesome.
He does, he goes to conferences, does all kinds of good spieling about it in the documentation.
It's geared towards new users.
It's easy to get started.
It's probably already in, you know, it's in brew.
It's in a lot of package managers.
You get a nice little interactive rebel to play with it.
It's just super fun to get started with.
I haven't, yeah, I haven't used it for anything serious, but it was so easy to get started.
I was like, there's really no excuse.
I'll try to do a couple of things.
And it is fun to be thinking in that concurrency style where you can just make a process for
whatever.
You have processes to store data.
You have processes to make HTTP requests.
You have processes to do basically anything you want.
And that Erlang VM in its ADC glory handles all the scheduling.
That's really awesome.
Yeah.
The other nice part too is you get access to OTP, which is the open telephony system
or protocol project, whatever the P stands for.
That is a lot of the stuff that gets bundled with Erlang.
It's its own project, but has historically been developed with Erlang and it adds a lot
of sort of the redundancy fault tolerance supervision structure that Erlang is known
for because you know, when you're running a big telco switch, you can't really tolerate
very much downtime.
So it's good at things like hot reloading and it's really good at instead of having
to deal with all the error pads, you just sort of set up a tree of supervised actors
and you can configure things like a restart, how many retries should I do before I fail
up to the next level?
And how do I restart or, you know, do I have things I need to do before I run or after
I run?
And all of that's in that library for you.
So you can, it really has like primitives to build a distributed system in a reliable
way baked right into the runtime and the popular libraries.
Very cool.
So Closures is not your true, true love, is it?
No, no, it wouldn't be.
That's still Closure, of course.
Ah, lay it on me, man.
You know, I've just been really enjoying it.
There's been some good developments going on since the last time we talked about it.
In particular, the Closure community, I mean, lots of communities are good.
It's a little bit, it's small enough that it can have a character of its own.
Of course, there's still different pieces of it and all kinds of unique personalities
that are involved, but it's a unique set of, Clojure's not often a first programmer's language.
It's sort of a grumpy old programmer's language who got sick of fighting Java or JavaScript
or whatever else and wanted something better.
So it can be tough, a bit tough for people to pick up for the first language, but as
a result, most of the people doing it are experienced senior programmers.
So you get a lot of, there's a lot of maturity in the community, and while they have a lot
of respect for academia, and one of the things they love to do as a community is pull great
ideas from papers from the 70s and then implement them, but they do that with an air to being
pragmatic because they all work at day jobs programming and just want to get stuff done
and build reliable systems.
So it's like.NET, but stable.
I'm kidding.
Yeah, totally.
Totally.
It even runs on.NET.
There's a version that compiles to the CLR.
It's not much used compared to the JVM or JS, but there is a project to get it to run
well on mono and then you can hook it up to Unity, which is kind of neat.
That would be the most hardcore game on Humble Bundle.
You mentioned JS.
Now is that JS via transpiling to JavaScript or is it WebAssembly?
Yes, it is ClojureScript, which is a project written in Clojure that is a compiler that
compiles a Clojure-like dialect.
They're like 98% the same to JavaScript.
It's Clojure inception there.
ClojureScript is written in Clojure and what ClojureScript does is it compiles a dialect
of Clojure?
Yes.
And then it compiles that to JavaScript.
Let me spin my little thing here to see if I'm awake or not.
So theoretically you're writing an application, again Clojure is one that I haven't done anything
but I've been curious.
You're writing an application.
I'm assuming you're writing server software and you need some sort of front end because
that's life.
People want to look at your data that you've spent all this time making for them.
Shocking.
You can't just say the data's there, I promise.
I've got a JSON blob for you if you want to go send a GET request over here.
Does that work?
If I really don't like you it's going to be XML.
Is your full stack Clojure?
Obviously you probably have CSS and all that.
That is one of the compelling stories for ClojureScript is you can have full stack and
you can share a lot of it because it's mostly just all the host primitives that are going
to end up different.
There's now compiler support so you can have a project that has three types of files, a
.clj for pure Clojure, a.cljs for ClojureScript, and a.cljc which can be compiled as either.
So you can have a bunch of definitions of things, you can have protocols implemented
or any kind of abstraction that isn't going to see a direct implementation on top of the
host.
All of that can be shared in these.cljc files and then you can just implement the pull from
that big standard library that you've made yourself there from both sides of it.
So you can reuse your standard library?
Yes.
So your standard library, it's not just...
Yeah, right.
So you can make any sort of amount of code as long as, I mean, sometimes you need to
have slight differences for the two platforms.
But by and large, you can see projects where most of it is written in CLJC and then they've
got a couple, you know, oh, here's a couple of things that we've got to do, the thread
in on the server part, and here's the thing we've got to do, the UI part, or...
So it's pretty flexible in that regard.
And you can see a lot of, you know, they have the same data structures, and so there's several
neat projects that have libraries for both the back end and the front end, and it does
all the serialization and stuff for you.
There's already several formats, one that's very fast, one that's very human readable,
to handle Clojure data structures back and forth.
So you can have...
One of them, I think it's Sente, it's like a WebSocket abstraction, you can just have
a WebSocket between your server and your client and just throw Clojure data structures across
it and pick it up and you don't have to, there's no, you know, no mapping to different objects
and different object systems between the languages, there's just a low impedance and it works
really nicely.
So is there like a popular development framework where obviously Python has like Django, Ruby
has Rails?
No, that's a good question.
That's another thing Elixir has going forward is they've got Phoenix, which is a popular
framework which is compared to Rails.
Clojure not really, that is one aspect of its community that's a bit odd is it's almost
like the Unix philosophy, there's a lot of composition, so they really tend to prefer
libraries from frameworks, and I think again this stems out of the more mature community
base because Rails is great, especially if you're starting a project, you don't really
know where it's going to go, maybe you're not that, you haven't done doing it that long,
Rails handles all the things that have to get handled but you don't necessarily care
about right away.
You know, I don't really care how the CSRF protection works, maybe later I need to customize
it when I start doing that part of my project, but just throw it in there for me.
Clojure's much more, they've got a lot of components that you can use to build a system
of any kind that you want.
Now there are some standard defaults out there and there's a couple sort of like project
templates, you know, you can use to set it up and just sort of easily add like, oh here
I'm going to do a full stack one, or this is just going to be a server, or this is a
node project, and they'll just lay that all out for you, but you're still going to see
all the pieces.
Oh yeah, so ClojureScript also targets node, which is neat.
Well, I mean everything targets node now, right?
I can't get up and throw a rock without hitting a node developer these days.
No you cannot.
That is...
So that's interesting though, so theoretically, I mean this is probably a terrible comparison,
ClojureScript would be like TypeScript, you could theoretically use the node framework
and just like the language of your choice?
Yeah, yeah.
Absolutely.
So I've been working, I should actually pick it up again, I stopped working on it, but
I was working on a Alexa app using the JS APIs, but using ClojureScript.
Interesting, okay.
Other than that, I'll later just probably go run on a Lambda running on node, and it'll
just work.
And there you go, and you're good.
Yeah, and that's been interesting too, because I've done some Java, but I didn't have a huge
Java background when I started learning Clojure, and I'd done more JavaScript.
So there's a lot of libraries.
One thing that is great and makes Clojure pretty easy is that there are direct Clojure
libraries for things, but by and large, because the host interrupt is meant to be so good,
and it is just really, it's really clear, you can just do all the host things from Clojure
no problem, so you can use any either Java or JavaScript library, pull it right in and
use it just like it was the host language, so you would just have this huge application
base of software that's been already written for you, and you can just tie it together.
So you could just pull in jars, basically.
Yep, absolutely.
And then you can, from the ClojureScript side, you can use NPM.
Wow, okay.
So that actually brings up another great question.
So I'm looking at a, we've talked about it, I think, six months ago, last time you and
I talked.
Yeah, whenever that was.
Yeah, it was like, it feels like a hundred years now.
I think it might have been a hundred years.
You're absolutely right.
Last century.
Nice to see you.
Yeah, somehow the fashions come back around, so we still look great.
I told you, we got to keep all our clothes.
Now we sell them to hipsters.
They're vintage.
And these sweet mustaches we've grown.
That's right.
Top hats are back.
How adept does one have to be at Java and kind of like the whole Java ecosystem to successfully
start with Clojure?
Is it a prerequisite or can you just kind of get on with it?
I would say you don't really have to start with it.
You're going to have to learn some things as you go along, like certainly you have to
install a JVM onto your system.
So that's probably the most unpleasant part.
Actually recently in the past six months or so, the starting story for Clojure has gotten
a lot better because before Clojure was just a jar, you know, like you just, it was a jar
that you downloaded and that was the Clojure language and runtime and standard library
all in that jar.
So here's a command you can run where you run java-jar and you start up a REPL.
So now they've done a much better job of, one, having that, they have a standalone program
now that has an interface you can use and you just run it and it'll open up a REPL for
you.
It can also handle, instead of having to use Maven or some of the other Clojure-centric
build tooling that's out there, which is all very good and very useful.
This little tool can do that all for you as well.
And it can pull from Git depth, so you can put in Maven coordinates or you can put in
like a Git SHA or a Git tag and it'll pull all that down and handle all that for you.
So that makes it really easy if you just want to like go grab a couple libraries, open a
REPL and start hacking on it.
That said, probably for the first, for a lot of the learning, you really don't need it
that much.
Especially when you do, you'll eventually pull in some Java libraries or maybe work
with some of the Java base API for IO or other things.
So you'll start learning some of the Java things, but if you have even a tiny understanding
of object orientation, I had done way more Python than I had done Java before I started
playing with Clojure and that was more than enough.
It's like, okay, you get what's happening here, here's a method call.
Here's why that works.
Here's what the factory is.
That's all you need.
You don't need to get into any of the complicated, more obscure parts of Java unless you want
to.
Okay.
So yeah, that makes a ton of sense.
So you're still in love with it?
Still everything, any gripes?
Gripes, not a ton.
They've been making progress in a lot of the areas people commonly gripe about.
So one thing that's been hard over the years is error messages because it's a hosted language
and it tries to not hide that it's a hosted language.
So you end up oftentimes with like really long stack traces that go through your code
and then into the Clojure library code and then into JVM code and just this big stack
trace.
And if you're not used to Java or stack traces, that could be hard to read.
Now, I think if you're good at scientific debugging and you already are the sort of
developer who, you know, there's one style where you kind of like have, it's like you're
bowling with guards on the lanes where you're sort of bouncing off the compiler and bouncing
off just running into things.
But if you already have a really good understanding of what you're doing as you're writing your
program and know just like, you know, you have small commits where you know what you
changed and in what areas.
I've never found it to be that big of a deal.
That said, they are putting in a lot of work in that area and it's rapidly getting better.
So I'm hoping to see that improve for people that it really upsets.
So basically, I would completely fail immediately because, you know, my commits, I need at least
10 files, a couple thousand lines.
Well, I mean, as long as you're aware of what you're changing.
Yeah, I'm joking.
Oh man, you're triggering me here.
There's been so many people I've worked with over the years that are just like, either
they didn't get git or they just hated the idea of it because they refused to use it
in any same way.
Here's our Code Reader Tip of the Week.
Don't ever type a git commit tachy.
Just don't do it.
It's bad.
You're going to regret it.
You're probably going to have a rough code review.
Yeah, you have the staging area for a reason, like you should probably use it.
You should like use it and it's unlikely you change six files and only did one thing.
So I will say Clojure is worth learning if people are interested in a lot of the sort
of non, if you take out the statically typed world of functional programming, if you're
just interested in like a data-oriented functional thing, to compare it to like Go or C or some
of the more low-level languages, there's some aspects of programming.
Maybe you're implementing TCP or some other network protocol.
It feels like a state machine.
It feels like a little mechanical thing that you're cranking on the side or the CPU is
cranking it and it goes and you're processing low-level bits.
You're accessing memory.
You're sending little bits of data here and there.
And then there's like the bigger systems, not necessarily even bigger, but there's the
higher level, the more like up towards the human scale of things that are information
processing systems that are really dealing with data, rich data, complex data.
That's the side of things that I'd say Clojure really excels at.
You might still reach down to the host language.
You know, there's a lot of libraries out there that have part of them implemented in Java
for like the really hot, tight inner loops.
And then you just use Clojure on top of that to sort of orchestrate it in a way where you
don't have to have all the overhead of, you know, all the types of Java and all the boilerplate
of Java and just the, you get a nice mutable standard library.
That sounds really cool.
And yeah, the ability to pull in any jar effectively seems awesome.
Yeah.
So you can just kind of leverage it and it's, you know, it's just going to always be more
concise than Java.
And so you have less code to look at.
The other aspect I've really enjoyed and have been consistently surprised by is, so there's
the biggest outlier for Clojure is that it's a dynamic language and it's not statically
typed.
Oh, I didn't know.
I thought it was static.
Okay.
Yeah.
And so that's, that's one thing that people are constantly kind of tripped up by because
it's a weird part of the, if you imagine like a big grid, you know, there's sort of like
dynamically typed and mutable languages like Python and Ruby.
And then there's stuff that is, you know, Haskell on the other corner up here that is
immutable and statically typed and Clojure is immutable and dynamically typed.
And there's just not that many other languages that sit where it sits and it's its own unique
experience.
Yeah, that is interesting.
That isn't so immutable and dynamically typed.
I'm trying to think of what other languages like that.
I think Elixir is pretty close to it in that respect.
Maybe some other like weird Lisp or Lispy, I was thinking like, yeah, yeah, but there's
not that many.
And I think, well, like I have nothing against static typing or Haskell, which I find fascinating.
If you can and want to use Haskell, like do it.
But I think people take their experience of either like Java being too verbose, but like
they'd still like the types there or Python and Ruby growing to be like a big noodly mess
where you have no idea what's happening.
And the Ruby is just sending messages all over the place and you have no idea and it's
all happening at runtime and who the heck knows what's happening in this project anymore.
Monkey patching.
Yeah.
Monkey patching everywhere.
Yes, exactly.
And it's not to say that Clojure is immune from those problems, but the combination of
being really concise and the immutability means it's just not as big of a deal.
You know, you can have something that would be like four or five files in Java, be probably
just like one Clojure file of 100, 200, it depends on exactly what you're doing.
But it's just so much more concise.
You can look at the function and be like, oh, yeah, here we go.
I can understand what's happening because there's less of it.
It's not in three different classes.
That's super cool.
That is like, yeah.
And the other thing, too, is it embraces both data and runtime in a way that I've not seen
very many other languages.
From the runtime aspect, it's almost as much as Smalltalk did, where Smalltalk has its
own sort of crazy running environment.
So it's not quite to that level, but you really feel you're connected to this program.
So when you open up your editor, one people seem to really like is Cursive, which is built
on top of IntelliJ, basically.
So it's familiar to anyone using IntelliJ already, hooks up into Clojure.
But you've got this running REPL connection all the time.
And the way Clojure compiles is a single form at a time.
So you can just evaluate any form in your editor at any time and just send it to your
real system, sort of hack live against it until you've got it to a point that you like.
That is really cool.
Yeah, it's a sort of like jacked into the computer in a way that you don't often experience.
You can see the matrix as long as it's in Clojure.
Yeah, it's all S-expression, so you have to be down with that.
But if you can see past that, it has ruined me a bit for other languages because it's
a Lisp, right?
And Lisps are strange.
And their syntax is implemented in data structures.
And when that really clicks and you start thinking like, you know, when I see like a
let's say like a function definition in Python, you know, there's the name of the function
and then opening parentheses and then a list of the arguments for the function.
What is that?
Well, it's nothing, right?
It's just syntax.
In Clojure, that would be an actual list that you hand to the compiler.
That would be an actual list.
So like the syntax for Clojure is Clojure data structures.
Well, I think I just had a mind implosion moment.
Yeah, it's crazy.
So a Clojure function would not be what I think it would be, it wouldn't look like the
way I think it looks, right?
Yeah, it depends on what you mean.
So it'll be, if you're like defining a function in Clojure, it's an opening parentheses and
then the word defn, but in Clojure it's called a symbol, the symbol defn, D-E-F-N, and then
a space and then the name of the function and then a space and then a vector, which
is a square bracket and a list of the parameters that function accepts.
But it's not just syntax because what the compiler sees is an actual list, a data structure
that is a list, and then the first item of that list is a data structure that's a symbol,
which is defn, and then it sees another symbol, which is the name of the function, and then
it sees an actual vector with more symbols inside of it.
Wow.
Okay.
Yeah.
So the compilation's a bit different.
So the first stage is reading, and reading takes the Clojure file and there's actually
a, it's actually its own thing, it's called Eden Extensible Data Notation.
It's like JSON, but more Lispy, S-expression based, and a little more extensible, which
is nice.
So it takes an Eden file, reads it so it gets a big, builds a big data structure, and then
hands those data structures, one structure at a time, to the compiler, the compiler emits
bytecode, ships it to the JVM, and it runs it.
So basically everything all the way down is effectively Clojure data structures.
Yes, exactly.
And that's what makes the ability to write macros so useful, because you already have,
like the whole Clojure standard library is just utility functions to work on the built-in
data structures.
It's all about data, so you've got all the kinds of things to handle, nested maps and
complicated arrangements of vectors, and there's four comprehensions in there, and there's
map and filter and reduce and all sorts of stuff.
All of that can also be used in macros, because when you write a macro, the compiler sees
it, takes whatever you've written inside the macro, doesn't evaluate it, and hands it as
a data structure to the macro code that you write, and then you can use all of your normal
tools to manipulate that, emit more code, and then the compiler compiles that instead.
Okay.
My mind is blown.
Yeah, and that's why it's so powerful, and that's why, you know, for like C-Sharp they
added async await to the compiler, and Clojure core async answers some of the same problems,
and it's just a library.
Now there are some limitations that make it in some cases worse to do that style, but
it means the community didn't have to wait for the language designers to add that.
They could do it at any time.
Right, you just add your own macros and go from there.
Yeah, you can grow the language, shape it as you need to, and of course you want to
be, you know, you want to use that with care.
It's a lot of power, but when it's appropriate, it's awesome.
No, that sounds like it'd be very powerful.
Yeah, once you wrap your head around that everything's a data structure, and if you're
not used to, as I'm not used to, like Lispy-like languages, just for the audience, when we
say Lispy-like, we mean, you know, descendant from literally Lisp.
Yeah, exactly.
Usually prefix notation, S-expressions, that sort of thing.
Yeah, yeah, that's, I'm just looking at some of the stuff on Clojure.org here, I'm looking
at some of the codes, and my head is spinning.
It's like, it is very, very data centric.
Yeah, yes, absolutely.
Here I can send you a, I'll just post it and put it in the top of the doc, here's a recent
data-driven routing library that exists out there, there we go, I'll make that a link
for you.
And so you can just scroll down and see some of the examples, and it is, you know, it is,
it's all data structures all the way down.
All right.
Yeah.
So, one thing that people come from, like, you know, Scala people, or people used to,
even just Java's level of static typing, there's a little bit of uncertainty, so you do need
a little more, and again, I think this goes back to the sort of senior programmer mentality.
Certainly it's easy, maybe not easy, but it happens all the time, dynamic languages can
be abused, you can make a little suit for yourself.
It helps that Clojure is very function-oriented, and instead of classes, you have namespaces,
and there's already sort of, it's almost like microservices in your code, you know, it encourages
and stylistically is encouraged by the community to separate concerns and have very clear responsibilities
and single, immutable, idempotent functions.
So that helps a lot in that regard.
And if you just are a more experienced programmer, have a little discipline, you know, you learn
how to, you have doc strings, and you have good tests, and it all kind of just works.
Works together.
Yeah, I'm gonna have to take a look at this, just, you know, just for thinking in a different
way, right?
Yeah.
Thinking about code as data structures and being more in the list.
I spend most of my time working in C family languages.
Yeah, you know, that's part of it, too.
It's funny, I think that turns a lot of people off, and that's fair, ALGOL just won.
That style of syntax seems to be mostly what we learn, and so that's what feels intuitive
to us.
So it's probably healthy, even if you never intend to build a real project with it, learning
some kind of Lisp.
Clojure is nice because it has so many libraries, it's easy to do a toy project that's actually
useful as compared to maybe something like Racket, which is a little more academic.
But go learn some weird stuff, right?
It's nice to learn an ML family language, Prologues, interesting Erlang, Lisp, like there's
all kinds of crazy languages.
Forth is a cool, you know, concatenative stack-based languages are neat.
People still learn Haskell?
I remember that used to be like the hot non-C family, although this is definitely more foreign
than Haskell.
Yeah.
I mean, yes and no.
It's definitely more foreign on the surface, I would say.
Haskell has a lot of deepness to it because it is like just a rich playground for implementing
all sorts of ideas from type theory, which is cool, which is neat, like they do a lot
of cool stuff.
One thing I love about Clojure is it just tries to be simple.
I'm like simple.
There's one of the classic talks in the community is simple, not easy.
And to prefer simplicity, ease is great, it's not that ease is bad, but simplicity is what
helps scale and simplicity is what helps come back and review code and understand what's
happening.
So once you, there is a big gap of familiarity, but if you can get across that, like I don't
know if you've followed any of the drama from like the Scala side of things, just all the
incompatibilities between Scala versions and having to build multiple times and configure
SPT to emit for different Scala versions and all of that, it just doesn't happen in
Clojure.
There's been like one or two breaking changes over the entirety of its 10-year record.
That's pretty good.
Yeah.
I mean, that's, yeah, that's, yeah.
It's also, so it can be a little unsettling for people too because you see a Clojure library
and part of it is because of just the stability of the language and part of it is because
a lot of the libraries end up just wrapping, like a popular HTTP library wraps the Apache
HTTP library from Java.
So you just get these libraries that don't ever really see a 1.0 release, but it's because
they were already, there's such a thin little wrapper and layer to make it slightly more
palpable to a Clojure programmer that you don't have to worry about it and it doesn't
need that many changes.
It just works.
That is super cool.
Yeah.
But very different.
So I was turned off at first.
Yeah.
I was like, what is happening?
Well, it's a good exercise though, for frankly, myself and the listeners break out of your
C-sharp Java, God forbid JavaScript bubble and give something like Clojure a shot, right?
Yeah.
Just to learn.
Taste something strange.
So where can folks find you and learn more about this crazy data structure love?
Oh yeah.
You can find me over at Westpane on Twitter or check out some of the other JB shows I
sometimes appear on.
Check out TechSnap this week.
It's been tons of fun.
We had special guest Martin Wimpress on.
So we had, we just had a riotous time.
One of the wimpy.
Yeah, exactly.
Exactly.
Friend of the network.
What about you, Mike?
Where can they get more of you besides this here coder radio, a coder.show, right?
HTTP colon slash slash coder.show.
That's right.
You can find me at Dumanuco on Twitter and yeah, check out the calendar for the recording
schedule.
It's going to be weird for a few weeks.
Yeah.
But don't worry.
Nothing can stop Coder Radio.
And that with Clojure.

WEBVTT

00:00.000 --> 00:07.000
This is Koda Radio, episode 371, for August 19th, 2019.

00:31.000 --> 00:46.000
Hello and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business of software development and related technologies.

00:46.000 --> 00:51.000
My name is Wes, and of course, I'm joined by Mike. Welcome, Mike.

00:51.000 --> 00:53.000
Mr. Here, round two, Wes!

00:53.000 --> 00:59.000
Oh no, no, it's Jar Jar. I didn't plan for this. Where's Mike? What have you done with Mike, Jar Jar?

00:59.000 --> 01:01.000
I put him back in the legacy bin.

01:01.000 --> 01:05.000
Oh, okay. Well, never mind. Never mind. That's fine. That's where he belongs.

01:05.000 --> 01:08.000
All right. How are you, Wes, now that I'm back?

01:08.000 --> 01:12.000
Get out of here. Stop licking the floor. What are you doing?

01:12.000 --> 01:14.000
Yeah, he's pretty gross, but...

01:14.000 --> 01:17.000
He understands Koda Radio comes first, of course.

01:17.000 --> 01:24.000
Oh, I'm doing great. I'm excited to talk about something a little more abstract today.

01:24.000 --> 01:35.000
But before we do, let's get into some feedback. We got an email from our friend, Bob, who wanted to write to us a little bit about your adventures with Clojure.

01:35.000 --> 01:39.000
Thanks for the great show. I'm really enjoying the Seven Languages segment.

01:39.000 --> 01:47.000
I just wanted to share with Mike that if he's looking for a good free resource for Clojure, check out Clojure for the Brave and True.

01:47.000 --> 01:51.000
You can read it online for free or by the book.

01:51.000 --> 01:57.000
You might also want to check out Living Clojure by Karen Meyer and Getting Clojure by Russ Olson.

01:57.000 --> 02:02.000
And I'll just say here myself, those are all great resources.

02:02.000 --> 02:07.000
I have to say, a few people recommended Clojure for the Brave and True, and it looks very cool.

02:07.000 --> 02:14.000
I'm going to pick it up because, you know, I feel like not knowing a Lisp at all is just a big gap.

02:14.000 --> 02:22.000
And what's nice about that book is it's very approachable. All the examples are very fun and get you coding right away.

02:22.000 --> 02:29.000
It was a little less, in air quotes here, academic than the sort of thing I wanted personally.

02:29.000 --> 02:34.000
So it wasn't my favorite, but I've recommended it to other people who just really love it.

02:34.000 --> 02:37.000
So it's definitely worth checking out.

02:37.000 --> 02:39.000
Bob continues.

02:39.000 --> 02:48.000
At the end of the last show, you mentioned that you had to take some time to think about the code that you were writing in Clojure before you started to code.

02:48.000 --> 02:59.000
I know you may have found this frustrating, but I also think that part of writing good Clojure code is taking the time to think through the problem that you're attempting to solve.

02:59.000 --> 03:04.000
Thinking about the problem could take the form of leveraging the REPL to work out code to solve a problem.

03:04.000 --> 03:12.000
Or you could spend some time away from your computer screen, or in hammock time, working out problems.

03:12.000 --> 03:21.000
If I've learned anything from Clojure's creator, Rich Hickey, it's programming is not about typing. It's about thinking.

03:21.000 --> 03:26.000
Also, in reference to what Mike said about talking more about Lisp and its influences on programming,

03:26.000 --> 03:34.000
two interesting Lisp-slash-scheme languages you might check out are Racket and Extempore.

03:34.000 --> 03:40.000
I've not played with the latter, but Racket is definitely worth looking at if you just want to use a modern scheme.

03:40.000 --> 03:46.000
All right, well that all sounds great. Yeah, I'm definitely looking to look more into Lisp, just to kind of fill that hole.

03:46.000 --> 03:50.000
Yeah, I agree. Yeah, that's fair.

03:50.000 --> 03:54.000
We'll see. Maybe you'll make a Clojure convert out of me yet, Wes.

03:54.000 --> 03:59.000
We'll have links to the handy things Bob linked to us, and I will also say,

03:59.000 --> 04:03.000
thinking more and typing less is something we could all do better at.

04:03.000 --> 04:06.000
Very true. Very true.

04:06.000 --> 04:10.000
Moving right along, a story I wanted to check back in on.

04:10.000 --> 04:16.000
A few weeks ago, we talked about the surprising proof of the sensitivity conjecture.

04:16.000 --> 04:24.000
And I happened to notice a little update over in the comments on Scott Aaronson's blog post about that proof.

04:24.000 --> 04:34.000
Well, no one else but famous Don Knuth showed up to present an even simpler version he'd made after reading the proof,

04:34.000 --> 04:37.000
seeing a couple other suggestions from people in the comments there.

04:37.000 --> 04:44.000
He distilled that all down, and instead of a two-page proof, well, now it's one page.

04:44.000 --> 04:47.000
What can you say to that other than Knuth is key?

04:47.000 --> 04:53.000
Yeah, I just think it's great to see, you know, he's contributed so much to computer science.

04:53.000 --> 04:58.000
And a commenter over on Hacker News, I think, put it really well.

04:58.000 --> 05:01.000
Note what Knuth has done here.

05:01.000 --> 05:05.000
He's taken a published paper, understood it well, thought hard about it,

05:05.000 --> 05:11.000
and come up with what he feels is the best way to present this result.

05:11.000 --> 05:17.000
And this has been his primary activity all his life with the art of computer programming.

05:17.000 --> 05:25.000
Every page is full of results from the research literature that Knuth has often understood better than even the original authors

05:25.000 --> 05:30.000
and presented in a great and uniform style.

05:30.000 --> 05:33.000
He's basically digested the entire computer science literature,

05:33.000 --> 05:38.000
passed it through his personal interestingness filter, and presented it as something interesting.

05:38.000 --> 05:40.000
And that's what he's doing here too.

05:40.000 --> 05:42.000
And I think it's just an interesting reflection.

05:42.000 --> 05:49.000
I think we think a lot about produced work, but thinking is work too.

05:49.000 --> 05:53.000
And oftentimes, even if you're not the original researcher,

05:53.000 --> 05:59.000
being able to look at multiple people's work, distill things, summarize it, improve, refine,

05:59.000 --> 06:02.000
there's kind of multiple roles there.

06:02.000 --> 06:07.000
Some people really excel at just banging code out, getting the first implementation done,

06:07.000 --> 06:13.000
and others excel at taking existing code and tweaking it and refining it and making it better.

06:13.000 --> 06:15.000
And there's value in all those roles.

06:15.000 --> 06:16.000
Yeah, I agree.

06:16.000 --> 06:22.000
I mean, and also what struck me about this is kind of the open-sourcy spirit of this, right?

06:22.000 --> 06:28.000
That another, I won't say academic, but another researcher into the field,

06:28.000 --> 06:32.000
I don't know if he is an academic, I don't know why I wouldn't say that.

06:32.000 --> 06:34.000
Yeah, that's a distinction without a difference.

06:34.000 --> 06:38.000
He published a paper, it was fundamentally sound,

06:38.000 --> 06:43.000
Knuth saw that he could make it better, contributed back the changes.

06:43.000 --> 06:47.000
Is that not the spirit of, let's say, the GPL or hell, even the,

06:47.000 --> 06:50.000
I mean, I know the BSC is a bad example because people can take it away,

06:50.000 --> 06:52.000
but a free software open-source ethos,

06:52.000 --> 06:55.000
is that not the spirit of the whole plan we're trying to do here?

06:55.000 --> 06:57.000
No, it very much is.

06:57.000 --> 07:00.000
And I think there are many kindred spirits and principles

07:00.000 --> 07:04.000
between academia at its best and open-source at its best.

07:04.000 --> 07:10.000
Unfortunately, you know, this is coder radio and we can't be all positive.

07:10.000 --> 07:12.000
That's never going to work.

07:12.000 --> 07:14.000
Especially me, I mean, I could try.

07:14.000 --> 07:17.000
You could try, but you've already failed for this episode

07:17.000 --> 07:22.000
because you wanted to talk about something that I'm sure we've all been frustrated with.

07:22.000 --> 07:27.000
And it sounds like you've got a particular example that motivated this whole discussion.

07:27.000 --> 07:31.000
What we're talking about here are leaky abstractions.

07:31.000 --> 07:35.000
You know, I think the best way just to approach this is real quick,

07:35.000 --> 07:38.000
make sure we define what an abstraction is, right,

07:38.000 --> 07:41.000
before I dive into my little war story here.

07:41.000 --> 07:45.000
And I'm going to give my definition, other people have,

07:45.000 --> 07:49.000
including Joel Olson, not Joel Olson, that's very different,

07:49.000 --> 07:53.000
Joel Spolsky, have defined it and talked about it in greater depth.

07:53.000 --> 07:55.000
We have links to all that in the show notes.

07:55.000 --> 07:59.000
But Wes, would you agree with the definition of a leaky abstraction is

07:59.000 --> 08:08.000
an attempt in a piece of software to kind of fluff away complications in implementation details

08:08.000 --> 08:11.000
and give you a nice interface to other functionality

08:11.000 --> 08:15.000
or running on different operating systems or interacting with different services.

08:15.000 --> 08:18.000
Is that a fair working definition?

08:18.000 --> 08:21.000
Right, and we're just talking about abstraction in general here,

08:21.000 --> 08:24.000
or at least in the common programming sense.

08:24.000 --> 08:27.000
Right, we're purely talking about software engineering here, right.

08:27.000 --> 08:32.000
So I really don't want to make you this happy today, Wes,

08:32.000 --> 08:36.000
because you know what, you just hate Rails.

08:36.000 --> 08:41.000
And it is indeed in Rails, this leaky abstraction.

08:41.000 --> 08:43.000
I see, yeah, okay.

08:43.000 --> 08:46.000
I do think I like your definition.

08:46.000 --> 08:50.000
You know, oftentimes abstractions lift things to a higher level

08:50.000 --> 08:54.000
and, you know, remove some unnecessary details.

08:54.000 --> 08:58.000
You know, oftentimes it's about finding the sort of same thing

08:58.000 --> 09:00.000
or ways that you can have very similar behavior

09:00.000 --> 09:05.000
and not have to worry about what's different at least most of the time, right.

09:05.000 --> 09:08.000
I'm thinking about, you know, a common example might be implementing

09:08.000 --> 09:13.000
a common operation across all kinds of data structures, right.

09:13.000 --> 09:16.000
As long as the performance characteristics are roughly the same,

09:16.000 --> 09:17.000
you don't have to care, right.

09:17.000 --> 09:21.000
As long as you can say, like, hey, I want to add this thing to your structure.

09:21.000 --> 09:23.000
I don't care how you do it.

09:23.000 --> 09:27.000
You cover that up for me, and I'll just walk away

09:27.000 --> 09:30.000
and have a simple interface to understanding this.

09:30.000 --> 09:35.000
So I had a project that uses very large files.

09:35.000 --> 09:37.000
I think I mentioned it in passing a few times,

09:37.000 --> 09:39.000
a lot of ColorobiJs and STL files.

09:39.000 --> 09:41.000
Oh, this is the STL project, I see.

09:41.000 --> 09:48.000
Yes, and it is being deployed to AWS using S3 for storage.

09:48.000 --> 09:50.000
Pretty standard, right?

09:50.000 --> 09:53.000
Nothing controversial there, I would say.

09:53.000 --> 09:57.000
Well, to be clear here, right, you're also, it's running on AWS

09:57.000 --> 10:00.000
and then you're storing large files remotely onto,

10:00.000 --> 10:04.000
I mean, it's still within AWS, whatever, but onto the S3 service.

10:04.000 --> 10:08.000
And then you're having some library here, I assume, or a part of Rails

10:08.000 --> 10:11.000
that's kind of making that somewhat transparent?

10:11.000 --> 10:13.000
Right, so Active Storage, which is a part of Rails,

10:13.000 --> 10:17.000
but you do have to install a gem.

10:17.000 --> 10:22.000
Basically, Active Storage is a file storage and retrieval solution

10:22.000 --> 10:24.000
that's meant, it's really meant for large files,

10:24.000 --> 10:26.000
but a lot of people use it just for everything

10:26.000 --> 10:28.000
because it's relatively easy to use.

10:28.000 --> 10:31.000
And it abstracts away the file store you're using.

10:31.000 --> 10:35.000
So for instance, the basic, you know, 500-word blog post version of it,

10:35.000 --> 10:37.000
you're going to see how to use Active Storage,

10:37.000 --> 10:42.000
it's just saving things to like var slash Rails, whatever, right?

10:42.000 --> 10:45.000
Or like Rails slash storage, and that's it.

10:45.000 --> 10:48.000
Ah, right, just dumping it, whatever, on the local machine.

10:48.000 --> 10:54.000
It will work with AWS S3 as your, the name of the solution escapes me,

10:54.000 --> 10:57.000
but their version of S3.

10:57.000 --> 11:02.000
Minio, which is key here, which Minio is an open source project.

11:02.000 --> 11:05.000
We've mentioned it years ago on the show that they do a lot more

11:05.000 --> 11:07.000
than they used to now, but the way I've been using them

11:07.000 --> 11:12.000
is they implement the S3 API, but you can run it locally.

11:12.000 --> 11:15.000
Ah, local S3.

11:15.000 --> 11:19.000
Is this only for testing or also for production use?

11:19.000 --> 11:21.000
No, Minio is a pretty robust production solution.

11:21.000 --> 11:25.000
So if you're concerned, like they have this whole AI pitch they're doing now,

11:25.000 --> 11:28.000
which I don't know a lot about, I haven't used them for anything like that.

11:28.000 --> 11:33.000
But if you're looking for file storage and you don't want to be external

11:33.000 --> 11:37.000
to your, let's say your intranet, or you just don't want an S3,

11:37.000 --> 11:40.000
but you want all the goodness that comes with S3,

11:40.000 --> 11:44.000
yeah, you can just set up a RAID array or whatever and you're good to go.

11:44.000 --> 11:48.000
I actually have people using it. It works great.

11:48.000 --> 11:52.000
So I thought, okay, because I need to test a lot of this stuff.

11:52.000 --> 11:55.000
These files are big. It takes a long time to load them in S3.

11:55.000 --> 12:00.000
It's also kind of expensive because of how AWS and S3 work.

12:00.000 --> 12:04.000
Let me just set up a Minio instance locally.

12:04.000 --> 12:08.000
And it's the same API calls, and it's all abstracted away by active storage,

12:08.000 --> 12:11.000
which when I first started using Minio, it wasn't.

12:11.000 --> 12:15.000
I used to actually have to use the AWS gem directly.

12:15.000 --> 12:19.000
So I get everything working.

12:19.000 --> 12:24.000
Now, there is a processing step I have to do with these files

12:24.000 --> 12:28.000
that I was using a method in active storage called Path4,

12:28.000 --> 12:31.000
which is pretty simple.

12:31.000 --> 12:35.000
On an active storage object, you can call Path4 and get a temporary file path,

12:35.000 --> 12:40.000
or I guess if you're storing locally in slash rails, it's a permanent file path.

12:40.000 --> 12:45.000
Ah, I see. And if it's not locally, then it's some layer on top there.

12:45.000 --> 12:48.000
Well, that's what I thought. I thought it was supposed to be.

12:48.000 --> 12:52.000
Turns out that is the case in some systems.

12:52.000 --> 12:56.000
In Minio, that is the case. In S3, it just fails.

12:56.000 --> 12:58.000
Really?

12:58.000 --> 13:01.000
Right. And because I was doing this on a background worker process,

13:01.000 --> 13:04.000
it doesn't 500 or anything. It just fails silently.

13:04.000 --> 13:09.000
So it works in testing, works on local host, fails in production.

13:09.000 --> 13:13.000
I'm seeing over at Minio here, they say,

13:13.000 --> 13:18.000
100% open source enterprise grade Amazon S3 compatible objects storage.

13:18.000 --> 13:22.000
It's interesting then that, you know, did something change?

13:22.000 --> 13:27.000
Not on Minio, but not on S3. And in theory, the API is the same, right?

13:27.000 --> 13:30.000
So the API is exactly the same. So the irony is,

13:30.000 --> 13:35.000
it's because of the abstraction in active storage, right?

13:35.000 --> 13:39.000
This method is an active storage, not in the AWS gem.

13:39.000 --> 13:41.000
I see.

13:41.000 --> 13:46.000
And it's funny, in the documents for 4Path on the Rails documentation,

13:46.000 --> 13:49.000
it doesn't mention that it doesn't work in a few of the sources.

13:49.000 --> 13:53.000
With stack overflow, can you see the whales of the desperate?

13:53.000 --> 13:55.000
Of course.

13:55.000 --> 13:58.000
Wondering why this worked on local host or on their whatever weird

13:58.000 --> 14:01.000
testing implementation that I had.

14:01.000 --> 14:06.000
Would they find, oh yeah, it just fails on S3 because Amazon doesn't let you do that.

14:06.000 --> 14:09.000
And they don't for good reasons, right? Security.

14:09.000 --> 14:12.000
But again, if it's an intranet, you don't care.

14:12.000 --> 14:15.000
So, okay.

14:15.000 --> 14:20.000
It took me about half a day to figure out what was going on there.

14:21.000 --> 14:24.000
Not to fix it, right? Because once I figured out what was going on,

14:24.000 --> 14:28.000
there's many solutions. Convert the file to a binary and do it that way.

14:28.000 --> 14:31.000
Yeah, what did the debugging process look like here?

14:31.000 --> 14:34.000
Because when you started, you probably didn't know where the error was happening.

14:34.000 --> 14:37.000
Well, I did what I always do. I roll back the deployment.

14:37.000 --> 14:40.000
I go to the testing environment and I'm like, okay, let me reproduce this.

14:40.000 --> 14:43.000
Spent a significant amount of time doing that.

14:43.000 --> 14:46.000
But again, you said, yeah, you couldn't, right? Because you're using Minio there.

14:46.000 --> 14:51.000
Right. So then I started adding more logging.

14:51.000 --> 14:55.000
Eventually, I was just, we can name drop some gems here.

14:55.000 --> 14:59.000
I was using another gem called Sucker Punch to do some backgrounding on these files.

14:59.000 --> 15:04.000
Sucker Punch basically is another abstraction on doing background processes in Rails.

15:04.000 --> 15:09.000
Turns out the logging on production did catch the error,

15:09.000 --> 15:14.000
but threw it as it didn't like completely error out. It just put it in the log.

15:14.000 --> 15:17.000
And too many things were happening. The log kept refreshing.

15:17.000 --> 15:22.000
So I had to search specifically for a background error.

15:22.000 --> 15:27.000
Eventually, once I had the error, I did what everybody does, right?

15:27.000 --> 15:30.000
I Googled it. Yep, that's exactly what it is.

15:30.000 --> 15:34.000
You can no longer do that in S3. I felt like you used to be able to,

15:34.000 --> 15:39.000
but most of my deployments are internal.

15:39.000 --> 15:44.000
A lot of them are using things like Minio or alternatives to that.

15:44.000 --> 15:49.000
So I was pretty shocked that the Rails documentation

15:49.000 --> 15:54.000
didn't actually say that that method doesn't work.

15:54.000 --> 15:59.000
It doesn't error out in your debugger. It just errors out in production.

15:59.000 --> 16:02.000
Which is always the worst kind of error.

16:02.000 --> 16:05.000
Because this path 4 is supposed to do whatever it needs to do

16:05.000 --> 16:08.000
for each different file hosting environment.

16:08.000 --> 16:10.000
And you don't need to care, as long as you have the credentials,

16:10.000 --> 16:12.000
as long as you have the keys and your environment variables,

16:12.000 --> 16:16.000
or however you want to do that. It doesn't matter.

16:16.000 --> 16:20.000
But there's just one thing in the S3 implementation of this

16:20.000 --> 16:23.000
that this one little piece of functionality doesn't work.

16:23.000 --> 16:26.000
Everything else works fine.

16:26.000 --> 16:30.000
And that is your abstraction leaking.

16:30.000 --> 16:34.000
What do you say, Wes? Is that a leaky abstraction, or do you think not?

16:34.000 --> 16:38.000
It's interesting, right? Because obviously you were using this

16:38.000 --> 16:42.000
active storage method because it was useful, right?

16:42.000 --> 16:45.000
And part of Rails.

16:45.000 --> 16:48.000
Right. And it was abstracting over things for you, right?

16:48.000 --> 16:54.000
How much more difficult was the workaround here?

16:54.000 --> 16:58.000
Is the abstraction still useful, or have you had to abandon it entirely

16:58.000 --> 17:02.000
because of this leak, or is it just sort of a minor leak that you patch up

17:02.000 --> 17:06.000
a little bit in the production case and have to make some modifications?

17:06.000 --> 17:09.000
Does it feel gross to you, what you've had to do to solve it?

17:09.000 --> 17:13.000
And are you still using that method everywhere?

17:13.000 --> 17:16.000
I'm still using active storage. In fact, this is going back to our feedback,

17:16.000 --> 17:18.000
think more, code less.

17:18.000 --> 17:21.000
The challenge was just figuring out where the abstraction was.

17:21.000 --> 17:24.000
Solving it was, I don't love the solution.

17:24.000 --> 17:28.000
It's basically temporarily throwing around binary data.

17:28.000 --> 17:30.000
But it works.

17:30.000 --> 17:33.000
And the nice thing I like about the solution I implemented,

17:33.000 --> 17:37.000
it works in local host, the testing environment, and production.

17:37.000 --> 17:41.000
So there's not this crazy case of doing switches, like compiler flags,

17:41.000 --> 17:44.000
or if-def-ing your way through to say, am I in prod?

17:44.000 --> 17:47.000
I personally hate that. I think that's a huge code smell,

17:47.000 --> 17:50.000
if you're doing stuff like that.

17:50.000 --> 17:53.000
Again, I'm not starting a sort of flame war with anybody.

17:53.000 --> 17:57.000
But yeah, I think it's funny, and it's why when I slacked you,

17:57.000 --> 18:00.000
I was like, we have to talk about leaky abstractions.

18:00.000 --> 18:03.000
Because you would think, in Rails, when you see anything that starts active,

18:03.000 --> 18:07.000
insert other word here, that's usually rock solid.

18:07.000 --> 18:10.000
Right, that's one of the great things about Rails,

18:10.000 --> 18:13.000
is it's just been used to build these kinds of services for so long

18:13.000 --> 18:17.000
and in so many cases that it basically has a good solution for everything.

18:17.000 --> 18:21.000
Exactly, and this was just one case where once you know it,

18:21.000 --> 18:25.000
you know it forever, and you just know you can't call that helper method

18:25.000 --> 18:28.000
on an environment using S3.

18:28.000 --> 18:32.000
But figuring that out, damn, that's...

18:32.000 --> 18:35.000
I mean, that requires you paying deep attention to logs.

18:35.000 --> 18:38.000
You have to already have your logging set up in your production environment,

18:38.000 --> 18:41.000
which I know a lot of people don't do.

18:41.000 --> 18:45.000
So it's a pretty, I want to say annoying,

18:45.000 --> 18:48.000
but it's not the way you want to spend half your day.

18:48.000 --> 18:50.000
No, no, definitely not.

18:50.000 --> 18:52.000
But the alternative is terrible.

18:52.000 --> 18:56.000
The alternative is implementing three solutions for three different environments.

18:56.000 --> 19:00.000
I like this quote you put in the doc kind of relatedly.

19:00.000 --> 19:05.000
Since all non-trivial abstractions are imperfect and will leak in one way or another,

19:05.000 --> 19:10.000
this means any serious programmer should always have at least a minimal knowledge

19:10.000 --> 19:13.000
of the abstractions they use.

19:13.000 --> 19:15.000
This usually means knowing a bit about how your CPU works,

19:15.000 --> 19:19.000
how your network protocols work, how your kernel works, and so on.

19:19.000 --> 19:21.000
Yeah, exactly.

19:21.000 --> 19:22.000
And that seems true, right?

19:22.000 --> 19:27.000
I mean, there's just no way that you can escape thinking about your system.

19:27.000 --> 19:29.000
And abstractions are useful tools,

19:29.000 --> 19:33.000
and I don't think the existence of these of leaky abstractions of problems

19:33.000 --> 19:35.000
where it's frustrating,

19:35.000 --> 19:38.000
there are times maybe where you've chosen the wrong abstraction

19:38.000 --> 19:43.000
or it's just not possible to abstract that in that way under these circumstances.

19:43.000 --> 19:48.000
But even in your case, you'd be able to sort of patch things up and make it work.

19:48.000 --> 19:54.000
Right, and it's a leak you only miss once, right?

19:54.000 --> 19:58.000
So now you know forever that, okay, Amazon S3, active storage,

19:58.000 --> 20:00.000
it doesn't allow the helper method.

20:00.000 --> 20:03.000
I saw another article about this, and they had a great example.

20:03.000 --> 20:05.000
Think about garbage collection.

20:05.000 --> 20:09.000
It hides manual memory management, but as anyone who uses it knows,

20:09.000 --> 20:14.000
sometimes getting peak performance is hard work.

20:14.000 --> 20:16.000
You'd still have to think about it, right?

20:16.000 --> 20:18.000
You pay the cost of garbage collection, of course,

20:18.000 --> 20:20.000
and you may have to go try to tune things.

20:20.000 --> 20:24.000
You may have to try to reuse stuff instead of freeing and reallocating new objects.

20:24.000 --> 20:29.000
You end up having to engage with and think about how the garbage collector works.

20:29.000 --> 20:32.000
But is it unsuitable or just incomplete?

20:32.000 --> 20:34.000
It depends.

20:34.000 --> 20:37.000
It could be an unsuitable abstraction for whatever task you're doing,

20:37.000 --> 20:42.000
saying you're trying to make a very low latency sort of system or building a game,

20:42.000 --> 20:45.000
and you just need to do manual memory management.

20:45.000 --> 20:49.000
Or you could have kind of an incomplete abstraction,

20:49.000 --> 20:52.000
something you need to extend or work with better,

20:52.000 --> 20:55.000
and find the right garbage collector and the right settings for it

20:55.000 --> 20:57.000
so that it works for your particular case.

20:57.000 --> 21:01.000
But you still don't have to think about all of the nitty-gritty of memory management work.

21:01.000 --> 21:06.000
Either way, you end up having to understand some of your problem domain.

21:06.000 --> 21:08.000
Yeah, that's exactly it, right.

21:08.000 --> 21:15.000
You can't just blindly trust the abstraction and hope it'll all work out.

21:15.000 --> 21:19.000
Another common case, I'm not sure it's directly applicable,

21:19.000 --> 21:23.000
and I'm curious what you think, and it kind of ties back in with Rails,

21:23.000 --> 21:26.000
and that's the use of ORMs, right?

21:26.000 --> 21:28.000
Object Relational Mapping.

21:28.000 --> 21:32.000
Because you'll find a subset of people who really just prefer to write the query themselves

21:32.000 --> 21:36.000
and will often say, well, look, I end up having to write the query myself

21:36.000 --> 21:41.000
or waste a bunch of time fighting with the ORM to try to get it to produce the query

21:41.000 --> 21:46.000
that I know that it should be so that it's actually performant on the SQL backend.

21:46.000 --> 21:49.000
But at the same time, you know, you're writing a CRUD app,

21:49.000 --> 21:53.000
and an ORM just like does most of the work for you.

21:53.000 --> 21:56.000
Yeah, I tend to lean on the, I'm curious where you found this,

21:56.000 --> 22:00.000
I tend to lean on the pro ORM side of life here.

22:00.000 --> 22:04.000
So you end up engaging more with the relational idea, I guess, right?

22:04.000 --> 22:07.000
Sort of nature of how those are constructed.

22:07.000 --> 22:11.000
But there are some libraries that try to smooth things over, right?

22:11.000 --> 22:15.000
Like there are cases where the mappings work out pretty cleanly, right?

22:15.000 --> 22:19.000
You have some map or a structure, an object that has some fields,

22:19.000 --> 22:22.000
and those just, you know, they end up just mapping to columns and the rows,

22:22.000 --> 22:26.000
and it all just sort of works for you.

22:26.000 --> 22:30.000
I think it just shows, again, that, you know, anytime this is non-trivial and complex,

22:30.000 --> 22:32.000
it's going to be hard.

22:32.000 --> 22:37.000
But probably there's, you know, a trade-off you have to consider too

22:37.000 --> 22:41.000
with how familiar you are and how familiar you want to be with the system.

22:41.000 --> 22:44.000
Now, performance is almost always going to be the real limiting factor, right?

22:44.000 --> 22:49.000
Like if it doesn't work for the performance that you need, it's not going to work.

22:49.000 --> 22:53.000
But if you're already familiar with SQL, it may be easier for you to use

22:53.000 --> 22:56.000
a sort of more minimal system, right, where you might want some helper method,

22:56.000 --> 22:59.000
something that can easily translate and store an object,

22:59.000 --> 23:04.000
but you don't need these complicated joins being constructed for you to go to that level.

23:06.000 --> 23:11.000
Yeah, I mean, the whole ORM thing is tough, right?

23:11.000 --> 23:16.000
Because most of the time, you don't need it, at least in a Rails application.

23:17.000 --> 23:22.000
I'm sorry, you don't need to drop to raw SQL queries.

23:22.000 --> 23:27.000
But there's usually one or two in every application that you kind of end up doing.

23:27.000 --> 23:32.000
Right, it's on the hot path.

23:29.000 --> 23:34.000
It happens a lot, or for some reason, the ORM is just getting it kind of wrong.

23:34.000 --> 23:39.000
Right, or it's just like the code you have to write

23:36.000 --> 23:41.000
to make ActiveRecord do what you want is so just gnarly.

23:41.000 --> 23:46.000
Right, gross, gnarly, hard to understand.

23:44.000 --> 23:49.000
Right, that having a stored procedure for that is just easier.

23:49.000 --> 23:54.000
But yeah, I tend to try to do everything I can in ActiveRecord.

23:54.000 --> 23:59.000
We really have to go ahead and get a stored procedure.

23:58.000 --> 24:03.000
I think one aspect that you can't ignore when you're talking about leaky abstractions

24:02.000 --> 24:07.000
and abstractions in general, and it's something we kind of talked about a little bit

24:07.000 --> 24:12.000
without naming it in the last episode.

24:11.000 --> 24:16.000
And that's choosing the right level of distraction.

24:14.000 --> 24:19.000
Last week, you were talking a bit about large legacy C sharp code bases.

24:19.000 --> 24:24.000
And I've certainly seen sometimes in large, older OO projects

24:25.000 --> 24:30.000
that things just get abstracted too early and too far

24:29.000 --> 24:34.000
so that you end up with so many layers of abstraction

24:32.000 --> 24:37.000
that it's hard to find where the concreteness is actually happening.

24:37.000 --> 24:42.000
And that's important, right, because abstractions are useful,

24:42.000 --> 24:47.000
but at the end of the day, there's implementations down there,

24:47.000 --> 24:52.000
especially as you're learning a new code base.

24:50.000 --> 24:55.000
And it can be nice to have a layer of abstraction added

24:53.000 --> 24:58.000
if you know that you really need multiple implementations.

24:56.000 --> 25:01.000
But I'm sure you've seen cases where a bunch of abstractions are added

25:00.000 --> 25:05.000
and then there's only ever one implementation for each of them.

25:04.000 --> 25:09.000
This is probably one of the most common disagreements I think developers have, right?

25:08.000 --> 25:13.000
Is what level do you start at in terms of implementing abstractions

25:13.000 --> 25:18.000
to a lower layer, whether that's database or cross-platform, right?

25:18.000 --> 25:23.000
Because even in the cross-platform world, Xamarin, Flutter, whatever it's called,

25:23.000 --> 25:28.000
all of that stuff is just an abstraction, wouldn't you say?

25:26.000 --> 25:31.000
Oh, yeah, of course, right?

25:27.000 --> 25:32.000
It's trying to smooth things over

25:29.000 --> 25:34.000
so you can talk about a generic input element

25:32.000 --> 25:37.000
and not worry that on the Linux desktop, it's totally different than iOS.

25:37.000 --> 25:42.000
I mean, the Linux desktop is iOS though, right? Am I confused?

25:42.000 --> 25:47.000
I think that head injury was more serious than we thought, Mike.

25:46.000 --> 25:51.000
But yeah, you're right.

25:47.000 --> 25:52.000
I mean, of course those are abstractions and they are useful, right?

25:50.000 --> 25:55.000
I mean, look at the popularity of cross-platform frameworks like that

25:58.000 --> 26:03.000
or things like React Native, Electron.

26:02.000 --> 26:07.000
There are a lot of things you just don't want to think about

26:07.000 --> 26:12.000
and that can be useful.

26:08.000 --> 26:13.000
I don't know, you just always have to end up thinking about some aspect of it

26:12.000 --> 26:17.000
or you need to be aware.

26:13.000 --> 26:18.000
And so that's why the case you ran into is kind of interesting

26:16.000 --> 26:21.000
because I'm sure if you'd seen a little caveat declared for that,

26:20.000 --> 26:25.000
or maybe a table of backends that are supported with that that works,

26:27.000 --> 26:32.000
that would have been very useful knowledge upfront

26:30.000 --> 26:35.000
because it's okay that there's no denying that it can't work,

26:35.000 --> 26:40.000
but it's still a useful abstraction for a majority of use cases.

26:39.000 --> 26:44.000
It just has its natural limits.

26:42.000 --> 26:47.000
Right, for the vast majority of, yeah.

26:45.000 --> 26:50.000
There's just this one operation where it doesn't make sense.

26:49.000 --> 26:54.000
This is one of those things that I do think about,

26:52.000 --> 26:57.000
I hate to say the E word, but Electron, right?

26:55.000 --> 27:00.000
A story came out today where there's some,

26:58.000 --> 27:03.000
it's on Ars Technica and I'll find the link,

27:03.000 --> 27:08.000
but I think we are both currently running.

27:06.000 --> 27:11.000
I mean, how much bigger of an abstraction can you get than that, right?

27:11.000 --> 27:16.000
It does also show, right, though, like I think about the popularity.

27:14.000 --> 27:19.000
And I imagine there's many,

27:17.000 --> 27:22.000
I'm thinking of this as a desktop Linux user here,

27:19.000 --> 27:24.000
but probably many applications

27:23.000 --> 27:28.000
that wouldn't necessarily target the Linux desktop

27:26.000 --> 27:31.000
without that level of abstraction being available, right?

27:31.000 --> 27:36.000
Without the abstractions, you have to end up learning more.

27:34.000 --> 27:39.000
When they work, they can really successfully hide things from you

27:38.000 --> 27:43.000
and the Linux desktop or whatever small market

27:42.000 --> 27:47.000
doesn't usually have the necessary weight

27:45.000 --> 27:50.000
to demand that level of resource to go implement

27:48.000 --> 27:53.000
basically something that could be abstracted over

27:50.000 --> 27:55.000
because it wasn't fundamentally different.

27:54.000 --> 27:59.000
Yeah, and there's tons of examples, right?

27:59.000 --> 28:04.000
It's actually in itself an abstraction,

28:02.000 --> 28:07.000
though I would argue operating in a much lower layer,

28:05.000 --> 28:10.000
although maybe not, right?

28:06.000 --> 28:11.000
C++ is an abstraction, which is the language

28:08.000 --> 28:13.000
you tend to be developing when using Qt.

28:12.000 --> 28:17.000
Objective-C is an abstraction,

28:14.000 --> 28:19.000
although it's amazing and glorious

28:15.000 --> 28:20.000
and we should all be using it.

28:17.000 --> 28:22.000
Yeah, I mean, really, our whole world is based on that, right?

28:21.000 --> 28:26.000
I mean, even if you're programming in assembly language,

28:26.000 --> 28:31.000
it's compiled to the real operations going on under the hood.

28:31.000 --> 28:36.000
I liked the way this was put over at the principles wiki.

28:36.000 --> 28:41.000
A solution is bad if A, the leakiness of abstractions is ignored,

28:42.000 --> 28:47.000
B, the benefits of the abstraction cannot justify

28:46.000 --> 28:51.000
the disadvantages created by the leakiness,

28:51.000 --> 28:56.000
C, the abstraction is just more leaky than necessary,

28:56.000 --> 29:01.000
meaning you've maybe chosen the wrong abstraction.

29:00.000 --> 29:05.000
Yeah, completely agree.

29:01.000 --> 29:06.000
So where do you fall in the abstraction hierarchy?

29:04.000 --> 29:09.000
Do you start, like I think I'm pretty clear,

29:07.000 --> 29:12.000
I start at the high level and move down when I need to.

29:10.000 --> 29:15.000
Is that how you also operate, Wes,

29:12.000 --> 29:17.000
or do you prefer to somewhere in the middle, low level?

29:17.000 --> 29:22.000
Somewhere in the middle.

29:20.000 --> 29:25.000
I think they're very valuable.

29:22.000 --> 29:27.000
One thing about, say, Python that I think that it could do to have better

29:29.000 --> 29:34.000
is some of these abstraction toolings.

29:31.000 --> 29:36.000
I mean, you've got the double underscore methods and all that,

29:33.000 --> 29:38.000
but I think Java interfaces are just a good way to think about things

29:40.000 --> 29:45.000
in many cases, or the Clojure version is protocols, right?

29:45.000 --> 29:50.000
Groupings of methods that operate on,

29:48.000 --> 29:53.000
that can be implemented by different data types.

29:51.000 --> 29:56.000
It's reasonable to want to abstract early with the,

29:55.000 --> 30:00.000
especially if you're thinking about

29:58.000 --> 30:03.000
what's going to go wrong later,

30:00.000 --> 30:05.000
or are we going to add more backends for this, right?

30:02.000 --> 30:07.000
Like, oh, I need to talk to this service,

30:03.000 --> 30:08.000
but we might want to have a second service

30:05.000 --> 30:10.000
that does the same thing as a backup

30:06.000 --> 30:11.000
or to talk to both of them at the same time.

30:11.000 --> 30:16.000
And that's fine.

30:12.000 --> 30:17.000
I would just caution that

30:16.000 --> 30:21.000
you should also be trying to keep things flexible enough

30:19.000 --> 30:24.000
and easy to change enough

30:22.000 --> 30:27.000
that adding abstractions later shouldn't be difficult, right?

30:27.000 --> 30:32.000
I guess I'm in the middle where you should be thinking about it

30:30.000 --> 30:35.000
and programming in a way that allows for it to be added,

30:33.000 --> 30:38.000
but not necessarily adding it concretely all the time.

30:38.000 --> 30:43.000
I mean, it's so funny.

30:40.000 --> 30:45.000
That's exactly one of the use cases

30:42.000 --> 30:47.000
that Active Storage is meant to help.

30:44.000 --> 30:49.000
If you want to have a duplicate service implemented, right?

30:48.000 --> 30:53.000
There's actually, right in the config file,

30:49.000 --> 30:54.000
you can set a mirror so you can do S3 and, again,

30:52.000 --> 30:57.000
whatever Azure's version is,

30:53.000 --> 30:58.000
or Minio and something else, right?

30:56.000 --> 31:01.000
Right, or I mean,

30:57.000 --> 31:02.000
DigitalOcean has one that's S3 compatible.

30:59.000 --> 31:04.000
There's tons of them.

31:00.000 --> 31:05.000
Yeah, DO has one now, right?

31:02.000 --> 31:07.000
So whatever is,

31:07.000 --> 31:12.000
implementing the second service is quote, unquote, free.

31:10.000 --> 31:15.000
Exactly. That's a good way to put it.

31:13.000 --> 31:18.000
This is hard stuff because it's just so context dependent

31:18.000 --> 31:23.000
and it depends a lot on what you're doing,

31:21.000 --> 31:26.000
how long it's going to live,

31:23.000 --> 31:28.000
and how much it might grow,

31:25.000 --> 31:30.000
and those aren't always clear

31:26.000 --> 31:31.000
at the time you're actually creating it.

31:29.000 --> 31:34.000
We'll, of course, have links

31:30.000 --> 31:35.000
to all the things we talked about,

31:35.000 --> 31:40.000
or guides, or, you know,

31:36.000 --> 31:41.000
ways to think about the right level of abstraction,

31:39.000 --> 31:44.000
or favorite tools to deal with leaky abstractions.

31:43.000 --> 31:48.000
If so, let us know.

31:45.000 --> 31:50.000
We're at coder.show slash contact.

31:49.000 --> 31:54.000
Now, Mike, we took a little bit of a break.

31:52.000 --> 31:57.000
You were traveling.

31:53.000 --> 31:58.000
There was a lot of things going on

31:54.000 --> 31:59.000
behind the scenes for both of us.

31:57.000 --> 32:02.000
But it's time again

31:59.000 --> 32:04.000
for our seven languages challenge,

32:04.000 --> 32:09.000
I do.

32:06.000 --> 32:11.000
I know you're just jonesing for it and

32:08.000 --> 32:13.000
hands are shaking.

32:09.000 --> 32:14.000
Who am I to stand in your way?

32:11.000 --> 32:16.000
I mean, look at you.

32:12.000 --> 32:17.000
You look horrible.

32:13.000 --> 32:18.000
You need something to play with

32:15.000 --> 32:20.000
to get excited by.

32:16.000 --> 32:21.000
Sweating, I'm crying.

32:18.000 --> 32:23.000
It's terrible.

32:19.000 --> 32:24.000
And I know, you know,

32:20.000 --> 32:25.000
you were just kind of burned

32:22.000 --> 32:27.000
by rails here,

32:23.000 --> 32:28.000
so I thought we'll keep you

32:25.000 --> 32:30.000
kind of close to rails in Ruby,

32:27.000 --> 32:32.000
but also mix everything up.

32:32.000 --> 32:37.000
Crystal.

32:33.000 --> 32:38.000
You know I like my gemstone

32:34.000 --> 32:39.000
named languages, right?

32:36.000 --> 32:41.000
Oh, I sure do.

32:37.000 --> 32:42.000
Crystals build as a language

32:39.000 --> 32:44.000
that's fast as C and slick as Ruby.

32:43.000 --> 32:48.000
I've been lied to before.

32:45.000 --> 32:50.000
Yeah, but you'll also find

32:46.000 --> 32:51.000
that Crystals statically typed

32:48.000 --> 32:53.000
and seemingly very efficient.

32:52.000 --> 32:57.000
Got non-nullable things,

32:54.000 --> 32:59.000
null checks,

32:55.000 --> 33:00.000
so you've got that safety added.

33:00.000 --> 33:05.000
And green threads,

33:03.000 --> 33:08.000
also known as fibers,

33:06.000 --> 33:11.000
as a concurrency model.

33:07.000 --> 33:12.000
So that's exciting.

33:08.000 --> 33:13.000
That's something you encountered

33:10.000 --> 33:15.000
in a somewhat different variant

33:12.000 --> 33:17.000
over when you were playing

33:13.000 --> 33:18.000
with Elixir.

33:15.000 --> 33:20.000
True, true.

33:16.000 --> 33:21.000
Yeah, you know,

33:17.000 --> 33:22.000
I did take a brief look at Crystal,

33:18.000 --> 33:23.000
and I have to say,

33:19.000 --> 33:24.000
I cannot deny that my heart

33:21.000 --> 33:26.000
has desired this,

33:22.000 --> 33:27.000
ala Galadriel here.

33:23.000 --> 33:28.000
Yeah, you know,

33:24.000 --> 33:29.000
it seemed like it might make sense

33:29.000 --> 33:34.000
to do something with Rust.

33:30.000 --> 33:35.000
So perhaps something that has

33:32.000 --> 33:37.000
some of the similar properties,

33:33.000 --> 33:38.000
a nice robust type system,

33:35.000 --> 33:40.000
but can also target

33:37.000 --> 33:42.000
somewhat more lower-level tasks

33:41.000 --> 33:46.000
might be something

33:42.000 --> 33:46.000
you would actually use

33:43.000 --> 33:48.000
in your toolkit.

33:44.000 --> 33:49.000
Sounds good.

33:45.000 --> 33:50.000
Looking forward to it.

33:48.000 --> 33:53.000
So I saw you had a pick

33:49.000 --> 33:54.000
for us this week, Wes,

33:50.000 --> 33:55.000
or two, even.

33:52.000 --> 33:57.000
Well, one of them

33:53.000 --> 33:58.000
is really a supplement

33:58.000 --> 34:03.000
to Ruby, yeah, exactly, exactly.

34:01.000 --> 34:06.000
I mean, this whole episode

34:02.000 --> 34:07.000
has been, you know,

34:03.000 --> 34:08.000
it kind of started off

34:03.000 --> 34:08.000
in the Ruby world,

34:04.000 --> 34:09.000
and we might as well

34:05.000 --> 34:10.000
end it that way, too.

34:07.000 --> 34:12.000
And that's why I've picked

34:09.000 --> 34:14.000
Effect,

34:10.000 --> 34:15.000
an algebraic effects library

34:14.000 --> 34:19.000
for Ruby.

34:16.000 --> 34:21.000
Yeah, okay.

34:17.000 --> 34:22.000
If you're not really

34:18.000 --> 34:23.000
familiar with that,

34:19.000 --> 34:24.000
let's say you're trying to do

34:20.000 --> 34:25.000
some, you know,

34:21.000 --> 34:26.000
more functional Ruby,

34:26.000 --> 34:31.000
you want more of it,

34:27.000 --> 34:32.000
but Ruby pays your bills.

34:29.000 --> 34:34.000
Well, Effect is a tiny

34:31.000 --> 34:36.000
Ruby gem, providing a way

34:33.000 --> 34:38.000
to isolate and handle

34:35.000 --> 34:40.000
side effects in

34:36.000 --> 34:41.000
functional programs.

34:38.000 --> 34:43.000
Effect implements

34:39.000 --> 34:44.000
algebraic effects in Ruby,

34:41.000 --> 34:46.000
but can also be used

34:42.000 --> 34:47.000
to implement other patterns

34:43.000 --> 34:48.000
like object-oriented programming,

34:46.000 --> 34:51.000
inversion of control,

34:47.000 --> 34:52.000
and dependency injection.

34:50.000 --> 34:55.000
They've got some

34:50.000 --> 34:55.000
nice examples here,

34:55.000 --> 35:00.000
is pushing I-O

34:57.000 --> 35:02.000
to the boundaries,

34:58.000 --> 35:03.000
or other, you know,

34:59.000 --> 35:04.000
stateful stuff, right?

35:00.000 --> 35:05.000
And we've talked about this

35:01.000 --> 35:06.000
before, too, where that stuff's

35:03.000 --> 35:08.000
hard to test, right?

35:04.000 --> 35:09.000
You end up needing to do,

35:05.000 --> 35:10.000
you know, integration stuff

35:07.000 --> 35:12.000
or crazy mocking and stubbing,

35:09.000 --> 35:14.000
and it just gets rough.

35:11.000 --> 35:16.000
So one of the advantages

35:12.000 --> 35:17.000
of a library like this

35:13.000 --> 35:18.000
is you can use its facilities

35:16.000 --> 35:21.000
to do this for you,

35:18.000 --> 35:23.000
because instead of actually

35:19.000 --> 35:24.000
sending I-O, say,

35:24.000 --> 35:29.000
and then it's actually going to

35:25.000 --> 35:30.000
go do all of that for you,

35:26.000 --> 35:31.000
so you can test your stuff

35:28.000 --> 35:33.000
just by, you know,

35:29.000 --> 35:34.000
making sure that you've sent

35:30.000 --> 35:35.000
the right information

35:31.000 --> 35:36.000
to the library.

35:33.000 --> 35:38.000
Okay, okay, I'm down with that.

35:36.000 --> 35:41.000
Behind the scenes,

35:38.000 --> 35:43.000
well, there's kind of

35:40.000 --> 35:45.000
a lot going on.

35:41.000 --> 35:46.000
It's a cool concept,

35:42.000 --> 35:47.000
algebraic effects,

35:44.000 --> 35:49.000
and really at this stage,

35:45.000 --> 35:50.000
it's more of a research

35:47.000 --> 35:52.000
programming language feature.

35:52.000 --> 35:57.000
Yeah, I mean, you're probably

35:53.000 --> 35:58.000
not going to run this in production,

35:54.000 --> 35:59.000
and in fact,

35:55.000 --> 36:00.000
you probably shouldn't.

35:56.000 --> 36:01.000
But I think it's a useful model,

35:58.000 --> 36:03.000
and it's nice to play with

36:00.000 --> 36:05.000
new ways of thinking

36:01.000 --> 36:06.000
about things, right,

36:02.000 --> 36:07.000
and trying to add tools

36:04.000 --> 36:09.000
that help you separate concerns,

36:06.000 --> 36:11.000
push state to the edges,

36:08.000 --> 36:13.000
and keep things pure.

36:10.000 --> 36:15.000
So, you know,

36:11.000 --> 36:16.000
maybe don't go deploying effect

36:13.000 --> 36:18.000
wherever you need it to be.

36:15.000 --> 36:20.000
But I think it's a practical

36:16.000 --> 36:21.000
example of actually

36:21.000 --> 36:26.000
using it and has a bunch of math.

36:23.000 --> 36:28.000
But I saw that this came out,

36:25.000 --> 36:30.000
and I thought,

36:26.000 --> 36:31.000
if anyone's actually interested,

36:27.000 --> 36:32.000
they want to go play with this,

36:28.000 --> 36:33.000
you can still read a bunch

36:29.000 --> 36:34.000
of nerdy PDFs,

36:31.000 --> 36:36.000
and you can try to use it

36:33.000 --> 36:38.000
in some toy programmings

36:34.000 --> 36:39.000
and see what it might be like.

36:36.000 --> 36:41.000
And as always,

36:37.000 --> 36:42.000
Wes is trying to educate you,

36:39.000 --> 36:44.000
and I'm trying to make you

36:40.000 --> 36:45.000
not have to know things.

36:41.000 --> 36:46.000
So my pick is Minio.

36:43.000 --> 36:48.000
Pretend like those servers

36:45.000 --> 36:50.000
and S3 instances aren't there.

36:50.000 --> 36:55.000
Like all over the place?

36:51.000 --> 36:56.000
Oh, Minio, several years.

36:52.000 --> 36:57.000
Several years.

36:53.000 --> 36:58.000
It's actually funny,

36:54.000 --> 36:59.000
I haven't been to their main

36:57.000 --> 37:02.000
non-GitHub website

36:59.000 --> 37:04.000
for a few years since today.

37:02.000 --> 37:07.000
I had no idea that they had

37:04.000 --> 37:09.000
this whole AI library thing

37:06.000 --> 37:11.000
going on, too.

37:07.000 --> 37:12.000
Oh, it's 2019 now, Mike.

37:09.000 --> 37:14.000
Everyone does.

37:11.000 --> 37:16.000
I have Alice.

37:13.000 --> 37:18.000
I keep deciding if C Sharp

37:18.000 --> 37:23.000
is going to be there

37:18.000 --> 37:23.000
for the next few weeks.

37:20.000 --> 37:25.000
But yeah, they have a lot going on.

37:23.000 --> 37:28.000
I can't vouch for anything else,

37:24.000 --> 37:29.000
but I can tell you,

37:26.000 --> 37:31.000
as an open source,

37:28.000 --> 37:33.000
make your own little rate array

37:29.000 --> 37:34.000
and store your files, top shelf.

37:32.000 --> 37:37.000
Thanks for the great pick

37:33.000 --> 37:38.000
this week.

37:34.000 --> 37:39.000
Thank you.

37:35.000 --> 37:40.000
Now, where can people find you

37:37.000 --> 37:42.000
to learn more about

37:38.000 --> 37:43.000
computer science and calculus?

37:40.000 --> 37:45.000
Oh, you can find me rambling

37:42.000 --> 37:47.000
about things over on Twitter

37:47.000 --> 37:52.000
but they can find you

37:48.000 --> 37:53.000
trolling the universe

37:50.000 --> 37:55.000
over there, too, right?

37:51.000 --> 37:56.000
That's on Twitter

37:52.000 --> 37:57.000
at Domenico

37:53.000 --> 37:58.000
and visit dominechem.com.

37:55.000 --> 38:00.000
I will be writing up the horrors

37:56.000 --> 38:01.000
of abstractions this week.

37:58.000 --> 38:03.000
Oh, I'm looking forward to that.

38:00.000 --> 38:05.000
You can also find the whole

38:02.000 --> 38:07.000
network over at Jupiter Signal

38:04.000 --> 38:09.000
or jupiterbroadcasting.com

38:06.000 --> 38:11.000
where you'll also find

38:08.000 --> 38:13.000
the calendar.

38:09.000 --> 38:14.000
That'll let you know

38:10.000 --> 38:15.000
when we're doing this show live

38:11.000 --> 38:16.000
and if you have the time available,

38:16.000 --> 38:21.000
just tune in live

38:17.000 --> 38:22.000
when you have a chance.

38:19.000 --> 38:24.000
Of course, there's also a ton

38:20.000 --> 38:25.000
of other great Jupiter

38:21.000 --> 38:26.000
broadcasting shows,

38:22.000 --> 38:27.000
so check those out, too.

38:24.000 --> 38:29.000
Or if you just want Coder Radio,

38:25.000 --> 38:30.000
well, coder.show.

38:27.000 --> 38:32.000
There you can contact us

38:28.000 --> 38:33.000
or just subscribe to the RSS feed

38:30.000 --> 38:35.000
which is the easiest way

38:32.000 --> 38:37.000
to make sure you always

38:33.000 --> 38:38.000
get the latest episode.

38:36.000 --> 38:41.000
Thank you all so much

38:37.000 --> 38:42.000
for joining us

38:38.000 --> 38:43.000
and we'll see you right back here

38:43.000 --> 38:49.000
for another episode of

38:49.000 --> 39:18.000
Jupiter Radio.

39:19.000 --> 39:23.000
radio.com


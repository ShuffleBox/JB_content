This is Koda Radio, episode 347 for March 4th, 2019.
Hello and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show that's taking a pragmatic look at the art and business of software development.
And don't you forget those related technologies.
My name is Wes and I'm joined once again by that funky Floridian, Mr. Michael Dominic. Hello, Mike.
I've got gators in my garage.
I mean, that seems like good motivation to stay inside and get your work done.
Damn, Skippy. I've written more Ruby code in one week than I think you have in your entire life because you're too smart for that.
I've been writing actually a decent amount of Ruby these past couple of years.
I really thought I had you this time.
I know. I mean, it may not have been my first love and it may still not be really my love, but I will say it's very practical.
So this is not even a topic for today, Wes, but in what context are you writing Ruby?
Well, some of the show stuff, some of the automation system ends up being written in Ruby just because the larger system was already Ruby.
Oh yeah, JBot already, but no, some of the new stuff we've been working on, like the system that will post this show once it's done.
I stand corrected.
Yeah. And I mean, I also was, for a while I did a lot of Ruby because I was working with Chef.
So that kind of, I'd done about four, but it was more of a Pythonista myself.
So that just kind of got me familiar enough with Ruby where now I can hack it when I have to.
I don't, I don't know, there's lots I don't like.
I mean, Gem, come on.
There's so much tooling that is kind of unfortunate.
The number of times I've compiled Nokogiri without ever needing to use it whatsoever.
I mean, I actually have used it recently, but most of the times you don't actually.
So you use Rails is what you're telling me.
I have used Rails, yes.
Right. So if you don't mind, we don't even have it on the doc today.
I mean, I think we're talking about it now, buddy.
So I think we are, we're committed now.
So if you had to name like your top three things you dislike about Ruby and that can extend to Rails if you want.
What are they?
Oh, OK. That's a great question.
You know, it's just a little, it's a little loose.
It just doesn't feel very.
I know that's a great thing about it.
Right. It's so message passage.
It's almost it's like a it's like a weird small talk lisp.
I don't know what else other languages you want to throw in there, but it's got a very unique and strange pedigree that I like a lot.
Objective C. Yeah, that totally fits.
I like a lot of the pedigree, but the way it came together, I don't love the do blocks.
The syntax really just rubs me the wrong way, which is totally, totally meaningless consideration, which is again why I end up using it.
Right. Like that doesn't affect it.
It just doesn't feel.
Something about it doesn't strike me as pretty.
I know everyone loves Ruby for that reason, and I just don't get it.
Oh, no, I don't think everyone loves Ruby.
I've been to enough meetups where I can tell you for a fact that not everyone loves Ruby.
All right. So you would call that the loose nature of the message passing system, even though it's not really message passing.
Right. No, but I get the syntax. OK, so that's one.
Yeah. Well, yeah. And then just like, yeah, the I think for a long time there was somewhat culture, which the community's got a lot better.
But overuse of mixins, just all the rails magic that got started.
I will give you mixins. Give me three.
Number three. I don't like the deployment story very much.
Oh, like Python has a number of tools that make it pretty easy if you have to go publish something that runs like Twitter has checks.
There's a ton of them now. And I know there are some things like that for Ruby, but anything that has a bunch of dependencies that I want to go run on another system.
I know how to make it work, but it just doesn't doesn't feel very clean compared to be able to like make a jar or a static binary.
So it's so funny you say deployment. I spent most of my morning fixing a broken Ruby deployment from a right from someone who no longer works with me.
And yeah, it's. You know what?
I'm going to go on and say one of my crazy broad things that people are going to get mad about if you're doing and this is rails, the context I'm talking about is Ruby on rails.
Right. Right. Just use Docker and Doku. Everything else is like its own little beautiful princess that has to be taken care of.
And if like you're missing a key or something weird from, you know, the guy or gal that did it, you know, three years ago, then you're hosed for hours.
It's I will give you the deployment story, particularly then if I don't know how much you want to dive into this.
So stop me when you want to. But the issue we had, what is it? We're running on AWS Linux.
So Amazon's particular flavor of Linux. I'm sure you're familiar with this, right?
And for whatever reason, AWS Linux defaults when you do there's like an auto, you know, there's like a preset Ruby on rails.
Yeah, they've got it all ready to go packaged up for you.
So you don't have to worry about it. If you're if you're using rails five, which is the current stable version, they call bundler two point zero instead of bundler one point.
I think it's like nine three. So our entire application just like broke.
Oh, my gosh, that is the other thing, especially when you combine bundler in the mix and there's so much rewriting happen like the functionality provides is good.
And there's like a whole complicated world of the different ways, in particular languages like Ruby and Python take care of those tasks.
But boy, some tiny weird Ruby path issue. And anytime you end up debugging that, you just kind of want to scrap the whole thing.
Oh, so it the error I got was kind of insane, right?
Because it just said bundler doesn't is not, you know, the binary not found gem system.
E o n t. Right. We don't need to. Oh, yeah. Yeah. The strange Ruby error. But then you go like, you know, gem list and bundlers right there.
It took me a couple of minutes to say, does bundler two point X have breaking changes from bundler one point X?
Right. Right. And I would imagine so. Yeah. Oh, it does indeed. Google the issue with the with the tag on Stack Overflow, AWS, Linux.
And it's a huge problem. People were sharing. I had to write and I think this is really stupid, but it wasn't a lot of work, but.
I just think it's dumb. I had to write a they call them because really, we're using the code deploy thing, which is actually a problem.
Right. They used to call elastic beanstalk, but Amazon rebrands everything every five seconds.
So I had to write an elastic beanstalk. They call them extensions, which basically that's a dark road.
Yeah. Well, they're basically like Docker proc files or Docker pre run scripts, right?
Except they have their own weird proprietary format. And it's just this annoying thing where you're maybe writing 20 or 30 lines of code.
But because it's specific to Amazon, you have to like at least I do because I tend to prefer DigitalOcean and, you know,
generic Ubuntu because, you know, I like things that are standard.
I'm sitting there split screen the Amazon docs to the left for the old elastic beanstalk system.
And my in this case was a Ruby mine in in dev mode.
They have a one screen code mode on the right. And son of a bitch.
I mean, it's it is not what you want to be doing at seven thirty in the morning.
Oh, no, that's that sounds so unfortunate. But I now know how to do it forever.
So the issue, by the way, if somebody has this problem, the issue is from now on, from whatever date going forward,
the Amazon Ruby on Rails install is defaulting to Bundler 2.0.
If you don't explicitly specify in an elastic beanstalk extension that you want the one point X series.
The problem is the rails generator still assume that you're going to do like one point nine point three, I think is the current.
So that's just it's just all that stuff. I think you're right.
Using Docker does help. It feels like it gives a bit more reproducibility insist on what I wanted to install.
Right. Yeah. You get to choose the whole thing and kind of have a different interface to it.
Yeah. Do you have any tips or tricks that you like for deploying?
Do you ever deploy just sort of like command line scripts or utility written in Ruby?
All the time. That's usually a little less painful because you're almost never.
I mean, you can still use Ruby gems, but in that case, you just go for like system installed gems.
What if you just like, you know, you wanted to like it's so handy in some other languages like go, for instance, really does this well.
Right. Where you can just go, especially if you have a GitHub release, you can just go have a generic Linux binary up there that people can download.
Put in, you know, home der slash bin ch ch modded and away they go.
Yeah. So on the binary side, I tend not to use Ruby. I tend to use either C++ or actually it's almost always C++ unless it's Java for whatever reason.
But the way I solve the system install gem problem on Ruby for kind of like just like scripting is I use a Ruby environment, R, B, E and V.
Oh, yeah, totally. And I just have like an environment per what I'm doing.
So each project just gets its own little environment.
It's its own little natural snowflake. Yeah. Right. Yeah.
Similar in many ways to the virtual end of Python fame. Exactly.
Yeah, it's just such a contrast with the binary thing because it's so easy.
The great part about Ruby, right, is like you can sit down, install a few things, pull up a Ruby repl and you can do whatever you want.
And there is a gem for basically whatever you could possibly need. Every API exists in there.
So at one hand, it feels very powerful. There's a lot of leverage. It's easy and fun and generally pretty nice to use.
And on the other hand, it feels like once you get serious, you're like, oh, man, OK, my project works.
Now I've got to go run it in the wider world. It's a huge letdown.
Well, and the other answer to that problem, too, would be Docker, though.
Right. If you just have a prefab container that can be Docker pulled, even if you're using a private repo for that instead of Docker.
That's a good point. Or some other stuff. Right.
Like like a snap package, for instance, would be just fine. A package would work.
Yeah, snap package would work. Yeah. Interesting.
All right. Well, we're getting into the sides of deploying stuff.
And that might just be one thing you think about when you're talking serverless.
I saw and it sounds like you also saw some good feedback over in the CoderRadio subreddit.
So also just a pro tip. We've got a subreddit. Yeah, that's right. R slash CoderRadio.
You really you just can't miss it. Thankfully, user and listener Tom Enum pointed out that one thing we didn't quite get to in our discussion of serverless last episode was that it scales to zero.
Which I got to say, it is totally fair. That's a great use case.
And we just didn't manage to talk about it. But it's certainly true.
Right. If you have some stuff that is just really periodic, you don't need it.
It can be simpler and maybe cleaner in some ways, too. Right. Rather than just be like, yeah, I put it on this other box and it runs as a cron job.
Kind of feels dirty. Yeah, and it can be more cost effective.
Right. If you only have like a big import that you do once a month, just throwing it on Lambda or or Azure functions.
I mean, we did that with Alice with some PDF scanning and emails.
That was we just had a bunch of Azure functions that did that.
And why? Because there was almost no customer. I think we only ever had one who actually had enough PDFs that were big enough that we wanted to offload it.
Yeah. OK. And that was a node application.
Right. And I guess I suppose perhaps why we didn't quite get there is because we were talking at the time, the question that prompted that was going full serverless.
And it could be very different if you're considering full versus like as an addendum, an additional thing that just as a periodic job runner or event responder. Super useful.
I agree. We have to disagree on something, Wes. I mean, this is getting very boring.
Come on. Let me ask you a question, Wes. How do you feel about Germany and Linux together?
Oh, Germany and Linux together. Well, I'm a big I'm a big fan of Germany, so no problem there.
And you might have guessed I'm a big I'm a big fan of Linux, but together, it's kind of a guy.
Well, actually, I spent a long time on Windows and me. Let me tell you about that.
But actually, I can't because I purposely blocked out those memories.
So elephant the room, we're obviously talking about open Zeus and it sounds like you've actually been doing some open Zeus things, which I found a little bit strange.
I've got nothing against it. It's just it's not an ecosystem.
I play it very often and it kind of strikes me and I'm curious about your thoughts about this.
But there's a lot of very interesting tooling and tooling choices and tools available, techniques, powerful file systems and the way it's been configured.
But it seems like you kind of got to know enough to put it together in a way that you might not have to if you're deploying on Ubuntu.
Yeah, that's super true. So I have been working with a new client who is an open Zeus shop.
Now, we should just set this up. For context, we're talking server side open Zeus for the context of what we're going to discuss here.
So we're running open Zeus on servers. That's the operating system you've chosen to run your software on top of.
Right, and actually they're running and they're running Zeus proper, Zeus Enterprise. Oh, good.
But I'm deving to open Zeus and I'm using the Thaleo as I was corrected by Emma to do the actual work.
So I have, and I'm sure you do too, Wes, like a collection of my own bash scripts and like Docker scripts and all this kind of stuff that I use on Ubuntu.
Yeah, the things that if we were, you know, if we worked in a physical trait, those would be on our tool chest, you know?
Right, these are things that I use. Anytime I have a new project, there's like a couple shell scripts that I run on a server, right?
Well, none of them work on open Zeus.
Yeah, gosh, that is very different.
So I did not notice how much of a dependency I had on apt.
Yeah, you kind of just trust that you would be in a debian ecosystem.
You would be in a debian environment. So I did what I do with any new engagement and I say, you know what, AWS is powerful.
I personally have some concerns about how proprietary Amazon has made their version of Linux, particularly with the tooling side,
that it's like not that easy to get off unless you're just using Docker.
That's a big one, right? Especially, I see it a lot in the ML space too. Yeah, we've compiled all the hard and annoying ML libraries, so just use our Linux.
Yeah, but yeah, and that's the topic for a whole other show, right? But let's...
Yes, it is. Stay focused here. Open Zeus, I'm sorry.
So I tend to recommend DO to people, the former sponsor of the show when we, before our Linux overlords bought us.
And I was frankly surprised when I went into my DO dashboard, looked at the hundreds of droplets that I apparently have that I don't pay attention to, but pay for every month.
Yeah, don't think about that. None of us, we're not willing to fight that fight today.
And I went to create a new one. You've used DO, right? It's got the nice little dropdown, you got all the logos for the distros.
Yeah, it's nice and they have a decent distro selection.
Well, I ended up doing a control find for Open Zeus because for the life of me, I couldn't find it.
Yeah, okay. Is there another page? Is it page two? Where is it?
I missed something. So off to the forums I go and sure enough, as soon as I duck, duck, go search it because I've become a hippie,
I find that this is like the number one user voice complaint from the DO community is that there's no Open Zeus.
So I ask around, I make kind of a cheeky tweet saying, you know, Germans or I forgot what the other one was,
but I said basically German people who love Linux, help me. How do I get Open Zeus and DO?
And a maintainer of the Open Zeus project replied and said, it's possible, but if you could write a write up, we'd appreciate it.
Okay.
And so you did just that.
So I did that.
What a guy, Mike, geez.
And you know what? It's really not that hard. And in fact, I think, again, Wes can tell you because I know we all love Wes.
I'm telling you, DO is not a sponsor of the show anymore, but DO makes it very easy to upload custom Linux or BSD images of what you want.
So in my case, what I want is an Open Zeus box with some Rails, let's just say tool chain, right? Rails tool chain configured.
So for the write up, I skipped the Rails tool chain, I just did the box.
But sure enough, it's about a 20, 30 minute process. A lot of that's downloading an ISO and like uploading the ISO.
Yeah, right. You got to be the middleman.
You got to be the middleman. And there's like a whatever process DO does on the back end to process it is, in my experience, not very quick.
Right. They've got to go get it integrated, ready to run in one of their data centers, all that.
And then you have to set up a droplet, right? Then you got to set up like, you know, the IP, the DNS, all that good stuff.
But I'd say within a half hour, I was up and running on Open Zeus.
And then I was learning all about Zipper and Yast, which apparently Yast is the GUI front end to Zipper.
So we can talk about that if you want.
I would love to. Yeah. I mean, had you had you used this operating system before?
Are you familiar with any of the tools? Way, way back in like 2007 when I originally used Linux before I went to Mac.
So, yeah, fun fact, if you're a new listener, I used to use Linux before I used Mac.
Then I went to Mac for a long time. Then I now I'm back on both.
I did play around with Open Zeus. I liked it because I felt it was more put together because you got to remember at the time we were talking like Ubuntu 8.10.
And there were some serious issues.
Oh, yeah. OK, well, those were different days. Yeah, it was a different time.
I so I went and I actually also used Fedora at the time, which I know is Fedora is completely different now because KDE is completely different.
But on the server now, I mean, I've been using I went on the server when I was primarily an iOS dev.
I just used Ubuntu 16.04 or whatever it was, 15.04 actually LTS.
And and a little bit of RHEL, right, because I have customers who love RHEL.
Yeah, of course. I mean, it's hard to avoid.
But Open Zeus, like I have to be honest with you, I sincerely believed it was just for Germans.
Is this even allowed? Are there some sort of customs check that's going to happen?
Do I have to like go surrender to Homeland Security now or something like.
I assume there was like a delicious bratwurst that you ate while you were getting the ISO all rigged up and ready.
It was weird. As soon as the ISO downloaded, a gentleman in Lederhosen brought me like a like a nice like substantial beer, you know, and a couple pretzels.
It was weird.
OK, so are you using are you deploying using your trick from the start of the show and deploying containers here?
Or are you actually having to get nitty gritty and build your software and really run on Zeus?
So that is an open question. For the purposes of dev, I'm just doing Docker containers.
Right. Sure. Because you deploy like five times a day and it's just not worth it to like have to worry about this problem.
I will say that Open Zeus is very, very different.
Like yeah, yes, I keep saying yes, I really mean zipper zipper is.
Well, it functionally does what aptitude gets and West, you can correct me because you're the stronger Linux person here.
I find it very foreign to work.
I mean, there's so there's always going to be some mental overhead, right?
When you switched things, most people have at least done, you know, play a little bit in Debian and then maybe gone over to Fedora and used Yom and DNF.
Somehow that doesn't feel as different. I agree.
Like zipper is its own tool and they almost think about things in a slightly different fashion over in Suse land.
But it's not I mean, it's not bad.
It's strange that it's it feels a little bit more segmented, like they have their own the walls to their community.
Not that they aren't welcoming, but just it's more often its own world than the other larger Linux ecosystems.
I don't know if it's a good thing or a bad thing, but they just have more differentiation, I guess.
Well, more differentiation, and I think it's a case that they just have a I can't I can't even try to think of how to say this correctly.
They are one of the if you're using Suse proper, one of the certified Linux districts, right?
So this is like REL for people who don't want to use REL, I guess.
Or, you know what, to be honest with you, I and I can't speak for other people, but my understanding is that the people using Suse are using it because a business decision was made, you know, and years ago.
Right. I mean, yeah, usually those are long term major decisions.
Frankly, once you've built up the knowledge to actually operate in a Suse environment, why not?
Right. Well, like I'm coming from the opposite side. I'm used to Debian, but if I had been working in Suse forever, I would probably continue to prefer Suse.
Right. Sure. So you really you haven't found any reasons not to. That shouldn't be a problem.
Yeah. I mean, so once I uploaded the ISO to DO and got that all set up, like that's a little more work.
But, you know, mostly mostly a fixed cost, right?
Like you get it all set up at first and integrate literally. So I uploaded the Rails one for my customer and then I just uploaded to my personal account a generic Suse of the current, whatever the long support one version for them is.
Only because if somebody in the future asks me for Suse, well, now I have an image that's ready to go.
Oh, excellent. Yeah. Yeah, right. Now it's just going to be sitting there.
DO is not going to delete the images off my account.
Smart thinking there, Mr. Dominic. I try.
Well, this is this is fascinating. I'm going to be curious to see how this evolves as you as you keep playing with it.
Might we someday see you running Suse on the desktop?
No, I love me some Pop OS. I know.
I was looking at your article here in the Pop OS screenshots. I mean, they do pop.
They pop. I love pop and I love elementary. So I in fact, if I if I could, I might switch the Thaleo to elementary, but I can't right now because it's a customer bought it.
So pop is. Yeah, go ahead.
What I was going to say is, well, what stands out to me is you must like Pop OS so much that even though there's like a new Mac in your life, you've relegated that to an appliance role and kept pop for your little desktop, huh?
Yes, so I'm running Pop as my desktop because I also have the Darter Pro, which I'm going to finally finish the review of this week. I wanted to take into the field for a while, which is if you don't know, a system 76 laptop, again, defaulting to pop, right?
Yes.
I need a good Mac build machine, though, Wes, for iOS dev.
Right. I mean, you can't you can't really get away from that, right? Unless you want to pay someone else to host one for you.
Which I was doing and was back.
Yeah, exactly.
So what I did was I took all of my valley of, let's just call them mistreated Macs, and I sold them to be repaired and resold.
Good. Oh, man, they will find better homes.
They will find better, more stable homes.
Dryer too.
Dryer. Yes. And I purchased a Mac Mini that will go on the router and be a podcast machine to avoid any any fan noise issues.
So that is the plan.
Oh, OK. So you said you said we'll go on the router. What did you mean by that?
Sure. So automated iOS builds, right?
Right now I'm renting Mac build services from Microsoft's, I want to get this right, App Dev Center, I think they call it.
Wait, what? Can you break this down for me?
OK, so in theory, so let's slow down. You can automate any build you want. In GitLab I can automate Rails builds and run my tests and get that feedback in Slack.
Really?
Yeah, that's what I do. That's actually what I do for Rails.
Yeah, totally. You go trigger a build, go find out what happens, either successful or whatever, and then get some fast feedback.
Yeah, and Bitbucket can do the same thing. They call it pipelines on the Bitbucket side.
So a problem I've always had is that no one can do this for iOS, at least none of the big source control vendors like GitHub, Bitbucket or GitLab, because you have to do code signing.
You have to do code signing, right. That is just not something I always think about, because most of the platforms that I end up writing for, well, I don't have to do that.
Right, which means you need a physical Mac or a VM of a Mac, but it has to be on Mac hardware.
It has to be on Mac hardware, really?
Yeah.
Oh, boy.
So it's kind of crazy. In the meantime, I've been using Microsoft Azure, they call it the App Dev Center, which was great, but Azure credits aren't necessarily something I have a lot of.
And it's just a little pricey, given how quickly we like to iterate.
I see. Yeah, so the model doesn't work out for the way that you want to develop.
Right. So a Mac mini can serve multiple purposes. It can be an iOS dev machine.
It can go on the router and effectively be a one-time cost forever free build machine.
And it can be a podcast machine since we obviously want to mitigate, we want the highest sound quality we can get.
Ain't that the truth?
Now, the challenge is there's multiple ways to do this.
Obviously, at Jenkins, Apple used to have something called the robots, which I was asking about in the chat before, which is part of Xcode.
And frankly, there's a ton of other automated build systems.
Yeah, how many of those work well when you're targeting iOS?
Well, there are specific ones, too. There are specific other open source or proprietary CI systems for iOS.
So have you decided which one you're going to deploy? You're still weighing that.
I am going to try to stick to the Xcode solution as much as possible.
My second choice would be something like Jenkins.
Yeah.
So does this work the same way?
I mean, so do you just go point this at some Git repository that it pulls or are you pushing notifications into it and it has the source already?
It can be either way. You can push it in or it can pull off a Git repo.
Nice.
Yeah.
So it's definitely – and the problem I'm solving is two.
One, I want automated builds of iOS stuff.
And two, I want to make sure – and this has been a problem given the number of Macs I've gone through and how kind of finicky code signing is.
I want one machine that can do all of my code signing and not have that horrible thing where you upload a build,
and then you go away and 10 minutes later you get it rejected because some certificate's out of date or –
Kind of reduce variability that you might have.
You always know it's going to break fast, you're going to find out quickly because it's all going through that machine.
Exactly. I want to mitigate the risk of the Apple-specific issues.
Yeah, that makes a lot of sense.
For such a successful ecosystem, the number of things that you have to do just to make it all work in the same way that are just a little bit easier at every step in other ecosystems, it's kind of strange.
As an outsider, it boggles my mind a bit.
Not that there aren't reasons for it. I can understand how it got here. It's just different.
I still think they're going to have to do something about it, but it's becoming too much of a hassle to constantly have to revoke and regenerate certificates
and then worry about does someone have the right provisioning profile on their machine and have to send the awkward email.
Here's your build, here's your invoice, and then the guy comes back and says, oh, well, it doesn't open on my phone because I got this weird error.
So you have to say, okay, go back, delete the provisioning profile. It's just a bad experience.
Yeah, yeah, okay, that's true. What's it – it's funny to think of – you have this little Mac mini. It's almost like a little server.
Is it going to be headless? Are you going to have a monitor attached to it and it's going to be on a desk somewhere?
So it's probably going to be on the desk here because I'm probably going to use it for podcasting too.
Right, right. Yeah, okay, you will sound pretty good. I guess I'm okay with that.
Right, since we had a little rigmarole about background noise before the show.
Yeah, the whole start of the show is me just haranguing you to fix your sound and you saying, wow, there's nothing else I can change.
Yeah, so, okay, will you also move any of your other CI or is this going to be just solely for the iOS stuff?
No, this is going to be solely iOS.
Yeah, right, I guess it really wouldn't make that much sense. The cloud infrastructure is already available or whatever else that you are using and you'd be running it on a different platform.
Yeah, yeah, I mean, everything else we do, it deploys to basically Ubuntu with like the one exception of the openSUSE and there's like one rel thing.
So, I'm pretty happy with, we're doing a GitLab CE instance for all of that and I'm pretty happy with that.
It supports Rails really well, it supports Python, it supports Node, it basically supports everything that we do.
What do you mean by really well?
So, you merge into a branch or you push depending on how we have the project set up and it intelligently runs the tests and it does a bunch of stuff to just basically.
Hmm, just like plenty of built-in understanding.
Yeah, built-in understanding that you don't have to configure.
Love it. That does fit with the whole Rails ecosystem too, so that makes plenty of sense.
Magic.
I can't, Rails is useful, I'm not trying to bash Rails, okay?
Hey, would you like my magic gems?
Maybe, I mean, yeah, how do they, what's the catch here? There's got to be a catch.
The catch is you don't know what's in them. That's the catch.
I love it.
It's the same thing with pip, let's not even go there.
Oh my gosh, yes. It is the same thing with pip. Why is packaging so painful all of the time?
It just is.
I mean, so you're just talking about Node, one of the both more vigorous and alive and just filled to the brim with stuff packaging worlds,
and one of the most problematic of late and seemingly all the time is obviously JavaScript, right?
NPM makes me cry.
NPM makes me cry, yeah, right? I mean, I think it makes a lot of people cry, probably also the people who have to deal with it.
But it did, I mean, it did kind of solve an interesting problem.
It's funny to think about JavaScript as it was such a neglected language for so long and then suddenly revitalized.
So I can see that you might make some mistakes.
And now, of course, it's gotten even more complicated because suddenly we have different types of packages,
CommonJS and then the native packages that now exist, and there's been so many workarounds and different ways to do things.
It's pretty confusing in 2019 how it all can work together and support the maximal set of possible client configurations.
And I'm sure that must be something that you have to run into, right?
Like part of those CI systems probably involves some sort of transpilers, build things, packers, Webpack, maybe Babel.
What's all happening in those dirty JavaScript configurations of yours, Mr. Dominic?
So, honestly, all of the above, and I haven't even picked one.
It's a shit show.
I mean, the JavaScript ecosystem, for all of the progress ECMAScript has made, it just...
Oh, we're going full names here. Listen to that.
Yeah, we're going full names.
That's how you know you're in trouble, buddy.
ECMAScript.
See, ECMAScript is a good language until you pull in some dependencies.
Then it's JavaScript, and it sucks.
Yeah, I mean, well, that's why I think you found for us this week, right?
Pika package.com, which basically only allows you to find packages that adhere to the newest standards.
Yeah, it's...
Okay, full disclosure, I have not tried it, but I saw it floating around various people talking about it.
Pika's mission is to make modern JavaScript more accessible by making it easier to find, publish, install, and use modern packages on NPM.
Yeah, so you're saying, Mike, firstly, you can go to pika package.com, and then they've got a search bar there that will just help you find fast, modern, native packages that match your keywords.
Basically, they've built up this repository and found all the ones that are already being built in a modern way that makes it easy for you to consume them in a modern way.
But they've also got a whole bunch of tooling to support this so that, in theory, try to simplify what you're doing and enable you to support native modules and all the latest JavaScript stuff.
I don't know what I think, because obviously the first question, besides the cute branding, which is kind of cute, yet another tool?
Isn't that always something we have to be a little bit skeptical of?
Yeah, I mean, in your opening to this, you mentioned Webpack, Babel, and I think two other things, right?
The JavaScript ecosystem, particularly anything run by Node, it's just a lot of magic.
I mean, we were talking about Rails before. There's so much more magic here.
I don't know how I feel about this.
I don't like it when I do a large amount of JavaScript and then I pull in some old package and I have to accommodate all the old terribleness.
Yeah, so this does seem like it, in theory, can try to help do that.
It wouldn't allow you to pull in that package, right?
So that package would not surface on Pica, is my understanding.
Yeah, but it does look like they've got a whole bunch of plugins and various interfaces to help you.
You can package to support those things, but it looks like you could also maybe help import some other packages and modernize them.
But they've got a whole bunch of stuff. They even support, interestingly, they even support BuckleScript and ReasonML.
They've got a TypeScript thing, of course. It's interesting.
So let me take this on a curveball for you, Wes.
You like ClosureScript, right? You're kind of more of a functional, mathy kind of programmer than I am.
Indeed.
How does this not all just seem like an abomination to you in the JavaScript world?
I mean, parts of it does. I mean, ClosureScript obviously exists because of the fact that transpiling is so well supported.
It would be hard to exist as the only language that worked that way, probably, just in terms of development tooling.
Chrome ships stuff so that if you have source maps for ClosureScript, it shows up and gets syntax highlighting all that right in Chrome.
So that's really nice.
JavaScript, ECMAScript, you're right. It's getting a lot better. It's come a long way.
The part that feels like a mess. I think it's honestly really reasonable.
And if you can find the right documentation, learn just the modern stuff, it's actually pretty reasonable, right?
It feels like almost a sane language. But having watched it happen, I don't know if it's ever going to really –
I think practically it'll be fine for as long as it hangs around, which is going to be just forever.
Forever, right.
But I don't think it'll ever escape the cruft of its weird history.
So does JavaScript need to – so this is where I want to take this.
And credit to the Pika team. I think this is actually a great tool. I will probably try this out.
Yeah, I'm definitely going to try it, dude.
Because I hate when I import old libraries and I get trapped into nightmare land, as I call it.
Maybe the answer isn't that JavaScript the language escapes. Maybe it's that WebAssembly just wins.
And I know DHH, and we covered it a few weeks ago, doesn't like this idea.
But you know what, Wes? If you like to write in Swift, which I know – or Ruby.
I know you're a Professor Ruby lover today.
And I like to write in Objective-C. Maybe not Objective-C. Nobody loves Objective-C anymore, except for me.
But let's say Ruby.
What about your dream? What if you could write in C sharp?
Oh, my dream. Or F sharp, even, if I remember.
Oh, yeah.
Both compile to WebAssembly. It seems that you could pull in my little library as a binary, right?
Just pull it in as a statically compiled WebAssembly library.
Or I could pull in yours and we're happy.
And everybody gets to work in the tool chain that they're most comfortable with.
If you're a Windows guy and you want to work in C sharp, God bless you. Just compile to WebAssembly.
I mean, we talked about Project Uno that does this, Avalonia does this, in terms of re-implementing XAML and the.NET UWP stack into WebAssembly for web development.
Maybe my whole point – which I realize I'm meandering – my whole point is, maybe it's less, is JavaScript going to evolve out of its legacy?
Because we're talking – we're back in the 90s here, so I kind of don't think it's going to happen.
Maybe the answer is that you code the way you want to code, and we just target WebAssembly.
So if you're a.NET shop, you code in C sharp and F sharp.
If you're a Ruby shop, you code in Ruby and horrible CoffeeScript, and we all end up in WebAssembly on the front end.
I mean, that doesn't seem unreasonable to me just because it's kind of what we're doing now, right?
I mean, we've just done that with JavaScript.
It seems like what's starting to happen, yeah.
It's just that we've been limited somewhat by the types of languages that could run with any sort of advantage being transpiled to JavaScript,
whereas WebAssembly, we're rethinking that a little bit and saying –
We're not transpiling anymore, right?
That's the big difference.
Well, but I mean, sure, we're just compiling in one sense, right?
We're just changing from running as JavaScript to having a different execution engine, notably one without a GC.
Right, so this is how – this is the big thing about WebAssembly, though, right?
If you're an optimist like me, you believe that WebAssembly is basically going to become, for all intents and purposes, real assembly.
It's like whether you compile C++ or Objective-C into assembly in native code, you're good to go.
Right now, I know that's not technically true.
I think that's – in fact, on the show, I could do a better job of putting it in the show notes that we should be covering not what API changed in JavaScript,
but how close is WebAssembly and how differently the different browser and engines support it that it's coming to that ideal –
again, this is opinion, what I believe is the ideal – of it effectively, if not in actual practice, being literal native assembly.
So does that not bring back some problems?
At least when we're all doing JavaScript, there's some –
It's ActiveX.
Yeah, well, yeah, so there's that. There's the, like, oh, gosh, now it's even more obscured binary things running from some stranger on the internet.
But it also makes me think, like, at least when you're running as JavaScript, the base is JavaScript, and that's a pretty high base,
which is obviously bad for many things, right?
That's why we don't have – you can do all these cool, exciting stuff with game engines in the browser and in WebAssembly,
but it means, like, sharing data.
You don't have to, like, make up weird binary calling conventions or go through all that, right?
In the WebAssembly world, you could have things that maybe can't interrupt,
or interrupt is harder because you have some crazy functional high-level thing trying to interact with something from a totally different world.
But we already have that.
Yeah, do we want that again?
Sure, we already have –
Because right now, like you said, I could pull in your JavaScript thing, and even if it's super weird,
since it is using JavaScript data structures at the end of the day, I can use them.
Right, it'll just make your code maybe be non-standard for your style in terms of –
Right.
Right, the whole problem with JavaScript is, you know, I don't remember what year this was,
and I know you know those books, I'm sure we've both read it, JavaScript the Good Parts versus JavaScript, right?
Yes, right.
One was real small, one was real big, and that's the problem.
But, I mean, to your point about higher languages and lower languages and different paradigms,
I mean, I literally call Rust from Ruby now.
I call C++ and C from Ruby all the time.
You know, people are doing that same thing in Python, that same thing in Java, right?
Certainly, yeah.
No, I mean, it's useful, it's needed, but it's kind of always a pain.
Yeah, but FFI exists, and I know we're going deep into the nerdy stuff here, but like –
Foreign Function Interface.
Exactly. Why can't there be an FFI for WebAssembly?
And I believe there already are.
Oh, is there really? See, I didn't even know.
We're working on this, so it's certainly going to be a soft problem.
It just makes me think like we are – it's not a bad thing.
It's just questions to ask as we go down this road of further reinventing the whole world in the web browser.
So I think the scarier part is, what if one browser vendor ends up being able to take control of this?
Yes, right.
And we've already seen that happen in spaces like – particularly with Chrome.
Right.
I basically code to – well, actually, I say I code to WebKit, I really code to Firefox, which is not WebKit.
But most of – yeah, I actually think that most –
You are – I love it.
You know what? I think Mozilla is the best tech to learn this vision.
Resist from the inside.
Resistance is futile, but I'm going down hard, like my good friend, Jean-Luc.
Nothing bad happened to Jean-Luc, right?
No, no, never.
The cutest? Nothing? Okay.
I think he learned a lot from that experience.
You know what? I'm sure he did.
Maybe not things you want to learn.
But I do worry about the Chrome – what's the right word? Like hegemony, right?
Let's put our old man hats on, Wes.
Do you remember –
Mine's already on. Don't worry.
Okay. It's always on.
Getting specs that say must run target platform IE6.
Oh, yes. Why are you reminding me of this?
Well, I know, and then I might start to cry, so we're going to do this real fast.
I'm getting the same things for Chrome now.
Yeah, yeah, absolutely.
I mean, part of that is you just don't move, and it's nice to have one supported platform from the end user's perspective anyway.
Yeah, I think everybody shoots Firefox and DuckDuckGo, to be honest with you.
But that's a whole different argument.
Right. So to bring it back a little bit, your worry is that Chrome in particular,
but any browser steps away from it and becomes – you have enough non-standard features.
However, it goes down that they become the runtime, and it's not a glorious WebAssembly future where it really is portable and you can run wherever.
Instead, it's just this one platform.
So my whole dream of WebAssembly is the lie that I was told in the 90s about Java being run everywhere might actually now be true.
Yeah.
Or it has the potential to become true within the next five to ten years.
Yeah, we've already seen tools to write little WebAssembly things to run on the command line.
Yeah, exactly.
Wow, people really don't like it when you mention IE.
Yay, chat room.
So that's all I've got, Wes.
That was my Mozilla sermon for the day.
No, I like it.
I mean, as a fellow frequent Firefox user, I'm glad they're saying relevant.
Actually, they've got some of the best write-ups on WebAssembly, I think, out of anyone out there, and they've done a lot of good work, right?
They've done ASM.js stuff for a long time.
Oh, sure, yeah.
To have their hands deep in the stuff.
Rust?
Yeah, yeah, exactly.
In fact, we didn't cover it today, but you shared in our Slack Mozilla's article about writing browser components in Rust.
That is the underlying theme.
We haven't mentioned it, right?
The other part, too, is I saw an interesting case study for Rust of the NPM people rewriting parts of it in Rust, using FFI to make NPM faster where JavaScript was too slow.
You know what?
I am a Rust convert.
I have been quietly the last few weeks, whatever I mentioned the first time, it's probably been over a month now, doing really annoying functional data things in Rust, and it has made my life better.
Okay, we're going to have to talk about that in an upcoming episode, because now that we're just wrapping up for the day,
you've piqued my interest, functional Rust data, what's happening, Mike?
And why didn't you tell me this at the top of the show?
Yeah, well, because we're going to do a Rust show, if not next week, then the following week.
We have to wait for Chris to be here so we can all hear him snoring.
I think I'll take snoring over burping.
In any case, let's get out of here and start working on next week's episode.
Let's plan it.
Thank you all for joining us.
If you'd like more Coder Radio, just go to coder.show.
Or check out all the other fine Jupiter Broadcasting programs at JupiterBroadcasting.com.
We've got some pretty exciting study groups coming up, so if you want to learn more about Kubernetes or Ansible,
and I think you might, go to Jupiter Broadcasting's meetup page, meetup.com slash Jupiter Broadcasting.
You'll also find all the local events and conferences that we're going to go to, and there might just be one near you.
You can also find us on Twitter.
The whole network is at Jupiter Signal.
I'm at Wes Payne, and Mike's at Dimenuco.
Thank you all for joining us. We'll see you next week.

This is Coder Radio, episode 350, for March 25th, 2019.
Hello, and welcome to Coder Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business of software development and related technologies.
My name is Wes, and I'm joined once again by the Swamp Master himself, Mr. Michael Dominic. Hello, Mike.
Yo, yo, yo, we got WWW, Mr. Worldwide, that's right, Worldwide Wes. You heard about the Worldwide Web, forget about that. It's all about the Worldwide Wes, son. How you doing, Wes?
I'm doing fantastic. I'm Worldwide, didn't you know, because we're streaming live at jblive.tv, as we do every week. It's a little bit more fun than listening to the recorded version. Sure, that's good, too. It's super convenient.
But when you're here live, you get to interact with our IRC room, yell at Mike and I for getting stuff wrong, which it turns out, Mike, sometimes we do.
Just little things like countries. Like, for instance, Wes, did you know, because I didn't, and I'm the one on the tape, that Ethiopia is not Nigeria?
It turns out that is a fact, and we said the wrong thing, and unfortunately, it's a live show, things happen off the cuff, and neither of us caught it.
Things happen. And in Wes's defense, the we is me. So it is in fact the case that we mentioned Ethiopia, or Nigeria, rather, and it turns out it's the opposite, right? So this is in regards to the 737 Max story we had last week, which there's some developments on, but again, we're going to let that go.
Ethiopia is not Nigeria. We are sorry. Thank you for the person right again, who was very kind and, you know, just a little correction. Obviously, with a live show, sometimes we mistake things. No biggie, no malice intended.
Yeah, really. I mean, it's just a great chance to go to coder.show slash contact. Please do let us know because, you know, we just get things wrong, and we'd like to set the record straight when we can.
Continuing the trend of failure. Did you know, Wes, that I have been drinking myself into a stupor for no reason?
Well, that's a little bit depressing for you to just share right here, but how can I help?
Well, apparently Objective-C is not dead, one of our listeners shared with us. And sure enough, we have a red monk leak. Thank you listener who shared this. Objective-C is originally, it was originally in 2012 when we started the show, it was like number three or four on the programming index. Now it's back up to number 10.
Back up to number 10, you say. Okay, so number 10. Can you give us a little more background? What are we talking about? What do these actually mean? Where's this data coming from?
Yeah, so the data is kind of, it's a survey, right? So one, once you have a survey, you're already talking about a self selecting, selecting set of developers who actually care enough to like, read these websites, listen to podcasts and actually fill out a survey. But having said that, on the same survey about a year ago, Objective-C did not make the top 10. So it's interesting that it rose back up.
Now, having said that, Wes, if you'll indulge me, let's go through the top four languages on this survey.
Oh, yeah, let's do it. Let's break this down and talk about and again, right, like, popularity is not everything. But it is kind of indicative of where what people might look for hiring managers, look at this kind of data, you know, people that probably shouldn't look at this data, look at this data, we might as well look at it too.
Well, and number one tells you that popularity is not everything because who's the number one language? None other than JavaScript.
You know, if you think about that for more than two seconds, it makes sense because, you know, the world runs on JavaScript. Number two is Java, makes sense, enterprise software. Number three is Python, which I'm a little surprised at. Four is PHP.
Out of the top four languages, do you know what they all scream? Actually, let me put to you, what do all four of those languages scream to you, Wes?
I mean, kind of they seem they seem just a little bit old. Now, a lot of them are rather rather dynamic, Java being the exception here with its, you know, oh, so static nature, but they are they are long established languages that we haven't really seen maybe move around on this list, but but not really disappear.
Yeah, I would say they're old, but they're also they're like hyper practical, right? People working in PHP are doing it because they just need to get a job done. And JavaScript, I work in JavaScript because I have to, right?
Exactly. Everyone has to, if you have anything that touches the web, or maybe you have to use node for some reason, like JavaScript is everywhere.
Right? I mean, architect in the chat points out at least 3 billion devices run JavaScript. Makes sense, because every smartphone does write every web browser, every hell you can do embedded JavaScript these days through a number of weird open source libraries.
So I find it interesting that Objective C is back in the top 10. But actually, to be honest with you, the answer to this is, this is not like an Objective C renaissance, right? It's, there are a lot of large scale applications out there, particularly for iOS, Mac, that have tens of thousands of lines of Objective C that need to be maintained.
And porting them to Swift just, you know, unless you know this, it's just not practical, right? You don't port languages, because you want to. You do it because you have to, right? I mean, you have to choose, you know, almost never, almost never just want to do that, because it's going to be it's going to be a huge amount of work that you're going to have to take on.
It's going to be error prone and complicated. Now, maybe there are times where the new language, the new framework is interesting enough or better enough. But even then, that's all time you've spent not working on whatever actual features you were trying to work on.
Yeah, I mean, I agree completely. So I guess there's hope for old men like me. Oh, by the way, Ruby was number eight. Just, you know, just kind of throw that out there for Wes, because I know he's a Ruby fan. They've also included CSS on this list, which feels just like, kind of kind of strange to me. I mean, which makes them lose all credibility.
Yeah, I don't I don't see HTML. So maybe that didn't that doesn't quite make the cut. Did you have any other I mean, it's like some of the stuff that they mentioned specifically is like the rise of TypeScript, which I think, yeah, everyone kind of know, I was surprised to see I mean, it's probably not really meaningful statistically, but go didn't really increase a lot kind of went back just just a hair.
You know, I since I've been tweeting about rust and f sharp, I have had a lot of people telling me that I should look at go much more seriously than I did about. Oh, I want to say two years ago for the show. But go has not, in my estimation, moved very far in terms of market share. I think there is a very passionate go community. And we should say rust is not on this top 15 list we have here at all. So obviously, go is more popular than rust, accordingly.
According to red monk. I don't know, was your expectation that go would have been higher? Oh, yeah, I mean, it just seems maybe we've found all the places that it was good. But there was a time kind of when I don't know, in the last four years, maybe where it felt like go was eating everything in its segment. I'm thinking about like, like all the little canonical tools that come out a lot of the container tools, Kubernetes, anything that just gets distributed as a tiny, you know, little nice binary that go does.
So well, it seemed like it really fit at these sort of mechanistic programming tasks, especially kind of lower level, anything having to do with networking, especially given the great standard library support, right? So like, it just became this thing, you're gonna go write this little, you know, this little rest daemon or some sort of proxy system.
Go was the choice for that, at least if you you know, if you can live within the constraints of go. And maybe, maybe we've just seen, you know, it's eaten that category and isn't as relevant to other stuff.
Maybe I hesitate to say that it's not relevant, I would just say it's not popular. Which, for instance, you know, how many people do we get writing into the show and tweeting at us about how much dotnet? Or I'm sorry, JavaScript sucks, right? Or PHP sucks? Yet, respectively, they are number one for?
Yeah, that's, that's true. I guess, I guess it's a good lesson that languages stick around longer than you might think. And I, for one can often be blamed for living a little bit in too much of the hacker news bubble or other, you know, people that like interesting programming languages.
Well, it's not like you write Clojure.
No, right? No, of course not. And I guess goes kind of on the opposite side of that, because it's just a very practical, relatively simple, no nonsense, no, you know, fancy features, at least, not yet. Maybe I should give it a little more credence. But according to Red Monk, apparently not.
Speaking of open source, Wes, I have decided to contribute my body and soul to the open source. I have volunteered as tribute, we could say, much like my, my girl Katniss Everdeen.
Kind of a little bit cryptic, Mike. I know you already, you know, put in all kinds of good work all over the world. What are you talking about now? Because you've kind of made just this week, today even, a big announcement.
Yes, so I have joined as a supporter and member of the.NET Foundation, which is, before you all freak out and write your, your YouTube comments, it is the open source.NET that supports not only the open source project.NET and.NET Core itself, but also third party open source projects and the open source community.
So I wrote a little post on dominechem.com that we have linked in the show notes. Basically, it's, you know, I use a lot of.NET, I write a lot of.NET and more and more I find myself writing things like C sharp and F sharp on Linux or embedded systems.
And I kind of just want to give something back. It kind of helped the community, particularly in the Linux space, because I feel like there's some, you know, the.NET Foundation has done a lot to get into the open source community, but I feel like they haven't done a great job with the Linux community in particular, like breaking down those walls and saying, hey, actually, we are open source.
Right, because we kind of we saw it was announced, right? Everyone knows that you can now run it on Linux. But I haven't seen a huge amount of traction or, you know, people talking about it a lot of excitement on Twitter or blog posts, or, you know, just reinforcing the day to day realities of how well does it work? Is this a good solution?
And maybe you could talk a little bit about that. Why this stack? Obviously, on Linux, you can choose just about any technology stack you want.
Yeah, I mean, one of the the unusual things about.NET against, let's say, a Ruby, for example, although people were writing because there are weird projects to make Ruby do a lot of weird things, is that.NET runs on mobile, it runs on desktop, it runs in the server, runs in the browser now with things like Blazor.
And Project Uno, which we had in the show several months ago, I'd encourage listeners to go back to the back catalog. Avalonia, which full disclosure, my company, the Mad Potter is a financial supporter of.
That project makes.NET GUI's XAML applications run on Windows, Mac, mobile, web, everywhere you want to go, you can use XAML.
And frankly, my biggest interest, though, is F sharp in embedded devices. So we're talking custom boards, custom IoT devices, you know, I don't know if you remember, Wes, right before you started co-hosting the show with me, I was evaluating the Azure spheres product from Microsoft, obviously.
Yes, I do remember that because I was kind of interested. That's been a project we've watched on Unplugged and other shows on the network. So I was curious to see, you know, you were evaluating it as a first hand thing.
Yeah, I ended up not going with it. I ended up going with a pure Debian Linux based IoT solution. And I can't really give you details on what the job is yet until it's already shipped.
But running mostly F sharp, right, a totally.NET solution, but compiling down into almost native performance. But we get the advantages of developing, you know, in frankly, a platform that's not C++. So it protects us from certain errors that we might make, right?
Right. I mean, you have a really nice high level sophisticated language in F sharp in particular.
And of course, if I want to support or if I want to contract out part of the job, F sharp and C sharp are 100% compatible because it's all the CLR, which is an easier language to work in.
Right. I mean, this is kind of the same advantage that that Java stuff has, right? Whether you're doing Java, or maybe you're implementing the library in Scala or Kotlin, right? So you have that same thing. If you're using F sharp or C sharp.
And I mean, there's other stuff, too. Actually, it's not super popular, but there is even a Clojure version that compiles down to run on.NET, too. So it is a valid and valuable runtime all on its own.
Yeah, it's a serious, there is a lot going on here. And I think, I mean, I hope it will be good for the Linux community. And I understand that there's a lot of bad blood, too, right? Like, I'm not, you know, I'm not Red Riding Hood skipping through the woods here. I understand that this is going to be a hard sell.
But I have myself shipped a product using Avalonia, which is, of course, the open source.NET product that I mentioned before on Linux. And there is no reason, no technical reason that this shouldn't be possible.
So I don't know, I know we're gonna get a lot of hate mail about this, Wes. I'm just saying, this is a very practical environment to work in. And it's completely open source. So I think it's MIT licensed, if I'm not wrong. I think maybe an open mind, we could have as a Linux community, a great toolkit to work in.
Oh, I like that. So what other you have, like responsibilities? I imagine there's like a financial component of this. But do you how else are you involved in the foundation?
Yeah, so there's a donation of $100 a year. I am talking to them now to try to kind of accelerate some open source products. An issue that's very personal to me is kind of education, like engineering education or STEM. I hate to use the buzzword education for young folks.
So I'm trying to see is there a way we could put together a meetup where we teach, you know, younger folks, I'm talking middle school kids, things like that development. I don't know if you know this, a couple years ago, I did a deal with Microsoft where I did a STEM thing with Minecraft where we did like little Minecraft add ons.
Oh, that's a great platform for learning.
Yeah, yeah, it really is. Now I know my now kids are different West. I mean, in three years, kids can change, you know, so I don't know what the new hot thing is. But if you are a kid, you want to email, please let me know.
Mike needs informants here. So yeah, just coder.show slash contact.
I need munchkin spies, hashtag show title.
Well, that's probably the perfect time to transition to our next topic today, which is all about gaming. In particular, we're going to talk about Google's new stadia because did you know this Mike, the future of gaming, it's not a box.
It's a place. It's a place in your heart, as long as you have 25 megabytes per second.
And that is the catch because this is a game streaming service. Maybe you've probably already heard there's been lots of coverage. We mentioned it very briefly on the previous Linux unplugged.
If you haven't, though, close to the latest Linux action news episode 98. There's a great breakdown in addition to what we'll talk about today.
The basic premise is, though, you know, Google, Google has all the GPUs, they've got all the cloud, they've got well connected data centers.
And so instead of you having to have all the hardware, keeping up with the latest and greatest, if you don't need a desktop, maybe you certainly don't need a fancy Nvidia card for your day to day job or, or just, you know, casual computing.
Google is offering to, you know, for for price unknown, probably some sort of subscription type service. Do all that magic for you on their side and just send you the frames.
So before I dive into my haterade, what was your initial impression? Are you a gamer? We should even cover that first.
Yeah, I mean, I'm not I'm not it. I don't know that I would label myself a gamer, but I do really enjoy I have played video games almost all of my life and I do really enjoy them and appreciate them.
I don't have as much time for it these days as I would perhaps like, but I certainly have steam installed.
Okay, so would you? So I have so much skepticism here. One, what about bandwidth, right? Like they said on stage for 1080p, you need about 25 megabits per second or megabytes per second. Doesn't that seem insane for most of the country?
I guess so. That's probably true. I, I'd like to look up some some new figures about this because I wonder how well, you know, obviously, the closer you had a big population centers, the better connections you often have available.
And there's also more people there. So is it feasible for this to roll out to, you know, all the city folk and perhaps ends up as some pressure for rural ISPs to improve?
And maybe that's not true. Maybe there are plenty of, you know, big urban areas that still have connections that aren't up to this. I'm biased. I live in Seattle and obviously, a tech focused city and we have a little bit of ISP choice. So I'm super spoiled and can't really comment.
But you've got to think they've thought about that, right? I mean, they're not. They've been in that game. They have their rather unsuccessful Google fiber attempts. So they clearly have thought and must have some numbers market research about the kind of connections people have before rolling out this service.
I hope so. I mean, I, I'm more interested. I mean, I'm just being a cold blanket on the bandwidth stuff, but I'm more interested on do you think that developers who may or may not want to support stadia might by accident, end up supporting desktop local Linux games?
That is one of the big things here, right? The sort of question, because on the back end, Google is basically saying we're running these on Linux servers, right? Because of course they are. That's how their infrastructure works. And they're using Vulkan. So those are both, those are both good. They sound like good things, right?
And honestly, I'm not sure we don't really have enough details to, to, to say, I'm a little skeptical though. I think at some low level, yes. Like having support for some of that already built into some of the bigger frameworks, right? Like unity, like unreal.
That's probably good. Although, you know, they actually kind of already, already had some of that stuff. What worries me is stadia is going to be a pretty rich environment for a game to run in and somewhat different. So I'm a little skeptical of how much, all right, great.
You've got the like basic graphics part of it all done, but I don't imagine for complicated games, like it's not going to be a couple extra little clicks to export a native Linux client. You're going to have to really design with that intention in mind. And in that case, stadia is going to reach, you know, has the possibility of reaching a way bigger audience than Linux, you know, a native Linux game client ever would.
Yeah, I don't know. I mean, maybe that's too skeptical. I don't know. Color me a fraidy cat, but I'm worried that, I am worried that stadia Linux might become like Amazon Linux where it's basically Debian or some, some, you know, flavor of Debian that you're used to, but like weirdly proprietary, right?
If it was like, and I know this is like super nitpicky, but if it were the case that they were just running Debian or Ubuntu or name your distro of choice here, I'm not trying to be a shill for canonical here.
I would be like, yes, the benefits of developers wanting to cover stadia is going to come downstream to Linux. And as a developer myself, who was, I don't know if you know this, a decade ago used to work in the games industry.
I did not know that. Whoa, interesting.
Yeah, it would make a lot more sense to be a lot easier to pitch that to management that we should cover Linux. However, it is unclear to me whether this is like stock Linux or, you know, is this some weird Google proprietary?
Like I did take a look at what they had for their stadia developer site and they do seem to, obviously as an online service, they have their own API, right?
Like there is a world, and you know, let me put my tinfoil hat ala Chris here, where people are just programming towards stadia rather than towards, or to rather Linux, right?
I don't know, maybe that's too paranoid. I mean, I still miss Google Reader, right? So I'm a little paranoid.
Yeah, there is the other, that elephant in the room of Google's known to sort of drop services. I will admit to having used the inbox service, which is ending in seven days, so my phone tells me.
Oh, sure. Yeah, it is. Yeah.
So I feel that pain myself. I don't know. Yeah, it is interesting. I am honestly hopeful that having Linux and Vulkan as a runtime for what maybe will be a popular service has got to at least bleed out in the effect of like more developers are educated for that.
So if they're interested in supporting that platform in other ways, they can do so.
And of course, you know, we've had a lot of other updates about, you know, with Proton and other stuff. So it seems like it's still things are looking at momentum's building.
We're still a small community and don't have a lot there to leverage.
I don't know, stadia certainly is presenting an interesting take though, because as a casual gamer, I can really see the appeal.
I've seen a lot of skepticism from, you know, maybe more hardcore people.
It also continues most likely this sort of notion. Again, we don't really know, but, you know, more service based, less physical copy.
There is no physical copy. And is it even a sort of thing you own in any sense anymore?
Is there just going to be entirely subscription based? And that's I can see how that be frustrating for, you know, people who are dedicated gamers.
But even then, in the casual side, it still sort of works because maybe I don't care, but I just want to be able to, you know, once a weekend connect up with some buddies and easily play a great game.
No matter if I'm at home or on the road with my laptop.
Yeah, yeah, that would be I mean, that's the dream, right?
Where you own your game content or you license it rather from wherever you are and you can play it wherever you are.
Yeah. And that is a big shift. And I mean, from the you know, from the open source side, from all of that, none of that makes me super happy.
I will be the first to admit, but it's not like we'd made we haven't made that much progress there anyway.
You know, a lot of popular online games all are proprietary anyway and rely on proprietary back end services to really function, at least many of them.
I did see some pretty humorous remarks, though, like noting, oh, yes, well, with Project Stadia, finally, single player games will have lag too.
That's savage. Yeah.
The other thing I wanted to note is I've seen some discussion about like the new executives they brought on for this and sort of their approach because it's it does seem like there are pushing
or are getting ready to push maybe some, you know, Stadia focused content, kind of Netflix style with original programming.
Yeah. And I wonder how that's going to work because that rather than focusing on, you know, just bringing all the sort of, you know, existing big, big titles over,
it seems like they are going to be focused on content, not just platform.
Yeah, I don't know how that's going to work. I mean, I think for developers, the opportunity here is can you be one of the early indie developers on Stadia that gets featured?
Right? Because you know, Google, if they're smart, is going to be looking to feature a few indie developers.
Again, I know that's a very crass kind of droll way to look at this.
But right now you have to do a little bit of hoop jumping to get started.
You've got to, you know, actually sort of have a business basically.
And no, Google won't accept an at Gmail email address to register.
Nope.
Which I thought was just a little bit amusing.
I thought it was great myself. But so, Wes, I hear you hate Rust.
No, Mike. Come on. Don't be dramatic.
So we'd seen some stuff floating around. I mean, you know, you've been you've been hyping up Rust here on the show.
You keep sending me links about it, which is great and appreciated.
Oh, now who's being dramatic? OK, keep going.
Recently, that old there was an old clip of Linus talking about C and how great it is kind of resurfaced and floated around.
And I was also recently watching a good video by the always entertaining, whether you like him or not, Mr. Brian Cantrell,
talking about sort of really it's like a history of operating systems with a little bit about Rust and where it might fit.
And I think there is rightly good pressure to be like, we should write lots of things in Rust now because, you know,
there is additional safety that we can get and we keep seeing incorrect C programs.
So I thought it'd be interesting maybe just to talk about a little bit.
And actually, just today, Drew DeVault, the creator of so many things, but Sway primarily, which just had a 1.0 release.
He's doing lots of Wayland stuff these days. He had a blog post titled Rust is not a good C replacement.
So I thought maybe we could go through this, think about a little bit and consider, especially as you start ramping up on Rust.
Yeah. So walk me through what is like, what are the arguments why Rust is not a good replacement for, say, C?
And I just want to put a pause on this. When he says C, does he mean C proper or like C++ slash ob C as well?
OK, no one means ob C, but C++.
Yeah, I was going to say no one. No one means objective C, Mike. Come on.
No, we're really there's a distinction here. And actually, he starts with that right at the top.
I have a saying that summarizes my opinion of Rust compared to Go. Go is the result of C programmers designing a new programming language.
And Rust is the result of C++ programmers designing a new programming language.
This isn't just a metaphor. Go was designed by a lot of Plan 9 alumni, an operating system written in C.
And Rust was designed by the folks at Mozilla, whose flagship product is one of the largest C++ code bases in the world.
And here's where here's, I think, part of the main point. The values of good C++ programmers are incompatible with the values of good C programmers.
So Rust may be a decent C++ replacement if you have the same goals as C++. But if you don't, the design has some drawbacks.
OK, so there's so much here. One, I have to be a troll. No one hates C++ programmers more than C programmers.
It's just, you know. That does seem to be true. And everybody hates the two of them. They're called objective C programmers.
What does he feel are the values of C++? In your estimation?
Well, both Rust and C++ are sort of kitchen sink programming languages.
And, you know, they solve a lot of problems and they have a lot of language features. So I think part of it is just sort of the simplicity of C.
And you do kind of see that, too, like in the kernel development community for Linux, kind of avoidance of some C features that aren't deemed simple enough or too complicated or perhaps based on overhead as well.
So there is sort of this, you can get a core subset of C. And so some of the other stuff here, obviously C's not changing that much.
Whereas if you look at Rust, obviously it's being very actively developed. A Rust program written last year may already look outdated.
Whereas a C program written 10 years ago has pretty good odds of being just fine. And of course, you know, styles and other things might change.
But by and large, you can probably at least get it to compile.
Could we safely say that C is a more conservative language and C++ and by extension, therefore, its child Rust are a little more, would you say, cutting edge, bleeding edge?
Yeah, I mean, I think so, right? I mean, if you think about C++, there's a lot going on. It's pretty complicated. I'm no expert C++ programmer by any extent.
And there's just a lot of stuff I've never touched in the language because there's just a lot of stuff in the language.
And C, I mean, it certainly takes time to learn C, but I think a lot of that is just because it's so, you know, it's relatively close, not really to the real metal of today, but close to the metal of the sort of old computer that we approximate it on.
So you have to learn a lot about that and memory management, but you learn the core constructs of the language.
Sure, C in particular has a lot of weird edge cases there, but you learn the core constructs pretty fast.
So I don't know, I think this is maybe an argument that not that, you know, Rust isn't good or Rust doesn't fit in many places and not that Rust can't do C things, right?
We've already seen many embedded tools and tool sets start to get Rust support or improved Rust support.
Rust does have pretty good, you know, list of supported targets for a new language because they leverage LLVM on the backside.
But C is always going to be, maybe not always, for now, C is still like the first language you port to a machine or an architecture when you bootstrap it.
It's the thing that you get going. It is often the thing that, you know, serves as an intermediate representation sometimes.
It's just the simple supported thing. And you kind of have a little bit of free rein.
You have a consistent and stable API. You don't have to use a particular build tool or anything like that.
You get a lot of choice. And I don't want that. I don't think you should use that for any sort of necessarily high level language.
But perhaps, perhaps there's an argument that C has been refined enough and polished enough in some particular low level use cases, perhaps operating system development, perhaps other other such embedded applications,
that there are ergonomics for experienced C developers that make it better than Rust.
So if you don't mind, I'm just going to jump to the hottest take in this in this article here.
And I'm quoting now, concurrency is generally a bad thing. Serial programs have X problems and parallel programs have X to Y problems, where Y is the amount of parallelism you introduce.
So, you know, I've read through this earlier today. It seems to me that this article is basically making the argument that we have gone in our language design, particularly in Rust, too far towards accommodating parallelism.
And I'll drop it there. What would you say to that?
Yeah, I mean, concurrency is definitely difficult. There are times, you know, you can often we should be careful what we're talking about.
So he talks about concurrency and obviously that's different than parallel.
Right. To be fair, he uses them interchangeably. Right. So I directly quoted him.
Yeah, that's that's fair. I do think with better languages and so not speaking from to Rust specifically here, but like thinking about Clojure, for instance, in my own life.
Yes, usually, you know, any any sort of parallelism. Well, really, really concurrency.
It's going to make your program more complicated most of the time, but you can there are tools that can make it not nearly that sort of a nightmare. And we have parallel machines now.
So in that respect, we should be thinking about that if we have, you know, if we want our programs to run well.
And so, like when you look at Java has some really nice, you know, concurrent data structures now.
But when you're trying to design some Java program with like threads and locks, that's super unpleasant. And it's hard to get right. Right. There are a whole books about how to do that well.
And when you switch to Clojure, you just don't think about it anymore.
Well, it's hard because it's probably the wrong thing.
Like and this is not me shilling for.NET Foundation at all, but like in.NET, if you are parallel or you want to be, I prefer the word concurrent as well, Wes, but I'm just using the language of the article.
Dropping into C and I'm sorry, dropping into F sharp, C sharp, just by the design of the language will help you avoid many of the concurrency issues that you would have had in C sharp.
And in the Java space, because I used to do a lot of Java place, you have obviously Java. And this is just putting it back in time. This is before Kotlin existed. So we had Java and Scala. Right.
So I would say like where you have C sharp, you have Java, where you have Scala, you kind of have F sharp. F sharp is a much more dramatic shift from C sharp in terms of being more concurrency friendly than Java than Scala is. Right.
I mean, Scala kind of straddles that middle ground where it can be a souped up Java or it can be like a junior Haskell. So whereas F sharp is a little more.
Right. So can I just can I swing the Coderadio episode one hammer? Do it. Yes. And say there are different languages that are designed to solve different problems.
If you are writing a simple program, a non concurrency focused language, a non parallelism to use his words language is a good solution because you just want to get something done. God damn. Right.
There's something wrong with just getting something done. Like I am not I am not a priestess of Haskell over here. Right. I mean, it's the same thing.
Like you can write if you're you know, you need to bang out a quick 50, 100 line Python script. OK, maybe that makes the most sense because you got it done really easy. You didn't have to write a whole bunch of cook. You just you just write your thing.
But that may not be the same thing you want for writing the software that runs on a pacemaker or, you know, is scheduling real time events or like flies a drone, for example.
You may want something a little more parallel, a little more stateless. And that I think the the key that this guy misses, which actually I like this article.
But for this point, I would argue it's not C or C plus plus. It's not C sharp or F sharp.
It's both in the same program, depending on what the need of the module or library, whatever term you choose to give is.
I think you're right about that. It is interesting to you. I'd like to before we get out of this article to talk about, you know, he does say, yes, Rust is more safe. I don't really care.
I suppose for your own work, that's true. I, for one, welcome more things being written in languages that have more tools for verifying memory safety and reasoning about it.
You know, Rust has really taken some stuff that was previously academic research and translated it into useful constructs. And so maybe a lot of his argument, I think, too, and sort of says this at the end, the kitchen sink approach doesn't work.
And I don't I don't know if that's necessarily true. I'm not sure I agree with that. Yeah.
So you may or yeah, people may or may not agree with that. But I think Rust is useful in its own light for pushing these safety things. So perhaps, you know, perhaps there will be another language that takes some of the stuff from go and rust and C and combines it to a more focused hybrid.
But it will probably port the way you know, at least some of the techniques Rust has been using to handle memory.
Yeah, again, I mean, I don't mean to repeat myself, but like, you know, I have been learning Rust and I will tell you, I am never going to write a Rust script or a little Rust program to do something for me because it's too much of a pain in the ass to deal with all the rules.
Right. And I'm ignoring the unsafe keyword or whatever here. I'll do I'll continue to do those kind of things in Ruby or Python. I'm taking actually I'm doing the Linux Academy course on Python scripting right now.
Oh, is that right? That's true, because I'm trying to see, you know, I have a whole pile of Ruby scripts that are kind of on Ruby 1.9. Obviously, that's way out of date for the Ruby world. We're on like 2.5, I think.
Correct me if I'm wrong chat room, but I think it's 2.5 something. And more and more I'm thinking, you know, it's time to sharpen the little Python I've done into something more useful.
But again, both Ruby and Python, for all Wes hates Ruby because, you know, he's a hater. Hey, hey, hey, now that's a little bit strong. I had to go for the kidney punch there. Yeah, OK, that's fair. I deserve it.
Both Ruby and Python compared to Rust are extremely loose languages, right? They're scripting languages effectively.
I would never write a script to process, you know, somebody's Excel file or some, you know, some directory of, you know, some tar GZ of images someone sent me in Rust. I mean, that's just torture. I would do it in Ruby or I do it in Python.
Or if I'm sad and depressed and drunk, I do it on Objective C.
No, that's that is a good point, right? We do. I mean, we we have multiple programming languages. Yes, there is a burden sometimes to adding a new, you know, a new language to a project.
But when when they have specific focuses or, you know, you have multiple needs within a project, sometimes that's the right answer.
And actually back to go way back to the beginning and talk about Go, I think that's been true to like this.
I've seen a number of people working for, you know, Python shops or had a lot of Python code.
Some of that stuff, maybe the more performance sensitive stuff or real time or network stuff that got ported, but you might not port some of your, you know, higher level stuff where you're just crunching a little numbers or outputting something really quick in a short script because it's just not worth the effort and you don't need the extra guarantees somewhere at the time.
Right. If you run a script once a quarter, does it really matter?
I mean, you know, and I'm going to throw the age gauntlet down here. Once you hit a certain age, you realize, you know, there was a perfect language.
It was called Objective C, but times change. And, you know, in your Objective C, maybe hell, it could be V basic, right? It could be V.
You could be a real basic developer, which means you're not a developer.
Blow blow. But, like, you have to move on. You have to, you know, I've been doing this for 12 years now, 13 years. I don't know. I'll actually have to do some math later.
But and that's professional work. And I got to tell you, I change languages more than I change underwear. Now, granted, I sleep on the couch most nights, but you get what I'm getting at.
You change languages approximately as often as you get new laptops, it seems like.
Well, no, I get more laptops. By the way, the Darter Pro, new record, three months.
Congratulations. I think you finally matured into an adult.
I know. I don't, like, put martinis on my laptops anymore.
Yeah, you just get like a nice little, you know, get a nice martini holder section dedicated. Martinis deserve that.
I'm in Florida. I just put it on the nose of the alligator.
Yeah, that's lovely. I do like your sentiment, though. I think you hit it right there. Choose your choose your tools.
I think this applies to all kinds of stuff, not only just like programming languages, but development practices, workflow techniques, project management, even just, you know, are you doing how are you managing your time?
Are you using Pomodoro or just doing bigger, longer sprints?
You have to think about all of those because it's all going to change on whatever your type of work you're doing. And that might be very different whether you're doing high level planning or architecture or really trying to implement some low level Rust code.
That's a lot to think about, though. So maybe we should take a break because I kind of want to take a nap and then I might go play with Rust some more or just start thinking about my tooling.
And I think you, Mr. Dominic, you should probably go finish some more of that Python course.
Oh, yes. I feel the constriction of the snake.
Yeah, that's right. I am pretty excited that Linux Academy has that course available now and we'll have a link in the show notes if you'd like to take it because it's a really great introduction.
I've actually recommended it to a couple of people who are just kind of getting started with programming and they learned a little bit of Java at their, you know, the university course.
And I think this is a good mix of teaching you the basics of Python. And if you're just coming up and programming, it's not going to be way over your head partially because it's Python and it's just really well laid out.
So you can get up to speed quickly if you already do, like Mr. Dominic, know some programming languages.
Only a few.
You can, of course, also find the rest of everything we talked about today linked in our show notes. That's going to be coder dot show slash three five zero coder dot show slash contact for ways to get in touch with us.
And head on over to Jupiter broadcasting dot com if you'd like to find all the other fine shows on the network.
Plus, so you don't miss any. I mean, subscribe to the RSS feeds in whatever podcast player you use. That's just the easiest way. But also you can follow at Jupiter signal on Twitter.
I'm there, too. I'm at West Paine. And Mr. Dominic, I can never remember yours. So I make you say it. You're at Dumanuco on Twitter.
Thank you all for joining us today. It's been lots of fun. Come join us next week for another episode of Coder Radio.

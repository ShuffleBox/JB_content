This is Kota Radio, episode 368 for July 29th, 2019.
Hello and welcome to Kota Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business, software development and related technologies.
My name is Wes and I'm very pleased to be joined by Mr. Michael Dominic. Welcome back to the show, Mike.
Thank you. How are you, Wes?
Oh, I am doing fantastic. I'm excited about the episode we've got today.
Not only are you finally going to reveal what you think of Clojure, you know I'm dying to know, but we've got a whole bunch of other great things to talk about.
So we might as well start off with one of my favorite things. That's some feedback from you, our dear audience.
This comes from the subreddit, kotoradio.reddit.com, from the user Selsek.
It starts off like this.
Thanks, guys. Thanks for everything you do. I'm a new listener and a complete new programmer, but I've learned quite a few things from listening and love the show, even if I don't understand most of it yet.
Well, thank you for the kind words.
The more I get into CS, the more I wish I understood it better.
I'm currently working on a cybersecurity degree with a minor in computer science.
And I've got a question I can never get an adequate answer to on Google or from professors and thought maybe you guys could answer it on the show.
There are so many languages out there, and I just don't understand when or why you would want to use one language over another.
For example, I always thought you had to use Java for Android and Swift or Objective-C for iOS, but I recently learned you could also use things like F sharp or C sharp.
It's so confusing for anyone to know when to use what, and I just don't know where to turn next.
What should I learn? Do you guys have any advice?
First of all, thank you for the kind words. It's always appreciated.
As we stumble into the language flame war here, kind of do whatever you want, right? I mean, as long as you're picking Objective-C, you're obviously making the right choice.
So let your heart guide you to Objective-C.
Oh, ouch, Mike. That's only just like a little bit biased, I think, but I understand your position.
That seems biased, really?
I really liked one of the commenters on the question from Tyler A. Young.
He pointed out a good few axes to consider when you're thinking about stuff.
So one might be developer productivity.
Lots of people like higher level languages like Python or Ruby.
They're expressive. They're nice to work with.
On the other hand, your application domain might really need strong performance guarantees if you're making something like a video game, say.
And other ones, you know, if you're just making a web app that's already bound by something like database or disk performance, then you might have more options in terms of language choice.
You might be trying to target something like the embedded space or mobile.
In all of those, there's usually languages that are commonly used.
Now, you can use almost any language for almost anything, right?
So you can use F sharp to write Android apps, say.
Usually you find that out as you get better with languages and you learn more.
So I don't think there's anything wrong with just sort of sticking to learning the basics for whatever projects you're trying to work on.
Because once you've learned a handful of languages, it just gets easier to start learning other languages.
And you'll naturally find as you try using different languages for different tasks where they fit nicely for you, because that can be a very personal choice sometimes.
Yeah, I mean, honestly, trolling aside, it definitely is about, you know, what can you get stuff done and but also what will you enjoy, right?
Foreshadowing, I think we're going to have something about that later in this episode.
Oh, yes, we will.
One other note I really liked about Tyler's feedback here, Tyler's answer to the feedback, that's ecosystem.
Sometimes ecosystem can be more important than the language.
If you just really need a rich selection of well-supported, robust libraries, then, you know, something like Java or Python, that can make sense.
It depends on what you're trying to target.
But I think that's something that doesn't always get considered when you're considering things like aesthetics and how it feels to use a language.
It also matters, you know, if you have the right database driver easily at hand.
Now, I don't know how useful that is, but I'd say as you're learning and studying this stuff anyway, yeah, just stick with what you're doing.
You'll hear us talk about esoteric languages and they're worth playing with.
But don't feel like you need to do that at any pace more than you're curious about them.
You know, there's plenty to learn and continuing down the route of learning Java or Python or other popular languages, you're still going to learn a lot.
So, Wes, what is this crazy thing you sent me?
Yeah, OK, so there's been some news out there in the computer science circles, and that's because what's called a decades old computer science conjecture.
It's been solved in two pages.
Now, that might be a silly headline.
What's going on? Why do people actually care?
Well, it's called the sensitivity conjecture, and it's kind of just an embarrassing outline problem for computer scientists.
It's basically stood as one of the most frustrating and embarrassing problems in all of combinatorics in theoretical computer science.
At least according to Scott Aaronson of the University of Texas.
You might be familiar with his blogs.
It's great.
Talks a lot about various theoretical computer science as well as quantum computer related stuff.
I follow it very avidly.
He has a really good explanation of what's going on here.
But honestly, the best one I was able to find is over at, believe it or not, the Explain Like I'm Five subreddit.
What is the sensitivity conjecture like really all about?
Well, it has to do with Boolean circuits and how much the output of that circuit varies is sensitive to the input to the circuit.
So you might imagine this big, you know, Boolean function with lots of ANDs and NOTs and NORs and NANDs and ZORs and whatever gates you have all strung up and you've got some number of input bits and then some output bits.
Sensitivity is basically a measure of how complicated the system is and, you know, what different ways of varying the inputs will affect the output.
And the analogy the user Portarossa made was think of it like a BuzzFeed quiz.
Oh, no.
Yes, that's right. So maybe you've done one of these, Mike.
You answer a bunch of multiple choice input questions about seemingly random topics like what's your favorite breakfast cereal and what's your favorite classic movie?
And then eventually at the end, you get a response back, which is something like which Hogwarts house you belong to.
Mike, something tells me you're a Slytherin.
You know, that's what my wife says, too. I don't I can't imagine why.
OK, so we've all taken those quizzes and like you're not happy with the outcome. So you kind of wonder, you know, like how many answers would you have to change to get a change in the output?
Some of them don't make a difference at all. Right. So it doesn't matter if you prefer Coco Pops or Rice Krispies if the sorting hat algorithm only uses that to determine between Gryffindors and Slytherins or Hufflepuff and Ravenclaw.
Right. So there could be choices that based on other choices don't matter at all.
On the other hand, some of them matter a lot and it might be enough to just change one answer and get a totally opposite house.
So I can tell you no self-respecting Slytherin is eating Coco Pops. Just throwing it out there.
Right. Yeah. See, it just makes sense. So what the conjecture is about is if the rules for sensitivity, you know, this sort of system measuring the variability of the outputs on the inputs.
If that follows the same sort of rules as other measures of complexity for other types of circuits, or if it's some sort of weird outlier and, you know, it's kind of just been sitting there.
Theoreticians have posited that, okay, well, we probably assume that it is, you know, it follows the same. It's probably not a weird outlier. And that's what this proof is finally confirming.
Okay.
So the other part about this, it's interesting from a technical perspective. And if you have a little bit of familiarity with linear algebra, there's some great breakdowns out there which we'll have linked in the show notes.
So you can go check those out and try to work your way through it. And what's notable is that this is what's called a proof from the book.
Famous and wonderful mathematician, Paul Erdos, famously spoke of this book, Maintained by God, in which every perfect, most beautiful proof of all the theorems lived, right?
And so anytime it's a great compliment, anytime someone solves something in an amazing and elegant way, it's what's known as a proof from the book.
And that's what's astounded people here because it's an open problem. It's interesting theoretically. And for some reason, it was not only was it like took ages and hundreds and hundreds of hours of researchers trying to, you know, fight this problem over the years.
Right.
But then out comes this beautiful, remarkably simple, seemingly obvious two page proof.
Yeah, there's something kind of really weirdly poetic about having such an old problem, have such a, I mean, relatively simple solution, right?
Two pages is, I mean, that's most things aren't that short.
I like to point that Scott Aaronson made, which was, you know, a lot of research, especially these days, you know, you put in a lot of work, you know, the researchers spend four or five months researching something and then write a paper sort of summarizing what they've found.
And, you know, it takes a lot to sort of understand and be familiar with it. So the ratio of like, you know, what you need to understand to like find the answer and what you need to understand to understand the answer once it's been formulated is small.
But here, like, the math is really simple and people are just shocked that it took so long to figure out.
It's good that it's solved. And if you have any questions, email Wes at Jupiter Broadcasting.
That's right. You know, I just like to, we're mostly a pragmatic show, as we mentioned in the introduction, but I still think it's nice to maintain a link with theory every now and again.
Oh, no, I think it's great. Yeah, I think we could do a little more theory, actually.
Oh, perhaps in a future episode.
Now, what's the proof written in Objective C? I'm kidding. I'm kidding. Just keep moving.
No, although maybe it will be soon if I get what you're thinking, Mike.
So apparently there's some issues regarding trade conflict and GitHub.
Yes, that's right.
There's the debate over free speech taking place after Microsoft owned GitHub, remember, restricted the account of a developer based in Crimea, who used the service to host a website and some gaming software.
So this is one case. Anatoly Kashkin, a 21 year old Russian citizen who lives in Crimea, basically woke up and found that his GitHub hosted site no longer worked.
And some other restrictions about private repositories and basically found himself with, due to trade war imposed sanctions, unable to use GitHub.
There's also been other hubbubs around some similar actions taking place to open source developers living in Iran.
Kind of seems like a stark reminder that while GitHub is, you know, loves open source, Microsoft loves open source, it's a great place to develop and work on open source. It's a US entity, you know, it's not immune.
We think of the internet as this borderless place, but that's just no longer the case, at least for things involving big business.
So now, what is the potential impact on the wider open source community? Is it just that you can't work with people from, I guess, rival countries on GitHub now?
Or is it like, what happens to that code, right? Is that code now contraband, so to speak, because of the trade war? Or is it you just can't, they can't have GitHub accounts now?
And I'm assuming if there was an Iranian version of GitHub, that would work the same way for us. But there's, you know, not, at least not one that's big, like GitHub.
So you get what I'm getting at? I was like, what if let's just make something up, right? What if like, Apache? Or I'll make it even better.
What if, you know, the trade war was with Great Britain? And so can you no longer like download Ubuntu? Is that what that means? Because canonical is a British entity.
So here's the here's what one of the developers got in an email, you know, or explaining what happened.
Due to US trade control law restrictions, your GitHub account has been restricted. For individual accounts, you may have limited access to free GitHub public repository services for personal communications only.
So yeah, it does seem like at least for a large part, it's it's just cutting off contributions and ways for these developers to actually maintain projects or possibly interact in a large way with existing open source projects that happen to be hosted on GitHub, let alone host their own projects.
Wow. I mean, that that sounds actually very chilling to me. Like, just a reminder that literally, this global community of software developers, dare I put on my RMS hat and say hackers?
Yes, the old style definition of hacker, yes. In the Unix sense.
You know what, we will not be singing the free software song today, Wes.
Oh, please. Come on, Mike.
And if you know what the free software song is, great. If you don't, you really need to YouTube that one. I guess. I guess not, though, if you're an Iraner. Yeah, that sucks.
That's really crappy. I mean, so can we get rid of closure with this sanction? Oh, geez.
Ouch, ouch, Mike. Not appreciated. Yeah, I mean, so it doesn't seem like it's terribly the end of the world. We'll see what happens. Maybe some of the trade restrictions are not permanent. But maybe many people have jumped in and tried to suggest like, oh, well, you could use competing services, right?
Like there's GitLab and Bitbucket. But at least for the competing services, most of those companies still have to abide by, you know, they're either on stock exchanges or otherwise tangled up in ways that they also have to do what the US says.
Yeah, so there is just like, another thing here of like, my understanding is these people actually lost access to the repos, right? They can't do anything with them right now.
Yes, exactly. And there was not a warning either. It was just GitHub flipping a switch.
Once again, GitHub's great. I use GitHub. I love it. Git is meant to be decentralized, right? So if you're using GitHub, like old school SVN, you're just doing it wrong, right? It's really GitHub should just be a product management tool, which I love it for. I'm a big fan of the Kanban board thing.
It's not that new, I just started using it. But like, and a backup for your code, right? An offsite backup, it really shouldn't be, you know, the one source of truth for your project. And I know it basically is for a lot of people.
Yes, it is.
And I can't say that I've never done that. But it just a reminder, Linus Torvalds, who yes, Linus made Git if you didn't know that, made it decentralized for many, many good reasons.
So happy hacking.
All right, well, let's move on from that complicated issue. And talk back a little bit more about open source software, the technical side of things. Now, this is a crazy story you sent to me, Mike, and that's a Rust based TLS library, outperformed open SSL in quote, almost every category. What's going on here?
So we know that I love Rust. And I do pay attention to the Rust news when I can. Basically, there's a Rust implementation of a TLS library that pretty significantly outperforms open SSL. Now, that's kind of the headline here.
There is a little bit of back and forth because, you know, there's some shared history and some shared code. And it's anytime you're talking benchmarks, you're going to get the well, but actually guy who's like, in these cases, or, you know, yes, of course, really, you shouldn't.
This isn't like dunking on open SSL.
It is just very cool, like, to see Rust being used in yet another way. And honestly, Rust is very performant. I would love to do more with it. I think the Rust community as it's growing, is going to start to replace a lot of these older utilities.
And not just open SSL. Again, this isn't the story is about open SSL, but I'm not trying to like tack open SSL. No, no, I'll give you my exact use case of how I'm using Rust. I had to do some crazy STL file processing things. And I could have done that in C++.
But you know what, the security and safety were really the safety guarantees of Rust, coupled with the performance made that a no brainer. So now I'm going back as I need to update some of my old C++. I'm using the wrong word libraries, maybe they are libraries, but like, there are things I bring into Rails projects for performance sensitive tasks, right?
Stuff that you've offloaded out of the Rails thing, but you know, have some other code, we're living outside, do it faster, and then just return the results.
Even if you just run it in a different process, right? And then just return it back. It's, it really has been more efficient from a developer perspective, protected me from a lot of stupid memory mistakes, because, you know, I used to write Objective C with, you know, manual memory management every day. But now I don't write because time moves on and C++ was never my first language anyway.
So yeah, there's definitely a tendency to make mistakes there, where in Rust, those mistakes are simply not allowed. And I'm getting just tremendous performance. So I'm gaining safety, gaining developer productivity, once you kind of learn some of the idiosyncrasies of Rust.
And I'm, I'm not giving up performance. I think that's great. I just like to highlight these Rust stories, because I honestly think that it is one of the, I mean, the Rust people won't shut up about it. But it is one of the lesser known, and I would say underrated languages of, you know, I think the next few years.
Yeah, what excites me is, you know, it brings this these targets that can do stuff like write an operating system or target embedded boards. But with all the nice features that you get from you expect from modern languages that have build tools and easy way to pull down and manage dependencies with, you know, with cargo and rust, for example.
So that's exciting. And it's exciting to see it succeed in this area. Again, not to knock open SSL, but as we all know, it's a, it's an old, complicated, large project started before, you know, we really understood all we do now about modern security practices in software.
Not only can rust help address some of that, like some of the stuff here is nice to not only the security stuff, but like, it's faster in some ways. And the big one for me I saw was uses approximately half as much RAM. That's a handy optimization if you've got a lot of SSL connections.
Of course, we'll have links to everything the author has some great blog posts that actually dive into all the different measures that they did to try to do these benchmarks because obviously benchmarking is complicated. That's not the takeaway here.
But if you're curious about what makes this all work, you want to dig into some of the code. That's all linked coder dot show slash 368.
All right, Mike, we've put it off far too long. It's time once again for our seven languages check in.
Yeah, so closure. All right. I'm going to do a little preamble to the Constitution here.
Oh, I'm excited already.
This is the first language I have looked at in a long time, where I went in, got frustrated and stayed frustrated with it.
Now, I actually was able to get it set up and do a little bit around it. But the more I read about it, the more I understood why I didn't like it. So maybe we should just take a step back.
So closure is West's one ring of Sauron of programming languages.
That seems right. Yeah, that seems right.
It is, you know, closure is to West as objective C is to Mike, right? So just, it's also a, would you call it a child of Lisp?
Yeah, I mean, it is, it is a Lisp. Rich Hickey, the author, did a bunch of common Lisp before.
So it shares some common Lisp heritages, although it is not the same as common Lisp by any means. But yes, it is definitely a Lisp.
Right. So if you are like me, and you never liked Lisp, then you are not going to like closure.
And this is coming from the small talk guy. Come on.
Oh, this is nothing like small talk. Oh, come on. Really?
I just meant you're generally very open about languages, you know, except when they're criticizing objective C.
Well, I, you know, you had to bring up small talk, huh? Okay. So fair enough.
So it actually like, I don't have a reason that like, you shouldn't be using closure. I actually think it's very good.
I just don't like it. But let's, let's give the fair case. And then I'll explain why I don't like it after maybe that's, that's better.
I actually found getting started was relatively quick, which I, I had this expectation was going in that this was going to be like a beast to get set up.
It was not.
Oh, good. I'm glad to hear that. Did you install line again, the main build tool? Or did you go with the default CLI tools that were recently introduced?
I went with the default CLI tools with one big asterisk, there is a VS code extension for it. That brings it all kind of more to the forefront and accessible.
Oh, yeah. Kelva?
If you're familiar with any of the other VS code, like build tools, it looks very much the same, you know, with the obvious accommodations to closure.
So it was nice. I was in an environment that I'm used to working in. Great.
I, I really wanted to like it, right? Because I think it has a lot going for it. First off, the JVM.
So I've done a ton of Java, I've done a bit of Kotlin. And there's like JVMs are running around everywhere, right? Big enterprises, little, there are hell you can run the JVM on some of these IoT boards.
I'm not really sure. Maybe you shouldn't, but you can.
But you can't. Yeah. I mean, the JVM is almost everywhere and is run in production by many, many large organizations.
Right. And closure is giving you, you know, by being so purely functional, it's giving you again, kind of that safety that I was going on with, with Rust, comparing it to an F sharp.
Closure is much pure functional language, in my opinion, than an F sharp.
I, I think that's actually a pretty, pretty safe assertion there.
Interesting.
See, this is the problem, right? I like everything I did. I looked at other people's benchmarks.
I wrote a few kind of dumb, you know, write a blackjack card counter and things like that.
Yeah, right.
I wanted to like it. I could not get over the syntax was my real issue.
Really? The syntax?
The syntax. I could just, I kept having to stop and I don't even know how to say like, stop and think about what I was doing because I kept typing things in more of a, I want to say like, like C family style language, right? Like, yeah.
Yes. Yeah. Algol derived.
Right. And I was just kept being wrong.
It really has everything I should like, right? Functions are first class objects, although I'm not sure that you would really call them objects.
Looping, it's meant for looping, right?
My weird dunking on Lisp before, Lisp has been around for a long time and does a lot of great work and Clojure is, it's true. It's a much nicer, more modern Lispian. I'm not even sure how you'd say that. Like Lisp derivative.
Yeah, I just say, you can just call it a Lisp.
Okay. You just call it a Lisp. Okay. I wanted to like it, Wes. I really did. I feel terrible. Like the ability, so my number one positive feature, you could just like import stuff from Java.
Oh yeah. You get access to the whole Java ecosystem. Anything that runs on the JVM.
Yeah. So like grab some great old jars and have a party.
Yeah.
In theory, and this is actually a question, so I'm not sure. Let's say you have like a big enterprise Java app, right? And you want to write this new, very complex data processing module. Could you just like write that in Clojure and just pull in what you need from, you know, whatever your existing, your existing Java modules?
Yeah. And I would say actually that's a fairly common sort of thing. You know, if you have a bunch of libraries, maybe existing or external that are written in Java, either because legacy or you like them that way, or for performance reasons, possibly.
And then you can use Clojure as a higher level sort of thing on top to connect that all together in a nice way, as it does, as you say, you know, has nice facilities for working with data, managing it in a high level way.
And because we're talking about the JVM here, it is literally everywhere, as you stated before.
And you can do the reverse too. So because Clojure is distributed as just as a jar, right, it's just a bunch of compiled JVM bytecode, you can sort of sneak it into Java projects to just sort of add it as a dependency.
That can be one neat thing you can do is in a Java application, if you wanted to have a little more, you know, debuggability or like live ways to introspect at runtime, one thing you can do is add Clojure and just have it open up a network REPL doesn't have to do anything else.
But then you can connect to the network REPL and then go interrogate all the structures living on the JVM at runtime.
Oh, wow. Okay.
And of course, there are other tools, right? One of the nice things about the JVM is there's a rich suite of observability tools already. But that's one way you can play with it.
I mean, the whole macro thing, which I had a hard time wrapping my head around.
You can kind of think of them as compiler extensions that you can write in line with your code.
Interesting. Okay.
Because when you when the compiler sees a macro, it takes the so that the thing about Lisp right is the homo iconicity that you the language you use to describe it is the same data structures you use with the language.
And that's it takes a while to get used to that. It's kind of a kind of a head trip because Clojure is not written. So the compiler for Clojure never sees text.
There's a separate component called the reader. And the reader reads the actual, you know, the text file, but it immediately converts it to actual data structures.
And that's what the Lisp or the Clojure compiler actually uses. So when you write a macro, the compiler stops its compilation, and it just reads whatever is in the macro, you know, whatever you're using the macro on.
And so you get a data structure that is describing, you know, could be like a function body definition, say, and then you can use all the tools you have in Clojure for working with lists and sets and vectors and maps to modify that return a new data structure.
And then that's what the compiler compiles. Oh, crap. That's actually really powerful.
Yes, it is amazing for doing like meta programming work, adding abilities to add abstraction. So tons of the language itself. It's just written as macros, for instance, the or function, it's not really a function, it's a macro, because it needs that ability.
Because of the control flow, you know, it may or may not evaluate everything, you can do that with the added power of a macro.
Right. I mean, another thing that just stuck out to me was I really like the way it handles asynchronous programming, which you can tell, like, this is something that would make a lot of sense in a data intensive asynchronous environment.
I thought the so there was one concept was that I'm, I think I understand it, but I might be wrong. The atoms and how they relate to agents.
So agents are a little more confusing, and are not really, I mean, they are used and can be useful, and sometimes the right abstraction, but atoms are used ubiquitously in Clojure, because they just ended up being a really nice way to do state and they're kind of the default way to handle state in Clojure.
And the key to understanding atoms is to think of them as compare and swap. That's the semantics of the atom.
So really, it's all about an atom is basically a, a reference to an immutable value. So everything in Clojure is immutable, basically.
You have all this data, it's an immutable value, it's not, don't think of it as immutable object. But you do sometimes need to make changes, right? You do need change in your program.
You need some state. Yeah.
And that's where the atom comes in. So you say, like, all right, I'm setting my state in the atom. And then you can later go back and say, all right, I have this reference my atom. And then I can point that atom from one immutable value to the next one.
But it's got nice concurrency things in there. So you write a function that receives the current atom state and returns the new atom state. And then Clojure behind the scenes handles all the compare and swap stuff.
So like, if there's a race where one person had, you know, got the lock and was trying to write, like, you don't have to think about any of that. It just does it for you. So you do have to write it being aware, right? Like there may be retries happening under the hood.
But as long as you stick to a few simple rules, they are fantastic. And because they're used everywhere, they're well optimized. So most of the time, you don't have to worry about using them. They're not a lot of overhead.
So on a high level, why am I wrong? What am I missing in the glory of Clojure? Like, it's by no means bad, in my opinion, I'm just, it didn't enchant me the way it did you. So I'm clearly I'm missing something, right?
I guess the things I thought you would like were the simplicity of it, the lack of getting in your way, you know, you're a capable developer who moves fast and works on his own set of projects. And I think that's one area where, where Clojure can shine just because it's, it can give you a lot of leverage, right?
So instead of having if you did have a Java project, or you needed to produce an X, you know, object that would run on the JVM, what would you choose? Would you not choose Clojure?
I would probably choose Kotlin.
Yeah, that's fair. No, Kotlin is a great choice as we you know, as we talked about when we when we talked about Kotlin. Because it depends on if you want to shift to a different paradigm. It may be tricky, because I think if you don't have a strong, as you say, you know, if you if you hate Lisp already, there is a little barrier to overcome.
It's funny. So at first, you know, take some time to learn to read because it's a weird ordering, right? Like the function name comes first. And while I think that ends up being pretty clear, once you get used to it, it's a big change.
Yeah, I think I you know, I think it's difficult to understate how much just the novelty of the syntax threw me off, especially because I've spent, you know, the last three weeks working almost exclusively in Ruby.
Right? Yes, it's quite different.
And then at night trying to like, do some closure. And it's pretty frustrating when you like, especially as you say, the kid is an experienced programmer, you have the idea, basically, most of the time of like, what you're actually trying to do.
And then you have to, you know, flap around and try to make the language actually cooperate with you. And so that that can take a while before, you know, before you that impedance mismatch sort of calms itself.
And I find the opposite now. It's kind of funny. There was a while where I was first learning Clojure. And I'd also been doing a lot of Scala at the same time. But I'd started Scala first, actually, and then kind of switched to Clojure and then had to come back to Scala for a project.
And you found Scala foreign to you?
I really did. And I actually struggle. I struggled with Python. I struggle with the C like languages now because I got so used to the way Clojure does it. And what's neat is that homo iconicity stuff comes back because
big words, big words. There are no weird magic stuff. So like, when you're looking at a Python, like a Python source file, right? Like, what is the def when you're defining a function? What is that? I mean, is there even a name for it? No, it's just like a part of the syntax.
Clojure has reified everything. So you're just writing a data structure. And all everything is remarkably consistent. Because how do you define a function? Well, you just make a list with def and as the first part of it. So other languages just sort of seem like they have a lot of unnecessary ceremony.
And a whole bunch of, you know, restrictions for no reason.
Yeah, I think that's actually fair. I think that's a great point to bring up. Because, you know, with a general show like this, there's so many different types of programming paradigms, right? And I think, honestly, I think we should cover more lisp-esque stuff as much as that hurts me to say, only because it's a whole, it really is a whole different, I don't know, like tradition, right?
Almost like we were talking to the Harry Potter houses, right? It's like a whole different, it's Hogwarts compared to that weird Russian school from the books and movies. If you don't know what I'm talking about, there are other magic schools, and they're very different.
Derm strength, something like that. So a couple questions for you. Did you, were you using par infer? So like, there's a couple different ways to edit lisp. And one of them, par edit has been around for a long time, and it's very respected. Because you sort of do it syntactically, like you don't worry about the syntax, you do it semantically, and you worry about the statement. So instead of writing text, you think way more about just like manipulating data structures, like, oh, pop this off the end of that list and add it to the head of this thing.
I was I was not that sounds a lot better. So that's right. And then there's also par infer, which is a great project from Sean LeBron, that kind of makes Clojure, like writing Python, where the spaces, they don't really matter. Clojure doesn't care about whitespace at all. And in fact, in Clojure commas are whitespace, which is one thing I love. And it's like, been so hard when you go back to languages that are really picky about commas being in the right place. So it just doesn't matter, why should it? So par infer lets you like, as you so let's say you tab something to the to the right.
That will then auto update all the right number of parentheses that you have to balance for you, because it's able to infer what kind of thing you're trying to write. And it helps you keep your code looking very nicely styled and typeset for you.
So is this is this kind of a standard tool chain that this be slash Clojure developers are using? Is like, is there no chip like IntelliJ for Clojure?
No, actually, so there absolutely is. And I'd be curious to see if you like it. It's called cursive. And it's based on and based on IntelliJ, a large part of it's actually written in Kotlin, and then some Clojure in there as well.
And so that's another example where Kotlin was used, because, like it needed really fast stuff implemented to match up with the Java stuff. Kotlin was perfect for that. It was originally in Clojure. But there were some reasons why not to have an enclosure. So it's Clojure is not always the right fit.
But you will find, you know, there's good professional level tooling. As we talked about last week, SpaceMax can also be a great tool. There's, there's really first class support there. So what was your workbook like?
Yeah, I was building on the command line. I was using the, it was Clava. Oh, Calva, sorry, is the plugin I was using. I mean, it did some of this balancing, you know, kind of like the ID features I expected. But not, I'm looking at Parn for right now, not to that level, not even close.
The other thing too, about Clojure development that I'm not, I'm curious to know if you picked up on, it's kind of different than most other ways, unless you're coming from a LISP background, because every single top level form in a Clojure file can be evaluated independently. So it's not like a complicated static type language that has to take a whole bunch of stuff and, you know, runs over the whole file or maybe a whole set of nested files and then eventually, you know, consumes all of it and then produces an output.
Most Clojure developers send forms, which is just the name for like a set of parentheses sort of thing, to the compiler, interactively, and you build up a program. So you can start with maybe a blank sheet, and then you start defining stuff. And then you just usually there's like a hotkey. So like Ctrl C is a common one, that then just sends that code over to a running REPL. And it gets evaluated in a running JVM that you keep for most of your development session. And then as you want to like redefine a function, you just send it over there again. And then you just send it over there again.
And then you add stuff, and then work interactively. It's kind of like constantly unit testing, as you go.
I completely missed that. I heard what you said, I just completely I didn't even notice that ability.
Yeah, so that's one thing that people love about Clojure, because you can, you know, you don't have to do this write, compile, test sort of cycle, you can make that a lot faster. And as you're well aware, as many people are, fast feedback and debugging is critical.
Oh, yeah, yeah. It would be interesting. Yeah. You know what, I'm you know what I might want to do in a couple months, I should play around with the more take another, maybe even pick up a list book and cry the entire way through. And see if I got a little more familiar with just the entire list way of doing things, would I find it less jarring?
Right. And I think that is a hard, that's a, this was a hard challenge. And I'll be the first to say that, because it is so different there. It's a different paradigm, it's more functional, and the whole background and heritage of the language and culture is different. So it was a tall ask to see that, you know, how much could you really get familiar with in like a week's amount of playing with the language, right? I just want to know, did you try Clojure script at all?
I did not. Well, I take it back, I did, I did something stupid and trivial, but I ended up being. So from a practical perspective, I was actually, I still am very interested in like, just just the scenario that I laid out before using Clojure to modify existing old Java applications. I shouldn't say old, I'll say legacy, right. And that's less on the front end side.
Hmm. Yeah, that makes sense.
But I know, I know, Clojure script is also near and dear to your heart. It is just because you get to leverage the same thing. And, you know, take a fight some of the JavaScript woes that we all know and love. So let's let's summarize here, Wes. So far, you have done TypeScript, Kotlin, and Objective-C.
Yes, I have.
I have done Elixir, ReasonML, Go, and Clojure. I have to pick a language for you. And if you want, you can pick one for me, or you can wait till next week. So what kind of language would you like? Do you want something like common that maybe you haven't done? Do you want something out there? Like, what are you thinking?
Not, not too out there. I would kind of like it to be something I might actually use or want to use or could use, you know, that had a reasonable enough world that it might still be not the default choice, but I could make use of in some capacity.
All right, then I'm going to pick F sharp for you.
Oh, all right. This is this is interesting, because I mean, that's your new darling, and you're trusting me with her.
Actually, though, as you've shown me Elixir, I've been loving F sharp quite a lot less. But so there's a point to that. And I'm curious if you come out with the same impression that I do, because you're coming, I think, from a much, much, much more functional background than I am. That F sharp is a really, really good introduction to functional programming for folks who want to get into it.
But maybe, you know, compare it to bulk closure, right elixir, recent ML, and any of them, dare we say Haskell. And it really just feels like it's, you know, the low, low fat, no carbs, functional programming languages. That's not a bad thing, right? Like the interop with.net, the interop with C sharp. Super important. There's tons of.net code out there. But I'm just curious how you feel about it.
No, I'm curious. And I'm curious about that aspect, too. It's been a while since I've used the.net platform. But I've followed it's, you know, open sourcing and all the developments coming out of it for a while now. So I'm excited to give it more of a check in.
It runs great on Linux and is very fast.
See, that's perfect. I'm excited already. Is there anything I should I mean, should I just aim for the standard docs and go from there?
Yeah, and for the standard docs, I mean, the tool chain on Linux, you're probably just fine with VS code and the command line tools. I wouldn't even bother like, you know, I love JetBrains, I wouldn't even bother installing their ID. It's, frankly, VS code is so, so good. The F sharp plugin there that you won't need it. You won't need it. And I think it's called the rider, if I'm not mistaken, right?
Okay, well, that's great. That's way up my alley. And I'm excited to get started. And maybe next episode, you can tell us a little bit more about why you're loving elixir so much. But we don't have time for that today. We've got to get out of here.
We do.
Yeah, that's it for this episode of coder radio. But if you'd like a whole bunch more, and I assume you do coder.show is the place to go coder.show slash RSS is our RSS feed or slash subscribe. If you want to find all the other ways you can find the latest show content. Also, head on over to Jupiter broadcasting.com. Because not only do we have all the other great Jupiter broadcasting productions, like the newly rebooted shoes, Linux, but we also have a bunch of other things that we're going to cover in the next episode.
With l drew and Joe, which I'm very much enjoying. But we also have a calendar on Jupiter broadcasting.com. That'll tell you when we're doing this show live to usually noon Pacific, but check the calendar to be sure. If all of that is not enough. Well, Mike's on Twitter, and he's a lot of fun. What's your handle by
at Dumanuco. I'm at Westpane and you can follow the network at Jupiter signal. Thank you all for joining us. We'll see you right back here next week.

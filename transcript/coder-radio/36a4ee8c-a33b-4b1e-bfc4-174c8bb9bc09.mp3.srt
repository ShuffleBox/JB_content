1
00:00:00,000 --> 00:00:07,000
This is Coder Radio, episode 372, for August 26th, 2019.

2
00:00:31,000 --> 00:00:43,000
Hello, and welcome to Coder Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business, software development, and related technologies.

3
00:00:43,000 --> 00:00:49,000
My name is Wes, and I'm joined by everyone's favorite Floridian, Mr. Michael Dominic. Welcome back to the show, Mike.

4
00:00:49,000 --> 00:00:52,000
Welcome back, Mr. Payne.

5
00:00:52,000 --> 00:01:04,000
Boy, a lot has happened. You know, the last two episodes, they were pre-recorded, but this one is live once again. And not only is it nice to hear you, but I'm excited to hear what you thought about all the things going on in the world.

6
00:01:04,000 --> 00:01:11,000
Yeah, so I, you know, of course, a week where we pre-record, everything drops. Why not, right?

7
00:01:11,000 --> 00:01:15,000
Sounds like you were having some particular problems with G Suite. Am I right?

8
00:01:15,000 --> 00:01:24,000
Pro tip, guys, using proprietary solutions that are hosted somewhere else, unless they're for me, then you should definitely buy them.

9
00:01:24,000 --> 00:01:31,000
Well, that's a problem if, let's say, your entire business runs on G Suite and Slack, but you only talk to customers on G Suite.

10
00:01:31,000 --> 00:01:45,000
And you have to go back to, like, the dark ages of having to explain to people that will actually, can you just, like, I don't know, Dropbox this to me, and then you have to, like, open a Dropbox account because you really need files for a demo.

11
00:01:45,000 --> 00:01:51,000
So for those who aren't G Suite addicts, last week, G Suite had an outage for about half a day.

12
00:01:51,000 --> 00:01:57,000
It was everything from Gmail to Drive. It was the whole kit and caboodle, anything that authed with Google.

13
00:01:57,000 --> 00:02:04,000
I don't know if it extended to the non-commercial G Suite accounts. I probably did. Why wouldn't it?

14
00:02:04,000 --> 00:02:15,000
But it was, I'd like to complain, but honestly, there was no Google chat pings. There was no emails for, like, four hours. It was glorious.

15
00:02:15,000 --> 00:02:18,000
Oh, that sounds nice. Sometimes you just need a little break.

16
00:02:18,000 --> 00:02:28,000
And I suppose that's the flip side of the benefit of they manage everything for you, and while it's frustrating when you can't control it, it also means it's not on you to fix it. You just get a sit and wait.

17
00:02:28,000 --> 00:02:35,000
Yeah, I mean, the reality of the situation is it was fine, right? But then that evening, of course, was chaos responding to emails and going through documents.

18
00:02:35,000 --> 00:02:49,000
And I'm going to just say that I probably have an over-reliance on G Suite right now. But having said that, I've been using it for over 10 years, and this is maybe the third or fourth outage I've ever experienced.

19
00:02:49,000 --> 00:02:52,000
Not so bad considering. I mean, not ideal, but...

20
00:02:52,000 --> 00:02:54,000
All things considered, right?

21
00:02:54,000 --> 00:02:55,000
Yeah, that makes sense.

22
00:02:55,000 --> 00:02:57,000
So how about you? Were you partying it hard?

23
00:02:57,000 --> 00:03:11,000
There's been all kinds of stuff. It was nice to have a little bit of some time away to reflect on all the fun we've had. I've particularly been enjoying the coding challenges, and it sounds like a lot of you guys out there have too, which makes me really happy.

24
00:03:11,000 --> 00:03:20,000
Because, you know, it takes a lot of time and effort to sort of actually sit down and review and try out all these new languages, but there's also a lot of insights and a lot of features.

25
00:03:20,000 --> 00:03:30,000
It's made me think about what I want and need from a language differently. So we'll get into that a little bit more in the show because you've got a check in for us. I'm particularly excited about Mike.

26
00:03:30,000 --> 00:03:38,000
Oh, okay. Well, I can't wait to hear why you're excited, but I sure do. And it was a... Let me just say my explanations will be crystal clear.

27
00:03:38,000 --> 00:03:55,000
So before we do that, let's set up some feedback. First in our feedback basket today is a letter from Reid. Dear Wes and Mike, I'm a fourth year math PhD student and have always had a hobbyist's interest in coding and software development.

28
00:03:55,000 --> 00:04:11,000
While I plan to stay in academia, I realize it's always good to have a backup plan. Do either of you have any insights as to how the software development community would feel about someone with a math PhD but no industry coding experience as a job applicant?

29
00:04:11,000 --> 00:04:17,000
Any advice would be appreciated. Love the show. You guys make a great duo. Well, thanks much, Reid.

30
00:04:17,000 --> 00:04:29,000
I'm curious, you know, maybe you might not have some specific expertise about academia, Mike, but I'm sure you run across many of green coders fresh out of school and I imagine a lot of those same lessons apply.

31
00:04:29,000 --> 00:04:53,000
Yeah, I mean, you know, it's funny in the pre-show I couldn't remember, but I have had previous experience of a place who specifically wanted, I think, master's degrees and now I hate to be specific, but I'm almost sure it was like statistic. They were doing some fintech to use the buzzword things and they would basically be willing to teach you Python.

32
00:04:53,000 --> 00:05:12,000
But that is definitely the rare case for the kind of stuff that I've been doing. It's a lot more, like you said, folks coming in from undergrad or even boot camps or associate programs that might know, particularly the folks coming from CS undergrads, know or remember a lot more of their Knuth and their math.

33
00:05:12,000 --> 00:05:15,000
Right, random algorithmic quiz questions.

34
00:05:15,000 --> 00:05:30,000
Right, although if you are like me and don't have that background, great books by Rob Connery, I think it's called Computer Science for Imposters, which basically will teach you all the basic algorithms you need to know. I'll throw it in the show notes.

35
00:05:30,000 --> 00:05:32,000
Oh, that's a great title.

36
00:05:32,000 --> 00:05:49,000
I think I misquoted the title. It was something imposters. But these young people come out, they're great, they know how do I get through a linked list, which I keep forgetting because the one true language objective seed did not have them. Now they're just Ruby.

37
00:05:49,000 --> 00:05:52,000
I think that speaks a lot for both of them.

38
00:05:52,000 --> 00:06:03,000
Oh, don't even lay the closure on me. But like, you know, undergrads, how can we say this nicely, Wes? We'll blow up your Git history so fast, you'll cry?

39
00:06:03,000 --> 00:06:31,000
I mean, it just there's a lot of there's a lot of practical knowledge, working in a team dealing with maybe larger frameworks than you're accustomed to, especially if you're just writing, you know, one off scripts to accomplish a single task for like a personal use. There's also not always a huge, I think that's changing, but not always a huge emphasis on stuff like testing and reliability in school. What else? What else do you see newbies kind of struggle with or just not have a background in if they haven't worked in industry?

40
00:06:31,000 --> 00:06:44,000
I mean, I could tell you, like the two most common things I've seen are really not getting how important aggressive use of source control is. And by aggressive, I mean frequent, frequent commits.

41
00:06:44,000 --> 00:06:45,000
Right.

42
00:06:45,000 --> 00:07:13,000
And the other thing is maybe a little bit of a cavalier attitude towards legacy. So there was a perfect case a couple years ago that I can think of right off the top of my head. We had this huge iPad app. And because of when it was started, and when I say huge, this is enterprise level. This app is effectively a custom tool for this company. And it's just like, they run their business, their shop, floorman, all have iPads, right? And this app was in production already for like three or four years.

43
00:07:13,000 --> 00:07:29,000
So it was a big old bucket of Objective-C with a ton of CocoaPods. And you know, Swift had come out, the world had changed. CocoaPods kind of, I mean, people still use CocoaPods. But I think at the time, Carthage was becoming more popular. I don't know how familiar you are with Carthage.

44
00:07:29,000 --> 00:07:30,000
Oh, not really.

45
00:07:30,000 --> 00:07:54,000
It's basically just another package management tool. There are reasons that it maybe is a bit more modern than CocoaPods. And actually now Swift does its own things too. But back then, it was really Carthage and CocoaPods. And this, you know, very well meaning new developer decided he was going to rip out our CocoaPods dependencies and try to replace them at Carthage.

46
00:07:54,000 --> 00:08:03,000
Well, we had pinned some of our dependencies to specific versions, because of course, part of this app was not using automatic reference counting, because it was so old.

47
00:08:03,000 --> 00:08:05,000
You did say legacy at the start of this.

48
00:08:05,000 --> 00:08:25,000
We're talking like circa, when did Swift come out? 2014? So this must have been like 2015. And the app started in like, 11 or 12. So there was just a lot of stuff that had gone on in the Cocoa Touch ecosystem since this project was kicked off.

49
00:08:25,000 --> 00:08:43,000
So that was a build breaking experience. Luckily, through the powers of Git, we were able to undo everything. But he had a hard time and it was kind of a conversation about, yes, you're probably right that there are memory leaks in the manual memory code. But they're small enough, they don't matter.

50
00:08:43,000 --> 00:09:03,000
And two, the investment required to actually rewrite all of this legacy code and get it to the tested production standard accepted by the end users, you know, level that we needed at just isn't going to be worth it until they release, you know, well, almost like what they're doing now with Swift UI, right?

51
00:09:03,000 --> 00:09:07,000
Until there's a major platform paradigm shift, where we don't have a choice.

52
00:09:07,000 --> 00:09:10,000
Once you already have to rip everything else apart. Yeah.

53
00:09:10,000 --> 00:09:13,000
Right. But what about you? What's your what's your war story?

54
00:09:13,000 --> 00:09:20,000
Well, I was more I was more thinking of positive things to go along with your your war stories here.

55
00:09:20,000 --> 00:09:21,000
Of course.

56
00:09:21,000 --> 00:09:40,000
And I think there's many developers who kind of shy away from some of the more math oriented things, you know, you go through you slog through maybe you're like couple terms where you do like you do a bunch of graph stuff and prove some theorems. And then you know, then you're back to like, implementing stuff or testing stuff or writing some Java. And that's okay.

57
00:09:40,000 --> 00:10:00,000
I think having familiarity with math, especially if you're going to work on, you know, more complicated algorithmic sort of problems that can be really handy. So read, you might want to sort of just stay current in in that sort of areas, especially maybe some machine learning areas where more math and computer science start to mix, you could be especially effective there.

58
00:10:00,000 --> 00:10:25,000
Also, just start looking at projects and in languages or projects that you're interested at, because one of the one of the skills that you may not get in academia, but that you'll definitely need an industry is being able to just struggle through a bunch of someone else's bad code and understand how to work with it and make whatever changes you might have to because you as Mike's talking about you often aren't in the best ideal sort of scenarios, but you're still going to have to make it work.

59
00:10:25,000 --> 00:10:37,000
There's always going to be legacy. And if you can figure out good tools, get some practice in learning how to modify that, knowing that most of the stuff you're going to work on, it'll likely be supported for years. That'll be useful.

60
00:10:37,000 --> 00:10:50,000
Yeah, I like that. And I have to say I was not a huge mathy person. And in the last couple years, I've started having to go back and be like, okay, maybe I didn't need to burn through the canoe quite as much reckless abandon.

61
00:10:50,000 --> 00:11:15,000
Yes. You know, you might also just be interested in some more of the functional languages, maybe some, some stuff like Haskell, or even more esoteric languages than that. Also, a lot of a lot of math in school can often be problem solving. And those skills I find translate really well. So focus on that to be able to break down a problem, model it and work your way through each of the steps. That's a useful skill everywhere.

62
00:11:15,000 --> 00:11:19,000
I admire your discipline, sir.

63
00:11:19,000 --> 00:11:30,000
Okay, well, thank you for the email read. Let's move right along just a little bit of feedback we got about one of our last episodes over on our subreddit coderadio.reddit.com.

64
00:11:30,000 --> 00:11:54,000
User Ninja Aaron has a little FYI, and I totally should have mentioned this FYI about wanting interfaces in Python, that you basically just want abstract base classes. And I totally should have mentioned that user jam 163 notes, I agree with what's his point about preferring interfaces in abstractions. It seems to me that abstractions targeting interfaces are more reliable than abstractions deriving functionality from base objects.

65
00:11:54,000 --> 00:12:15,000
So I think there's some there's some interesting intersections there and probably kind of why I didn't think to mention abstract base classes. It's just not the preferred way I have of modeling. And I kind of like the polymorphism and other stuff, all the cart that you can get when you break those things apart. But Python definitely has that functionality. Thank you guys for pointing it out. That's very useful.

66
00:12:15,000 --> 00:12:34,000
Also, as a small little side here, I've been playing more and more with like some of the later Python three releases. And it's really, it's really getting to be a nice language. Again, I mean, I've always liked Python, but some of the modernness and some of the newer API styles and libraries that have come around, it's, it's, it's a pleasant place to be.

67
00:12:34,000 --> 00:12:38,000
I don't know. Python is like a mean Ruby, as far as I'm concerned, but we could just keep moving.

68
00:12:38,000 --> 00:12:47,000
Yes, well, that's a natural segue to our final little bit of feedback today from Dex asking about breaking and changes.

69
00:12:47,000 --> 00:12:55,000
I developed a niche Python package that has some user following in the network security realm, but I'm at a crossroads.

70
00:12:55,000 --> 00:13:09,000
A change I want to make will subtly break scripts that work in previous or in current versions. The end result of my pending change is good for the project, but I fear it'll ruin the workflow of all the existing users.

71
00:13:09,000 --> 00:13:15,000
Other than my GitHub page, I don't know how to query or inform the users of this pending change.

72
00:13:15,000 --> 00:13:17,000
What do I do?

73
00:13:17,000 --> 00:13:25,000
Well, what do you think, Mike? You know, this is an interesting question. It comes up a lot and just step one, asking this question, thinking about it. Well, that's good.

74
00:13:25,000 --> 00:13:38,000
Yeah, this is a tough one. I mean, I think if you're thinking about it and not just either protecting a legacy forever or making breaking changes willy-nilly, you're already 10 steps ahead of most people.

75
00:13:38,000 --> 00:13:47,000
What I have done in the dark old days when I used to maintain an Objective-C networking library, yes, it's all Objective-C today, kids.

76
00:13:47,000 --> 00:13:49,000
Oh, interesting story.

77
00:13:49,000 --> 00:13:57,000
I did briefly, and briefly is defined as I think three months, support the non-ARC version of it on a different branch.

78
00:13:57,000 --> 00:14:02,000
This is before people were using CocoaPods and fun stuff like that. This is way back in the bad old days.

79
00:14:02,000 --> 00:14:10,000
So people would just literally like the way you got it. It was 10 classes. You just downloaded the, you know, git sub modules. I hope most of you know about that, right?

80
00:14:10,000 --> 00:14:12,000
Oh, yes.

81
00:14:12,000 --> 00:14:25,000
But eventually, I was pretty clear that this is a 90-day extension. I'm not going to delete it or break it. But after 90 days, you know, I'm not going to support it.

82
00:14:25,000 --> 00:14:37,000
That's one way to do it. I can't say that I didn't get any mean emails. I don't know. But remember, you're doing this for free, which is, I think, something we're going to cover in a future topic here.

83
00:14:37,000 --> 00:14:50,000
And, you know, it's really not a service to your users or, I'm sure, yourself to pin your code, your library, whatever it is, to an older version indefinitely, right?

84
00:14:50,000 --> 00:15:03,000
This is one of those hot topics that I'm very hesitant on because I'm pretty aggressive. I'm liking to push things forward when I'm maintaining them. But Wes, maybe you're more conservative?

85
00:15:03,000 --> 00:15:12,000
Well, you know, it always sucks when stuff you rely on breaks. So clarity is good. It is an interesting question of how to communicate this.

86
00:15:12,000 --> 00:15:22,000
You know, it's a little easier if you're working in like a business relationship or in a team relationship where you can kind of sort of force everyone to have a meeting. But that model doesn't work so well in open source, necessarily.

87
00:15:22,000 --> 00:15:33,000
If you can avoid breaking, I would say do so. Sometimes you can keep legacy functionality around and just sort of mask it or rebuild it on top of newer features.

88
00:15:33,000 --> 00:15:42,000
Another option might be if you're not already using something, you could consider more rigorous use of something like semantic versioning.

89
00:15:42,000 --> 00:15:55,000
Or another option might be to just make a new project, you know, fork this off. If it really is going to be different, if it's going to break things, make a note in the old one, say that you're deprecating support for this existing version.

90
00:15:55,000 --> 00:16:04,000
You know, maybe a link in the README to the new one and then go happily develop not considering anything else over in the new repository and you'll have total freedom.

91
00:16:04,000 --> 00:16:14,000
Now, it sucks like we're very particular about names and you have to come up with a new name. That's the hardest part. But if it's a new thing, if it's different enough to be breaking, maybe it deserves a new name.

92
00:16:14,000 --> 00:16:17,000
Yeah, that's a powder keg in itself, too.

93
00:16:17,000 --> 00:16:27,000
Yeah, it is. It's a tricky situation. But I would say if you if you can just make a new one, then then do it. Otherwise, make it clear how people can use their existing stuff.

94
00:16:27,000 --> 00:16:36,000
It's probably trickier to that it's a script like you don't have maybe don't have all the tooling that nice package managers do to pin versions and other stuff that you that your users could rely on.

95
00:16:36,000 --> 00:16:39,000
If they're just grabbing the latest code from GitHub that that will break.

96
00:16:39,000 --> 00:16:48,000
I mean, maybe a unpopular anti RMS suggestion here is, you know, there used to be lots of businesses that what they did was like customize open source things for other people.

97
00:16:48,000 --> 00:17:01,000
You could totally if you're getting complaints from someone who has the means or the desire to pay for that, say I will, you know, say I'll do it for a fork for you.

98
00:17:01,000 --> 00:17:08,000
But you'll have to pay for the time that contribution takes. That's not unreasonable, right? People are paid to contribute to open source.

99
00:17:08,000 --> 00:17:17,000
Absolutely. Another option here, too, might be just to start the conversation, make an issue with the pending changes and your proposed implementation changes.

100
00:17:17,000 --> 00:17:22,000
Possibly users out there will have some sort of compromise that'll work for everyone, but you won't know till you try.

101
00:17:22,000 --> 00:17:26,000
Or if someone else could pick it up. Yeah, like Wes was saying, someone else might just pick up the mantle.

102
00:17:26,000 --> 00:17:35,000
Exactly. All right. Well, speaking of interesting changes, Mike, I saw you chatting away about some stuff in rail six.

103
00:17:35,000 --> 00:17:42,000
And it's been a while since I've used rails and I haven't used six at all. So maybe you can break down what's so interesting over there.

104
00:17:42,000 --> 00:17:50,000
Yes. So rail six is, you know, interesting, like buying a new Subaru. It's a little nicer.

105
00:17:50,000 --> 00:17:55,000
You've got maybe one or two features you're not so sure about, but it's basically the same.

106
00:17:55,000 --> 00:17:59,000
You're familiar with the brand and most of the models and it's just the latest version.

107
00:17:59,000 --> 00:18:05,000
I mean, they're pretty keen to tell you about Action Cable Testing and Action Mailbox.

108
00:18:05,000 --> 00:18:09,000
I think most people, particularly in Action Mailbox, I think most people are using like SendGrid.

109
00:18:09,000 --> 00:18:16,000
Action Text is interesting. So you can have like fancy text content, bridging it to rails a little better than you could before.

110
00:18:16,000 --> 00:18:22,000
Oh, yeah. Here, listen to this. Action Text brings rich text content and editing to rails.

111
00:18:22,000 --> 00:18:29,000
So it includes the Trix editor and then it sounds like it's got some like rich text model already made for you in the back end that you can tie it to.

112
00:18:29,000 --> 00:18:34,000
Oh, yeah. And then any embedded images are automatically stored using active storage and associated.

113
00:18:34,000 --> 00:18:38,000
So you want to have fancy text. It's a one stop shop. Interesting.

114
00:18:38,000 --> 00:18:42,000
I mean, there's a few removals. None of them are devastating, although I think the one.

115
00:18:42,000 --> 00:18:47,000
So there used to be a thing where you could do config dot secret token, which is exactly what it sounds like.

116
00:18:47,000 --> 00:18:54,000
You could have manly just, you know, in plain text, put in your secret token.

117
00:18:54,000 --> 00:18:59,000
That is a deprecation that is going to catch a lot of people with their pants down, I think.

118
00:18:59,000 --> 00:19:05,000
But yeah, you should not be doing that in 2019. So I think it's a good idea to remove that.

119
00:19:05,000 --> 00:19:07,000
And to be clear, that's a straight removal, not a deprecation.

120
00:19:07,000 --> 00:19:14,000
In fact, if you've been using Rubocop or any other kind of rails linter, you have been getting yelled at for using that.

121
00:19:14,000 --> 00:19:21,000
Good. My biggest thing is actually that it's including Webpack now in rails.

122
00:19:21,000 --> 00:19:28,000
So Webpack, the JavaScript packaging tool. I'm mixed on this.

123
00:19:28,000 --> 00:19:38,000
The applications I tend to develop are pretty much, you know, build the HTML, JavaScript and all that horrible crap I don't like to deal with on the back end and send it to the front end.

124
00:19:38,000 --> 00:19:48,000
But, you know, rails does have to compete with the, you know, with the hot new kids and more and more, especially for, I would say, consumer facing things.

125
00:19:48,000 --> 00:19:51,000
You want to have a little richer JavaScript experience.

126
00:19:51,000 --> 00:19:56,000
I mean, we talked a bunch of the languages we've done in the coding challenge, you know, have compiled the JavaScript.

127
00:19:56,000 --> 00:19:58,000
God forbid you're using ClojureScript.

128
00:19:58,000 --> 00:20:00,000
Yeah, absolutely. Let's hope you are.

129
00:20:00,000 --> 00:20:01,000
Oh, geez.

130
00:20:01,000 --> 00:20:03,000
Or Fable, right?

131
00:20:03,000 --> 00:20:08,000
You could be using Fable, again, if you're using Fable and rails together, I have to wonder what happened.

132
00:20:08,000 --> 00:20:11,000
But sure, you could.

133
00:20:11,000 --> 00:20:15,000
So they listen to like Mirror Universe, Michael Dominic, I think.

134
00:20:15,000 --> 00:20:19,000
Yes, that's like when I'm on one of my dot net kicks.

135
00:20:19,000 --> 00:20:23,000
I don't want to downplay this release because I think it's actually a pretty important release.

136
00:20:23,000 --> 00:20:26,000
There are changes if you're coming from Rails 5.

137
00:20:26,000 --> 00:20:34,000
So, you know, it's not nothing, but this isn't like Python 2 to Python 3, the world is ending, right?

138
00:20:34,000 --> 00:20:38,000
Or this isn't even like, you know, dot net 4 to dot net core 2 big.

139
00:20:38,000 --> 00:20:40,000
This is more.

140
00:20:40,000 --> 00:20:46,000
OK, we're deprecating some things you shouldn't have been doing anyway, or we're straight up removing them in some cases.

141
00:20:46,000 --> 00:20:50,000
We're adding better integration for work.

142
00:20:50,000 --> 00:20:55,000
It's almost like adding a blessed, quote unquote, railsy way to do rich JavaScript finance,

143
00:20:55,000 --> 00:20:58,000
which I kind of like because now I don't have to think about that.

144
00:20:58,000 --> 00:21:00,000
Yeah, that's what I was going to ask.

145
00:21:00,000 --> 00:21:06,000
I mean, were you using other sort of JavaScript compilers, transpilers, packers, minimizers,

146
00:21:06,000 --> 00:21:09,000
or did you just have to learn Webpack as a result?

147
00:21:09,000 --> 00:21:11,000
Neither.

148
00:21:11,000 --> 00:21:15,000
So a lot of the Rails stuff we're doing are backends processing JSON requests from other frontends,

149
00:21:15,000 --> 00:21:18,000
either mobile apps or desktop applications.

150
00:21:18,000 --> 00:21:20,000
Sure.

151
00:21:20,000 --> 00:21:24,000
Some of them are written in JavaScript, but, you know, like if it's Ionic, you're using whatever comes with Angular, right?

152
00:21:24,000 --> 00:21:26,000
So that's a big difference.

153
00:21:26,000 --> 00:21:28,000
That's actually the best example here.

154
00:21:28,000 --> 00:21:33,000
If you're using something like Bootstrap, instead of installing a Bootstrap gem on the backend,

155
00:21:33,000 --> 00:21:36,000
you could actually Webpack it with Bootstrap and have it all be on the client side.

156
00:21:36,000 --> 00:21:40,000
It just kind of gives you an additional layers of toolkits that you have access to now.

157
00:21:40,000 --> 00:21:45,000
Well, if you're a consumer facing site with heavy traffic, that's definitely going to help you out quite a bit

158
00:21:45,000 --> 00:21:51,000
because Rails is not known for being particularly performant.

159
00:21:51,000 --> 00:21:56,000
And also, you know, that processing is now happening on the browser rather than your server.

160
00:21:56,000 --> 00:21:58,000
Right, yeah.

161
00:21:58,000 --> 00:22:01,000
So overall, are you finding Rails still to be like a productive environment,

162
00:22:01,000 --> 00:22:05,000
a place that you want and trust to build applications on top of?

163
00:22:05,000 --> 00:22:10,000
Yeah, I mean, Rails is kind of my, I need to get this done, and I need it to be solid

164
00:22:10,000 --> 00:22:15,000
because this is the kind of thing that's either going to get audited or, you know, it's my default

165
00:22:15,000 --> 00:22:18,000
unless somebody asks me for something else.

166
00:22:18,000 --> 00:22:21,000
Big or you need performance.

167
00:22:21,000 --> 00:22:25,000
Right, because making Rails fast requires, I know we're going to get email,

168
00:22:25,000 --> 00:22:28,000
but Wes is right that it's not that fast.

169
00:22:28,000 --> 00:22:30,000
Wes was right.

170
00:22:30,000 --> 00:22:33,000
I knew that was getting clicked. I knew it.

171
00:22:33,000 --> 00:22:37,000
Sorry. But I mean, you were asking for it.

172
00:22:37,000 --> 00:22:39,000
I really was, wasn't I?

173
00:22:39,000 --> 00:22:42,000
Oh, I guess the other thing that the Ruby people are going to be mad,

174
00:22:42,000 --> 00:22:45,000
yes, there's better testing support for Action Cable.

175
00:22:45,000 --> 00:22:47,000
What's the implication there?

176
00:22:47,000 --> 00:22:50,000
I kind of think Action Cable is a little overhyped.

177
00:22:50,000 --> 00:22:53,000
I'm not familiar with it. Can you break it down?

178
00:22:53,000 --> 00:23:00,000
Yeah, so Action Cable basically was a, oh, I'm going to pick my words very carefully here.

179
00:23:00,000 --> 00:23:02,000
Please do, please do.

180
00:23:02,000 --> 00:23:09,000
I would say Action Cable was a way to breach some of the HTML5 modern web functionality

181
00:23:09,000 --> 00:23:14,000
that maybe wasn't exactly native to Rails.

182
00:23:14,000 --> 00:23:18,000
One of the side issues with that is testing it is very,

183
00:23:18,000 --> 00:23:20,000
or traditionally has been completely challenging.

184
00:23:20,000 --> 00:23:22,000
And I can break that down a little better for you.

185
00:23:22,000 --> 00:23:25,000
So let's say you're using RSpec for testing, which most people are.

186
00:23:25,000 --> 00:23:26,000
Right, right.

187
00:23:26,000 --> 00:23:30,000
The support for Action Cable was virtually non-existent.

188
00:23:30,000 --> 00:23:33,000
There are hundreds of hipsters with gold MacBooks on YouTube

189
00:23:33,000 --> 00:23:39,000
who would love to tell you how they've managed to get 100% test coverage of their Active Action.

190
00:23:39,000 --> 00:23:42,000
Yeah, they've really got to stop using Active and Action.

191
00:23:42,000 --> 00:23:45,000
Action Cable code.

192
00:23:45,000 --> 00:23:49,000
Action Cable also does, if you're familiar with like ZMQ and PubSub models,

193
00:23:49,000 --> 00:23:51,000
you could do that in Action Cable.

194
00:23:51,000 --> 00:23:54,000
That's actually what I think is the best use of Action Cable.

195
00:23:54,000 --> 00:23:59,000
But other people have done lots of other interesting things, chat rooms, things like that.

196
00:23:59,000 --> 00:24:02,000
I can't say I've never used it. I can't say it's bad.

197
00:24:02,000 --> 00:24:09,000
I can say that these types of things are hard to test because conceptually they're just,

198
00:24:09,000 --> 00:24:17,000
the way most Rails testing has gone is really a byproduct of most people using RSpec.

199
00:24:17,000 --> 00:24:23,000
And RSpec was written in a time when it was request, response, server, client.

200
00:24:23,000 --> 00:24:30,000
So now that you're having subscriber-publisher relationships, your metaphors don't match up.

201
00:24:30,000 --> 00:24:38,000
I don't even know how to say it without getting into the deep of RSpec literally expects there to be a request and a response.

202
00:24:38,000 --> 00:24:42,000
Right. It's just hard that the models that they're designed under don't play well together

203
00:24:42,000 --> 00:24:45,000
and you don't get all the nice leverage that RSpec has in other arenas.

204
00:24:45,000 --> 00:24:48,000
And to the RSpec's team credit, they are fixing that.

205
00:24:48,000 --> 00:24:49,000
It's going forward.

206
00:24:49,000 --> 00:24:52,000
Rails 6 makes this a lot cleaner to test.

207
00:24:52,000 --> 00:24:56,000
I've never felt that this was exactly something you needed to kill yourself over not testing.

208
00:24:56,000 --> 00:24:57,000
I don't know.

209
00:24:57,000 --> 00:25:03,000
I'm less of a TDD jealous zealot than most of the people who use Ruby all the time.

210
00:25:03,000 --> 00:25:08,000
But I guess if it makes you happy and you know what?

211
00:25:08,000 --> 00:25:10,000
I mean, don't get me wrong.

212
00:25:10,000 --> 00:25:13,000
Now that it's easier, I will be testing my action cable code.

213
00:25:13,000 --> 00:25:15,000
I'm not saying I'm not going to do it.

214
00:25:15,000 --> 00:25:21,000
I'm just saying I was never going to be one of these people writing my own little testing shim because action is just hard.

215
00:25:21,000 --> 00:25:24,000
To me, that was not a good use of resources.

216
00:25:24,000 --> 00:25:29,000
But we can move on because we're getting out of fact and way into opinion here.

217
00:25:29,000 --> 00:25:39,000
Sometimes that's fun, but let's move on to something that maybe you're a little more excited about and that's our old friend Rust.

218
00:25:39,000 --> 00:25:49,000
I saw an interesting video come out over from the Open Source Technology Summit about Intel and their relationship with Rust.

219
00:25:49,000 --> 00:25:53,000
I mean, we've spoken a lot about Rust for some of your applications, Michael.

220
00:25:53,000 --> 00:25:54,000
Yes.

221
00:25:54,000 --> 00:25:58,000
And we've talked a bit about running it for all kinds of stuff and where it might be a good fit.

222
00:25:58,000 --> 00:26:06,000
Systems programming is obviously one of its design goals and Intel, well, I mean, they design and run a lot of systems.

223
00:26:06,000 --> 00:26:09,000
We haven't talked too much about exactly what they've been working on.

224
00:26:09,000 --> 00:26:13,000
I enjoyed this talk by their principal engineer, Josh Triplett.

225
00:26:13,000 --> 00:26:17,000
I thought maybe we could go over a few of the interesting points therein.

226
00:26:17,000 --> 00:26:18,000
Make it Rusty.

227
00:26:18,000 --> 00:26:28,000
They're going to start and talk about the evolutions of systems and embedded and lower level programming.

228
00:26:28,000 --> 00:26:33,000
As you know, Mike, it's hairy and sure, we've got C now, but for a long time, you just had to mess with assembly.

229
00:26:33,000 --> 00:26:38,000
Systems programming makes many demands on programming languages.

230
00:26:38,000 --> 00:26:43,000
Systems programming, because of that, needs both capability as well as safety.

231
00:26:43,000 --> 00:26:50,000
To talk about what I mean by that, I want to go into a little historical advancement in systems programming.

232
00:26:50,000 --> 00:26:54,000
This pattern of advancement applies to many different types of systems,

233
00:26:54,000 --> 00:26:59,000
but let's look specifically at BIOS, at firmware, and at bootloaders.

234
00:26:59,000 --> 00:27:06,000
All of these things were originally written very heavily in assembly language long after other software wasn't,

235
00:27:06,000 --> 00:27:12,000
with some extensions, with a small smattering of assembly, but in general, C worked its way down the stack.

236
00:27:12,000 --> 00:27:17,000
Now even the BIOS is written almost entirely in C with a little bit of assembly here and there.

237
00:27:17,000 --> 00:27:28,000
That took a surprisingly long time, but it was really only possible because C actually had some features that were worth upgrading for.

238
00:27:28,000 --> 00:27:35,000
In order to make that move, they had to be confident in two different ways to switch from one programming language to another.

239
00:27:35,000 --> 00:27:38,000
First of all, the language has to be sufficiently compelling,

240
00:27:38,000 --> 00:27:41,000
to have sufficiently compelling features to warrant moving in the first place.

241
00:27:41,000 --> 00:27:50,000
It can't just be a little bit better, it has to be substantially better to warrant the effort and engineering time needed to move.

242
00:27:50,000 --> 00:27:54,000
Now C had a lot of compelling features to offer assembly developers.

243
00:27:54,000 --> 00:27:59,000
It provided some degree of type safety, at least enough to not easily mix integers and pointers.

244
00:27:59,000 --> 00:28:05,000
It made developers more productive with higher level constructs, with more readable code,

245
00:28:05,000 --> 00:28:10,000
but just as important as that, the language also has to provide parity.

246
00:28:10,000 --> 00:28:16,000
Developers had to feel confident that C was no less capable than assembly language.

247
00:28:16,000 --> 00:28:24,000
And that is a huge point, and I think it's been an evolving episode in, does Rust have all of that?

248
00:28:24,000 --> 00:28:31,000
And I think the whole sort of endeavor here and what this talk is about is also just sort of an interesting microcosm that happens all the time, right?

249
00:28:31,000 --> 00:28:36,000
We do move on to other languages, we change the tools that we use,

250
00:28:36,000 --> 00:28:40,000
and it's fun to sort of examine how does that actually happen in practice?

251
00:28:40,000 --> 00:28:46,000
I'm curious if you agree, if you found that there are some things that Rust had that you liked,

252
00:28:46,000 --> 00:28:51,000
but maybe some other areas that it was sort of still advancing when you have been playing with it.

253
00:28:51,000 --> 00:28:55,000
You know, I actually think Rust is getting better and better all the time.

254
00:28:55,000 --> 00:29:01,000
I kind of think Rust is going to be around for a while as a systems programming language,

255
00:29:01,000 --> 00:29:03,000
and I think it's going to beat things like Go.

256
00:29:03,000 --> 00:29:09,000
It was a little frustrating, like those first couple weeks of using it, how strict the compiler was, if that makes sense?

257
00:29:09,000 --> 00:29:12,000
Sure, right, yeah. I mean, that's a big advantage, but you've got to learn.

258
00:29:12,000 --> 00:29:17,000
It's having a conversation with a whole new entity, and you've got to learn how to talk to it and what it expects.

259
00:29:17,000 --> 00:29:21,000
Right, and it's maybe a little tighter than what I was kind of used to.

260
00:29:21,000 --> 00:29:22,000
Yes.

261
00:29:22,000 --> 00:29:25,000
I have to say, the output has been very performant and very reliable.

262
00:29:25,000 --> 00:29:33,000
Again, the use case, or the primary one that is at least the most code, is processing STL and OBJ files that I had,

263
00:29:33,000 --> 00:29:41,000
and it worked great, which was a pretty intensive task that if not for Rust, I probably would have had to do in C++,

264
00:29:41,000 --> 00:29:47,000
which I would have found, one, much more error-prone because the non-strict compiler.

265
00:29:47,000 --> 00:29:53,000
And I don't see a reason to really hate on Rust, I'm sorry.

266
00:29:53,000 --> 00:29:55,000
No, that's great.

267
00:29:55,000 --> 00:30:02,000
Josh actually shared some reasons that you and many others, including Intel, are finding it a pleasure to work with.

268
00:30:02,000 --> 00:30:07,000
So, the same properties that make Rust work well for Mozilla to build a browser engine,

269
00:30:07,000 --> 00:30:13,000
also make it appealing for many other companies and projects that are building large, complex systems.

270
00:30:13,000 --> 00:30:18,000
So that includes a lot of companies that you already know, many companies that are represented here, even.

271
00:30:18,000 --> 00:30:26,000
Microsoft, Google, Facebook, Amazon, Dropbox, Chef, Fastly, Baidu, a huge number of companies beyond that.

272
00:30:26,000 --> 00:30:32,000
You can find a long list online, and hundreds of companies are using it to build all sorts of different software.

273
00:30:32,000 --> 00:30:34,000
There's a lot more to it than that.

274
00:30:34,000 --> 00:30:38,000
So, Rust actually has a long and interesting history.

275
00:30:38,000 --> 00:30:41,000
It was started four years ago today, in fact.

276
00:30:41,000 --> 00:30:44,000
This is the fourth anniversary of Rust 1.0, the stable release.

277
00:30:44,000 --> 00:30:50,000
It was started years before that, and beyond that, for those last four years,

278
00:30:50,000 --> 00:30:53,000
it's been the most loved language on Stack Overflow.

279
00:30:53,000 --> 00:30:57,000
People always say, well, I've started using it, and I want to keep using it.

280
00:30:57,000 --> 00:31:00,000
It has the most loyalty in that way.

281
00:31:00,000 --> 00:31:04,000
Beyond that, there are a lot of published security studies about the properties that Rust provides.

282
00:31:04,000 --> 00:31:10,000
This isn't just a thing that they advocate as, oh, you should use it because it has these properties.

283
00:31:10,000 --> 00:31:17,000
There was a study from Microsoft saying that 70% of security bugs are memory safety issues of some kind,

284
00:31:17,000 --> 00:31:21,000
and exactly the same type of issues that Rust fixes.

285
00:31:21,000 --> 00:31:27,000
A number of developers from Microsoft expressed interest in driving those types of security fixes using Rust.

286
00:31:27,000 --> 00:31:33,000
Mozilla did a study that showed that if they'd written one component of Firefox in Rust from the beginning,

287
00:31:33,000 --> 00:31:37,000
they'd have avoided 73% of its historical security issues.

288
00:31:37,000 --> 00:31:40,000
Mozilla went back and looked at every CVE in that component and said,

289
00:31:40,000 --> 00:31:45,000
which of them would still have existed, and which of them were fixed by writing it in Rust?

290
00:31:45,000 --> 00:31:49,000
Well, those are some pretty decent numbers, I would say.

291
00:31:49,000 --> 00:31:51,000
Yeah, I would say that's almost okay, right?

292
00:31:51,000 --> 00:31:53,000
Yeah, absolutely.

293
00:31:53,000 --> 00:31:58,000
But, of course, that doesn't mean everything is working, especially if you're doing low-level stuff,

294
00:31:58,000 --> 00:32:02,000
or maybe you need to produce super-duper optimized bytecode,

295
00:32:02,000 --> 00:32:06,000
and people at Intel do have some of those needs from time to time.

296
00:32:06,000 --> 00:32:10,000
I thought it was interesting that the talk kind of ends after going into more of the history of Rust

297
00:32:10,000 --> 00:32:13,000
and some of the nitty-gritty technical stuff.

298
00:32:13,000 --> 00:32:16,000
It just ends on a good summary of all the stuff that Intel is trying to work on

299
00:32:16,000 --> 00:32:21,000
to make that open-source ecosystem better for them and for others.

300
00:32:21,000 --> 00:32:24,000
I want to give a summary of what we're trying to work on.

301
00:32:24,000 --> 00:32:29,000
We need full parity with C to support the long tail of system software,

302
00:32:29,000 --> 00:32:32,000
and we have a Rust working group working towards that goal.

303
00:32:32,000 --> 00:32:37,000
And every feature that we add covers more of the space of systems programming.

304
00:32:37,000 --> 00:32:40,000
We want to make sure that all developers have a choice of languages,

305
00:32:40,000 --> 00:32:43,000
not just app developers but systems programmers as well,

306
00:32:43,000 --> 00:32:47,000
and nobody is stuck with only one language that will do what they need.

307
00:32:47,000 --> 00:32:50,000
So we want to make sure that no matter what language you're using,

308
00:32:50,000 --> 00:32:54,000
C or Rust or anything else, that it runs best on Intel hardware

309
00:32:54,000 --> 00:32:58,000
and that it gives you access to the full capabilities of your hardware.

310
00:32:58,000 --> 00:33:02,000
And we would love to have your feedback to help drive what C features

311
00:33:02,000 --> 00:33:04,000
that we add to Rust next.

312
00:33:04,000 --> 00:33:07,000
So please do get in touch if you want to do systems programming

313
00:33:07,000 --> 00:33:09,000
in higher-level languages.

314
00:33:09,000 --> 00:33:12,000
And please, please, please, don't buy AMD.

315
00:33:12,000 --> 00:33:13,000
Right.

316
00:33:13,000 --> 00:33:17,000
Well, of course, you've got to sneak that little sales pitch in there.

317
00:33:17,000 --> 00:33:18,000
Yeah.

318
00:33:18,000 --> 00:33:20,000
No, but that's pretty interesting.

319
00:33:20,000 --> 00:33:25,000
I mean, if you are, there's nothing wrong with Intel wanting to support your project.

320
00:33:25,000 --> 00:33:26,000
Right.

321
00:33:26,000 --> 00:33:30,000
And it's just kind of interesting to see because this is all in the open,

322
00:33:30,000 --> 00:33:34,000
and Rust has done a good job of having a lot of the language evolution done

323
00:33:34,000 --> 00:33:37,000
in a particularly transparent way, I would say.

324
00:33:37,000 --> 00:33:40,000
We get to sit here and watch and talk about it.

325
00:33:40,000 --> 00:33:44,000
Now, this is an example of open source work being done by Intel,

326
00:33:44,000 --> 00:33:46,000
obviously a very large corporation.

327
00:33:46,000 --> 00:33:50,000
But, Mike, you were pretty fired up about an article over in Wired

328
00:33:50,000 --> 00:33:55,000
by Keith Negley that reminds us that that's not always the case.

329
00:33:55,000 --> 00:33:56,000
Yeah.

330
00:33:56,000 --> 00:33:59,000
So I am an old man, so I subscribe to a number of print magazines,

331
00:33:59,000 --> 00:34:00,000
including Wired.

332
00:34:00,000 --> 00:34:01,000
Oh, look at you.

333
00:34:01,000 --> 00:34:04,000
You got the physical thing right there in your hands.

334
00:34:04,000 --> 00:34:05,000
Damn right.

335
00:34:05,000 --> 00:34:07,000
And they had this article, this last issue,

336
00:34:07,000 --> 00:34:11,000
about the tragedy of commons in FOSS, right?

337
00:34:11,000 --> 00:34:13,000
And, damn, it was heartbreaking.

338
00:34:13,000 --> 00:34:17,000
All these stories, the most telling one was of the open SSL team

339
00:34:17,000 --> 00:34:19,000
barely making a few thousand dollars a year.

340
00:34:19,000 --> 00:34:20,000
Right.

341
00:34:20,000 --> 00:34:23,000
I mean, this was kind of a reminder of what the situation was like

342
00:34:23,000 --> 00:34:24,000
before Heartbleed.

343
00:34:24,000 --> 00:34:25,000
Right, during Heartbleed.

344
00:34:25,000 --> 00:34:30,000
And just how, while it is absolutely true that the open source community

345
00:34:30,000 --> 00:34:34,000
can do great things, it's also true that, you know,

346
00:34:34,000 --> 00:34:37,000
I wouldn't even say corporate America, right, like corporate,

347
00:34:37,000 --> 00:34:41,000
I don't know, federation, like the Star Trek federation,

348
00:34:41,000 --> 00:34:44,000
are really leveraging the crap out of the community here.

349
00:34:44,000 --> 00:34:45,000
Right.

350
00:34:45,000 --> 00:34:48,000
And, I mean, on one side of that, that's kind of good and expected

351
00:34:48,000 --> 00:34:52,000
because you're putting it out there in the open to be used.

352
00:34:52,000 --> 00:34:58,000
But it sort of has, you know, hidden externalities, hidden reliances

353
00:34:58,000 --> 00:35:01,000
that we're not always doing a proper job of maintaining.

354
00:35:01,000 --> 00:35:04,000
And in the long run, that's not good for the businesses that rely on it

355
00:35:04,000 --> 00:35:07,000
or the people trying to make the software.

356
00:35:07,000 --> 00:35:10,000
Yeah, it's, you know, I more put this in for this week

357
00:35:10,000 --> 00:35:12,000
to kind of throw it out there to the audience

358
00:35:12,000 --> 00:35:14,000
and maybe get some feedback for next week.

359
00:35:14,000 --> 00:35:17,000
What do we think of this, you know, companies making millions

360
00:35:17,000 --> 00:35:20,000
and billions of dollars off open source projects

361
00:35:20,000 --> 00:35:23,000
where the maintainers are just hacking on it nights and weekends

362
00:35:23,000 --> 00:35:27,000
and, you know, not making anything?

363
00:35:27,000 --> 00:35:30,000
I mean, the best case he had, the author,

364
00:35:30,000 --> 00:35:32,000
was someone who ran a software consultancy,

365
00:35:32,000 --> 00:35:35,000
but they never even, you know, they never made a million in revenue.

366
00:35:35,000 --> 00:35:38,000
Meanwhile, some of the biggest Fortune 500s in the world

367
00:35:38,000 --> 00:35:40,000
depended on their project.

368
00:35:40,000 --> 00:35:41,000
Right, yeah.

369
00:35:41,000 --> 00:35:44,000
You know, I wonder, too, it seems like, I don't know if you'd agree,

370
00:35:44,000 --> 00:35:48,000
that more mainstream culture reporters, news organizations

371
00:35:48,000 --> 00:35:50,000
sort of discovered open source,

372
00:35:50,000 --> 00:35:53,000
and I think the wider world is still trying to make sense of it, too.

373
00:35:53,000 --> 00:35:55,000
And in this case, it's kind of nice

374
00:35:55,000 --> 00:35:59,000
because it points out some things that we don't talk about probably often enough.

375
00:35:59,000 --> 00:36:02,000
Yeah, I think Heartbleed, in particular,

376
00:36:02,000 --> 00:36:06,000
kind of took off some blinders for the mainstream.

377
00:36:06,000 --> 00:36:09,000
I would even say the mainstream tech press, right?

378
00:36:09,000 --> 00:36:12,000
So the tech press was not necessarily, you know,

379
00:36:12,000 --> 00:36:17,000
even in the development kind of Linux-y, Voss-y community.

380
00:36:17,000 --> 00:36:18,000
I don't know.

381
00:36:18,000 --> 00:36:23,000
Again, I am not going to jump into the GPL versus BSD debate here,

382
00:36:23,000 --> 00:36:28,000
but I will say that it doesn't make a lot of sense.

383
00:36:28,000 --> 00:36:30,000
And I think we've seen this in the Linux world, too,

384
00:36:30,000 --> 00:36:32,000
where some projects, notably this year,

385
00:36:32,000 --> 00:36:34,000
I can't remember the names off the top of my head,

386
00:36:34,000 --> 00:36:37,000
but I'm sure you do, have been shutting down or switching maintainership

387
00:36:37,000 --> 00:36:40,000
just because of, you know, it's not worth it, right?

388
00:36:40,000 --> 00:36:42,000
The maintainers are getting a little older, maybe,

389
00:36:42,000 --> 00:36:45,000
they have families, whatever, and they just can't do this.

390
00:36:45,000 --> 00:36:48,000
Right, I mean, you know, life gets in the way sometimes,

391
00:36:48,000 --> 00:36:52,000
and if we don't have a robust base of support to either let that continue

392
00:36:52,000 --> 00:36:54,000
or other people to, you know, sort of continue the work,

393
00:36:54,000 --> 00:36:57,000
well, we're going to lose things that we care about or find useful.

394
00:36:57,000 --> 00:36:59,000
One of the most haterade cases of this, I think,

395
00:36:59,000 --> 00:37:02,000
for our community at JB is going to be,

396
00:37:02,000 --> 00:37:04,000
remember, Mac is Darwin BSD.

397
00:37:04,000 --> 00:37:06,000
I mean, yes, they've mutated it quite a lot,

398
00:37:06,000 --> 00:37:09,000
but underneath it's the mock kernel running Darwin.

399
00:37:09,000 --> 00:37:11,000
They've done a lot to it, granted.

400
00:37:11,000 --> 00:37:16,000
There used to be FOSS Darwin BSD, like, alternatives.

401
00:37:16,000 --> 00:37:17,000
Yeah.

402
00:37:17,000 --> 00:37:20,000
Right, and there's a little show called BSD Now.

403
00:37:20,000 --> 00:37:21,000
Just saying.

404
00:37:21,000 --> 00:37:25,000
BSDNow.tv, if you'd like to check that out.

405
00:37:25,000 --> 00:37:29,000
It is a place to be for all things BSD.

406
00:37:29,000 --> 00:37:32,000
Where they all run Windows 7. Oops, sorry.

407
00:37:32,000 --> 00:37:35,000
I mean, sometimes people got to run Windows, Mike.

408
00:37:35,000 --> 00:37:36,000
You're one to talk.

409
00:37:36,000 --> 00:37:37,000
Oh, I know, I know.

410
00:37:37,000 --> 00:37:40,000
Next best Linux distro, Windows 10.

411
00:37:40,000 --> 00:37:45,000
Now, if you're all fired up like I am about what Mike just said,

412
00:37:45,000 --> 00:37:47,000
please do leave us feedback.

413
00:37:47,000 --> 00:37:51,000
You can do that either over at our subreddit coder radio.reddit.com

414
00:37:51,000 --> 00:37:55,000
or just go to coder.show directly or coder.show slash contact,

415
00:37:55,000 --> 00:37:59,000
and we've got a handy dandy little form that sends us an email.

416
00:37:59,000 --> 00:38:01,000
Now, Mike, let's move right along.

417
00:38:01,000 --> 00:38:02,000
There's no avoiding it.

418
00:38:02,000 --> 00:38:05,000
It's time for our language check-in.

419
00:38:05,000 --> 00:38:09,000
This week it's your turn, and you've been checking out Crystal.

420
00:38:09,000 --> 00:38:10,000
It's so shiny.

421
00:38:10,000 --> 00:38:12,000
I think it's kind of perfect to talk about

422
00:38:12,000 --> 00:38:15,000
because we've just been talking about systems programming and Rust,

423
00:38:15,000 --> 00:38:20,000
and one of Crystal's stated language goals is be able to call C code

424
00:38:20,000 --> 00:38:23,000
by writing bindings in pure Crystal.

425
00:38:23,000 --> 00:38:24,000
What?

426
00:38:24,000 --> 00:38:27,000
But before we get there, tell me more.

427
00:38:27,000 --> 00:38:28,000
How has it been?

428
00:38:28,000 --> 00:38:31,000
What's it like, and is it as cool as the little spinning Crystal

429
00:38:31,000 --> 00:38:32,000
on their homepage makes it look?

430
00:38:32,000 --> 00:38:35,000
All right, so I have to give it to the Crystal team.

431
00:38:35,000 --> 00:38:37,000
They know how to brand things.

432
00:38:37,000 --> 00:38:40,000
First of all, their website is just amazing.

433
00:38:40,000 --> 00:38:45,000
Second of all, their tagline, fast to see, slick as Ruby.

434
00:38:45,000 --> 00:38:47,000
Let's just drop our mics right now.

435
00:38:47,000 --> 00:38:48,000
Oh, boy.

436
00:38:48,000 --> 00:38:49,000
Yeah, wow.

437
00:38:49,000 --> 00:38:52,000
So Crystal could trick you on a cursory look

438
00:38:52,000 --> 00:38:54,000
and have you think you're writing Ruby.

439
00:38:54,000 --> 00:38:58,000
Yeah, look at this, server equals http server dot news,

440
00:38:58,000 --> 00:39:00,000
and then like the whole do block right from Ruby.

441
00:39:00,000 --> 00:39:01,000
What's going on?

442
00:39:01,000 --> 00:39:05,000
It is, by design, meant to be very syntactically

443
00:39:05,000 --> 00:39:10,000
and in a general methodology and pattern sort of way like Ruby,

444
00:39:10,000 --> 00:39:12,000
but there's a couple big differences.

445
00:39:12,000 --> 00:39:15,000
This is kind of, well, let's get the obvious ones

446
00:39:15,000 --> 00:39:16,000
right out of the way here, right?

447
00:39:16,000 --> 00:39:20,000
So first off, it is a static language.

448
00:39:20,000 --> 00:39:22,000
Static typing, maybe.

449
00:39:22,000 --> 00:39:25,000
Ah, so that's a big difference from Ruby right away.

450
00:39:25,000 --> 00:39:26,000
That's a big difference.

451
00:39:26,000 --> 00:39:29,000
Now, it goes out of its way not to slap you in the face with that,

452
00:39:29,000 --> 00:39:31,000
so most of the time you don't need to manually declare the types.

453
00:39:31,000 --> 00:39:32,000
It figures it out.

454
00:39:32,000 --> 00:39:36,000
So it's a modern type language with nice handy inference

455
00:39:36,000 --> 00:39:39,000
to help you out so that most of the time you can just kind of,

456
00:39:39,000 --> 00:39:42,000
not forget about it, but not have to annotate every last little thing.

457
00:39:42,000 --> 00:39:43,000
Right, but it does enforce it

458
00:39:43,000 --> 00:39:46,000
as though it were a traditional static type language.

459
00:39:46,000 --> 00:39:47,000
Excellent.

460
00:39:47,000 --> 00:39:49,000
So it infers it the first time, and then after that,

461
00:39:49,000 --> 00:39:51,000
it just assumes you know what you're doing.

462
00:39:51,000 --> 00:39:54,000
And if it doesn't compile time, it fails,

463
00:39:54,000 --> 00:39:57,000
which by the way, unlike Ruby, it compiles.

464
00:39:57,000 --> 00:39:59,000
Now, I know there are weird implementations of Ruby

465
00:39:59,000 --> 00:40:01,000
that people have run through compilers.

466
00:40:01,000 --> 00:40:02,000
Sure, of course.

467
00:40:02,000 --> 00:40:04,000
We're talking mainline Ruby here, right?

468
00:40:04,000 --> 00:40:06,000
Yeah, it compiles, and you're running binaries

469
00:40:06,000 --> 00:40:08,000
that are compiling to your native platform,

470
00:40:08,000 --> 00:40:11,000
which means you have to care about your native platform.

471
00:40:11,000 --> 00:40:13,000
Yeah, that's a big difference right there.

472
00:40:13,000 --> 00:40:15,000
It's not just this high-level interpreted language anymore.

473
00:40:15,000 --> 00:40:17,000
But of course, as we all know,

474
00:40:17,000 --> 00:40:20,000
compiled languages are in general faster

475
00:40:20,000 --> 00:40:23,000
than their interpreted equivalents, right?

476
00:40:23,000 --> 00:40:26,000
Which makes sense if you understand what the compiler actually does.

477
00:40:26,000 --> 00:40:29,000
So that's where it gets a lot of its speed.

478
00:40:29,000 --> 00:40:32,000
Oh, and also it consumes C directly, so yay.

479
00:40:32,000 --> 00:40:34,000
That is cool.

480
00:40:34,000 --> 00:40:37,000
Part of the static typing I noticed that they've got nice null handling.

481
00:40:37,000 --> 00:40:39,000
All types are non-nullable,

482
00:40:39,000 --> 00:40:41,000
and nullable variables are represented separately

483
00:40:41,000 --> 00:40:44,000
as a union between that type and nil.

484
00:40:44,000 --> 00:40:46,000
So they've got some nice modern handling there.

485
00:40:46,000 --> 00:40:48,000
Right, huge departure from Ruby,

486
00:40:48,000 --> 00:40:50,000
where hey, you can throw nil around like it's candy.

487
00:40:50,000 --> 00:40:53,000
And I find that that's less of a problem.

488
00:40:53,000 --> 00:40:55,000
In my own work with Ruby anyway,

489
00:40:55,000 --> 00:40:57,000
I don't find nil to be the sort of problem

490
00:40:57,000 --> 00:40:59,000
that null is in some Java code bases.

491
00:40:59,000 --> 00:41:01,000
But still, this is nice to have.

492
00:41:01,000 --> 00:41:03,000
More and more I'm liking things to be a bit stricter

493
00:41:03,000 --> 00:41:05,000
on the whole null, nil front.

494
00:41:05,000 --> 00:41:07,000
I don't mind it.

495
00:41:07,000 --> 00:41:10,000
In some of my reading around the forums and asking people,

496
00:41:10,000 --> 00:41:12,000
some people had issues with that.

497
00:41:12,000 --> 00:41:14,000
I don't understand why.

498
00:41:14,000 --> 00:41:17,000
I kind of don't think your way of validating your logic

499
00:41:17,000 --> 00:41:20,000
should be checking for nil, but that's just me.

500
00:41:20,000 --> 00:41:22,000
Right.

501
00:41:22,000 --> 00:41:24,000
I can't say I've never done it.

502
00:41:24,000 --> 00:41:26,000
That's how Objective-C, that was a very common pattern.

503
00:41:26,000 --> 00:41:31,000
It's not, you know, with age comes wisdom.

504
00:41:31,000 --> 00:41:33,000
A couple things I don't like

505
00:41:33,000 --> 00:41:35,000
before we get into some love here.

506
00:41:35,000 --> 00:41:37,000
Yeah, okay, yeah.

507
00:41:37,000 --> 00:41:41,000
So with static typing comes a lot of safety.

508
00:41:41,000 --> 00:41:45,000
You do lose some of the flexibility that you have in Ruby.

509
00:41:45,000 --> 00:41:47,000
Again, Crystal is its own language.

510
00:41:47,000 --> 00:41:49,000
It's just meant to look like Ruby.

511
00:41:49,000 --> 00:41:51,000
It's not a derivative of Ruby.

512
00:41:51,000 --> 00:41:53,000
It's not trying to be derivative.

513
00:41:53,000 --> 00:41:55,000
It's not trying to be compatible, yeah.

514
00:41:55,000 --> 00:41:57,000
The dot each iterator

515
00:41:57,000 --> 00:41:59,000
does not do what you would like it to do in Ruby.

516
00:41:59,000 --> 00:42:01,000
It is actually much more complex.

517
00:42:01,000 --> 00:42:03,000
You have to know what your collection is going in

518
00:42:03,000 --> 00:42:07,000
where in Ruby you can basically iterate over a ham sandwich.

519
00:42:07,000 --> 00:42:11,000
There's a whole enumerable module in Ruby

520
00:42:11,000 --> 00:42:13,000
that everything has, yeah.

521
00:42:13,000 --> 00:42:15,000
I think this is good,

522
00:42:15,000 --> 00:42:18,000
although people who've been using it a long time

523
00:42:18,000 --> 00:42:21,000
know I was very upset when Swift removed it.

524
00:42:21,000 --> 00:42:23,000
Yeah, you don't need for loops.

525
00:42:23,000 --> 00:42:25,000
You know what? I know they're like Comp Sci 100.

526
00:42:25,000 --> 00:42:27,000
Everybody has to learn for loops.

527
00:42:27,000 --> 00:42:29,000
You don't need for loops.

528
00:42:29,000 --> 00:42:31,000
So Crystal's down with that.

529
00:42:31,000 --> 00:42:33,000
You don't get no for loops.

530
00:42:33,000 --> 00:42:35,000
So if you want to iterate over a collection,

531
00:42:35,000 --> 00:42:37,000
you actually have to create the right type of collection

532
00:42:37,000 --> 00:42:39,000
and iterate over it.

533
00:42:39,000 --> 00:42:41,000
Oh, interesting, yeah, okay.

534
00:42:41,000 --> 00:42:43,000
That'll be different for some people

535
00:42:43,000 --> 00:42:45,000
that maybe have not worked with such a low-level language.

536
00:42:45,000 --> 00:42:47,000
But I'm going to just like, again,

537
00:42:47,000 --> 00:42:49,000
like many of the things in Rust,

538
00:42:49,000 --> 00:42:51,000
the enforcement of just a little extra discipline

539
00:42:51,000 --> 00:42:53,000
actually can protect you from

540
00:42:53,000 --> 00:42:55,000
just like a wide array of common errors, right?

541
00:42:55,000 --> 00:42:57,000
See what I did there? Iteration mentioned an array.

542
00:42:57,000 --> 00:42:59,000
I just like that.

543
00:42:59,000 --> 00:43:01,000
Yes.

544
00:43:01,000 --> 00:43:03,000
But then we get into what I can only describe as

545
00:43:03,000 --> 00:43:05,000
don't call me Ruby gems. Shards.

546
00:43:05,000 --> 00:43:07,000
Shards are exactly what you think they are.

547
00:43:07,000 --> 00:43:09,000
They are the equivalent of Ruby gems.

548
00:43:09,000 --> 00:43:11,000
Oh, that's a cute name.

549
00:43:11,000 --> 00:43:13,000
Right. They work differently because it's compiled,

550
00:43:13,000 --> 00:43:15,000
but you really don't care.

551
00:43:15,000 --> 00:43:17,000
It's a command. You run on the command line.

552
00:43:17,000 --> 00:43:19,000
You install it. It gives you dependencies.

553
00:43:19,000 --> 00:43:21,000
I mean, they're doing great work with it,

554
00:43:21,000 --> 00:43:23,000
but it's just like every package manager

555
00:43:23,000 --> 00:43:25,000
for every language, right?

556
00:43:25,000 --> 00:43:27,000
Kind of what the check these days, I think,

557
00:43:27,000 --> 00:43:29,000
is like, did they mess it up?

558
00:43:29,000 --> 00:43:31,000
Did you get this wrong?

559
00:43:31,000 --> 00:43:33,000
It works fine.

560
00:43:33,000 --> 00:43:35,000
Yeah, you're right. They didn't mess it up.

561
00:43:35,000 --> 00:43:37,000
It's boring. We just move on.

562
00:43:37,000 --> 00:43:39,000
Fibers, which are their concurrency model,

563
00:43:39,000 --> 00:43:41,000
are interesting and complex.

564
00:43:41,000 --> 00:43:43,000
And another reminder that this is a compiled language

565
00:43:43,000 --> 00:43:45,000
running on native code

566
00:43:45,000 --> 00:43:47,000
and that you really have to care about

567
00:43:47,000 --> 00:43:49,000
what form you're on,

568
00:43:49,000 --> 00:43:51,000
and you have to know what you're doing.

569
00:43:51,000 --> 00:43:53,000
Again, I'm going to draw the parallel to Rust.

570
00:43:53,000 --> 00:43:55,000
You can do great concurrency in Rust,

571
00:43:55,000 --> 00:43:57,000
but you have to really know what you're doing.

572
00:43:59,000 --> 00:44:01,000
I also think fibers are probably,

573
00:44:01,000 --> 00:44:03,000
other than the native performance,

574
00:44:03,000 --> 00:44:05,000
one of the primary reasons one would use Crystal

575
00:44:05,000 --> 00:44:09,000
if you have a highly concurrent workload,

576
00:44:09,000 --> 00:44:11,000
which lots of things are these days, right,

577
00:44:11,000 --> 00:44:13,000
in our multi-threaded, multi-GPU...

578
00:44:13,000 --> 00:44:15,000
I'm sorry, not multi...

579
00:44:15,000 --> 00:44:17,000
really multi-CPU world, yeah.

580
00:44:17,000 --> 00:44:19,000
Macros.

581
00:44:19,000 --> 00:44:21,000
So macros are evil and wrong,

582
00:44:21,000 --> 00:44:23,000
just like monkey patching and DSLs on Ruby.

583
00:44:23,000 --> 00:44:25,000
Don't do it.

584
00:44:25,000 --> 00:44:27,000
I was intrigued. You don't see

585
00:44:27,000 --> 00:44:29,000
this kind of style of macro

586
00:44:29,000 --> 00:44:31,000
in all statically typed languages?

587
00:44:31,000 --> 00:44:33,000
I mean, it reminds me a little bit

588
00:44:33,000 --> 00:44:35,000
of the GLISP style macros almost.

589
00:44:35,000 --> 00:44:37,000
Did you write one?

590
00:44:37,000 --> 00:44:39,000
Did you play with that at all?

591
00:44:39,000 --> 00:44:41,000
I did. So there was an example

592
00:44:41,000 --> 00:44:43,000
of someone who was very annoyed.

593
00:44:43,000 --> 00:44:45,000
I didn't post in the doc

594
00:44:45,000 --> 00:44:49,000
because I felt the tone was a little too snarky,

595
00:44:49,000 --> 00:44:51,000
which, if you've listened to the show,

596
00:44:51,000 --> 00:44:53,000
tells you a lot.

597
00:44:53,000 --> 00:44:55,000
Yeah, so someone was really mad

598
00:44:55,000 --> 00:44:57,000
and wrote a macro to add four loops back.

599
00:44:57,000 --> 00:44:59,000
Of course.

600
00:44:59,000 --> 00:45:01,000
It's... it's bad.

601
00:45:01,000 --> 00:45:03,000
We call this monkey patching in Ruby, right?

602
00:45:03,000 --> 00:45:05,000
I think there's a proper name,

603
00:45:05,000 --> 00:45:07,000
but that's kind of the mean slang name.

604
00:45:07,000 --> 00:45:09,000
No, I think it is really called

605
00:45:09,000 --> 00:45:11,000
monkey patching in the docs now.

606
00:45:11,000 --> 00:45:13,000
I'll put that up and comment on Reddit.

607
00:45:13,000 --> 00:45:15,000
Basically, you can add functionality

608
00:45:15,000 --> 00:45:17,000
to the language.

609
00:45:17,000 --> 00:45:19,000
Great for DSLs, right?

610
00:45:19,000 --> 00:45:21,000
That's what everybody says.

611
00:45:21,000 --> 00:45:23,000
What you usually see is not DSLs,

612
00:45:23,000 --> 00:45:25,000
but people adding crap that's bad.

613
00:45:25,000 --> 00:45:27,000
I have done it.

614
00:45:27,000 --> 00:45:29,000
I don't think you should do it.

615
00:45:29,000 --> 00:45:31,000
I understand why Crystal has it as a...

616
00:45:31,000 --> 00:45:33,000
By the way, this language is not even 1.0 yet.

617
00:45:33,000 --> 00:45:35,000
So if you're thinking of, like,

618
00:45:35,000 --> 00:45:37,000
popping this out in prod,

619
00:45:37,000 --> 00:45:39,000
I saw there's some companies who are using it.

620
00:45:39,000 --> 00:45:41,000
I don't think it'll be 1.0

621
00:45:41,000 --> 00:45:43,000
unless it's a really special case role.

622
00:45:43,000 --> 00:45:45,000
So for me, I would not use this in production right now.

623
00:45:45,000 --> 00:45:47,000
Totally reasonable.

624
00:45:47,000 --> 00:45:49,000
But I definitely get

625
00:45:49,000 --> 00:45:51,000
why such a young language

626
00:45:51,000 --> 00:45:53,000
would need something like macros

627
00:45:53,000 --> 00:45:55,000
because I'm sure there are plenty of the shops

628
00:45:55,000 --> 00:45:57,000
and individual developers using this

629
00:45:57,000 --> 00:45:59,000
that simply wouldn't use it

630
00:45:59,000 --> 00:46:01,000
if they couldn't add on their own functionality.

631
00:46:01,000 --> 00:46:03,000
Right. That's the thing, right?

632
00:46:03,000 --> 00:46:05,000
Like, macros enable you to sort of expand the language.

633
00:46:05,000 --> 00:46:07,000
You're right if you have, I think,

634
00:46:07,000 --> 00:46:09,000
some particular problems in Ruby with monkey patching

635
00:46:09,000 --> 00:46:11,000
is that it is easily used

636
00:46:11,000 --> 00:46:13,000
for very widespread things, right?

637
00:46:13,000 --> 00:46:15,000
You can just end up adding these methods

638
00:46:15,000 --> 00:46:17,000
that show up on objects everywhere

639
00:46:17,000 --> 00:46:19,000
practically.

640
00:46:19,000 --> 00:46:21,000
It seems like macros

641
00:46:21,000 --> 00:46:23,000
are best used, at least in my experience,

642
00:46:23,000 --> 00:46:25,000
for very limited cases. Yeah, stuff where you...

643
00:46:25,000 --> 00:46:27,000
You know, it's obvious that you're doing some sort of

644
00:46:27,000 --> 00:46:29,000
complicated transformation here.

645
00:46:29,000 --> 00:46:31,000
It is neat that basically in Crystal,

646
00:46:31,000 --> 00:46:33,000
macros are just methods that receive

647
00:46:33,000 --> 00:46:35,000
AST nodes at compile time

648
00:46:35,000 --> 00:46:37,000
and then produce code that gets pasted right back

649
00:46:37,000 --> 00:46:39,000
so it's much like macros

650
00:46:39,000 --> 00:46:41,000
you might be familiar with from other languages.

651
00:46:41,000 --> 00:46:43,000
That's cool. You know, macros are

652
00:46:43,000 --> 00:46:45,000
kind of like AppSynth.

653
00:46:45,000 --> 00:46:47,000
You can...

654
00:46:47,000 --> 00:46:49,000
You can have a little bit, but you really got...

655
00:46:49,000 --> 00:46:51,000
That's like a once a year thing. Yeah.

656
00:46:51,000 --> 00:46:53,000
Yeah, once in a while.

657
00:46:53,000 --> 00:46:55,000
So one thing that looks a little bit similar

658
00:46:55,000 --> 00:46:57,000
to Ruby is in Crystal,

659
00:46:57,000 --> 00:46:59,000
everything is in objects, right?

660
00:46:59,000 --> 00:47:01,000
And basically they say the things you can know

661
00:47:01,000 --> 00:47:03,000
about it is that it has a type

662
00:47:03,000 --> 00:47:05,000
and it can respond to some methods

663
00:47:05,000 --> 00:47:07,000
and that's it.

664
00:47:07,000 --> 00:47:09,000
Yeah, I personally like that, but I like Ruby.

665
00:47:09,000 --> 00:47:11,000
If you don't like that, then you won't like it here either.

666
00:47:13,000 --> 00:47:15,000
Personally, I think that makes reasoning about

667
00:47:15,000 --> 00:47:17,000
your code very, very...

668
00:47:17,000 --> 00:47:19,000
I won't say simple, but

669
00:47:19,000 --> 00:47:21,000
it kind of gives you a...

670
00:47:23,000 --> 00:47:25,000
Just like a set of rules that you can follow

671
00:47:25,000 --> 00:47:27,000
and reason through. Yeah.

672
00:47:27,000 --> 00:47:29,000
Constrains the interface and API that you're

673
00:47:29,000 --> 00:47:31,000
using to talk between all these things.

674
00:47:31,000 --> 00:47:33,000
I definitely understand why there's a whole set of people

675
00:47:33,000 --> 00:47:35,000
who wouldn't like that kind of thing.

676
00:47:35,000 --> 00:47:37,000
I'm not sure how much you would or wouldn't like this.

677
00:47:37,000 --> 00:47:39,000
I'm very curious.

678
00:47:39,000 --> 00:47:41,000
For me, this is...

679
00:47:41,000 --> 00:47:43,000
When this hits 1.0, I would

680
00:47:43,000 --> 00:47:45,000
probably use this where I might use Rust.

681
00:47:45,000 --> 00:47:47,000
Right? As a more

682
00:47:47,000 --> 00:47:49,000
performant augmentation to a

683
00:47:49,000 --> 00:47:51,000
large scale application written in Ruby.

684
00:47:51,000 --> 00:47:53,000
I see.

685
00:47:53,000 --> 00:47:55,000
Having said that, I'm really enjoying

686
00:47:55,000 --> 00:47:57,000
using Rust for that. I hate

687
00:47:57,000 --> 00:47:59,000
to say it, and I could

688
00:47:59,000 --> 00:48:01,000
change my mind later because, yay.

689
00:48:01,000 --> 00:48:03,000
I don't see me

690
00:48:03,000 --> 00:48:05,000
picking this up. And obviously,

691
00:48:05,000 --> 00:48:07,000
my 1.0 rule, I won't pick it up

692
00:48:07,000 --> 00:48:09,000
now. Right. Let's say it was ready to go.

693
00:48:09,000 --> 00:48:11,000
You were comfortable with its stability.

694
00:48:11,000 --> 00:48:13,000
But I wouldn't discourage anybody, especially if you're

695
00:48:13,000 --> 00:48:15,000
just hacking for fun or doing

696
00:48:15,000 --> 00:48:17,000
a toy program for yourself.

697
00:48:19,000 --> 00:48:21,000
Honestly, the only thing I really

698
00:48:21,000 --> 00:48:23,000
don't like is macros, but lots of languages

699
00:48:23,000 --> 00:48:25,000
that I do like have it, i.e. Ruby,

700
00:48:25,000 --> 00:48:27,000
and I think I just don't use

701
00:48:27,000 --> 00:48:29,000
it because I don't like it.

702
00:48:29,000 --> 00:48:31,000
One thing I noticed that was interesting just looking at it,

703
00:48:31,000 --> 00:48:33,000
if you go take a peek at their GitHub,

704
00:48:33,000 --> 00:48:35,000
I think as a consequence of having macros,

705
00:48:35,000 --> 00:48:37,000
most of Crystal is implemented

706
00:48:37,000 --> 00:48:39,000
in Crystal at this point.

707
00:48:39,000 --> 00:48:41,000
And you don't need macros for that sort of thing,

708
00:48:41,000 --> 00:48:43,000
but it can make it easy because you can

709
00:48:43,000 --> 00:48:45,000
start with a few special primitives and sort of

710
00:48:45,000 --> 00:48:47,000
build the language upon itself from there.

711
00:48:47,000 --> 00:48:49,000
I don't want to hit the macro thing too hard

712
00:48:49,000 --> 00:48:51,000
because in reality, if I for some reason

713
00:48:51,000 --> 00:48:53,000
decided to use this, I am sure I would eventually

714
00:48:53,000 --> 00:48:55,000
have to write some macros for myself too.

715
00:48:55,000 --> 00:48:57,000
I'd be curious how you might compare it to Go

716
00:48:57,000 --> 00:48:59,000
as well, because it seems like

717
00:48:59,000 --> 00:49:01,000
right now the advantages or at least things you might be

718
00:49:01,000 --> 00:49:03,000
interested in as compared to Rust would be

719
00:49:03,000 --> 00:49:05,000
the really strong concurrency model.

720
00:49:05,000 --> 00:49:07,000
I know Rust has been working on async

721
00:49:07,000 --> 00:49:09,000
08 sort of style stuff, and there's various

722
00:49:09,000 --> 00:49:11,000
different proposals out there, but Crystal

723
00:49:11,000 --> 00:49:13,000
is up front, like, look, we've got

724
00:49:13,000 --> 00:49:15,000
fibers, we've got green threads, have

725
00:49:15,000 --> 00:49:17,000
at it, and

726
00:49:17,000 --> 00:49:19,000
it might not be suitable to target exactly

727
00:49:19,000 --> 00:49:21,000
as all the low-level things, or at least right now,

728
00:49:21,000 --> 00:49:23,000
I'm thinking stuff without a runtime or OS level

729
00:49:23,000 --> 00:49:25,000
stuff that Rust can also sort of

730
00:49:25,000 --> 00:49:27,000
play at, but if you want

731
00:49:27,000 --> 00:49:29,000
a tight little, you know, static

732
00:49:29,000 --> 00:49:31,000
executable, reasonably fast,

733
00:49:31,000 --> 00:49:33,000
efficient, pretty low-level stuff,

734
00:49:33,000 --> 00:49:35,000
it seems like this would be competing with

735
00:49:35,000 --> 00:49:37,000
Go as well in that regard.

736
00:49:37,000 --> 00:49:39,000
Yeah, I could see that.

737
00:49:39,000 --> 00:49:41,000
Is the argument then that you just get a syntax that maybe

738
00:49:41,000 --> 00:49:43,000
you like more?

739
00:49:43,000 --> 00:49:45,000
Well, you know, I would be maybe a little more

740
00:49:45,000 --> 00:49:47,000
optimistic than that.

741
00:49:47,000 --> 00:49:49,000
I mean, I think, you know, not many people were doing

742
00:49:49,000 --> 00:49:51,000
a whole lot of Ruby until Rails came along.

743
00:49:51,000 --> 00:49:53,000
Having said that, I don't think

744
00:49:53,000 --> 00:49:55,000
this is a great thing for the type of application

745
00:49:55,000 --> 00:49:57,000
you would write in Rails.

746
00:49:57,000 --> 00:49:59,000
No, no, probably not, right? It's a little lower level than that.

747
00:49:59,000 --> 00:50:01,000
But I could see something

748
00:50:01,000 --> 00:50:03,000
coming along where,

749
00:50:03,000 --> 00:50:05,000
you know, there's not a lot of

750
00:50:05,000 --> 00:50:07,000
people use, well, I won't say not a lot, but

751
00:50:07,000 --> 00:50:09,000
Erlang is not one of the biggest languages out there,

752
00:50:09,000 --> 00:50:11,000
but there are domains where it makes a ton of

753
00:50:11,000 --> 00:50:13,000
sense.

754
00:50:13,000 --> 00:50:15,000
Yeah, that's the other thing this would seem to be sort of targeting, right?

755
00:50:15,000 --> 00:50:17,000
I mean, you tried Elixir to kick off this whole language

756
00:50:17,000 --> 00:50:19,000
challenge, and they have similar

757
00:50:19,000 --> 00:50:21,000
concurrency models here.

758
00:50:21,000 --> 00:50:23,000
And they both got that Ruby, yeah, that Ruby DNA almost.

759
00:50:23,000 --> 00:50:25,000
Now, I know there's been some interest

760
00:50:25,000 --> 00:50:27,000
over in the Erlang world

761
00:50:27,000 --> 00:50:29,000
because you can write, you know, basically extensions

762
00:50:29,000 --> 00:50:31,000
out from the Erlang VM, so you can

763
00:50:31,000 --> 00:50:33,000
implement sort of stuff that needs to be faster, lower

764
00:50:33,000 --> 00:50:35,000
level things. But there's always the

765
00:50:35,000 --> 00:50:37,000
risk, at least when they're implemented classically in C,

766
00:50:37,000 --> 00:50:39,000
of that ruining a lot of your

767
00:50:39,000 --> 00:50:41,000
safety, right? When you build it on their nice Beam VM,

768
00:50:41,000 --> 00:50:43,000
you get all this nice managed safety for you.

769
00:50:43,000 --> 00:50:45,000
But if your C extension then like crashes the

770
00:50:45,000 --> 00:50:47,000
whole thing, well, that won't work. So there's been

771
00:50:47,000 --> 00:50:49,000
some interest in using Rust. I wonder

772
00:50:49,000 --> 00:50:51,000
how Crystal might work in the same regard.

773
00:50:51,000 --> 00:50:53,000
As always, Rust is the right answer.

774
00:50:53,000 --> 00:50:55,000
Oh, Mike.

775
00:50:55,000 --> 00:50:57,000
So, Wes, we forgot to mention

776
00:50:57,000 --> 00:50:59,000
on the last recording, you are doing a challenge.

777
00:50:59,000 --> 00:51:01,000
Yeah. Now,

778
00:51:01,000 --> 00:51:03,000
what have you picked for me? Because you've given

779
00:51:03,000 --> 00:51:05,000
a great report here on Crystal. I might just have to

780
00:51:05,000 --> 00:51:07,000
play with it myself as an aside because

781
00:51:07,000 --> 00:51:09,000
I'm curious. It's got me interested.

782
00:51:09,000 --> 00:51:11,000
But I need a language.

783
00:51:11,000 --> 00:51:13,000
I need something to be working on.

784
00:51:13,000 --> 00:51:15,000
So, you know what? I had

785
00:51:15,000 --> 00:51:17,000
a language in mind, but I think you've actually

786
00:51:17,000 --> 00:51:19,000
changed my mind. Oh,

787
00:51:19,000 --> 00:51:21,000
what? I don't think we've done Go yet,

788
00:51:21,000 --> 00:51:23,000
have we? Didn't you do Go?

789
00:51:23,000 --> 00:51:25,000
Oh, I did do Go, didn't I?

790
00:51:25,000 --> 00:51:27,000
But I haven't. Now, we did

791
00:51:27,000 --> 00:51:29,000
get some, we did get some, there was a

792
00:51:29,000 --> 00:51:31,000
feedback item I saw somewhere. Maybe it was on,

793
00:51:31,000 --> 00:51:33,000
maybe it was on Reddit. Someone suggested

794
00:51:33,000 --> 00:51:35,000
I try Julia. That might be interesting.

795
00:51:35,000 --> 00:51:37,000
That's a language I've been looking at,

796
00:51:37,000 --> 00:51:39,000
but have not actually played with. I mean, I think you'll

797
00:51:39,000 --> 00:51:41,000
hate it. So that's part of the...

798
00:51:41,000 --> 00:51:43,000
Perfect. All right. Do you want to do Julia?

799
00:51:43,000 --> 00:51:45,000
Yeah, it sounds good. I mean,

800
00:51:45,000 --> 00:51:47,000
we must be close to seven by now.

801
00:51:47,000 --> 00:51:49,000
Yeah, probably. But this is fun. So, you know.

802
00:51:49,000 --> 00:51:51,000
All right. So, and what for me

803
00:51:51,000 --> 00:51:53,000
next? So I have two weeks to do it.

804
00:51:53,000 --> 00:51:55,000
Hmm. Hmm.

805
00:51:55,000 --> 00:51:57,000
That's a good question, Mike.

806
00:51:57,000 --> 00:51:59,000
I don't, I don't know. I might

807
00:51:59,000 --> 00:52:01,000
have to think about that a little bit.

808
00:52:01,000 --> 00:52:03,000
Maybe we'll send out a tweet

809
00:52:03,000 --> 00:52:05,000
about that later this week once we've decided.

810
00:52:05,000 --> 00:52:07,000
Well, Mike, thank you

811
00:52:07,000 --> 00:52:09,000
for a very interesting language

812
00:52:09,000 --> 00:52:11,000
report. And, you know, it's great

813
00:52:11,000 --> 00:52:13,000
to be doing the show live with you again. We'll be here doing

814
00:52:13,000 --> 00:52:15,000
the show live like we do almost

815
00:52:15,000 --> 00:52:17,000
every week. Next week

816
00:52:17,000 --> 00:52:19,000
you can join too. Head on over to jupiterbroadcasting.com

817
00:52:19,000 --> 00:52:21,000
slash calendar.

818
00:52:21,000 --> 00:52:23,000
That will list the

819
00:52:23,000 --> 00:52:25,000
live times of this show and all the

820
00:52:25,000 --> 00:52:27,000
other shows that we do live.

821
00:52:27,000 --> 00:52:29,000
If you want more Coder Radio, well, head

822
00:52:29,000 --> 00:52:31,000
on over to coder.show. That has

823
00:52:31,000 --> 00:52:33,000
the whole back catalog. And if

824
00:52:33,000 --> 00:52:35,000
that's not enough, jupiterbroadcasting.com

825
00:52:35,000 --> 00:52:37,000
has all the other fine

826
00:52:37,000 --> 00:52:39,000
shows, including, you know,

827
00:52:39,000 --> 00:52:41,000
we've got some new stuff going on over in our

828
00:52:41,000 --> 00:52:43,000
Extras feed. If you haven't heard, if you

829
00:52:43,000 --> 00:52:45,000
haven't checked it out, but maybe you've already caught

830
00:52:45,000 --> 00:52:47,000
up on all the JB content for the week and need

831
00:52:47,000 --> 00:52:49,000
a little bit more, extras.show.

832
00:52:49,000 --> 00:52:51,000
Go check out

833
00:52:51,000 --> 00:52:53,000
the latest Brunch with Brent.

834
00:52:53,000 --> 00:52:55,000
I think you'll find it's very enjoyable.

835
00:52:55,000 --> 00:52:57,000
Mike, if they want

836
00:52:57,000 --> 00:52:59,000
more of you, well, you're over

837
00:52:59,000 --> 00:53:01,000
on Twitter. What's your handle?

838
00:53:01,000 --> 00:53:03,000
That's at Domenico on Twitter.

839
00:53:03,000 --> 00:53:05,000
I'm there too, at

840
00:53:05,000 --> 00:53:07,000
Westpane. And you can find the whole

841
00:53:07,000 --> 00:53:09,000
network sending out notifications about all the

842
00:53:09,000 --> 00:53:11,000
latest and greatest shows at

843
00:53:11,000 --> 00:53:13,000
Jupiter Signal. Thank

844
00:53:13,000 --> 00:53:15,000
you all so much for joining us.

845
00:53:15,000 --> 00:53:17,000
We'll see you right back here

846
00:53:17,000 --> 00:53:45,000
next week.

847
00:53:47,000 --> 00:53:49,000
you


WEBVTT

00:00.000 --> 00:07.000
This is Coder Radio, episode 372, for August 26th, 2019.

00:31.000 --> 00:43.000
Hello, and welcome to Coder Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business, software development, and related technologies.

00:43.000 --> 00:49.000
My name is Wes, and I'm joined by everyone's favorite Floridian, Mr. Michael Dominic. Welcome back to the show, Mike.

00:49.000 --> 00:52.000
Welcome back, Mr. Payne.

00:52.000 --> 01:04.000
Boy, a lot has happened. You know, the last two episodes, they were pre-recorded, but this one is live once again. And not only is it nice to hear you, but I'm excited to hear what you thought about all the things going on in the world.

01:04.000 --> 01:11.000
Yeah, so I, you know, of course, a week where we pre-record, everything drops. Why not, right?

01:11.000 --> 01:15.000
Sounds like you were having some particular problems with G Suite. Am I right?

01:15.000 --> 01:24.000
Pro tip, guys, using proprietary solutions that are hosted somewhere else, unless they're for me, then you should definitely buy them.

01:24.000 --> 01:31.000
Well, that's a problem if, let's say, your entire business runs on G Suite and Slack, but you only talk to customers on G Suite.

01:31.000 --> 01:45.000
And you have to go back to, like, the dark ages of having to explain to people that will actually, can you just, like, I don't know, Dropbox this to me, and then you have to, like, open a Dropbox account because you really need files for a demo.

01:45.000 --> 01:51.000
So for those who aren't G Suite addicts, last week, G Suite had an outage for about half a day.

01:51.000 --> 01:57.000
It was everything from Gmail to Drive. It was the whole kit and caboodle, anything that authed with Google.

01:57.000 --> 02:04.000
I don't know if it extended to the non-commercial G Suite accounts. I probably did. Why wouldn't it?

02:04.000 --> 02:15.000
But it was, I'd like to complain, but honestly, there was no Google chat pings. There was no emails for, like, four hours. It was glorious.

02:15.000 --> 02:18.000
Oh, that sounds nice. Sometimes you just need a little break.

02:18.000 --> 02:28.000
And I suppose that's the flip side of the benefit of they manage everything for you, and while it's frustrating when you can't control it, it also means it's not on you to fix it. You just get a sit and wait.

02:28.000 --> 02:35.000
Yeah, I mean, the reality of the situation is it was fine, right? But then that evening, of course, was chaos responding to emails and going through documents.

02:35.000 --> 02:49.000
And I'm going to just say that I probably have an over-reliance on G Suite right now. But having said that, I've been using it for over 10 years, and this is maybe the third or fourth outage I've ever experienced.

02:49.000 --> 02:52.000
Not so bad considering. I mean, not ideal, but...

02:52.000 --> 02:54.000
All things considered, right?

02:54.000 --> 02:55.000
Yeah, that makes sense.

02:55.000 --> 02:57.000
So how about you? Were you partying it hard?

02:57.000 --> 03:11.000
There's been all kinds of stuff. It was nice to have a little bit of some time away to reflect on all the fun we've had. I've particularly been enjoying the coding challenges, and it sounds like a lot of you guys out there have too, which makes me really happy.

03:11.000 --> 03:20.000
Because, you know, it takes a lot of time and effort to sort of actually sit down and review and try out all these new languages, but there's also a lot of insights and a lot of features.

03:20.000 --> 03:30.000
It's made me think about what I want and need from a language differently. So we'll get into that a little bit more in the show because you've got a check in for us. I'm particularly excited about Mike.

03:30.000 --> 03:38.000
Oh, okay. Well, I can't wait to hear why you're excited, but I sure do. And it was a... Let me just say my explanations will be crystal clear.

03:38.000 --> 03:55.000
So before we do that, let's set up some feedback. First in our feedback basket today is a letter from Reid. Dear Wes and Mike, I'm a fourth year math PhD student and have always had a hobbyist's interest in coding and software development.

03:55.000 --> 04:11.000
While I plan to stay in academia, I realize it's always good to have a backup plan. Do either of you have any insights as to how the software development community would feel about someone with a math PhD but no industry coding experience as a job applicant?

04:11.000 --> 04:17.000
Any advice would be appreciated. Love the show. You guys make a great duo. Well, thanks much, Reid.

04:17.000 --> 04:29.000
I'm curious, you know, maybe you might not have some specific expertise about academia, Mike, but I'm sure you run across many of green coders fresh out of school and I imagine a lot of those same lessons apply.

04:29.000 --> 04:53.000
Yeah, I mean, you know, it's funny in the pre-show I couldn't remember, but I have had previous experience of a place who specifically wanted, I think, master's degrees and now I hate to be specific, but I'm almost sure it was like statistic. They were doing some fintech to use the buzzword things and they would basically be willing to teach you Python.

04:53.000 --> 05:12.000
But that is definitely the rare case for the kind of stuff that I've been doing. It's a lot more, like you said, folks coming in from undergrad or even boot camps or associate programs that might know, particularly the folks coming from CS undergrads, know or remember a lot more of their Knuth and their math.

05:12.000 --> 05:15.000
Right, random algorithmic quiz questions.

05:15.000 --> 05:30.000
Right, although if you are like me and don't have that background, great books by Rob Connery, I think it's called Computer Science for Imposters, which basically will teach you all the basic algorithms you need to know. I'll throw it in the show notes.

05:30.000 --> 05:32.000
Oh, that's a great title.

05:32.000 --> 05:49.000
I think I misquoted the title. It was something imposters. But these young people come out, they're great, they know how do I get through a linked list, which I keep forgetting because the one true language objective seed did not have them. Now they're just Ruby.

05:49.000 --> 05:52.000
I think that speaks a lot for both of them.

05:52.000 --> 06:03.000
Oh, don't even lay the closure on me. But like, you know, undergrads, how can we say this nicely, Wes? We'll blow up your Git history so fast, you'll cry?

06:03.000 --> 06:31.000
I mean, it just there's a lot of there's a lot of practical knowledge, working in a team dealing with maybe larger frameworks than you're accustomed to, especially if you're just writing, you know, one off scripts to accomplish a single task for like a personal use. There's also not always a huge, I think that's changing, but not always a huge emphasis on stuff like testing and reliability in school. What else? What else do you see newbies kind of struggle with or just not have a background in if they haven't worked in industry?

06:31.000 --> 06:44.000
I mean, I could tell you, like the two most common things I've seen are really not getting how important aggressive use of source control is. And by aggressive, I mean frequent, frequent commits.

06:44.000 --> 06:45.000
Right.

06:45.000 --> 07:13.000
And the other thing is maybe a little bit of a cavalier attitude towards legacy. So there was a perfect case a couple years ago that I can think of right off the top of my head. We had this huge iPad app. And because of when it was started, and when I say huge, this is enterprise level. This app is effectively a custom tool for this company. And it's just like, they run their business, their shop, floorman, all have iPads, right? And this app was in production already for like three or four years.

07:13.000 --> 07:29.000
So it was a big old bucket of Objective-C with a ton of CocoaPods. And you know, Swift had come out, the world had changed. CocoaPods kind of, I mean, people still use CocoaPods. But I think at the time, Carthage was becoming more popular. I don't know how familiar you are with Carthage.

07:29.000 --> 07:30.000
Oh, not really.

07:30.000 --> 07:54.000
It's basically just another package management tool. There are reasons that it maybe is a bit more modern than CocoaPods. And actually now Swift does its own things too. But back then, it was really Carthage and CocoaPods. And this, you know, very well meaning new developer decided he was going to rip out our CocoaPods dependencies and try to replace them at Carthage.

07:54.000 --> 08:03.000
Well, we had pinned some of our dependencies to specific versions, because of course, part of this app was not using automatic reference counting, because it was so old.

08:03.000 --> 08:05.000
You did say legacy at the start of this.

08:05.000 --> 08:25.000
We're talking like circa, when did Swift come out? 2014? So this must have been like 2015. And the app started in like, 11 or 12. So there was just a lot of stuff that had gone on in the Cocoa Touch ecosystem since this project was kicked off.

08:25.000 --> 08:43.000
So that was a build breaking experience. Luckily, through the powers of Git, we were able to undo everything. But he had a hard time and it was kind of a conversation about, yes, you're probably right that there are memory leaks in the manual memory code. But they're small enough, they don't matter.

08:43.000 --> 09:03.000
And two, the investment required to actually rewrite all of this legacy code and get it to the tested production standard accepted by the end users, you know, level that we needed at just isn't going to be worth it until they release, you know, well, almost like what they're doing now with Swift UI, right?

09:03.000 --> 09:07.000
Until there's a major platform paradigm shift, where we don't have a choice.

09:07.000 --> 09:10.000
Once you already have to rip everything else apart. Yeah.

09:10.000 --> 09:13.000
Right. But what about you? What's your what's your war story?

09:13.000 --> 09:20.000
Well, I was more I was more thinking of positive things to go along with your your war stories here.

09:20.000 --> 09:21.000
Of course.

09:21.000 --> 09:40.000
And I think there's many developers who kind of shy away from some of the more math oriented things, you know, you go through you slog through maybe you're like couple terms where you do like you do a bunch of graph stuff and prove some theorems. And then you know, then you're back to like, implementing stuff or testing stuff or writing some Java. And that's okay.

09:40.000 --> 10:00.000
I think having familiarity with math, especially if you're going to work on, you know, more complicated algorithmic sort of problems that can be really handy. So read, you might want to sort of just stay current in in that sort of areas, especially maybe some machine learning areas where more math and computer science start to mix, you could be especially effective there.

10:00.000 --> 10:25.000
Also, just start looking at projects and in languages or projects that you're interested at, because one of the one of the skills that you may not get in academia, but that you'll definitely need an industry is being able to just struggle through a bunch of someone else's bad code and understand how to work with it and make whatever changes you might have to because you as Mike's talking about you often aren't in the best ideal sort of scenarios, but you're still going to have to make it work.

10:25.000 --> 10:37.000
There's always going to be legacy. And if you can figure out good tools, get some practice in learning how to modify that, knowing that most of the stuff you're going to work on, it'll likely be supported for years. That'll be useful.

10:37.000 --> 10:50.000
Yeah, I like that. And I have to say I was not a huge mathy person. And in the last couple years, I've started having to go back and be like, okay, maybe I didn't need to burn through the canoe quite as much reckless abandon.

10:50.000 --> 11:15.000
Yes. You know, you might also just be interested in some more of the functional languages, maybe some, some stuff like Haskell, or even more esoteric languages than that. Also, a lot of a lot of math in school can often be problem solving. And those skills I find translate really well. So focus on that to be able to break down a problem, model it and work your way through each of the steps. That's a useful skill everywhere.

11:15.000 --> 11:19.000
I admire your discipline, sir.

11:19.000 --> 11:30.000
Okay, well, thank you for the email read. Let's move right along just a little bit of feedback we got about one of our last episodes over on our subreddit coderadio.reddit.com.

11:30.000 --> 11:54.000
User Ninja Aaron has a little FYI, and I totally should have mentioned this FYI about wanting interfaces in Python, that you basically just want abstract base classes. And I totally should have mentioned that user jam 163 notes, I agree with what's his point about preferring interfaces in abstractions. It seems to me that abstractions targeting interfaces are more reliable than abstractions deriving functionality from base objects.

11:54.000 --> 12:15.000
So I think there's some there's some interesting intersections there and probably kind of why I didn't think to mention abstract base classes. It's just not the preferred way I have of modeling. And I kind of like the polymorphism and other stuff, all the cart that you can get when you break those things apart. But Python definitely has that functionality. Thank you guys for pointing it out. That's very useful.

12:15.000 --> 12:34.000
Also, as a small little side here, I've been playing more and more with like some of the later Python three releases. And it's really, it's really getting to be a nice language. Again, I mean, I've always liked Python, but some of the modernness and some of the newer API styles and libraries that have come around, it's, it's, it's a pleasant place to be.

12:34.000 --> 12:38.000
I don't know. Python is like a mean Ruby, as far as I'm concerned, but we could just keep moving.

12:38.000 --> 12:47.000
Yes, well, that's a natural segue to our final little bit of feedback today from Dex asking about breaking and changes.

12:47.000 --> 12:55.000
I developed a niche Python package that has some user following in the network security realm, but I'm at a crossroads.

12:55.000 --> 13:09.000
A change I want to make will subtly break scripts that work in previous or in current versions. The end result of my pending change is good for the project, but I fear it'll ruin the workflow of all the existing users.

13:09.000 --> 13:15.000
Other than my GitHub page, I don't know how to query or inform the users of this pending change.

13:15.000 --> 13:17.000
What do I do?

13:17.000 --> 13:25.000
Well, what do you think, Mike? You know, this is an interesting question. It comes up a lot and just step one, asking this question, thinking about it. Well, that's good.

13:25.000 --> 13:38.000
Yeah, this is a tough one. I mean, I think if you're thinking about it and not just either protecting a legacy forever or making breaking changes willy-nilly, you're already 10 steps ahead of most people.

13:38.000 --> 13:47.000
What I have done in the dark old days when I used to maintain an Objective-C networking library, yes, it's all Objective-C today, kids.

13:47.000 --> 13:49.000
Oh, interesting story.

13:49.000 --> 13:57.000
I did briefly, and briefly is defined as I think three months, support the non-ARC version of it on a different branch.

13:57.000 --> 14:02.000
This is before people were using CocoaPods and fun stuff like that. This is way back in the bad old days.

14:02.000 --> 14:10.000
So people would just literally like the way you got it. It was 10 classes. You just downloaded the, you know, git sub modules. I hope most of you know about that, right?

14:10.000 --> 14:12.000
Oh, yes.

14:12.000 --> 14:25.000
But eventually, I was pretty clear that this is a 90-day extension. I'm not going to delete it or break it. But after 90 days, you know, I'm not going to support it.

14:25.000 --> 14:37.000
That's one way to do it. I can't say that I didn't get any mean emails. I don't know. But remember, you're doing this for free, which is, I think, something we're going to cover in a future topic here.

14:37.000 --> 14:50.000
And, you know, it's really not a service to your users or, I'm sure, yourself to pin your code, your library, whatever it is, to an older version indefinitely, right?

14:50.000 --> 15:03.000
This is one of those hot topics that I'm very hesitant on because I'm pretty aggressive. I'm liking to push things forward when I'm maintaining them. But Wes, maybe you're more conservative?

15:03.000 --> 15:12.000
Well, you know, it always sucks when stuff you rely on breaks. So clarity is good. It is an interesting question of how to communicate this.

15:12.000 --> 15:22.000
You know, it's a little easier if you're working in like a business relationship or in a team relationship where you can kind of sort of force everyone to have a meeting. But that model doesn't work so well in open source, necessarily.

15:22.000 --> 15:33.000
If you can avoid breaking, I would say do so. Sometimes you can keep legacy functionality around and just sort of mask it or rebuild it on top of newer features.

15:33.000 --> 15:42.000
Another option might be if you're not already using something, you could consider more rigorous use of something like semantic versioning.

15:42.000 --> 15:55.000
Or another option might be to just make a new project, you know, fork this off. If it really is going to be different, if it's going to break things, make a note in the old one, say that you're deprecating support for this existing version.

15:55.000 --> 16:04.000
You know, maybe a link in the README to the new one and then go happily develop not considering anything else over in the new repository and you'll have total freedom.

16:04.000 --> 16:14.000
Now, it sucks like we're very particular about names and you have to come up with a new name. That's the hardest part. But if it's a new thing, if it's different enough to be breaking, maybe it deserves a new name.

16:14.000 --> 16:17.000
Yeah, that's a powder keg in itself, too.

16:17.000 --> 16:27.000
Yeah, it is. It's a tricky situation. But I would say if you if you can just make a new one, then then do it. Otherwise, make it clear how people can use their existing stuff.

16:27.000 --> 16:36.000
It's probably trickier to that it's a script like you don't have maybe don't have all the tooling that nice package managers do to pin versions and other stuff that you that your users could rely on.

16:36.000 --> 16:39.000
If they're just grabbing the latest code from GitHub that that will break.

16:39.000 --> 16:48.000
I mean, maybe a unpopular anti RMS suggestion here is, you know, there used to be lots of businesses that what they did was like customize open source things for other people.

16:48.000 --> 17:01.000
You could totally if you're getting complaints from someone who has the means or the desire to pay for that, say I will, you know, say I'll do it for a fork for you.

17:01.000 --> 17:08.000
But you'll have to pay for the time that contribution takes. That's not unreasonable, right? People are paid to contribute to open source.

17:08.000 --> 17:17.000
Absolutely. Another option here, too, might be just to start the conversation, make an issue with the pending changes and your proposed implementation changes.

17:17.000 --> 17:22.000
Possibly users out there will have some sort of compromise that'll work for everyone, but you won't know till you try.

17:22.000 --> 17:26.000
Or if someone else could pick it up. Yeah, like Wes was saying, someone else might just pick up the mantle.

17:26.000 --> 17:35.000
Exactly. All right. Well, speaking of interesting changes, Mike, I saw you chatting away about some stuff in rail six.

17:35.000 --> 17:42.000
And it's been a while since I've used rails and I haven't used six at all. So maybe you can break down what's so interesting over there.

17:42.000 --> 17:50.000
Yes. So rail six is, you know, interesting, like buying a new Subaru. It's a little nicer.

17:50.000 --> 17:55.000
You've got maybe one or two features you're not so sure about, but it's basically the same.

17:55.000 --> 17:59.000
You're familiar with the brand and most of the models and it's just the latest version.

17:59.000 --> 18:05.000
I mean, they're pretty keen to tell you about Action Cable Testing and Action Mailbox.

18:05.000 --> 18:09.000
I think most people, particularly in Action Mailbox, I think most people are using like SendGrid.

18:09.000 --> 18:16.000
Action Text is interesting. So you can have like fancy text content, bridging it to rails a little better than you could before.

18:16.000 --> 18:22.000
Oh, yeah. Here, listen to this. Action Text brings rich text content and editing to rails.

18:22.000 --> 18:29.000
So it includes the Trix editor and then it sounds like it's got some like rich text model already made for you in the back end that you can tie it to.

18:29.000 --> 18:34.000
Oh, yeah. And then any embedded images are automatically stored using active storage and associated.

18:34.000 --> 18:38.000
So you want to have fancy text. It's a one stop shop. Interesting.

18:38.000 --> 18:42.000
I mean, there's a few removals. None of them are devastating, although I think the one.

18:42.000 --> 18:47.000
So there used to be a thing where you could do config dot secret token, which is exactly what it sounds like.

18:47.000 --> 18:54.000
You could have manly just, you know, in plain text, put in your secret token.

18:54.000 --> 18:59.000
That is a deprecation that is going to catch a lot of people with their pants down, I think.

18:59.000 --> 19:05.000
But yeah, you should not be doing that in 2019. So I think it's a good idea to remove that.

19:05.000 --> 19:07.000
And to be clear, that's a straight removal, not a deprecation.

19:07.000 --> 19:14.000
In fact, if you've been using Rubocop or any other kind of rails linter, you have been getting yelled at for using that.

19:14.000 --> 19:21.000
Good. My biggest thing is actually that it's including Webpack now in rails.

19:21.000 --> 19:28.000
So Webpack, the JavaScript packaging tool. I'm mixed on this.

19:28.000 --> 19:38.000
The applications I tend to develop are pretty much, you know, build the HTML, JavaScript and all that horrible crap I don't like to deal with on the back end and send it to the front end.

19:38.000 --> 19:48.000
But, you know, rails does have to compete with the, you know, with the hot new kids and more and more, especially for, I would say, consumer facing things.

19:48.000 --> 19:51.000
You want to have a little richer JavaScript experience.

19:51.000 --> 19:56.000
I mean, we talked a bunch of the languages we've done in the coding challenge, you know, have compiled the JavaScript.

19:56.000 --> 19:58.000
God forbid you're using ClojureScript.

19:58.000 --> 20:00.000
Yeah, absolutely. Let's hope you are.

20:00.000 --> 20:01.000
Oh, geez.

20:01.000 --> 20:03.000
Or Fable, right?

20:03.000 --> 20:08.000
You could be using Fable, again, if you're using Fable and rails together, I have to wonder what happened.

20:08.000 --> 20:11.000
But sure, you could.

20:11.000 --> 20:15.000
So they listen to like Mirror Universe, Michael Dominic, I think.

20:15.000 --> 20:19.000
Yes, that's like when I'm on one of my dot net kicks.

20:19.000 --> 20:23.000
I don't want to downplay this release because I think it's actually a pretty important release.

20:23.000 --> 20:26.000
There are changes if you're coming from Rails 5.

20:26.000 --> 20:34.000
So, you know, it's not nothing, but this isn't like Python 2 to Python 3, the world is ending, right?

20:34.000 --> 20:38.000
Or this isn't even like, you know, dot net 4 to dot net core 2 big.

20:38.000 --> 20:40.000
This is more.

20:40.000 --> 20:46.000
OK, we're deprecating some things you shouldn't have been doing anyway, or we're straight up removing them in some cases.

20:46.000 --> 20:50.000
We're adding better integration for work.

20:50.000 --> 20:55.000
It's almost like adding a blessed, quote unquote, railsy way to do rich JavaScript finance,

20:55.000 --> 20:58.000
which I kind of like because now I don't have to think about that.

20:58.000 --> 21:00.000
Yeah, that's what I was going to ask.

21:00.000 --> 21:06.000
I mean, were you using other sort of JavaScript compilers, transpilers, packers, minimizers,

21:06.000 --> 21:09.000
or did you just have to learn Webpack as a result?

21:09.000 --> 21:11.000
Neither.

21:11.000 --> 21:15.000
So a lot of the Rails stuff we're doing are backends processing JSON requests from other frontends,

21:15.000 --> 21:18.000
either mobile apps or desktop applications.

21:18.000 --> 21:20.000
Sure.

21:20.000 --> 21:24.000
Some of them are written in JavaScript, but, you know, like if it's Ionic, you're using whatever comes with Angular, right?

21:24.000 --> 21:26.000
So that's a big difference.

21:26.000 --> 21:28.000
That's actually the best example here.

21:28.000 --> 21:33.000
If you're using something like Bootstrap, instead of installing a Bootstrap gem on the backend,

21:33.000 --> 21:36.000
you could actually Webpack it with Bootstrap and have it all be on the client side.

21:36.000 --> 21:40.000
It just kind of gives you an additional layers of toolkits that you have access to now.

21:40.000 --> 21:45.000
Well, if you're a consumer facing site with heavy traffic, that's definitely going to help you out quite a bit

21:45.000 --> 21:51.000
because Rails is not known for being particularly performant.

21:51.000 --> 21:56.000
And also, you know, that processing is now happening on the browser rather than your server.

21:56.000 --> 21:58.000
Right, yeah.

21:58.000 --> 22:01.000
So overall, are you finding Rails still to be like a productive environment,

22:01.000 --> 22:05.000
a place that you want and trust to build applications on top of?

22:05.000 --> 22:10.000
Yeah, I mean, Rails is kind of my, I need to get this done, and I need it to be solid

22:10.000 --> 22:15.000
because this is the kind of thing that's either going to get audited or, you know, it's my default

22:15.000 --> 22:18.000
unless somebody asks me for something else.

22:18.000 --> 22:21.000
Big or you need performance.

22:21.000 --> 22:25.000
Right, because making Rails fast requires, I know we're going to get email,

22:25.000 --> 22:28.000
but Wes is right that it's not that fast.

22:28.000 --> 22:30.000
Wes was right.

22:30.000 --> 22:33.000
I knew that was getting clicked. I knew it.

22:33.000 --> 22:37.000
Sorry. But I mean, you were asking for it.

22:37.000 --> 22:39.000
I really was, wasn't I?

22:39.000 --> 22:42.000
Oh, I guess the other thing that the Ruby people are going to be mad,

22:42.000 --> 22:45.000
yes, there's better testing support for Action Cable.

22:45.000 --> 22:47.000
What's the implication there?

22:47.000 --> 22:50.000
I kind of think Action Cable is a little overhyped.

22:50.000 --> 22:53.000
I'm not familiar with it. Can you break it down?

22:53.000 --> 23:00.000
Yeah, so Action Cable basically was a, oh, I'm going to pick my words very carefully here.

23:00.000 --> 23:02.000
Please do, please do.

23:02.000 --> 23:09.000
I would say Action Cable was a way to breach some of the HTML5 modern web functionality

23:09.000 --> 23:14.000
that maybe wasn't exactly native to Rails.

23:14.000 --> 23:18.000
One of the side issues with that is testing it is very,

23:18.000 --> 23:20.000
or traditionally has been completely challenging.

23:20.000 --> 23:22.000
And I can break that down a little better for you.

23:22.000 --> 23:25.000
So let's say you're using RSpec for testing, which most people are.

23:25.000 --> 23:26.000
Right, right.

23:26.000 --> 23:30.000
The support for Action Cable was virtually non-existent.

23:30.000 --> 23:33.000
There are hundreds of hipsters with gold MacBooks on YouTube

23:33.000 --> 23:39.000
who would love to tell you how they've managed to get 100% test coverage of their Active Action.

23:39.000 --> 23:42.000
Yeah, they've really got to stop using Active and Action.

23:42.000 --> 23:45.000
Action Cable code.

23:45.000 --> 23:49.000
Action Cable also does, if you're familiar with like ZMQ and PubSub models,

23:49.000 --> 23:51.000
you could do that in Action Cable.

23:51.000 --> 23:54.000
That's actually what I think is the best use of Action Cable.

23:54.000 --> 23:59.000
But other people have done lots of other interesting things, chat rooms, things like that.

23:59.000 --> 24:02.000
I can't say I've never used it. I can't say it's bad.

24:02.000 --> 24:09.000
I can say that these types of things are hard to test because conceptually they're just,

24:09.000 --> 24:17.000
the way most Rails testing has gone is really a byproduct of most people using RSpec.

24:17.000 --> 24:23.000
And RSpec was written in a time when it was request, response, server, client.

24:23.000 --> 24:30.000
So now that you're having subscriber-publisher relationships, your metaphors don't match up.

24:30.000 --> 24:38.000
I don't even know how to say it without getting into the deep of RSpec literally expects there to be a request and a response.

24:38.000 --> 24:42.000
Right. It's just hard that the models that they're designed under don't play well together

24:42.000 --> 24:45.000
and you don't get all the nice leverage that RSpec has in other arenas.

24:45.000 --> 24:48.000
And to the RSpec's team credit, they are fixing that.

24:48.000 --> 24:49.000
It's going forward.

24:49.000 --> 24:52.000
Rails 6 makes this a lot cleaner to test.

24:52.000 --> 24:56.000
I've never felt that this was exactly something you needed to kill yourself over not testing.

24:56.000 --> 24:57.000
I don't know.

24:57.000 --> 25:03.000
I'm less of a TDD jealous zealot than most of the people who use Ruby all the time.

25:03.000 --> 25:08.000
But I guess if it makes you happy and you know what?

25:08.000 --> 25:10.000
I mean, don't get me wrong.

25:10.000 --> 25:13.000
Now that it's easier, I will be testing my action cable code.

25:13.000 --> 25:15.000
I'm not saying I'm not going to do it.

25:15.000 --> 25:21.000
I'm just saying I was never going to be one of these people writing my own little testing shim because action is just hard.

25:21.000 --> 25:24.000
To me, that was not a good use of resources.

25:24.000 --> 25:29.000
But we can move on because we're getting out of fact and way into opinion here.

25:29.000 --> 25:39.000
Sometimes that's fun, but let's move on to something that maybe you're a little more excited about and that's our old friend Rust.

25:39.000 --> 25:49.000
I saw an interesting video come out over from the Open Source Technology Summit about Intel and their relationship with Rust.

25:49.000 --> 25:53.000
I mean, we've spoken a lot about Rust for some of your applications, Michael.

25:53.000 --> 25:54.000
Yes.

25:54.000 --> 25:58.000
And we've talked a bit about running it for all kinds of stuff and where it might be a good fit.

25:58.000 --> 26:06.000
Systems programming is obviously one of its design goals and Intel, well, I mean, they design and run a lot of systems.

26:06.000 --> 26:09.000
We haven't talked too much about exactly what they've been working on.

26:09.000 --> 26:13.000
I enjoyed this talk by their principal engineer, Josh Triplett.

26:13.000 --> 26:17.000
I thought maybe we could go over a few of the interesting points therein.

26:17.000 --> 26:18.000
Make it Rusty.

26:18.000 --> 26:28.000
They're going to start and talk about the evolutions of systems and embedded and lower level programming.

26:28.000 --> 26:33.000
As you know, Mike, it's hairy and sure, we've got C now, but for a long time, you just had to mess with assembly.

26:33.000 --> 26:38.000
Systems programming makes many demands on programming languages.

26:38.000 --> 26:43.000
Systems programming, because of that, needs both capability as well as safety.

26:43.000 --> 26:50.000
To talk about what I mean by that, I want to go into a little historical advancement in systems programming.

26:50.000 --> 26:54.000
This pattern of advancement applies to many different types of systems,

26:54.000 --> 26:59.000
but let's look specifically at BIOS, at firmware, and at bootloaders.

26:59.000 --> 27:06.000
All of these things were originally written very heavily in assembly language long after other software wasn't,

27:06.000 --> 27:12.000
with some extensions, with a small smattering of assembly, but in general, C worked its way down the stack.

27:12.000 --> 27:17.000
Now even the BIOS is written almost entirely in C with a little bit of assembly here and there.

27:17.000 --> 27:28.000
That took a surprisingly long time, but it was really only possible because C actually had some features that were worth upgrading for.

27:28.000 --> 27:35.000
In order to make that move, they had to be confident in two different ways to switch from one programming language to another.

27:35.000 --> 27:38.000
First of all, the language has to be sufficiently compelling,

27:38.000 --> 27:41.000
to have sufficiently compelling features to warrant moving in the first place.

27:41.000 --> 27:50.000
It can't just be a little bit better, it has to be substantially better to warrant the effort and engineering time needed to move.

27:50.000 --> 27:54.000
Now C had a lot of compelling features to offer assembly developers.

27:54.000 --> 27:59.000
It provided some degree of type safety, at least enough to not easily mix integers and pointers.

27:59.000 --> 28:05.000
It made developers more productive with higher level constructs, with more readable code,

28:05.000 --> 28:10.000
but just as important as that, the language also has to provide parity.

28:10.000 --> 28:16.000
Developers had to feel confident that C was no less capable than assembly language.

28:16.000 --> 28:24.000
And that is a huge point, and I think it's been an evolving episode in, does Rust have all of that?

28:24.000 --> 28:31.000
And I think the whole sort of endeavor here and what this talk is about is also just sort of an interesting microcosm that happens all the time, right?

28:31.000 --> 28:36.000
We do move on to other languages, we change the tools that we use,

28:36.000 --> 28:40.000
and it's fun to sort of examine how does that actually happen in practice?

28:40.000 --> 28:46.000
I'm curious if you agree, if you found that there are some things that Rust had that you liked,

28:46.000 --> 28:51.000
but maybe some other areas that it was sort of still advancing when you have been playing with it.

28:51.000 --> 28:55.000
You know, I actually think Rust is getting better and better all the time.

28:55.000 --> 29:01.000
I kind of think Rust is going to be around for a while as a systems programming language,

29:01.000 --> 29:03.000
and I think it's going to beat things like Go.

29:03.000 --> 29:09.000
It was a little frustrating, like those first couple weeks of using it, how strict the compiler was, if that makes sense?

29:09.000 --> 29:12.000
Sure, right, yeah. I mean, that's a big advantage, but you've got to learn.

29:12.000 --> 29:17.000
It's having a conversation with a whole new entity, and you've got to learn how to talk to it and what it expects.

29:17.000 --> 29:21.000
Right, and it's maybe a little tighter than what I was kind of used to.

29:21.000 --> 29:22.000
Yes.

29:22.000 --> 29:25.000
I have to say, the output has been very performant and very reliable.

29:25.000 --> 29:33.000
Again, the use case, or the primary one that is at least the most code, is processing STL and OBJ files that I had,

29:33.000 --> 29:41.000
and it worked great, which was a pretty intensive task that if not for Rust, I probably would have had to do in C++,

29:41.000 --> 29:47.000
which I would have found, one, much more error-prone because the non-strict compiler.

29:47.000 --> 29:53.000
And I don't see a reason to really hate on Rust, I'm sorry.

29:53.000 --> 29:55.000
No, that's great.

29:55.000 --> 30:02.000
Josh actually shared some reasons that you and many others, including Intel, are finding it a pleasure to work with.

30:02.000 --> 30:07.000
So, the same properties that make Rust work well for Mozilla to build a browser engine,

30:07.000 --> 30:13.000
also make it appealing for many other companies and projects that are building large, complex systems.

30:13.000 --> 30:18.000
So that includes a lot of companies that you already know, many companies that are represented here, even.

30:18.000 --> 30:26.000
Microsoft, Google, Facebook, Amazon, Dropbox, Chef, Fastly, Baidu, a huge number of companies beyond that.

30:26.000 --> 30:32.000
You can find a long list online, and hundreds of companies are using it to build all sorts of different software.

30:32.000 --> 30:34.000
There's a lot more to it than that.

30:34.000 --> 30:38.000
So, Rust actually has a long and interesting history.

30:38.000 --> 30:41.000
It was started four years ago today, in fact.

30:41.000 --> 30:44.000
This is the fourth anniversary of Rust 1.0, the stable release.

30:44.000 --> 30:50.000
It was started years before that, and beyond that, for those last four years,

30:50.000 --> 30:53.000
it's been the most loved language on Stack Overflow.

30:53.000 --> 30:57.000
People always say, well, I've started using it, and I want to keep using it.

30:57.000 --> 31:00.000
It has the most loyalty in that way.

31:00.000 --> 31:04.000
Beyond that, there are a lot of published security studies about the properties that Rust provides.

31:04.000 --> 31:10.000
This isn't just a thing that they advocate as, oh, you should use it because it has these properties.

31:10.000 --> 31:17.000
There was a study from Microsoft saying that 70% of security bugs are memory safety issues of some kind,

31:17.000 --> 31:21.000
and exactly the same type of issues that Rust fixes.

31:21.000 --> 31:27.000
A number of developers from Microsoft expressed interest in driving those types of security fixes using Rust.

31:27.000 --> 31:33.000
Mozilla did a study that showed that if they'd written one component of Firefox in Rust from the beginning,

31:33.000 --> 31:37.000
they'd have avoided 73% of its historical security issues.

31:37.000 --> 31:40.000
Mozilla went back and looked at every CVE in that component and said,

31:40.000 --> 31:45.000
which of them would still have existed, and which of them were fixed by writing it in Rust?

31:45.000 --> 31:49.000
Well, those are some pretty decent numbers, I would say.

31:49.000 --> 31:51.000
Yeah, I would say that's almost okay, right?

31:51.000 --> 31:53.000
Yeah, absolutely.

31:53.000 --> 31:58.000
But, of course, that doesn't mean everything is working, especially if you're doing low-level stuff,

31:58.000 --> 32:02.000
or maybe you need to produce super-duper optimized bytecode,

32:02.000 --> 32:06.000
and people at Intel do have some of those needs from time to time.

32:06.000 --> 32:10.000
I thought it was interesting that the talk kind of ends after going into more of the history of Rust

32:10.000 --> 32:13.000
and some of the nitty-gritty technical stuff.

32:13.000 --> 32:16.000
It just ends on a good summary of all the stuff that Intel is trying to work on

32:16.000 --> 32:21.000
to make that open-source ecosystem better for them and for others.

32:21.000 --> 32:24.000
I want to give a summary of what we're trying to work on.

32:24.000 --> 32:29.000
We need full parity with C to support the long tail of system software,

32:29.000 --> 32:32.000
and we have a Rust working group working towards that goal.

32:32.000 --> 32:37.000
And every feature that we add covers more of the space of systems programming.

32:37.000 --> 32:40.000
We want to make sure that all developers have a choice of languages,

32:40.000 --> 32:43.000
not just app developers but systems programmers as well,

32:43.000 --> 32:47.000
and nobody is stuck with only one language that will do what they need.

32:47.000 --> 32:50.000
So we want to make sure that no matter what language you're using,

32:50.000 --> 32:54.000
C or Rust or anything else, that it runs best on Intel hardware

32:54.000 --> 32:58.000
and that it gives you access to the full capabilities of your hardware.

32:58.000 --> 33:02.000
And we would love to have your feedback to help drive what C features

33:02.000 --> 33:04.000
that we add to Rust next.

33:04.000 --> 33:07.000
So please do get in touch if you want to do systems programming

33:07.000 --> 33:09.000
in higher-level languages.

33:09.000 --> 33:12.000
And please, please, please, don't buy AMD.

33:12.000 --> 33:13.000
Right.

33:13.000 --> 33:17.000
Well, of course, you've got to sneak that little sales pitch in there.

33:17.000 --> 33:18.000
Yeah.

33:18.000 --> 33:20.000
No, but that's pretty interesting.

33:20.000 --> 33:25.000
I mean, if you are, there's nothing wrong with Intel wanting to support your project.

33:25.000 --> 33:26.000
Right.

33:26.000 --> 33:30.000
And it's just kind of interesting to see because this is all in the open,

33:30.000 --> 33:34.000
and Rust has done a good job of having a lot of the language evolution done

33:34.000 --> 33:37.000
in a particularly transparent way, I would say.

33:37.000 --> 33:40.000
We get to sit here and watch and talk about it.

33:40.000 --> 33:44.000
Now, this is an example of open source work being done by Intel,

33:44.000 --> 33:46.000
obviously a very large corporation.

33:46.000 --> 33:50.000
But, Mike, you were pretty fired up about an article over in Wired

33:50.000 --> 33:55.000
by Keith Negley that reminds us that that's not always the case.

33:55.000 --> 33:56.000
Yeah.

33:56.000 --> 33:59.000
So I am an old man, so I subscribe to a number of print magazines,

33:59.000 --> 34:00.000
including Wired.

34:00.000 --> 34:01.000
Oh, look at you.

34:01.000 --> 34:04.000
You got the physical thing right there in your hands.

34:04.000 --> 34:05.000
Damn right.

34:05.000 --> 34:07.000
And they had this article, this last issue,

34:07.000 --> 34:11.000
about the tragedy of commons in FOSS, right?

34:11.000 --> 34:13.000
And, damn, it was heartbreaking.

34:13.000 --> 34:17.000
All these stories, the most telling one was of the open SSL team

34:17.000 --> 34:19.000
barely making a few thousand dollars a year.

34:19.000 --> 34:20.000
Right.

34:20.000 --> 34:23.000
I mean, this was kind of a reminder of what the situation was like

34:23.000 --> 34:24.000
before Heartbleed.

34:24.000 --> 34:25.000
Right, during Heartbleed.

34:25.000 --> 34:30.000
And just how, while it is absolutely true that the open source community

34:30.000 --> 34:34.000
can do great things, it's also true that, you know,

34:34.000 --> 34:37.000
I wouldn't even say corporate America, right, like corporate,

34:37.000 --> 34:41.000
I don't know, federation, like the Star Trek federation,

34:41.000 --> 34:44.000
are really leveraging the crap out of the community here.

34:44.000 --> 34:45.000
Right.

34:45.000 --> 34:48.000
And, I mean, on one side of that, that's kind of good and expected

34:48.000 --> 34:52.000
because you're putting it out there in the open to be used.

34:52.000 --> 34:58.000
But it sort of has, you know, hidden externalities, hidden reliances

34:58.000 --> 35:01.000
that we're not always doing a proper job of maintaining.

35:01.000 --> 35:04.000
And in the long run, that's not good for the businesses that rely on it

35:04.000 --> 35:07.000
or the people trying to make the software.

35:07.000 --> 35:10.000
Yeah, it's, you know, I more put this in for this week

35:10.000 --> 35:12.000
to kind of throw it out there to the audience

35:12.000 --> 35:14.000
and maybe get some feedback for next week.

35:14.000 --> 35:17.000
What do we think of this, you know, companies making millions

35:17.000 --> 35:20.000
and billions of dollars off open source projects

35:20.000 --> 35:23.000
where the maintainers are just hacking on it nights and weekends

35:23.000 --> 35:27.000
and, you know, not making anything?

35:27.000 --> 35:30.000
I mean, the best case he had, the author,

35:30.000 --> 35:32.000
was someone who ran a software consultancy,

35:32.000 --> 35:35.000
but they never even, you know, they never made a million in revenue.

35:35.000 --> 35:38.000
Meanwhile, some of the biggest Fortune 500s in the world

35:38.000 --> 35:40.000
depended on their project.

35:40.000 --> 35:41.000
Right, yeah.

35:41.000 --> 35:44.000
You know, I wonder, too, it seems like, I don't know if you'd agree,

35:44.000 --> 35:48.000
that more mainstream culture reporters, news organizations

35:48.000 --> 35:50.000
sort of discovered open source,

35:50.000 --> 35:53.000
and I think the wider world is still trying to make sense of it, too.

35:53.000 --> 35:55.000
And in this case, it's kind of nice

35:55.000 --> 35:59.000
because it points out some things that we don't talk about probably often enough.

35:59.000 --> 36:02.000
Yeah, I think Heartbleed, in particular,

36:02.000 --> 36:06.000
kind of took off some blinders for the mainstream.

36:06.000 --> 36:09.000
I would even say the mainstream tech press, right?

36:09.000 --> 36:12.000
So the tech press was not necessarily, you know,

36:12.000 --> 36:17.000
even in the development kind of Linux-y, Voss-y community.

36:17.000 --> 36:18.000
I don't know.

36:18.000 --> 36:23.000
Again, I am not going to jump into the GPL versus BSD debate here,

36:23.000 --> 36:28.000
but I will say that it doesn't make a lot of sense.

36:28.000 --> 36:30.000
And I think we've seen this in the Linux world, too,

36:30.000 --> 36:32.000
where some projects, notably this year,

36:32.000 --> 36:34.000
I can't remember the names off the top of my head,

36:34.000 --> 36:37.000
but I'm sure you do, have been shutting down or switching maintainership

36:37.000 --> 36:40.000
just because of, you know, it's not worth it, right?

36:40.000 --> 36:42.000
The maintainers are getting a little older, maybe,

36:42.000 --> 36:45.000
they have families, whatever, and they just can't do this.

36:45.000 --> 36:48.000
Right, I mean, you know, life gets in the way sometimes,

36:48.000 --> 36:52.000
and if we don't have a robust base of support to either let that continue

36:52.000 --> 36:54.000
or other people to, you know, sort of continue the work,

36:54.000 --> 36:57.000
well, we're going to lose things that we care about or find useful.

36:57.000 --> 36:59.000
One of the most haterade cases of this, I think,

36:59.000 --> 37:02.000
for our community at JB is going to be,

37:02.000 --> 37:04.000
remember, Mac is Darwin BSD.

37:04.000 --> 37:06.000
I mean, yes, they've mutated it quite a lot,

37:06.000 --> 37:09.000
but underneath it's the mock kernel running Darwin.

37:09.000 --> 37:11.000
They've done a lot to it, granted.

37:11.000 --> 37:16.000
There used to be FOSS Darwin BSD, like, alternatives.

37:16.000 --> 37:17.000
Yeah.

37:17.000 --> 37:20.000
Right, and there's a little show called BSD Now.

37:20.000 --> 37:21.000
Just saying.

37:21.000 --> 37:25.000
BSDNow.tv, if you'd like to check that out.

37:25.000 --> 37:29.000
It is a place to be for all things BSD.

37:29.000 --> 37:32.000
Where they all run Windows 7. Oops, sorry.

37:32.000 --> 37:35.000
I mean, sometimes people got to run Windows, Mike.

37:35.000 --> 37:36.000
You're one to talk.

37:36.000 --> 37:37.000
Oh, I know, I know.

37:37.000 --> 37:40.000
Next best Linux distro, Windows 10.

37:40.000 --> 37:45.000
Now, if you're all fired up like I am about what Mike just said,

37:45.000 --> 37:47.000
please do leave us feedback.

37:47.000 --> 37:51.000
You can do that either over at our subreddit coder radio.reddit.com

37:51.000 --> 37:55.000
or just go to coder.show directly or coder.show slash contact,

37:55.000 --> 37:59.000
and we've got a handy dandy little form that sends us an email.

37:59.000 --> 38:01.000
Now, Mike, let's move right along.

38:01.000 --> 38:02.000
There's no avoiding it.

38:02.000 --> 38:05.000
It's time for our language check-in.

38:05.000 --> 38:09.000
This week it's your turn, and you've been checking out Crystal.

38:09.000 --> 38:10.000
It's so shiny.

38:10.000 --> 38:12.000
I think it's kind of perfect to talk about

38:12.000 --> 38:15.000
because we've just been talking about systems programming and Rust,

38:15.000 --> 38:20.000
and one of Crystal's stated language goals is be able to call C code

38:20.000 --> 38:23.000
by writing bindings in pure Crystal.

38:23.000 --> 38:24.000
What?

38:24.000 --> 38:27.000
But before we get there, tell me more.

38:27.000 --> 38:28.000
How has it been?

38:28.000 --> 38:31.000
What's it like, and is it as cool as the little spinning Crystal

38:31.000 --> 38:32.000
on their homepage makes it look?

38:32.000 --> 38:35.000
All right, so I have to give it to the Crystal team.

38:35.000 --> 38:37.000
They know how to brand things.

38:37.000 --> 38:40.000
First of all, their website is just amazing.

38:40.000 --> 38:45.000
Second of all, their tagline, fast to see, slick as Ruby.

38:45.000 --> 38:47.000
Let's just drop our mics right now.

38:47.000 --> 38:48.000
Oh, boy.

38:48.000 --> 38:49.000
Yeah, wow.

38:49.000 --> 38:52.000
So Crystal could trick you on a cursory look

38:52.000 --> 38:54.000
and have you think you're writing Ruby.

38:54.000 --> 38:58.000
Yeah, look at this, server equals http server dot news,

38:58.000 --> 39:00.000
and then like the whole do block right from Ruby.

39:00.000 --> 39:01.000
What's going on?

39:01.000 --> 39:05.000
It is, by design, meant to be very syntactically

39:05.000 --> 39:10.000
and in a general methodology and pattern sort of way like Ruby,

39:10.000 --> 39:12.000
but there's a couple big differences.

39:12.000 --> 39:15.000
This is kind of, well, let's get the obvious ones

39:15.000 --> 39:16.000
right out of the way here, right?

39:16.000 --> 39:20.000
So first off, it is a static language.

39:20.000 --> 39:22.000
Static typing, maybe.

39:22.000 --> 39:25.000
Ah, so that's a big difference from Ruby right away.

39:25.000 --> 39:26.000
That's a big difference.

39:26.000 --> 39:29.000
Now, it goes out of its way not to slap you in the face with that,

39:29.000 --> 39:31.000
so most of the time you don't need to manually declare the types.

39:31.000 --> 39:32.000
It figures it out.

39:32.000 --> 39:36.000
So it's a modern type language with nice handy inference

39:36.000 --> 39:39.000
to help you out so that most of the time you can just kind of,

39:39.000 --> 39:42.000
not forget about it, but not have to annotate every last little thing.

39:42.000 --> 39:43.000
Right, but it does enforce it

39:43.000 --> 39:46.000
as though it were a traditional static type language.

39:46.000 --> 39:47.000
Excellent.

39:47.000 --> 39:49.000
So it infers it the first time, and then after that,

39:49.000 --> 39:51.000
it just assumes you know what you're doing.

39:51.000 --> 39:54.000
And if it doesn't compile time, it fails,

39:54.000 --> 39:57.000
which by the way, unlike Ruby, it compiles.

39:57.000 --> 39:59.000
Now, I know there are weird implementations of Ruby

39:59.000 --> 40:01.000
that people have run through compilers.

40:01.000 --> 40:02.000
Sure, of course.

40:02.000 --> 40:04.000
We're talking mainline Ruby here, right?

40:04.000 --> 40:06.000
Yeah, it compiles, and you're running binaries

40:06.000 --> 40:08.000
that are compiling to your native platform,

40:08.000 --> 40:11.000
which means you have to care about your native platform.

40:11.000 --> 40:13.000
Yeah, that's a big difference right there.

40:13.000 --> 40:15.000
It's not just this high-level interpreted language anymore.

40:15.000 --> 40:17.000
But of course, as we all know,

40:17.000 --> 40:20.000
compiled languages are in general faster

40:20.000 --> 40:23.000
than their interpreted equivalents, right?

40:23.000 --> 40:26.000
Which makes sense if you understand what the compiler actually does.

40:26.000 --> 40:29.000
So that's where it gets a lot of its speed.

40:29.000 --> 40:32.000
Oh, and also it consumes C directly, so yay.

40:32.000 --> 40:34.000
That is cool.

40:34.000 --> 40:37.000
Part of the static typing I noticed that they've got nice null handling.

40:37.000 --> 40:39.000
All types are non-nullable,

40:39.000 --> 40:41.000
and nullable variables are represented separately

40:41.000 --> 40:44.000
as a union between that type and nil.

40:44.000 --> 40:46.000
So they've got some nice modern handling there.

40:46.000 --> 40:48.000
Right, huge departure from Ruby,

40:48.000 --> 40:50.000
where hey, you can throw nil around like it's candy.

40:50.000 --> 40:53.000
And I find that that's less of a problem.

40:53.000 --> 40:55.000
In my own work with Ruby anyway,

40:55.000 --> 40:57.000
I don't find nil to be the sort of problem

40:57.000 --> 40:59.000
that null is in some Java code bases.

40:59.000 --> 41:01.000
But still, this is nice to have.

41:01.000 --> 41:03.000
More and more I'm liking things to be a bit stricter

41:03.000 --> 41:05.000
on the whole null, nil front.

41:05.000 --> 41:07.000
I don't mind it.

41:07.000 --> 41:10.000
In some of my reading around the forums and asking people,

41:10.000 --> 41:12.000
some people had issues with that.

41:12.000 --> 41:14.000
I don't understand why.

41:14.000 --> 41:17.000
I kind of don't think your way of validating your logic

41:17.000 --> 41:20.000
should be checking for nil, but that's just me.

41:20.000 --> 41:22.000
Right.

41:22.000 --> 41:24.000
I can't say I've never done it.

41:24.000 --> 41:26.000
That's how Objective-C, that was a very common pattern.

41:26.000 --> 41:31.000
It's not, you know, with age comes wisdom.

41:31.000 --> 41:33.000
A couple things I don't like

41:33.000 --> 41:35.000
before we get into some love here.

41:35.000 --> 41:37.000
Yeah, okay, yeah.

41:37.000 --> 41:41.000
So with static typing comes a lot of safety.

41:41.000 --> 41:45.000
You do lose some of the flexibility that you have in Ruby.

41:45.000 --> 41:47.000
Again, Crystal is its own language.

41:47.000 --> 41:49.000
It's just meant to look like Ruby.

41:49.000 --> 41:51.000
It's not a derivative of Ruby.

41:51.000 --> 41:53.000
It's not trying to be derivative.

41:53.000 --> 41:55.000
It's not trying to be compatible, yeah.

41:55.000 --> 41:57.000
The dot each iterator

41:57.000 --> 41:59.000
does not do what you would like it to do in Ruby.

41:59.000 --> 42:01.000
It is actually much more complex.

42:01.000 --> 42:03.000
You have to know what your collection is going in

42:03.000 --> 42:07.000
where in Ruby you can basically iterate over a ham sandwich.

42:07.000 --> 42:11.000
There's a whole enumerable module in Ruby

42:11.000 --> 42:13.000
that everything has, yeah.

42:13.000 --> 42:15.000
I think this is good,

42:15.000 --> 42:18.000
although people who've been using it a long time

42:18.000 --> 42:21.000
know I was very upset when Swift removed it.

42:21.000 --> 42:23.000
Yeah, you don't need for loops.

42:23.000 --> 42:25.000
You know what? I know they're like Comp Sci 100.

42:25.000 --> 42:27.000
Everybody has to learn for loops.

42:27.000 --> 42:29.000
You don't need for loops.

42:29.000 --> 42:31.000
So Crystal's down with that.

42:31.000 --> 42:33.000
You don't get no for loops.

42:33.000 --> 42:35.000
So if you want to iterate over a collection,

42:35.000 --> 42:37.000
you actually have to create the right type of collection

42:37.000 --> 42:39.000
and iterate over it.

42:39.000 --> 42:41.000
Oh, interesting, yeah, okay.

42:41.000 --> 42:43.000
That'll be different for some people

42:43.000 --> 42:45.000
that maybe have not worked with such a low-level language.

42:45.000 --> 42:47.000
But I'm going to just like, again,

42:47.000 --> 42:49.000
like many of the things in Rust,

42:49.000 --> 42:51.000
the enforcement of just a little extra discipline

42:51.000 --> 42:53.000
actually can protect you from

42:53.000 --> 42:55.000
just like a wide array of common errors, right?

42:55.000 --> 42:57.000
See what I did there? Iteration mentioned an array.

42:57.000 --> 42:59.000
I just like that.

42:59.000 --> 43:01.000
Yes.

43:01.000 --> 43:03.000
But then we get into what I can only describe as

43:03.000 --> 43:05.000
don't call me Ruby gems. Shards.

43:05.000 --> 43:07.000
Shards are exactly what you think they are.

43:07.000 --> 43:09.000
They are the equivalent of Ruby gems.

43:09.000 --> 43:11.000
Oh, that's a cute name.

43:11.000 --> 43:13.000
Right. They work differently because it's compiled,

43:13.000 --> 43:15.000
but you really don't care.

43:15.000 --> 43:17.000
It's a command. You run on the command line.

43:17.000 --> 43:19.000
You install it. It gives you dependencies.

43:19.000 --> 43:21.000
I mean, they're doing great work with it,

43:21.000 --> 43:23.000
but it's just like every package manager

43:23.000 --> 43:25.000
for every language, right?

43:25.000 --> 43:27.000
Kind of what the check these days, I think,

43:27.000 --> 43:29.000
is like, did they mess it up?

43:29.000 --> 43:31.000
Did you get this wrong?

43:31.000 --> 43:33.000
It works fine.

43:33.000 --> 43:35.000
Yeah, you're right. They didn't mess it up.

43:35.000 --> 43:37.000
It's boring. We just move on.

43:37.000 --> 43:39.000
Fibers, which are their concurrency model,

43:39.000 --> 43:41.000
are interesting and complex.

43:41.000 --> 43:43.000
And another reminder that this is a compiled language

43:43.000 --> 43:45.000
running on native code

43:45.000 --> 43:47.000
and that you really have to care about

43:47.000 --> 43:49.000
what form you're on,

43:49.000 --> 43:51.000
and you have to know what you're doing.

43:51.000 --> 43:53.000
Again, I'm going to draw the parallel to Rust.

43:53.000 --> 43:55.000
You can do great concurrency in Rust,

43:55.000 --> 43:57.000
but you have to really know what you're doing.

43:59.000 --> 44:01.000
I also think fibers are probably,

44:01.000 --> 44:03.000
other than the native performance,

44:03.000 --> 44:05.000
one of the primary reasons one would use Crystal

44:05.000 --> 44:09.000
if you have a highly concurrent workload,

44:09.000 --> 44:11.000
which lots of things are these days, right,

44:11.000 --> 44:13.000
in our multi-threaded, multi-GPU...

44:13.000 --> 44:15.000
I'm sorry, not multi...

44:15.000 --> 44:17.000
really multi-CPU world, yeah.

44:17.000 --> 44:19.000
Macros.

44:19.000 --> 44:21.000
So macros are evil and wrong,

44:21.000 --> 44:23.000
just like monkey patching and DSLs on Ruby.

44:23.000 --> 44:25.000
Don't do it.

44:25.000 --> 44:27.000
I was intrigued. You don't see

44:27.000 --> 44:29.000
this kind of style of macro

44:29.000 --> 44:31.000
in all statically typed languages?

44:31.000 --> 44:33.000
I mean, it reminds me a little bit

44:33.000 --> 44:35.000
of the GLISP style macros almost.

44:35.000 --> 44:37.000
Did you write one?

44:37.000 --> 44:39.000
Did you play with that at all?

44:39.000 --> 44:41.000
I did. So there was an example

44:41.000 --> 44:43.000
of someone who was very annoyed.

44:43.000 --> 44:45.000
I didn't post in the doc

44:45.000 --> 44:49.000
because I felt the tone was a little too snarky,

44:49.000 --> 44:51.000
which, if you've listened to the show,

44:51.000 --> 44:53.000
tells you a lot.

44:53.000 --> 44:55.000
Yeah, so someone was really mad

44:55.000 --> 44:57.000
and wrote a macro to add four loops back.

44:57.000 --> 44:59.000
Of course.

44:59.000 --> 45:01.000
It's... it's bad.

45:01.000 --> 45:03.000
We call this monkey patching in Ruby, right?

45:03.000 --> 45:05.000
I think there's a proper name,

45:05.000 --> 45:07.000
but that's kind of the mean slang name.

45:07.000 --> 45:09.000
No, I think it is really called

45:09.000 --> 45:11.000
monkey patching in the docs now.

45:11.000 --> 45:13.000
I'll put that up and comment on Reddit.

45:13.000 --> 45:15.000
Basically, you can add functionality

45:15.000 --> 45:17.000
to the language.

45:17.000 --> 45:19.000
Great for DSLs, right?

45:19.000 --> 45:21.000
That's what everybody says.

45:21.000 --> 45:23.000
What you usually see is not DSLs,

45:23.000 --> 45:25.000
but people adding crap that's bad.

45:25.000 --> 45:27.000
I have done it.

45:27.000 --> 45:29.000
I don't think you should do it.

45:29.000 --> 45:31.000
I understand why Crystal has it as a...

45:31.000 --> 45:33.000
By the way, this language is not even 1.0 yet.

45:33.000 --> 45:35.000
So if you're thinking of, like,

45:35.000 --> 45:37.000
popping this out in prod,

45:37.000 --> 45:39.000
I saw there's some companies who are using it.

45:39.000 --> 45:41.000
I don't think it'll be 1.0

45:41.000 --> 45:43.000
unless it's a really special case role.

45:43.000 --> 45:45.000
So for me, I would not use this in production right now.

45:45.000 --> 45:47.000
Totally reasonable.

45:47.000 --> 45:49.000
But I definitely get

45:49.000 --> 45:51.000
why such a young language

45:51.000 --> 45:53.000
would need something like macros

45:53.000 --> 45:55.000
because I'm sure there are plenty of the shops

45:55.000 --> 45:57.000
and individual developers using this

45:57.000 --> 45:59.000
that simply wouldn't use it

45:59.000 --> 46:01.000
if they couldn't add on their own functionality.

46:01.000 --> 46:03.000
Right. That's the thing, right?

46:03.000 --> 46:05.000
Like, macros enable you to sort of expand the language.

46:05.000 --> 46:07.000
You're right if you have, I think,

46:07.000 --> 46:09.000
some particular problems in Ruby with monkey patching

46:09.000 --> 46:11.000
is that it is easily used

46:11.000 --> 46:13.000
for very widespread things, right?

46:13.000 --> 46:15.000
You can just end up adding these methods

46:15.000 --> 46:17.000
that show up on objects everywhere

46:17.000 --> 46:19.000
practically.

46:19.000 --> 46:21.000
It seems like macros

46:21.000 --> 46:23.000
are best used, at least in my experience,

46:23.000 --> 46:25.000
for very limited cases. Yeah, stuff where you...

46:25.000 --> 46:27.000
You know, it's obvious that you're doing some sort of

46:27.000 --> 46:29.000
complicated transformation here.

46:29.000 --> 46:31.000
It is neat that basically in Crystal,

46:31.000 --> 46:33.000
macros are just methods that receive

46:33.000 --> 46:35.000
AST nodes at compile time

46:35.000 --> 46:37.000
and then produce code that gets pasted right back

46:37.000 --> 46:39.000
so it's much like macros

46:39.000 --> 46:41.000
you might be familiar with from other languages.

46:41.000 --> 46:43.000
That's cool. You know, macros are

46:43.000 --> 46:45.000
kind of like AppSynth.

46:45.000 --> 46:47.000
You can...

46:47.000 --> 46:49.000
You can have a little bit, but you really got...

46:49.000 --> 46:51.000
That's like a once a year thing. Yeah.

46:51.000 --> 46:53.000
Yeah, once in a while.

46:53.000 --> 46:55.000
So one thing that looks a little bit similar

46:55.000 --> 46:57.000
to Ruby is in Crystal,

46:57.000 --> 46:59.000
everything is in objects, right?

46:59.000 --> 47:01.000
And basically they say the things you can know

47:01.000 --> 47:03.000
about it is that it has a type

47:03.000 --> 47:05.000
and it can respond to some methods

47:05.000 --> 47:07.000
and that's it.

47:07.000 --> 47:09.000
Yeah, I personally like that, but I like Ruby.

47:09.000 --> 47:11.000
If you don't like that, then you won't like it here either.

47:13.000 --> 47:15.000
Personally, I think that makes reasoning about

47:15.000 --> 47:17.000
your code very, very...

47:17.000 --> 47:19.000
I won't say simple, but

47:19.000 --> 47:21.000
it kind of gives you a...

47:23.000 --> 47:25.000
Just like a set of rules that you can follow

47:25.000 --> 47:27.000
and reason through. Yeah.

47:27.000 --> 47:29.000
Constrains the interface and API that you're

47:29.000 --> 47:31.000
using to talk between all these things.

47:31.000 --> 47:33.000
I definitely understand why there's a whole set of people

47:33.000 --> 47:35.000
who wouldn't like that kind of thing.

47:35.000 --> 47:37.000
I'm not sure how much you would or wouldn't like this.

47:37.000 --> 47:39.000
I'm very curious.

47:39.000 --> 47:41.000
For me, this is...

47:41.000 --> 47:43.000
When this hits 1.0, I would

47:43.000 --> 47:45.000
probably use this where I might use Rust.

47:45.000 --> 47:47.000
Right? As a more

47:47.000 --> 47:49.000
performant augmentation to a

47:49.000 --> 47:51.000
large scale application written in Ruby.

47:51.000 --> 47:53.000
I see.

47:53.000 --> 47:55.000
Having said that, I'm really enjoying

47:55.000 --> 47:57.000
using Rust for that. I hate

47:57.000 --> 47:59.000
to say it, and I could

47:59.000 --> 48:01.000
change my mind later because, yay.

48:01.000 --> 48:03.000
I don't see me

48:03.000 --> 48:05.000
picking this up. And obviously,

48:05.000 --> 48:07.000
my 1.0 rule, I won't pick it up

48:07.000 --> 48:09.000
now. Right. Let's say it was ready to go.

48:09.000 --> 48:11.000
You were comfortable with its stability.

48:11.000 --> 48:13.000
But I wouldn't discourage anybody, especially if you're

48:13.000 --> 48:15.000
just hacking for fun or doing

48:15.000 --> 48:17.000
a toy program for yourself.

48:19.000 --> 48:21.000
Honestly, the only thing I really

48:21.000 --> 48:23.000
don't like is macros, but lots of languages

48:23.000 --> 48:25.000
that I do like have it, i.e. Ruby,

48:25.000 --> 48:27.000
and I think I just don't use

48:27.000 --> 48:29.000
it because I don't like it.

48:29.000 --> 48:31.000
One thing I noticed that was interesting just looking at it,

48:31.000 --> 48:33.000
if you go take a peek at their GitHub,

48:33.000 --> 48:35.000
I think as a consequence of having macros,

48:35.000 --> 48:37.000
most of Crystal is implemented

48:37.000 --> 48:39.000
in Crystal at this point.

48:39.000 --> 48:41.000
And you don't need macros for that sort of thing,

48:41.000 --> 48:43.000
but it can make it easy because you can

48:43.000 --> 48:45.000
start with a few special primitives and sort of

48:45.000 --> 48:47.000
build the language upon itself from there.

48:47.000 --> 48:49.000
I don't want to hit the macro thing too hard

48:49.000 --> 48:51.000
because in reality, if I for some reason

48:51.000 --> 48:53.000
decided to use this, I am sure I would eventually

48:53.000 --> 48:55.000
have to write some macros for myself too.

48:55.000 --> 48:57.000
I'd be curious how you might compare it to Go

48:57.000 --> 48:59.000
as well, because it seems like

48:59.000 --> 49:01.000
right now the advantages or at least things you might be

49:01.000 --> 49:03.000
interested in as compared to Rust would be

49:03.000 --> 49:05.000
the really strong concurrency model.

49:05.000 --> 49:07.000
I know Rust has been working on async

49:07.000 --> 49:09.000
08 sort of style stuff, and there's various

49:09.000 --> 49:11.000
different proposals out there, but Crystal

49:11.000 --> 49:13.000
is up front, like, look, we've got

49:13.000 --> 49:15.000
fibers, we've got green threads, have

49:15.000 --> 49:17.000
at it, and

49:17.000 --> 49:19.000
it might not be suitable to target exactly

49:19.000 --> 49:21.000
as all the low-level things, or at least right now,

49:21.000 --> 49:23.000
I'm thinking stuff without a runtime or OS level

49:23.000 --> 49:25.000
stuff that Rust can also sort of

49:25.000 --> 49:27.000
play at, but if you want

49:27.000 --> 49:29.000
a tight little, you know, static

49:29.000 --> 49:31.000
executable, reasonably fast,

49:31.000 --> 49:33.000
efficient, pretty low-level stuff,

49:33.000 --> 49:35.000
it seems like this would be competing with

49:35.000 --> 49:37.000
Go as well in that regard.

49:37.000 --> 49:39.000
Yeah, I could see that.

49:39.000 --> 49:41.000
Is the argument then that you just get a syntax that maybe

49:41.000 --> 49:43.000
you like more?

49:43.000 --> 49:45.000
Well, you know, I would be maybe a little more

49:45.000 --> 49:47.000
optimistic than that.

49:47.000 --> 49:49.000
I mean, I think, you know, not many people were doing

49:49.000 --> 49:51.000
a whole lot of Ruby until Rails came along.

49:51.000 --> 49:53.000
Having said that, I don't think

49:53.000 --> 49:55.000
this is a great thing for the type of application

49:55.000 --> 49:57.000
you would write in Rails.

49:57.000 --> 49:59.000
No, no, probably not, right? It's a little lower level than that.

49:59.000 --> 50:01.000
But I could see something

50:01.000 --> 50:03.000
coming along where,

50:03.000 --> 50:05.000
you know, there's not a lot of

50:05.000 --> 50:07.000
people use, well, I won't say not a lot, but

50:07.000 --> 50:09.000
Erlang is not one of the biggest languages out there,

50:09.000 --> 50:11.000
but there are domains where it makes a ton of

50:11.000 --> 50:13.000
sense.

50:13.000 --> 50:15.000
Yeah, that's the other thing this would seem to be sort of targeting, right?

50:15.000 --> 50:17.000
I mean, you tried Elixir to kick off this whole language

50:17.000 --> 50:19.000
challenge, and they have similar

50:19.000 --> 50:21.000
concurrency models here.

50:21.000 --> 50:23.000
And they both got that Ruby, yeah, that Ruby DNA almost.

50:23.000 --> 50:25.000
Now, I know there's been some interest

50:25.000 --> 50:27.000
over in the Erlang world

50:27.000 --> 50:29.000
because you can write, you know, basically extensions

50:29.000 --> 50:31.000
out from the Erlang VM, so you can

50:31.000 --> 50:33.000
implement sort of stuff that needs to be faster, lower

50:33.000 --> 50:35.000
level things. But there's always the

50:35.000 --> 50:37.000
risk, at least when they're implemented classically in C,

50:37.000 --> 50:39.000
of that ruining a lot of your

50:39.000 --> 50:41.000
safety, right? When you build it on their nice Beam VM,

50:41.000 --> 50:43.000
you get all this nice managed safety for you.

50:43.000 --> 50:45.000
But if your C extension then like crashes the

50:45.000 --> 50:47.000
whole thing, well, that won't work. So there's been

50:47.000 --> 50:49.000
some interest in using Rust. I wonder

50:49.000 --> 50:51.000
how Crystal might work in the same regard.

50:51.000 --> 50:53.000
As always, Rust is the right answer.

50:53.000 --> 50:55.000
Oh, Mike.

50:55.000 --> 50:57.000
So, Wes, we forgot to mention

50:57.000 --> 50:59.000
on the last recording, you are doing a challenge.

50:59.000 --> 51:01.000
Yeah. Now,

51:01.000 --> 51:03.000
what have you picked for me? Because you've given

51:03.000 --> 51:05.000
a great report here on Crystal. I might just have to

51:05.000 --> 51:07.000
play with it myself as an aside because

51:07.000 --> 51:09.000
I'm curious. It's got me interested.

51:09.000 --> 51:11.000
But I need a language.

51:11.000 --> 51:13.000
I need something to be working on.

51:13.000 --> 51:15.000
So, you know what? I had

51:15.000 --> 51:17.000
a language in mind, but I think you've actually

51:17.000 --> 51:19.000
changed my mind. Oh,

51:19.000 --> 51:21.000
what? I don't think we've done Go yet,

51:21.000 --> 51:23.000
have we? Didn't you do Go?

51:23.000 --> 51:25.000
Oh, I did do Go, didn't I?

51:25.000 --> 51:27.000
But I haven't. Now, we did

51:27.000 --> 51:29.000
get some, we did get some, there was a

51:29.000 --> 51:31.000
feedback item I saw somewhere. Maybe it was on,

51:31.000 --> 51:33.000
maybe it was on Reddit. Someone suggested

51:33.000 --> 51:35.000
I try Julia. That might be interesting.

51:35.000 --> 51:37.000
That's a language I've been looking at,

51:37.000 --> 51:39.000
but have not actually played with. I mean, I think you'll

51:39.000 --> 51:41.000
hate it. So that's part of the...

51:41.000 --> 51:43.000
Perfect. All right. Do you want to do Julia?

51:43.000 --> 51:45.000
Yeah, it sounds good. I mean,

51:45.000 --> 51:47.000
we must be close to seven by now.

51:47.000 --> 51:49.000
Yeah, probably. But this is fun. So, you know.

51:49.000 --> 51:51.000
All right. So, and what for me

51:51.000 --> 51:53.000
next? So I have two weeks to do it.

51:53.000 --> 51:55.000
Hmm. Hmm.

51:55.000 --> 51:57.000
That's a good question, Mike.

51:57.000 --> 51:59.000
I don't, I don't know. I might

51:59.000 --> 52:01.000
have to think about that a little bit.

52:01.000 --> 52:03.000
Maybe we'll send out a tweet

52:03.000 --> 52:05.000
about that later this week once we've decided.

52:05.000 --> 52:07.000
Well, Mike, thank you

52:07.000 --> 52:09.000
for a very interesting language

52:09.000 --> 52:11.000
report. And, you know, it's great

52:11.000 --> 52:13.000
to be doing the show live with you again. We'll be here doing

52:13.000 --> 52:15.000
the show live like we do almost

52:15.000 --> 52:17.000
every week. Next week

52:17.000 --> 52:19.000
you can join too. Head on over to jupiterbroadcasting.com

52:19.000 --> 52:21.000
slash calendar.

52:21.000 --> 52:23.000
That will list the

52:23.000 --> 52:25.000
live times of this show and all the

52:25.000 --> 52:27.000
other shows that we do live.

52:27.000 --> 52:29.000
If you want more Coder Radio, well, head

52:29.000 --> 52:31.000
on over to coder.show. That has

52:31.000 --> 52:33.000
the whole back catalog. And if

52:33.000 --> 52:35.000
that's not enough, jupiterbroadcasting.com

52:35.000 --> 52:37.000
has all the other fine

52:37.000 --> 52:39.000
shows, including, you know,

52:39.000 --> 52:41.000
we've got some new stuff going on over in our

52:41.000 --> 52:43.000
Extras feed. If you haven't heard, if you

52:43.000 --> 52:45.000
haven't checked it out, but maybe you've already caught

52:45.000 --> 52:47.000
up on all the JB content for the week and need

52:47.000 --> 52:49.000
a little bit more, extras.show.

52:49.000 --> 52:51.000
Go check out

52:51.000 --> 52:53.000
the latest Brunch with Brent.

52:53.000 --> 52:55.000
I think you'll find it's very enjoyable.

52:55.000 --> 52:57.000
Mike, if they want

52:57.000 --> 52:59.000
more of you, well, you're over

52:59.000 --> 53:01.000
on Twitter. What's your handle?

53:01.000 --> 53:03.000
That's at Domenico on Twitter.

53:03.000 --> 53:05.000
I'm there too, at

53:05.000 --> 53:07.000
Westpane. And you can find the whole

53:07.000 --> 53:09.000
network sending out notifications about all the

53:09.000 --> 53:11.000
latest and greatest shows at

53:11.000 --> 53:13.000
Jupiter Signal. Thank

53:13.000 --> 53:15.000
you all so much for joining us.

53:15.000 --> 53:17.000
We'll see you right back here

53:17.000 --> 53:45.000
next week.

53:47.000 --> 53:49.000
you


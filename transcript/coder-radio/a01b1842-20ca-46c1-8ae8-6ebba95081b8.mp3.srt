1
00:00:00,000 --> 00:00:08,080
Welcome to Coda Radio, Jupiter Broadcasting's weekly talk show exploring the art and business

2
00:00:08,080 --> 00:00:11,900
of software development and related technologies.

3
00:00:11,900 --> 00:00:18,560
My name is Wes and I am just so lucky to be joined with that sorcerer of software, the

4
00:00:18,560 --> 00:00:21,760
one, the only, Mr. Michael Dominic.

5
00:00:21,760 --> 00:00:23,760
You just sound so much better than Chris.

6
00:00:23,760 --> 00:00:25,400
Oh, that's right I do.

7
00:00:25,400 --> 00:00:26,860
I'm so flattered.

8
00:00:26,860 --> 00:00:28,560
You sound pretty good today too.

9
00:00:28,560 --> 00:00:30,560
Thanks, sir.

10
00:00:30,560 --> 00:00:32,280
What planet do you find yourself on?

11
00:00:32,280 --> 00:00:35,560
Oh, well, the swamps of Riverview, Florida as usual.

12
00:00:35,560 --> 00:00:36,560
Me and Jar Jar.

13
00:00:36,560 --> 00:00:38,960
Yeah, you guys are just best buds down there, it seems like.

14
00:00:38,960 --> 00:00:39,960
Just best buds.

15
00:00:39,960 --> 00:00:43,360
You let them play in your pool, you're hanging out, you're smoking cigars together.

16
00:00:43,360 --> 00:00:45,120
It's a wild scene.

17
00:00:45,120 --> 00:00:46,120
That's right.

18
00:00:46,120 --> 00:00:47,120
That's right.

19
00:00:47,120 --> 00:00:50,400
Well, thank you for having me here with you today, Mike.

20
00:00:50,400 --> 00:00:53,120
Chris is still away, but that can't stop us.

21
00:00:53,120 --> 00:00:54,960
There's code to talk about.

22
00:00:54,960 --> 00:00:56,960
Can't stop the code.

23
00:00:56,960 --> 00:00:58,360
Heck, no.

24
00:00:58,360 --> 00:01:00,240
Well, maybe you can though.

25
00:01:00,240 --> 00:01:03,280
We've got some feedback to start off the show.

26
00:01:03,280 --> 00:01:05,120
It starts off pretty strong.

27
00:01:05,120 --> 00:01:08,200
Yeah, they're coming in pretty hot here.

28
00:01:08,200 --> 00:01:12,880
So Joe writes in and I'm going to read it, but first I'd like to summarize it.

29
00:01:12,880 --> 00:01:16,520
Joe would like to know what the hell is wrong with me.

30
00:01:16,520 --> 00:01:20,680
I haven't really read this yet, but I want to know too.

31
00:01:20,680 --> 00:01:24,680
So Joe says blah, I'm not sure I get that part.

32
00:01:24,680 --> 00:01:25,980
Why.NET?

33
00:01:25,980 --> 00:01:26,980
It's a dead end.

34
00:01:26,980 --> 00:01:28,880
It doesn't have support on any other systems.

35
00:01:28,880 --> 00:01:35,080
Yes, technically it has had Xamarin, but let's be realistic.

36
00:01:35,080 --> 00:01:37,480
There's no good front end for Linux.

37
00:01:37,480 --> 00:01:39,560
Not true anymore, but we'll get to it.

38
00:01:39,560 --> 00:01:42,200
I have known about Qt for a long time.

39
00:01:42,200 --> 00:01:47,360
Back when he did more C++ programming, I looked at various ways to do cross-platform development.

40
00:01:47,360 --> 00:01:53,880
He avoids Qt, he says, because the license now in C++ is using WX widgets, which actually

41
00:01:53,880 --> 00:01:57,200
a few other people have recommended and I'll talk about it in a minute.

42
00:01:57,200 --> 00:02:02,840
Nowadays he's a Java programmer and yeah, I'm summarizing this a little long, but he

43
00:02:02,840 --> 00:02:08,400
says JavaScript looks like a spaghetti nightmare from the 70s.

44
00:02:08,400 --> 00:02:09,600
The man does not mince words.

45
00:02:09,600 --> 00:02:10,600
You have to respect him.

46
00:02:10,600 --> 00:02:11,600
I appreciate that.

47
00:02:11,600 --> 00:02:12,600
Yeah, props, Joe, props.

48
00:02:12,600 --> 00:02:13,600
And I mean, that's right.

49
00:02:13,600 --> 00:02:15,400
I mean, it does look like that.

50
00:02:15,400 --> 00:02:16,720
Yeah, it really does.

51
00:02:16,720 --> 00:02:18,200
So point by point, right?

52
00:02:18,200 --> 00:02:23,280
Oh, and he says go Pats for the football season, which really undercuts the rest of

53
00:02:23,280 --> 00:02:24,280
your email.

54
00:02:24,280 --> 00:02:27,640
Just don't mention that you're a Patriots fan.

55
00:02:27,640 --> 00:02:29,620
So simple answer, right?

56
00:02:29,620 --> 00:02:37,280
The product I am launching next week, yay, and Linux, but mostly Windows.

57
00:02:37,280 --> 00:02:39,520
So.NET's a pretty natural choice.

58
00:02:39,520 --> 00:02:43,000
The aerospace industry tends to love them some Microsoft.

59
00:02:43,000 --> 00:02:44,000
Right?

60
00:02:44,000 --> 00:02:45,000
Yeah.

61
00:02:45,000 --> 00:02:48,180
I mean, if you already have support for the runtime there, you should reintroduce your

62
00:02:48,180 --> 00:02:49,360
product real quick there.

63
00:02:49,360 --> 00:02:51,360
You cut out for a split second.

64
00:02:51,360 --> 00:02:54,200
So it's launching next week, so I can't say anything about it yet.

65
00:02:54,200 --> 00:02:55,200
Ah, yeah, okay.

66
00:02:55,200 --> 00:02:56,200
We just missed a tiny bit.

67
00:02:56,200 --> 00:02:59,680
But you said it mostly runs on, you're mostly targeting Windows?

68
00:02:59,680 --> 00:03:00,680
Yeah, yeah.

69
00:03:00,680 --> 00:03:04,280
I think like about like nine out of 10 installs are going to be Windows.

70
00:03:04,280 --> 00:03:05,280
Got it.

71
00:03:05,280 --> 00:03:07,360
Okay, interesting.

72
00:03:07,360 --> 00:03:11,240
In terms of Q, yeah, that was a, Wes, have you taken a look at Q in a while?

73
00:03:11,240 --> 00:03:15,120
No, you know, honestly, it's been a couple of years since I've really, you know, gotten

74
00:03:15,120 --> 00:03:17,920
down and ready and had a new project that I was playing with it.

75
00:03:17,920 --> 00:03:19,080
Yeah, yeah.

76
00:03:19,080 --> 00:03:23,520
I was looking at it recently, and I just got tripped up on the licensing.

77
00:03:23,520 --> 00:03:27,840
That seems especially complicated if you're not just playing solely in the open source

78
00:03:27,840 --> 00:03:28,840
world.

79
00:03:28,840 --> 00:03:29,840
Yeah, it is.

80
00:03:29,840 --> 00:03:36,560
Yeah, and we had an episode on the whole LGPL, and then it being by component was pretty

81
00:03:36,560 --> 00:03:37,560
confusing.

82
00:03:37,560 --> 00:03:42,040
So does that mean that you've kind of just, is that written off for you now?

83
00:03:42,040 --> 00:03:43,040
Not a path you're going to be?

84
00:03:43,040 --> 00:03:44,040
Yeah, it's written off for now.

85
00:03:44,040 --> 00:03:45,040
Got it, yeah.

86
00:03:45,040 --> 00:03:47,120
Just exploring other ways to accomplish the same thing.

87
00:03:47,120 --> 00:03:53,760
Yeah, the pricing to be compliant with the license was going to be just way too high.

88
00:03:53,760 --> 00:03:58,640
So yeah, you know, everybody loves Java, not trying to knock Java.

89
00:03:58,640 --> 00:04:01,200
I know Wes is a big Java fan, right?

90
00:04:01,200 --> 00:04:03,400
You know, I have nothing against Java.

91
00:04:03,400 --> 00:04:10,800
I don't want to build certain things with it, but as a building block to build big systems,

92
00:04:10,800 --> 00:04:11,800
it's come a long way.

93
00:04:11,800 --> 00:04:16,600
I like the newer Javas as well when you have, you know, a little more functional influence.

94
00:04:16,600 --> 00:04:18,320
That's a much more pleasant language.

95
00:04:18,320 --> 00:04:19,860
Yeah, yeah.

96
00:04:19,860 --> 00:04:23,240
So yeah, I appreciate the email, Joe, and a lot about Wes, unless you have anything

97
00:04:23,240 --> 00:04:24,280
else here on WX widgets.

98
00:04:24,280 --> 00:04:25,280
I did look at it.

99
00:04:25,280 --> 00:04:28,520
I don't, I have not used it yet, so I can't really speak to.

100
00:04:28,520 --> 00:04:32,720
No, I can't either, although I guess I've seen a lot of things written in it.

101
00:04:32,720 --> 00:04:35,440
I don't know if they were beautiful, but if you just want to go for a functional, seems

102
00:04:35,440 --> 00:04:37,120
like it's certainly up to the task.

103
00:04:37,120 --> 00:04:40,400
There you go.

104
00:04:40,400 --> 00:04:46,560
So next on the docket, a similar comment I got on YouTube and a Twitter question.

105
00:04:46,560 --> 00:04:48,240
Quite a lot was, why not Tornado FX?

106
00:04:48,240 --> 00:04:49,640
Are you familiar with this at all?

107
00:04:49,640 --> 00:04:51,880
Oh no, what's Tornado FX?

108
00:04:51,880 --> 00:04:55,440
This is actually keeping in line with Joe's Java mentioned.

109
00:04:55,440 --> 00:04:59,320
This is a version of Java FX that uses Kotlin.

110
00:04:59,320 --> 00:05:00,960
Oh, okay.

111
00:05:00,960 --> 00:05:03,040
Well that, that sounds pretty nice actually.

112
00:05:03,040 --> 00:05:09,160
It, yeah, it does look pretty, pretty sexy if I say so myself, but it's a little too

113
00:05:09,160 --> 00:05:12,680
new for me to want to ship in a production project.

114
00:05:12,680 --> 00:05:13,680
Right.

115
00:05:13,680 --> 00:05:19,680
I mean, Kotlin itself isn't really that old yet, and yeah, it seems like this product,

116
00:05:19,680 --> 00:05:21,280
it's moving pretty quickly.

117
00:05:21,280 --> 00:05:25,160
But oh yeah, as they say here, not yet compatible with Java 9 or 10 yet.

118
00:05:25,160 --> 00:05:27,760
So yeah, clearly there's some stabilizing to do.

119
00:05:27,760 --> 00:05:28,760
Yeah.

120
00:05:28,760 --> 00:05:32,480
There's some weirdness with Kotlin and different Java versions, as I've learned the hard way.

121
00:05:32,480 --> 00:05:33,480
Really?

122
00:05:33,480 --> 00:05:34,640
That's actually, I had not heard that complaint before.

123
00:05:34,640 --> 00:05:38,120
I've almost always heard pleasant things about Kotlin so far.

124
00:05:38,120 --> 00:05:39,120
Yeah.

125
00:05:39,120 --> 00:05:43,880
Well, I don't think it's currently true, but when Java 10 came out, it was actually not

126
00:05:43,880 --> 00:05:44,880
compatible with Kotlin.

127
00:05:44,880 --> 00:05:45,880
Oh yeah.

128
00:05:45,880 --> 00:05:46,880
Okay.

129
00:05:46,880 --> 00:05:49,800
I suppose there's always bound to be, bound to be a little leg when you have big changes

130
00:05:49,800 --> 00:05:50,800
underneath.

131
00:05:50,800 --> 00:05:51,800
Yeah, exactly.

132
00:05:51,800 --> 00:05:52,800
It can't be easy, Mike.

133
00:05:52,800 --> 00:05:53,800
This is software.

134
00:05:53,800 --> 00:05:54,800
What are you, what are you thinking over there?

135
00:05:54,800 --> 00:05:55,800
What?

136
00:05:55,800 --> 00:05:56,800
I'm sorry.

137
00:05:56,800 --> 00:05:58,840
I'm just, I'm just, you know, I'm just lost.

138
00:05:58,840 --> 00:06:00,400
Yeah, that's right.

139
00:06:00,400 --> 00:06:04,440
Well, so last I heard you had done something terrible to your phone.

140
00:06:04,440 --> 00:06:07,960
Is that, is it still in a state of disrepair?

141
00:06:07,960 --> 00:06:12,440
It is still in a state of disrepair because I refuse to pay the exorbitant 200 and something

142
00:06:12,440 --> 00:06:14,280
dollars Apple wants for screen replacement.

143
00:06:14,280 --> 00:06:15,280
Oh, ouch.

144
00:06:15,280 --> 00:06:20,760
Yeah, that's a, that'll burn a hole in your pocket real quick.

145
00:06:20,760 --> 00:06:26,920
So speaking of losing money, Fortnite, 15 million downloads by sidestepping the Google

146
00:06:26,920 --> 00:06:28,880
Play Store on Android.

147
00:06:28,880 --> 00:06:29,880
Wow.

148
00:06:29,880 --> 00:06:30,880
Woo wee.

149
00:06:30,880 --> 00:06:31,880
That is, I'm impressed.

150
00:06:31,880 --> 00:06:32,880
That's got it.

151
00:06:32,880 --> 00:06:33,880
I'm impressed.

152
00:06:33,880 --> 00:06:39,680
That's got to be significant, significant revenue loss there for Google.

153
00:06:39,680 --> 00:06:40,680
Right?

154
00:06:40,680 --> 00:06:44,000
I mean, yeah, they're pulling a pretty big cut from, you'd presume a lot of those would

155
00:06:44,000 --> 00:06:45,640
have come through them otherwise.

156
00:06:45,640 --> 00:06:46,640
Yeah.

157
00:06:46,640 --> 00:06:50,720
And with a 30% every in-app purchase.

158
00:06:50,720 --> 00:06:54,800
Do you, would this work, would this strategy work for a less popular application?

159
00:06:54,800 --> 00:06:57,760
I mean, obviously Fortnite has a ton of momentum in mind.

160
00:06:57,760 --> 00:06:58,760
People already know about it.

161
00:06:58,760 --> 00:07:01,780
They don't need discoverability really on the store and they just, you know, and they're

162
00:07:01,780 --> 00:07:03,680
already motivated to download it.

163
00:07:03,680 --> 00:07:04,680
Yeah.

164
00:07:04,680 --> 00:07:07,260
Would this work for something like, could you go around the Play Store and have any

165
00:07:07,260 --> 00:07:08,260
kind of this success?

166
00:07:08,260 --> 00:07:09,260
No, no.

167
00:07:09,260 --> 00:07:10,260
No.

168
00:07:10,260 --> 00:07:14,460
And actually we should mention that for a few days there, Fortnite actually was the

169
00:07:14,460 --> 00:07:20,400
victim of a man in the middle attack where, yeah, people were getting infected APKs and

170
00:07:20,400 --> 00:07:24,040
Google very publicly pointed it out in, right?

171
00:07:24,040 --> 00:07:27,560
But I guess this is what happens when you skip on all our niceties.

172
00:07:27,560 --> 00:07:30,360
Circumvent the app store.

173
00:07:30,360 --> 00:07:31,560
It's certainly interesting though.

174
00:07:31,560 --> 00:07:32,560
Yeah.

175
00:07:32,560 --> 00:07:37,760
That 30% cut feels, you know, very outmoded.

176
00:07:37,760 --> 00:07:40,440
It really kind of feels pretty steep.

177
00:07:40,440 --> 00:07:41,440
It really is.

178
00:07:41,440 --> 00:07:42,440
Yeah.

179
00:07:42,440 --> 00:07:45,840
And it's like, it adds to the weird walled garden effect and it doesn't, you know, that's

180
00:07:45,840 --> 00:07:50,400
useful what they do, but 30%, you know, like a standard, a more standard listing fee.

181
00:07:50,400 --> 00:07:54,960
Seems like it would just encourage more and better apps on the ecosystem anyway.

182
00:07:54,960 --> 00:07:59,640
One more financially sustainable for the developers, even if they are just doing advertising or

183
00:07:59,640 --> 00:08:00,640
support.

184
00:08:00,640 --> 00:08:01,640
Yeah, exactly.

185
00:08:01,640 --> 00:08:03,080
So tell me about Loom.

186
00:08:03,080 --> 00:08:04,080
This is your thing.

187
00:08:04,080 --> 00:08:05,080
Yeah.

188
00:08:05,080 --> 00:08:06,080
Oh yeah.

189
00:08:06,080 --> 00:08:07,080
So let's just move right along.

190
00:08:07,080 --> 00:08:10,520
Cause we've got a, you know, this show, it's gotta, it's gotta move.

191
00:08:10,520 --> 00:08:13,920
So Mike, we were just talking about JavaScript, right?

192
00:08:13,920 --> 00:08:19,840
And well, it's funny because a lot of people liked node because of the concurrency story,

193
00:08:19,840 --> 00:08:20,840
right?

194
00:08:20,840 --> 00:08:23,640
It could, it could do, you know, 10, 10 X connections.

195
00:08:23,640 --> 00:08:27,240
It could scale those connections and had that event loop built right in.

196
00:08:27,240 --> 00:08:32,560
But the downside is of course you've got asynchronous JavaScript, which can just be a big old mess

197
00:08:32,560 --> 00:08:33,560
of callbacks.

198
00:08:33,560 --> 00:08:34,560
Right?

199
00:08:34,560 --> 00:08:35,560
I don't know.

200
00:08:35,560 --> 00:08:36,560
What's your, where do you fall?

201
00:08:36,560 --> 00:08:39,040
What do you usually do when you need, you know, concurrent software?

202
00:08:39,040 --> 00:08:40,040
What's your tool set?

203
00:08:40,040 --> 00:08:42,720
Oh, it depends on the language.

204
00:08:42,720 --> 00:08:47,440
I mean, if I'm in.net or really anything else that supports a sync away, I tend to lean

205
00:08:47,440 --> 00:08:48,440
on that.

206
00:08:48,440 --> 00:08:52,160
Um, but yeah, in JavaScript I'm, I'm living in callback hell.

207
00:08:52,160 --> 00:08:53,160
Okay.

208
00:08:53,160 --> 00:08:54,160
That, that makes sense.

209
00:08:54,160 --> 00:08:57,880
Um, how do you like async await over in the.net world?

210
00:08:57,880 --> 00:08:59,560
I like it.

211
00:08:59,560 --> 00:09:08,520
It so it's a really, it's a really big, my opinion is a huge abstraction and well 99%

212
00:09:08,520 --> 00:09:09,880
of the time I think it's great.

213
00:09:09,880 --> 00:09:14,360
It saves me from, you know, just having really ugly looking code that's hard to maintain

214
00:09:14,360 --> 00:09:18,440
every once in a while you get like weird edge cases where you accidentally lock something

215
00:09:18,440 --> 00:09:21,800
up or things don't finish the way you think they're going to finish.

216
00:09:21,800 --> 00:09:22,800
Oh yeah.

217
00:09:22,800 --> 00:09:26,800
And then you have some bad concurrency states and everything goes to hell.

218
00:09:26,800 --> 00:09:27,800
Yeah.

219
00:09:27,800 --> 00:09:30,720
Cause what it's doing is every time you, you type the await keyword and it compiles, it's

220
00:09:30,720 --> 00:09:33,560
actually generating a bunch of code behind that.

221
00:09:33,560 --> 00:09:37,560
And it's, it's, so it's not like, it's not removing the need for crazy callbacks and

222
00:09:37,560 --> 00:09:38,560
concurrent.

223
00:09:38,560 --> 00:09:39,560
Right.

224
00:09:39,560 --> 00:09:42,160
It just, the compiler like makes you a state machine to do all of that for you.

225
00:09:42,160 --> 00:09:43,160
Exactly.

226
00:09:43,160 --> 00:09:44,160
Yeah, exactly.

227
00:09:44,160 --> 00:09:47,480
Well, we can dive into it later if we want, but Clojure's got this similar mechanism.

228
00:09:47,480 --> 00:09:50,840
There's is just shipped as a macro, the go macro, which will implement basically the

229
00:09:50,840 --> 00:09:51,840
same idea.

230
00:09:51,840 --> 00:09:55,520
Um, so that's, so that's one way of people that people deal with it, right?

231
00:09:55,520 --> 00:10:00,560
So we have, you've got like bear callbacks, um, promises are being seen a lot these days,

232
00:10:00,560 --> 00:10:02,400
which sort of revise it up one level.

233
00:10:02,400 --> 00:10:05,720
At least then you've got something you can, you know, hold in a variable you can interact

234
00:10:05,720 --> 00:10:06,720
with.

235
00:10:06,720 --> 00:10:10,100
Uh, it's a little more than just waiting, knowing it's sitting in the queue to be executed

236
00:10:10,100 --> 00:10:12,120
somewhere in the runtime.

237
00:10:12,120 --> 00:10:15,880
And then you've got compiler options where the compiler or a macro or something can help

238
00:10:15,880 --> 00:10:17,880
you manage some of the complexity.

239
00:10:17,880 --> 00:10:23,240
But we've got a link in the show notes for a great article that talks about what color

240
00:10:23,240 --> 00:10:28,880
is your function and that, that a synchronicity can leak throughout your code base and anytime

241
00:10:28,880 --> 00:10:31,880
you touch it, you sort of start to feel it.

242
00:10:31,880 --> 00:10:37,360
Project Loom is trying to solve some of that by going one level deeper and trying to fix

243
00:10:37,360 --> 00:10:38,480
it at the runtime.

244
00:10:38,480 --> 00:10:44,320
So one thing that, uh, you know, a number of languages that are thought of as good for

245
00:10:44,320 --> 00:10:50,760
concurrency like Go or Erlang, well, they've got some lightweight threads and that's something

246
00:10:50,760 --> 00:10:54,800
Java, there was, there was proposals way back in the day, but it really has never been there.

247
00:10:54,800 --> 00:11:01,360
And we just have to rely on either async callbacks in Java or regular old blocking calls.

248
00:11:01,360 --> 00:11:07,680
Obviously that has problems scaling, enter project loom and fibers, which are lightweight

249
00:11:07,680 --> 00:11:12,720
threads you can use as if they were just OS threads.

250
00:11:12,720 --> 00:11:18,640
The JVM will manage running those on actual physical cores on OS threads for you.

251
00:11:18,640 --> 00:11:19,640
Interesting.

252
00:11:19,640 --> 00:11:23,560
So have you, have you been able to use this yet?

253
00:11:23,560 --> 00:11:28,560
I've played with, uh, so it looks like the, there was previously a project called Quasar,

254
00:11:28,560 --> 00:11:33,920
which did this already, but basically looked at the generated byte code and did some, some

255
00:11:33,920 --> 00:11:37,960
introspecting and changing and modifying of it on the fly to achieve the same effect because

256
00:11:37,960 --> 00:11:40,940
it wasn't supported upstream in the JVM.

257
00:11:40,940 --> 00:11:44,620
That the person behind that project is now working for Oracle and working on project

258
00:11:44,620 --> 00:11:48,520
loom as well with some other researchers, of course.

259
00:11:48,520 --> 00:11:53,440
So I've used that earlier incarnation a little bit, not in production or anything too serious,

260
00:11:53,440 --> 00:11:54,440
but it was neat.

261
00:11:54,440 --> 00:11:58,480
And I have played with, uh, well, I've mostly played with Elixir, but I've used the beam

262
00:11:58,480 --> 00:12:01,400
VM, uh, which has similar lightweight threads.

263
00:12:01,400 --> 00:12:03,280
They call them processes over there.

264
00:12:03,280 --> 00:12:04,280
Interesting, interesting.

265
00:12:04,280 --> 00:12:10,860
And remind me, I don't want to let you off the hook cause you mentioned Elixir.

266
00:12:10,860 --> 00:12:16,560
So I have to hear the pitch for Elixir, but what I didn't understand from reading this

267
00:12:16,560 --> 00:12:24,320
was it looks like it's still calling OS, uh, threads on the, underneath it all, right?

268
00:12:24,320 --> 00:12:25,320
Yes, it does.

269
00:12:25,320 --> 00:12:26,320
Okay.

270
00:12:26,320 --> 00:12:31,000
Uh, but it can implement, it's basically taking the, um, like the parking that happens in

271
00:12:31,000 --> 00:12:32,000
that state machine.

272
00:12:32,000 --> 00:12:36,360
Um, we were talking about for like async await, uh, it's taking that and being able to do

273
00:12:36,360 --> 00:12:37,680
it at the runtime layer.

274
00:12:37,680 --> 00:12:42,160
So once you're running on these lightweight threads, it can figure out that you're blocked

275
00:12:42,160 --> 00:12:46,920
waiting for some IO and it'll just park that, it'll schedule it off a real OS thread.

276
00:12:46,920 --> 00:12:50,460
And then once that input's received, it can put it back on the thread and then mostly

277
00:12:50,460 --> 00:12:52,920
it's going to be built, I think just on top of the regular fork join.

278
00:12:52,920 --> 00:12:57,400
So they've just got the scheduling layer on top.

279
00:12:57,400 --> 00:12:58,400
Layer on top.

280
00:12:58,400 --> 00:12:59,400
Right.

281
00:12:59,400 --> 00:13:02,840
And theoretically being the JVM, you would avoid any weird issues with like different

282
00:13:02,840 --> 00:13:04,800
threadings on different OS's being.

283
00:13:04,800 --> 00:13:08,360
Yeah, you would hope that the VM would have that abstraction there for you.

284
00:13:08,360 --> 00:13:09,360
Right.

285
00:13:09,360 --> 00:13:12,320
Looks to scan at windows 10 because thanks guys.

286
00:13:12,320 --> 00:13:13,400
Yeah, exactly.

287
00:13:13,400 --> 00:13:17,160
So this was just appealing for me because it seems like a pretty clean, if you, if they

288
00:13:17,160 --> 00:13:21,600
get it right, it seems like a nice thing to be able to build upon because instead of having

289
00:13:21,600 --> 00:13:26,260
to, you know, have either just like you can do a thread, let's say you're making some

290
00:13:26,260 --> 00:13:28,240
long running HTTP request.

291
00:13:28,240 --> 00:13:31,840
If you put each of those on the thread, well that'll just only scale so far.

292
00:13:31,840 --> 00:13:36,880
And that's why a lot of people have been driven to asynchronous APIs in the first place.

293
00:13:36,880 --> 00:13:38,660
With this you get the best of both worlds.

294
00:13:38,660 --> 00:13:39,660
You can write your code.

295
00:13:39,660 --> 00:13:45,200
It looks like it's just regular blocking code and in some sense it is, it's just managed

296
00:13:45,200 --> 00:13:46,320
below that layer for you.

297
00:13:46,320 --> 00:13:51,560
So you can have a green thread per HTTP request and you don't have to care about it and it'll

298
00:13:51,560 --> 00:13:56,000
just handle all the scheduling so that they execute in the order they need to.

299
00:13:56,000 --> 00:13:57,720
Wow.

300
00:13:57,720 --> 00:14:00,800
We are living in a world of asynchronous abstraction glory.

301
00:14:00,800 --> 00:14:01,880
I know, right?

302
00:14:01,880 --> 00:14:06,360
So this is probably a long way off to actually see it in production and in production JVM

303
00:14:06,360 --> 00:14:07,800
on your servers.

304
00:14:07,800 --> 00:14:13,020
But I'm glad that it's happening because, you know, the JVM, it just remains so popular.

305
00:14:13,020 --> 00:14:14,020
So many places use it.

306
00:14:14,020 --> 00:14:15,440
It's, it is a powerhouse.

307
00:14:15,440 --> 00:14:19,240
It's got some of the best just in time compiling out there.

308
00:14:19,240 --> 00:14:21,080
So many man hours have been used for it.

309
00:14:21,080 --> 00:14:22,080
Not everyone loves it.

310
00:14:22,080 --> 00:14:24,840
It's kind of weird, especially when you're dealing with, I don't know, weird class path

311
00:14:24,840 --> 00:14:29,000
construction or the way it handles certificates, which are just absolutely deplore.

312
00:14:29,000 --> 00:14:30,000
Yeah.

313
00:14:30,000 --> 00:14:33,220
Either way, it's fast and it's been battle tested over a lot of years.

314
00:14:33,220 --> 00:14:38,480
So if we can get even better concurrency primitives on it, there's a huge amount of programmers

315
00:14:38,480 --> 00:14:39,480
that stand to benefit.

316
00:14:39,480 --> 00:14:40,480
Oh yeah.

317
00:14:40,480 --> 00:14:46,840
No, I could, yeah, for large scale JV Java based applications, that would be pretty significant.

318
00:14:46,840 --> 00:14:47,840
Absolutely.

319
00:14:47,840 --> 00:14:50,140
So you mentioned Elixir.

320
00:14:50,140 --> 00:14:56,280
So elevator pitch me, what are you doing in Elixir and why Elixir?

321
00:14:56,280 --> 00:14:58,320
I made a couple of toy projects.

322
00:14:58,320 --> 00:15:00,120
I haven't done anything too serious.

323
00:15:00,120 --> 00:15:04,080
I'd always just been curious about the beam VM.

324
00:15:04,080 --> 00:15:08,760
It has an interesting history coming out of the telecommunications industry and Ericsson

325
00:15:08,760 --> 00:15:09,760
in particular.

326
00:15:09,760 --> 00:15:15,260
And it's been widely respected in like VoIP circles for running a lot of those hardware

327
00:15:15,260 --> 00:15:20,600
appliances and software projects and being scalable and low latency.

328
00:15:20,600 --> 00:15:25,880
Elixir is, well, Erlang came out, the first version was actually just in prologue.

329
00:15:25,880 --> 00:15:31,080
So it has weird prologue like syntax, which is not everyone's piece of cake.

330
00:15:31,080 --> 00:15:32,800
I can understand that.

331
00:15:32,800 --> 00:15:39,720
Elixir is a new language that sits on top of the beam VM, inherits a lot from Erlang,

332
00:15:39,720 --> 00:15:44,560
is inspired by Erlang, but it comes with a friendlier, more, they call it Ruby inspired.

333
00:15:44,560 --> 00:15:48,440
It's not really like Ruby, but it's got the basic sort of syntax, you know, if you squint

334
00:15:48,440 --> 00:15:53,320
at the screen, it looks like Ruby and it's a lot more traditional.

335
00:15:53,320 --> 00:16:00,280
It's also just a little more, Erlang's great, but it came out of the late 80s, 90s, that

336
00:16:00,280 --> 00:16:01,920
era is when it first saw a lot of its growth.

337
00:16:01,920 --> 00:16:04,760
So it's just a bit dated.

338
00:16:04,760 --> 00:16:08,760
Elixir has a lot more niceties, more like a literal syntax for different sort of data

339
00:16:08,760 --> 00:16:12,480
structures, more just sugar, I would say.

340
00:16:12,480 --> 00:16:13,480
Okay.

341
00:16:13,480 --> 00:16:16,880
So it's in a lot of ways like a modernized.

342
00:16:16,880 --> 00:16:17,880
Yeah.

343
00:16:17,880 --> 00:16:18,880
Yep.

344
00:16:18,880 --> 00:16:19,880
I would say so.

345
00:16:19,880 --> 00:16:23,340
You know, there's anyone who loves both those languages would have a, that would be, should

346
00:16:23,340 --> 00:16:26,200
be shouting at us right now because there's a lot more intricacies for that and there's

347
00:16:26,200 --> 00:16:30,520
a large community with a lot of history that I can't capture in a 10 second spiel.

348
00:16:30,520 --> 00:16:34,980
But yes, they share a lot of that same background and they fit really well for those same things.

349
00:16:34,980 --> 00:16:40,240
So famously like Erlang runs the WhatsApp servers and it works really well for that

350
00:16:40,240 --> 00:16:43,800
because you can get lots of, lots of simultaneous connections.

351
00:16:43,800 --> 00:16:45,720
All of the just like, yeah, they have a weird stack.

352
00:16:45,720 --> 00:16:47,120
It's FreeBSD and Erlang.

353
00:16:47,120 --> 00:16:51,160
So both kind of secret weapons, I guess, and they have big honking.

354
00:16:51,160 --> 00:16:54,040
There's always those BSD guys at the show, right, at the trade show.

355
00:16:54,040 --> 00:16:55,040
There has to be.

356
00:16:55,040 --> 00:16:56,040
Yeah.

357
00:16:56,040 --> 00:16:57,040
And it's, you know, it's part of the community.

358
00:16:57,040 --> 00:17:00,720
And so they got these big honking BSD servers running Erlang and just getting millions of

359
00:17:00,720 --> 00:17:02,560
concurrent connections to them.

360
00:17:02,560 --> 00:17:06,380
And you know, they're not necessarily like, the beam is not as fast for computational

361
00:17:06,380 --> 00:17:08,200
things as the JVM is.

362
00:17:08,200 --> 00:17:12,640
But if you're just doing like message passaging, some web sockets, maybe is a use this sees

363
00:17:12,640 --> 00:17:16,720
a lot where you want low latency, fast response, and just to shove some signaling data through

364
00:17:16,720 --> 00:17:21,920
rather than like a big pipe of real data beams your guy.

365
00:17:21,920 --> 00:17:22,920
Very cool.

366
00:17:22,920 --> 00:17:23,920
Yeah.

367
00:17:23,920 --> 00:17:27,220
I was actually just at a dev meetup and there was like three guys just like hunched over

368
00:17:27,220 --> 00:17:28,220
their MacBooks.

369
00:17:28,220 --> 00:17:30,360
Yes, they were MacBooks.

370
00:17:30,360 --> 00:17:36,520
And just I walked up and said, hey, what are you guys working on?

371
00:17:36,520 --> 00:17:38,000
Oh, we're doing something in Elixir.

372
00:17:38,000 --> 00:17:39,000
I said, what?

373
00:17:39,000 --> 00:17:40,000
Why?

374
00:17:40,000 --> 00:17:44,600
You know, cause you go to these things, 90% of the people that are like making websites

375
00:17:44,600 --> 00:17:45,600
or iOS apps, right?

376
00:17:45,600 --> 00:17:46,600
Totally.

377
00:17:46,600 --> 00:17:47,600
Yeah.

378
00:17:47,600 --> 00:17:48,600
Yeah.

379
00:17:48,600 --> 00:17:49,600
None of it's like crazy.

380
00:17:49,600 --> 00:17:50,600
Just run of the mill software projects.

381
00:17:50,600 --> 00:17:51,600
Yeah.

382
00:17:51,600 --> 00:17:52,600
Run of the mill normal stuff.

383
00:17:52,600 --> 00:17:57,160
But yeah, I keep hearing about it and I keep trying to figure out what the actual use case

384
00:17:57,160 --> 00:17:59,880
I've heard the view over IP thing before.

385
00:17:59,880 --> 00:18:00,880
I didn't know about what's out there.

386
00:18:00,880 --> 00:18:01,880
That's pretty cool.

387
00:18:01,880 --> 00:18:02,880
Yeah.

388
00:18:02,880 --> 00:18:06,740
I think the other thing about Elixir, which maybe makes it a good story for people just

389
00:18:06,740 --> 00:18:09,480
getting into it is it does have a lot of those nice primitives.

390
00:18:09,480 --> 00:18:12,800
It's got a good functional programming story, mutabilities there.

391
00:18:12,800 --> 00:18:18,680
It also has great documentation and the creator of the language, I think his name's Jose Valim.

392
00:18:18,680 --> 00:18:19,680
He's just, he's awesome.

393
00:18:19,680 --> 00:18:23,920
He does, he goes to conferences, does all kinds of good spieling about it in the documentation.

394
00:18:23,920 --> 00:18:25,360
It's geared towards new users.

395
00:18:25,360 --> 00:18:26,520
It's easy to get started.

396
00:18:26,520 --> 00:18:28,080
It's probably already in, you know, it's in brew.

397
00:18:28,080 --> 00:18:29,580
It's in a lot of package managers.

398
00:18:29,580 --> 00:18:33,200
You get a nice little interactive rebel to play with it.

399
00:18:33,200 --> 00:18:34,520
It's just super fun to get started with.

400
00:18:34,520 --> 00:18:37,720
I haven't, yeah, I haven't used it for anything serious, but it was so easy to get started.

401
00:18:37,720 --> 00:18:39,040
I was like, there's really no excuse.

402
00:18:39,040 --> 00:18:40,440
I'll try to do a couple of things.

403
00:18:40,440 --> 00:18:44,880
And it is fun to be thinking in that concurrency style where you can just make a process for

404
00:18:44,880 --> 00:18:45,880
whatever.

405
00:18:45,880 --> 00:18:47,000
You have processes to store data.

406
00:18:47,000 --> 00:18:49,880
You have processes to make HTTP requests.

407
00:18:49,880 --> 00:18:52,360
You have processes to do basically anything you want.

408
00:18:52,360 --> 00:18:59,120
And that Erlang VM in its ADC glory handles all the scheduling.

409
00:18:59,120 --> 00:19:00,120
That's really awesome.

410
00:19:00,120 --> 00:19:01,120
Yeah.

411
00:19:01,120 --> 00:19:06,840
The other nice part too is you get access to OTP, which is the open telephony system

412
00:19:06,840 --> 00:19:11,860
or protocol project, whatever the P stands for.

413
00:19:11,860 --> 00:19:15,120
That is a lot of the stuff that gets bundled with Erlang.

414
00:19:15,120 --> 00:19:19,400
It's its own project, but has historically been developed with Erlang and it adds a lot

415
00:19:19,400 --> 00:19:23,600
of sort of the redundancy fault tolerance supervision structure that Erlang is known

416
00:19:23,600 --> 00:19:27,740
for because you know, when you're running a big telco switch, you can't really tolerate

417
00:19:27,740 --> 00:19:29,140
very much downtime.

418
00:19:29,140 --> 00:19:33,280
So it's good at things like hot reloading and it's really good at instead of having

419
00:19:33,280 --> 00:19:38,120
to deal with all the error pads, you just sort of set up a tree of supervised actors

420
00:19:38,120 --> 00:19:42,060
and you can configure things like a restart, how many retries should I do before I fail

421
00:19:42,060 --> 00:19:43,460
up to the next level?

422
00:19:43,460 --> 00:19:47,420
And how do I restart or, you know, do I have things I need to do before I run or after

423
00:19:47,420 --> 00:19:48,420
I run?

424
00:19:48,420 --> 00:19:50,240
And all of that's in that library for you.

425
00:19:50,240 --> 00:19:55,120
So you can, it really has like primitives to build a distributed system in a reliable

426
00:19:55,120 --> 00:20:01,800
way baked right into the runtime and the popular libraries.

427
00:20:01,800 --> 00:20:02,800
Very cool.

428
00:20:02,800 --> 00:20:06,080
So Closures is not your true, true love, is it?

429
00:20:06,080 --> 00:20:07,920
No, no, it wouldn't be.

430
00:20:07,920 --> 00:20:09,840
That's still Closure, of course.

431
00:20:09,840 --> 00:20:12,400
Ah, lay it on me, man.

432
00:20:12,400 --> 00:20:15,640
You know, I've just been really enjoying it.

433
00:20:15,640 --> 00:20:19,300
There's been some good developments going on since the last time we talked about it.

434
00:20:19,300 --> 00:20:23,680
In particular, the Closure community, I mean, lots of communities are good.

435
00:20:23,680 --> 00:20:27,340
It's a little bit, it's small enough that it can have a character of its own.

436
00:20:27,340 --> 00:20:30,800
Of course, there's still different pieces of it and all kinds of unique personalities

437
00:20:30,800 --> 00:20:36,920
that are involved, but it's a unique set of, Clojure's not often a first programmer's language.

438
00:20:36,920 --> 00:20:41,260
It's sort of a grumpy old programmer's language who got sick of fighting Java or JavaScript

439
00:20:41,260 --> 00:20:44,000
or whatever else and wanted something better.

440
00:20:44,000 --> 00:20:47,400
So it can be tough, a bit tough for people to pick up for the first language, but as

441
00:20:47,400 --> 00:20:52,200
a result, most of the people doing it are experienced senior programmers.

442
00:20:52,200 --> 00:20:55,560
So you get a lot of, there's a lot of maturity in the community, and while they have a lot

443
00:20:55,560 --> 00:20:59,580
of respect for academia, and one of the things they love to do as a community is pull great

444
00:20:59,580 --> 00:21:04,120
ideas from papers from the 70s and then implement them, but they do that with an air to being

445
00:21:04,120 --> 00:21:07,980
pragmatic because they all work at day jobs programming and just want to get stuff done

446
00:21:07,980 --> 00:21:10,380
and build reliable systems.

447
00:21:10,380 --> 00:21:12,680
So it's like.NET, but stable.

448
00:21:12,680 --> 00:21:13,680
I'm kidding.

449
00:21:13,680 --> 00:21:14,680
Yeah, totally.

450
00:21:14,680 --> 00:21:15,680
Totally.

451
00:21:15,680 --> 00:21:16,680
It even runs on.NET.

452
00:21:16,680 --> 00:21:19,920
There's a version that compiles to the CLR.

453
00:21:19,920 --> 00:21:25,920
It's not much used compared to the JVM or JS, but there is a project to get it to run

454
00:21:25,920 --> 00:21:31,360
well on mono and then you can hook it up to Unity, which is kind of neat.

455
00:21:31,360 --> 00:21:35,500
That would be the most hardcore game on Humble Bundle.

456
00:21:35,500 --> 00:21:36,500
You mentioned JS.

457
00:21:36,500 --> 00:21:40,840
Now is that JS via transpiling to JavaScript or is it WebAssembly?

458
00:21:40,840 --> 00:21:48,880
Yes, it is ClojureScript, which is a project written in Clojure that is a compiler that

459
00:21:48,880 --> 00:21:50,920
compiles a Clojure-like dialect.

460
00:21:50,920 --> 00:21:55,280
They're like 98% the same to JavaScript.

461
00:21:55,280 --> 00:21:58,000
It's Clojure inception there.

462
00:21:58,000 --> 00:22:04,120
ClojureScript is written in Clojure and what ClojureScript does is it compiles a dialect

463
00:22:04,120 --> 00:22:05,120
of Clojure?

464
00:22:05,120 --> 00:22:06,120
Yes.

465
00:22:06,120 --> 00:22:07,440
And then it compiles that to JavaScript.

466
00:22:07,440 --> 00:22:13,440
Let me spin my little thing here to see if I'm awake or not.

467
00:22:13,440 --> 00:22:19,840
So theoretically you're writing an application, again Clojure is one that I haven't done anything

468
00:22:19,840 --> 00:22:22,520
but I've been curious.

469
00:22:22,520 --> 00:22:23,520
You're writing an application.

470
00:22:23,520 --> 00:22:27,820
I'm assuming you're writing server software and you need some sort of front end because

471
00:22:27,820 --> 00:22:29,480
that's life.

472
00:22:29,480 --> 00:22:32,200
People want to look at your data that you've spent all this time making for them.

473
00:22:32,200 --> 00:22:33,200
Shocking.

474
00:22:33,200 --> 00:22:34,200
You can't just say the data's there, I promise.

475
00:22:34,200 --> 00:22:38,200
I've got a JSON blob for you if you want to go send a GET request over here.

476
00:22:38,200 --> 00:22:39,200
Does that work?

477
00:22:39,200 --> 00:22:44,600
If I really don't like you it's going to be XML.

478
00:22:44,600 --> 00:22:46,760
Is your full stack Clojure?

479
00:22:46,760 --> 00:22:49,320
Obviously you probably have CSS and all that.

480
00:22:49,320 --> 00:22:53,740
That is one of the compelling stories for ClojureScript is you can have full stack and

481
00:22:53,740 --> 00:22:59,600
you can share a lot of it because it's mostly just all the host primitives that are going

482
00:22:59,600 --> 00:23:01,520
to end up different.

483
00:23:01,520 --> 00:23:05,960
There's now compiler support so you can have a project that has three types of files, a

484
00:23:05,960 --> 00:23:14,240
.clj for pure Clojure, a.cljs for ClojureScript, and a.cljc which can be compiled as either.

485
00:23:14,240 --> 00:23:18,040
So you can have a bunch of definitions of things, you can have protocols implemented

486
00:23:18,040 --> 00:23:21,760
or any kind of abstraction that isn't going to see a direct implementation on top of the

487
00:23:21,760 --> 00:23:22,760
host.

488
00:23:22,760 --> 00:23:27,240
All of that can be shared in these.cljc files and then you can just implement the pull from

489
00:23:27,240 --> 00:23:33,320
that big standard library that you've made yourself there from both sides of it.

490
00:23:33,320 --> 00:23:35,520
So you can reuse your standard library?

491
00:23:35,520 --> 00:23:36,520
Yes.

492
00:23:36,520 --> 00:23:38,480
So your standard library, it's not just...

493
00:23:38,480 --> 00:23:39,480
Yeah, right.

494
00:23:39,480 --> 00:23:42,960
So you can make any sort of amount of code as long as, I mean, sometimes you need to

495
00:23:42,960 --> 00:23:44,840
have slight differences for the two platforms.

496
00:23:44,840 --> 00:23:49,320
But by and large, you can see projects where most of it is written in CLJC and then they've

497
00:23:49,320 --> 00:23:52,440
got a couple, you know, oh, here's a couple of things that we've got to do, the thread

498
00:23:52,440 --> 00:23:58,320
in on the server part, and here's the thing we've got to do, the UI part, or...

499
00:23:58,320 --> 00:23:59,720
So it's pretty flexible in that regard.

500
00:23:59,720 --> 00:24:03,600
And you can see a lot of, you know, they have the same data structures, and so there's several

501
00:24:03,600 --> 00:24:08,800
neat projects that have libraries for both the back end and the front end, and it does

502
00:24:08,800 --> 00:24:10,280
all the serialization and stuff for you.

503
00:24:10,280 --> 00:24:14,760
There's already several formats, one that's very fast, one that's very human readable,

504
00:24:14,760 --> 00:24:17,540
to handle Clojure data structures back and forth.

505
00:24:17,540 --> 00:24:18,540
So you can have...

506
00:24:18,540 --> 00:24:22,560
One of them, I think it's Sente, it's like a WebSocket abstraction, you can just have

507
00:24:22,560 --> 00:24:26,560
a WebSocket between your server and your client and just throw Clojure data structures across

508
00:24:26,560 --> 00:24:31,480
it and pick it up and you don't have to, there's no, you know, no mapping to different objects

509
00:24:31,480 --> 00:24:35,600
and different object systems between the languages, there's just a low impedance and it works

510
00:24:35,600 --> 00:24:37,680
really nicely.

511
00:24:37,680 --> 00:24:43,920
So is there like a popular development framework where obviously Python has like Django, Ruby

512
00:24:43,920 --> 00:24:44,920
has Rails?

513
00:24:44,920 --> 00:24:47,920
No, that's a good question.

514
00:24:47,920 --> 00:24:52,080
That's another thing Elixir has going forward is they've got Phoenix, which is a popular

515
00:24:52,080 --> 00:24:56,520
framework which is compared to Rails.

516
00:24:56,520 --> 00:25:02,440
Clojure not really, that is one aspect of its community that's a bit odd is it's almost

517
00:25:02,440 --> 00:25:07,560
like the Unix philosophy, there's a lot of composition, so they really tend to prefer

518
00:25:07,560 --> 00:25:11,600
libraries from frameworks, and I think again this stems out of the more mature community

519
00:25:11,600 --> 00:25:14,680
base because Rails is great, especially if you're starting a project, you don't really

520
00:25:14,680 --> 00:25:17,960
know where it's going to go, maybe you're not that, you haven't done doing it that long,

521
00:25:17,960 --> 00:25:21,080
Rails handles all the things that have to get handled but you don't necessarily care

522
00:25:21,080 --> 00:25:22,080
about right away.

523
00:25:22,080 --> 00:25:26,080
You know, I don't really care how the CSRF protection works, maybe later I need to customize

524
00:25:26,080 --> 00:25:30,720
it when I start doing that part of my project, but just throw it in there for me.

525
00:25:30,720 --> 00:25:35,280
Clojure's much more, they've got a lot of components that you can use to build a system

526
00:25:35,280 --> 00:25:37,440
of any kind that you want.

527
00:25:37,440 --> 00:25:40,680
Now there are some standard defaults out there and there's a couple sort of like project

528
00:25:40,680 --> 00:25:45,680
templates, you know, you can use to set it up and just sort of easily add like, oh here

529
00:25:45,680 --> 00:25:49,240
I'm going to do a full stack one, or this is just going to be a server, or this is a

530
00:25:49,240 --> 00:25:53,640
node project, and they'll just lay that all out for you, but you're still going to see

531
00:25:53,640 --> 00:25:54,640
all the pieces.

532
00:25:54,640 --> 00:25:59,200
Oh yeah, so ClojureScript also targets node, which is neat.

533
00:25:59,200 --> 00:26:01,960
Well, I mean everything targets node now, right?

534
00:26:01,960 --> 00:26:05,640
I can't get up and throw a rock without hitting a node developer these days.

535
00:26:05,640 --> 00:26:06,640
No you cannot.

536
00:26:06,640 --> 00:26:07,640
That is...

537
00:26:07,640 --> 00:26:12,120
So that's interesting though, so theoretically, I mean this is probably a terrible comparison,

538
00:26:12,120 --> 00:26:17,240
ClojureScript would be like TypeScript, you could theoretically use the node framework

539
00:26:17,240 --> 00:26:18,880
and just like the language of your choice?

540
00:26:18,880 --> 00:26:19,880
Yeah, yeah.

541
00:26:19,880 --> 00:26:20,880
Absolutely.

542
00:26:20,880 --> 00:26:24,560
So I've been working, I should actually pick it up again, I stopped working on it, but

543
00:26:24,560 --> 00:26:31,720
I was working on a Alexa app using the JS APIs, but using ClojureScript.

544
00:26:31,720 --> 00:26:34,920
Interesting, okay.

545
00:26:34,920 --> 00:26:38,080
Other than that, I'll later just probably go run on a Lambda running on node, and it'll

546
00:26:38,080 --> 00:26:39,080
just work.

547
00:26:39,080 --> 00:26:40,880
And there you go, and you're good.

548
00:26:40,880 --> 00:26:44,640
Yeah, and that's been interesting too, because I've done some Java, but I didn't have a huge

549
00:26:44,640 --> 00:26:48,840
Java background when I started learning Clojure, and I'd done more JavaScript.

550
00:26:48,840 --> 00:26:50,180
So there's a lot of libraries.

551
00:26:50,180 --> 00:26:54,360
One thing that is great and makes Clojure pretty easy is that there are direct Clojure

552
00:26:54,360 --> 00:26:58,800
libraries for things, but by and large, because the host interrupt is meant to be so good,

553
00:26:58,800 --> 00:27:02,560
and it is just really, it's really clear, you can just do all the host things from Clojure

554
00:27:02,560 --> 00:27:07,680
no problem, so you can use any either Java or JavaScript library, pull it right in and

555
00:27:07,680 --> 00:27:11,640
use it just like it was the host language, so you would just have this huge application

556
00:27:11,640 --> 00:27:15,720
base of software that's been already written for you, and you can just tie it together.

557
00:27:15,720 --> 00:27:17,640
So you could just pull in jars, basically.

558
00:27:17,640 --> 00:27:19,120
Yep, absolutely.

559
00:27:19,120 --> 00:27:22,360
And then you can, from the ClojureScript side, you can use NPM.

560
00:27:22,360 --> 00:27:24,480
Wow, okay.

561
00:27:24,480 --> 00:27:28,680
So that actually brings up another great question.

562
00:27:28,680 --> 00:27:32,800
So I'm looking at a, we've talked about it, I think, six months ago, last time you and

563
00:27:32,800 --> 00:27:33,800
I talked.

564
00:27:33,800 --> 00:27:34,800
Yeah, whenever that was.

565
00:27:34,800 --> 00:27:36,800
Yeah, it was like, it feels like a hundred years now.

566
00:27:36,800 --> 00:27:38,000
I think it might have been a hundred years.

567
00:27:38,000 --> 00:27:39,000
You're absolutely right.

568
00:27:39,000 --> 00:27:40,000
Last century.

569
00:27:40,000 --> 00:27:41,000
Nice to see you.

570
00:27:41,000 --> 00:27:44,560
Yeah, somehow the fashions come back around, so we still look great.

571
00:27:44,560 --> 00:27:46,080
I told you, we got to keep all our clothes.

572
00:27:46,080 --> 00:27:47,080
Now we sell them to hipsters.

573
00:27:47,080 --> 00:27:48,080
They're vintage.

574
00:27:48,080 --> 00:27:50,320
And these sweet mustaches we've grown.

575
00:27:50,320 --> 00:27:51,320
That's right.

576
00:27:51,320 --> 00:27:54,000
Top hats are back.

577
00:27:54,000 --> 00:27:59,660
How adept does one have to be at Java and kind of like the whole Java ecosystem to successfully

578
00:27:59,660 --> 00:28:00,660
start with Clojure?

579
00:28:00,660 --> 00:28:04,320
Is it a prerequisite or can you just kind of get on with it?

580
00:28:04,320 --> 00:28:07,560
I would say you don't really have to start with it.

581
00:28:07,560 --> 00:28:10,400
You're going to have to learn some things as you go along, like certainly you have to

582
00:28:10,400 --> 00:28:12,480
install a JVM onto your system.

583
00:28:12,480 --> 00:28:15,720
So that's probably the most unpleasant part.

584
00:28:15,720 --> 00:28:19,520
Actually recently in the past six months or so, the starting story for Clojure has gotten

585
00:28:19,520 --> 00:28:23,600
a lot better because before Clojure was just a jar, you know, like you just, it was a jar

586
00:28:23,600 --> 00:28:27,480
that you downloaded and that was the Clojure language and runtime and standard library

587
00:28:27,480 --> 00:28:29,160
all in that jar.

588
00:28:29,160 --> 00:28:34,260
So here's a command you can run where you run java-jar and you start up a REPL.

589
00:28:34,260 --> 00:28:39,660
So now they've done a much better job of, one, having that, they have a standalone program

590
00:28:39,660 --> 00:28:43,160
now that has an interface you can use and you just run it and it'll open up a REPL for

591
00:28:43,160 --> 00:28:44,160
you.

592
00:28:44,160 --> 00:28:48,160
It can also handle, instead of having to use Maven or some of the other Clojure-centric

593
00:28:48,160 --> 00:28:53,160
build tooling that's out there, which is all very good and very useful.

594
00:28:53,160 --> 00:28:55,520
This little tool can do that all for you as well.

595
00:28:55,520 --> 00:28:59,520
And it can pull from Git depth, so you can put in Maven coordinates or you can put in

596
00:28:59,520 --> 00:29:04,400
like a Git SHA or a Git tag and it'll pull all that down and handle all that for you.

597
00:29:04,400 --> 00:29:07,520
So that makes it really easy if you just want to like go grab a couple libraries, open a

598
00:29:07,520 --> 00:29:11,760
REPL and start hacking on it.

599
00:29:11,760 --> 00:29:19,680
That said, probably for the first, for a lot of the learning, you really don't need it

600
00:29:19,680 --> 00:29:20,680
that much.

601
00:29:20,680 --> 00:29:25,560
Especially when you do, you'll eventually pull in some Java libraries or maybe work

602
00:29:25,560 --> 00:29:29,160
with some of the Java base API for IO or other things.

603
00:29:29,160 --> 00:29:33,820
So you'll start learning some of the Java things, but if you have even a tiny understanding

604
00:29:33,820 --> 00:29:38,200
of object orientation, I had done way more Python than I had done Java before I started

605
00:29:38,200 --> 00:29:40,480
playing with Clojure and that was more than enough.

606
00:29:40,480 --> 00:29:43,200
It's like, okay, you get what's happening here, here's a method call.

607
00:29:43,200 --> 00:29:44,200
Here's why that works.

608
00:29:44,200 --> 00:29:46,560
Here's what the factory is.

609
00:29:46,560 --> 00:29:47,560
That's all you need.

610
00:29:47,560 --> 00:29:51,760
You don't need to get into any of the complicated, more obscure parts of Java unless you want

611
00:29:51,760 --> 00:29:52,760
to.

612
00:29:52,760 --> 00:29:53,760
Okay.

613
00:29:53,760 --> 00:29:57,280
So yeah, that makes a ton of sense.

614
00:29:57,280 --> 00:29:59,840
So you're still in love with it?

615
00:29:59,840 --> 00:30:03,720
Still everything, any gripes?

616
00:30:03,720 --> 00:30:08,080
Gripes, not a ton.

617
00:30:08,080 --> 00:30:11,960
They've been making progress in a lot of the areas people commonly gripe about.

618
00:30:11,960 --> 00:30:16,760
So one thing that's been hard over the years is error messages because it's a hosted language

619
00:30:16,760 --> 00:30:20,480
and it tries to not hide that it's a hosted language.

620
00:30:20,480 --> 00:30:24,600
So you end up oftentimes with like really long stack traces that go through your code

621
00:30:24,600 --> 00:30:28,760
and then into the Clojure library code and then into JVM code and just this big stack

622
00:30:28,760 --> 00:30:29,760
trace.

623
00:30:29,760 --> 00:30:32,440
And if you're not used to Java or stack traces, that could be hard to read.

624
00:30:32,440 --> 00:30:37,680
Now, I think if you're good at scientific debugging and you already are the sort of

625
00:30:37,680 --> 00:30:41,880
developer who, you know, there's one style where you kind of like have, it's like you're

626
00:30:41,880 --> 00:30:46,900
bowling with guards on the lanes where you're sort of bouncing off the compiler and bouncing

627
00:30:46,900 --> 00:30:48,480
off just running into things.

628
00:30:48,480 --> 00:30:52,220
But if you already have a really good understanding of what you're doing as you're writing your

629
00:30:52,220 --> 00:30:55,240
program and know just like, you know, you have small commits where you know what you

630
00:30:55,240 --> 00:30:57,080
changed and in what areas.

631
00:30:57,080 --> 00:30:59,800
I've never found it to be that big of a deal.

632
00:30:59,800 --> 00:31:04,480
That said, they are putting in a lot of work in that area and it's rapidly getting better.

633
00:31:04,480 --> 00:31:09,220
So I'm hoping to see that improve for people that it really upsets.

634
00:31:09,220 --> 00:31:13,480
So basically, I would completely fail immediately because, you know, my commits, I need at least

635
00:31:13,480 --> 00:31:15,480
10 files, a couple thousand lines.

636
00:31:15,480 --> 00:31:19,760
Well, I mean, as long as you're aware of what you're changing.

637
00:31:19,760 --> 00:31:21,800
Yeah, I'm joking.

638
00:31:21,800 --> 00:31:24,640
Oh man, you're triggering me here.

639
00:31:24,640 --> 00:31:28,120
There's been so many people I've worked with over the years that are just like, either

640
00:31:28,120 --> 00:31:31,920
they didn't get git or they just hated the idea of it because they refused to use it

641
00:31:31,920 --> 00:31:34,040
in any same way.

642
00:31:34,040 --> 00:31:36,400
Here's our Code Reader Tip of the Week.

643
00:31:36,400 --> 00:31:38,520
Don't ever type a git commit tachy.

644
00:31:38,520 --> 00:31:40,160
Just don't do it.

645
00:31:40,160 --> 00:31:41,160
It's bad.

646
00:31:41,160 --> 00:31:42,480
You're going to regret it.

647
00:31:42,480 --> 00:31:45,000
You're probably going to have a rough code review.

648
00:31:45,000 --> 00:31:48,960
Yeah, you have the staging area for a reason, like you should probably use it.

649
00:31:48,960 --> 00:31:56,760
You should like use it and it's unlikely you change six files and only did one thing.

650
00:31:56,760 --> 00:32:02,760
So I will say Clojure is worth learning if people are interested in a lot of the sort

651
00:32:02,760 --> 00:32:06,320
of non, if you take out the statically typed world of functional programming, if you're

652
00:32:06,320 --> 00:32:12,800
just interested in like a data-oriented functional thing, to compare it to like Go or C or some

653
00:32:12,800 --> 00:32:17,060
of the more low-level languages, there's some aspects of programming.

654
00:32:17,060 --> 00:32:21,220
Maybe you're implementing TCP or some other network protocol.

655
00:32:21,220 --> 00:32:22,220
It feels like a state machine.

656
00:32:22,220 --> 00:32:26,840
It feels like a little mechanical thing that you're cranking on the side or the CPU is

657
00:32:26,840 --> 00:32:30,280
cranking it and it goes and you're processing low-level bits.

658
00:32:30,280 --> 00:32:31,480
You're accessing memory.

659
00:32:31,480 --> 00:32:34,060
You're sending little bits of data here and there.

660
00:32:34,060 --> 00:32:37,640
And then there's like the bigger systems, not necessarily even bigger, but there's the

661
00:32:37,640 --> 00:32:41,940
higher level, the more like up towards the human scale of things that are information

662
00:32:41,940 --> 00:32:46,920
processing systems that are really dealing with data, rich data, complex data.

663
00:32:46,920 --> 00:32:50,480
That's the side of things that I'd say Clojure really excels at.

664
00:32:50,480 --> 00:32:52,720
You might still reach down to the host language.

665
00:32:52,720 --> 00:32:55,760
You know, there's a lot of libraries out there that have part of them implemented in Java

666
00:32:55,760 --> 00:32:58,720
for like the really hot, tight inner loops.

667
00:32:58,720 --> 00:33:01,640
And then you just use Clojure on top of that to sort of orchestrate it in a way where you

668
00:33:01,640 --> 00:33:06,480
don't have to have all the overhead of, you know, all the types of Java and all the boilerplate

669
00:33:06,480 --> 00:33:11,240
of Java and just the, you get a nice mutable standard library.

670
00:33:11,240 --> 00:33:12,240
That sounds really cool.

671
00:33:12,240 --> 00:33:16,320
And yeah, the ability to pull in any jar effectively seems awesome.

672
00:33:16,320 --> 00:33:17,320
Yeah.

673
00:33:17,320 --> 00:33:20,080
So you can just kind of leverage it and it's, you know, it's just going to always be more

674
00:33:20,080 --> 00:33:21,280
concise than Java.

675
00:33:21,280 --> 00:33:23,160
And so you have less code to look at.

676
00:33:23,160 --> 00:33:27,880
The other aspect I've really enjoyed and have been consistently surprised by is, so there's

677
00:33:27,880 --> 00:33:31,880
the biggest outlier for Clojure is that it's a dynamic language and it's not statically

678
00:33:31,880 --> 00:33:32,880
typed.

679
00:33:32,880 --> 00:33:33,880
Oh, I didn't know.

680
00:33:33,880 --> 00:33:34,880
I thought it was static.

681
00:33:34,880 --> 00:33:35,880
Okay.

682
00:33:35,880 --> 00:33:36,880
Yeah.

683
00:33:36,880 --> 00:33:39,400
And so that's, that's one thing that people are constantly kind of tripped up by because

684
00:33:39,400 --> 00:33:43,400
it's a weird part of the, if you imagine like a big grid, you know, there's sort of like

685
00:33:43,400 --> 00:33:49,140
dynamically typed and mutable languages like Python and Ruby.

686
00:33:49,140 --> 00:33:52,440
And then there's stuff that is, you know, Haskell on the other corner up here that is

687
00:33:52,440 --> 00:33:56,480
immutable and statically typed and Clojure is immutable and dynamically typed.

688
00:33:56,480 --> 00:34:00,520
And there's just not that many other languages that sit where it sits and it's its own unique

689
00:34:00,520 --> 00:34:01,520
experience.

690
00:34:01,520 --> 00:34:02,520
Yeah, that is interesting.

691
00:34:02,520 --> 00:34:05,520
That isn't so immutable and dynamically typed.

692
00:34:05,520 --> 00:34:09,160
I'm trying to think of what other languages like that.

693
00:34:09,160 --> 00:34:13,920
I think Elixir is pretty close to it in that respect.

694
00:34:13,920 --> 00:34:18,600
Maybe some other like weird Lisp or Lispy, I was thinking like, yeah, yeah, but there's

695
00:34:18,600 --> 00:34:19,600
not that many.

696
00:34:19,600 --> 00:34:24,880
And I think, well, like I have nothing against static typing or Haskell, which I find fascinating.

697
00:34:24,880 --> 00:34:28,440
If you can and want to use Haskell, like do it.

698
00:34:28,440 --> 00:34:32,800
But I think people take their experience of either like Java being too verbose, but like

699
00:34:32,800 --> 00:34:38,160
they'd still like the types there or Python and Ruby growing to be like a big noodly mess

700
00:34:38,160 --> 00:34:39,160
where you have no idea what's happening.

701
00:34:39,160 --> 00:34:42,560
And the Ruby is just sending messages all over the place and you have no idea and it's

702
00:34:42,560 --> 00:34:47,360
all happening at runtime and who the heck knows what's happening in this project anymore.

703
00:34:47,360 --> 00:34:48,360
Monkey patching.

704
00:34:48,360 --> 00:34:49,360
Yeah.

705
00:34:49,360 --> 00:34:50,360
Monkey patching everywhere.

706
00:34:50,360 --> 00:34:51,360
Yes, exactly.

707
00:34:51,360 --> 00:34:55,600
And it's not to say that Clojure is immune from those problems, but the combination of

708
00:34:55,600 --> 00:35:02,120
being really concise and the immutability means it's just not as big of a deal.

709
00:35:02,120 --> 00:35:05,520
You know, you can have something that would be like four or five files in Java, be probably

710
00:35:05,520 --> 00:35:09,640
just like one Clojure file of 100, 200, it depends on exactly what you're doing.

711
00:35:09,640 --> 00:35:11,220
But it's just so much more concise.

712
00:35:11,220 --> 00:35:13,660
You can look at the function and be like, oh, yeah, here we go.

713
00:35:13,660 --> 00:35:15,660
I can understand what's happening because there's less of it.

714
00:35:15,660 --> 00:35:18,040
It's not in three different classes.

715
00:35:18,040 --> 00:35:19,300
That's super cool.

716
00:35:19,300 --> 00:35:20,960
That is like, yeah.

717
00:35:20,960 --> 00:35:26,040
And the other thing, too, is it embraces both data and runtime in a way that I've not seen

718
00:35:26,040 --> 00:35:28,200
very many other languages.

719
00:35:28,200 --> 00:35:32,360
From the runtime aspect, it's almost as much as Smalltalk did, where Smalltalk has its

720
00:35:32,360 --> 00:35:37,120
own sort of crazy running environment.

721
00:35:37,120 --> 00:35:40,920
So it's not quite to that level, but you really feel you're connected to this program.

722
00:35:40,920 --> 00:35:45,880
So when you open up your editor, one people seem to really like is Cursive, which is built

723
00:35:45,880 --> 00:35:47,920
on top of IntelliJ, basically.

724
00:35:47,920 --> 00:35:51,800
So it's familiar to anyone using IntelliJ already, hooks up into Clojure.

725
00:35:51,800 --> 00:35:55,920
But you've got this running REPL connection all the time.

726
00:35:55,920 --> 00:35:59,360
And the way Clojure compiles is a single form at a time.

727
00:35:59,360 --> 00:36:03,240
So you can just evaluate any form in your editor at any time and just send it to your

728
00:36:03,240 --> 00:36:09,080
real system, sort of hack live against it until you've got it to a point that you like.

729
00:36:09,080 --> 00:36:10,080
That is really cool.

730
00:36:10,080 --> 00:36:16,340
Yeah, it's a sort of like jacked into the computer in a way that you don't often experience.

731
00:36:16,340 --> 00:36:18,880
You can see the matrix as long as it's in Clojure.

732
00:36:18,880 --> 00:36:22,040
Yeah, it's all S-expression, so you have to be down with that.

733
00:36:22,040 --> 00:36:29,080
But if you can see past that, it has ruined me a bit for other languages because it's

734
00:36:29,080 --> 00:36:30,080
a Lisp, right?

735
00:36:30,080 --> 00:36:32,240
And Lisps are strange.

736
00:36:32,240 --> 00:36:35,640
And their syntax is implemented in data structures.

737
00:36:35,640 --> 00:36:40,440
And when that really clicks and you start thinking like, you know, when I see like a

738
00:36:40,440 --> 00:36:45,520
let's say like a function definition in Python, you know, there's the name of the function

739
00:36:45,520 --> 00:36:50,120
and then opening parentheses and then a list of the arguments for the function.

740
00:36:50,120 --> 00:36:51,120
What is that?

741
00:36:51,120 --> 00:36:52,120
Well, it's nothing, right?

742
00:36:52,120 --> 00:36:53,120
It's just syntax.

743
00:36:53,120 --> 00:36:58,360
In Clojure, that would be an actual list that you hand to the compiler.

744
00:36:58,360 --> 00:37:01,720
That would be an actual list.

745
00:37:01,720 --> 00:37:06,360
So like the syntax for Clojure is Clojure data structures.

746
00:37:06,360 --> 00:37:13,600
Well, I think I just had a mind implosion moment.

747
00:37:13,600 --> 00:37:15,200
Yeah, it's crazy.

748
00:37:15,200 --> 00:37:19,560
So a Clojure function would not be what I think it would be, it wouldn't look like the

749
00:37:19,560 --> 00:37:20,560
way I think it looks, right?

750
00:37:20,560 --> 00:37:22,640
Yeah, it depends on what you mean.

751
00:37:22,640 --> 00:37:27,640
So it'll be, if you're like defining a function in Clojure, it's an opening parentheses and

752
00:37:27,640 --> 00:37:34,760
then the word defn, but in Clojure it's called a symbol, the symbol defn, D-E-F-N, and then

753
00:37:34,760 --> 00:37:39,160
a space and then the name of the function and then a space and then a vector, which

754
00:37:39,160 --> 00:37:44,880
is a square bracket and a list of the parameters that function accepts.

755
00:37:44,880 --> 00:37:50,400
But it's not just syntax because what the compiler sees is an actual list, a data structure

756
00:37:50,400 --> 00:37:54,680
that is a list, and then the first item of that list is a data structure that's a symbol,

757
00:37:54,680 --> 00:37:58,240
which is defn, and then it sees another symbol, which is the name of the function, and then

758
00:37:58,240 --> 00:38:02,200
it sees an actual vector with more symbols inside of it.

759
00:38:02,200 --> 00:38:03,200
Wow.

760
00:38:03,200 --> 00:38:04,200
Okay.

761
00:38:04,200 --> 00:38:05,200
Yeah.

762
00:38:05,200 --> 00:38:07,640
So the compilation's a bit different.

763
00:38:07,640 --> 00:38:14,120
So the first stage is reading, and reading takes the Clojure file and there's actually

764
00:38:14,120 --> 00:38:17,640
a, it's actually its own thing, it's called Eden Extensible Data Notation.

765
00:38:17,640 --> 00:38:22,560
It's like JSON, but more Lispy, S-expression based, and a little more extensible, which

766
00:38:22,560 --> 00:38:23,560
is nice.

767
00:38:23,560 --> 00:38:28,960
So it takes an Eden file, reads it so it gets a big, builds a big data structure, and then

768
00:38:28,960 --> 00:38:33,200
hands those data structures, one structure at a time, to the compiler, the compiler emits

769
00:38:33,200 --> 00:38:36,800
bytecode, ships it to the JVM, and it runs it.

770
00:38:36,800 --> 00:38:41,280
So basically everything all the way down is effectively Clojure data structures.

771
00:38:41,280 --> 00:38:42,960
Yes, exactly.

772
00:38:42,960 --> 00:38:47,360
And that's what makes the ability to write macros so useful, because you already have,

773
00:38:47,360 --> 00:38:52,360
like the whole Clojure standard library is just utility functions to work on the built-in

774
00:38:52,360 --> 00:38:53,360
data structures.

775
00:38:53,360 --> 00:38:56,840
It's all about data, so you've got all the kinds of things to handle, nested maps and

776
00:38:56,840 --> 00:39:01,380
complicated arrangements of vectors, and there's four comprehensions in there, and there's

777
00:39:01,380 --> 00:39:03,960
map and filter and reduce and all sorts of stuff.

778
00:39:03,960 --> 00:39:08,560
All of that can also be used in macros, because when you write a macro, the compiler sees

779
00:39:08,560 --> 00:39:12,800
it, takes whatever you've written inside the macro, doesn't evaluate it, and hands it as

780
00:39:12,800 --> 00:39:16,880
a data structure to the macro code that you write, and then you can use all of your normal

781
00:39:16,880 --> 00:39:21,880
tools to manipulate that, emit more code, and then the compiler compiles that instead.

782
00:39:21,880 --> 00:39:23,040
Okay.

783
00:39:23,040 --> 00:39:24,040
My mind is blown.

784
00:39:24,040 --> 00:39:28,360
Yeah, and that's why it's so powerful, and that's why, you know, for like C-Sharp they

785
00:39:28,360 --> 00:39:35,720
added async await to the compiler, and Clojure core async answers some of the same problems,

786
00:39:35,720 --> 00:39:37,240
and it's just a library.

787
00:39:37,240 --> 00:39:41,240
Now there are some limitations that make it in some cases worse to do that style, but

788
00:39:41,240 --> 00:39:45,120
it means the community didn't have to wait for the language designers to add that.

789
00:39:45,120 --> 00:39:46,120
They could do it at any time.

790
00:39:46,120 --> 00:39:48,320
Right, you just add your own macros and go from there.

791
00:39:48,320 --> 00:39:51,600
Yeah, you can grow the language, shape it as you need to, and of course you want to

792
00:39:51,600 --> 00:39:53,560
be, you know, you want to use that with care.

793
00:39:53,560 --> 00:39:57,120
It's a lot of power, but when it's appropriate, it's awesome.

794
00:39:57,120 --> 00:40:00,480
No, that sounds like it'd be very powerful.

795
00:40:00,480 --> 00:40:04,720
Yeah, once you wrap your head around that everything's a data structure, and if you're

796
00:40:04,720 --> 00:40:11,480
not used to, as I'm not used to, like Lispy-like languages, just for the audience, when we

797
00:40:11,480 --> 00:40:15,280
say Lispy-like, we mean, you know, descendant from literally Lisp.

798
00:40:15,280 --> 00:40:17,200
Yeah, exactly.

799
00:40:17,200 --> 00:40:21,200
Usually prefix notation, S-expressions, that sort of thing.

800
00:40:21,200 --> 00:40:26,520
Yeah, yeah, that's, I'm just looking at some of the stuff on Clojure.org here, I'm looking

801
00:40:26,520 --> 00:40:29,180
at some of the codes, and my head is spinning.

802
00:40:29,180 --> 00:40:33,680
It's like, it is very, very data centric.

803
00:40:33,680 --> 00:40:36,080
Yeah, yes, absolutely.

804
00:40:36,080 --> 00:40:40,040
Here I can send you a, I'll just post it and put it in the top of the doc, here's a recent

805
00:40:40,040 --> 00:40:44,840
data-driven routing library that exists out there, there we go, I'll make that a link

806
00:40:44,840 --> 00:40:45,840
for you.

807
00:40:45,840 --> 00:40:49,440
And so you can just scroll down and see some of the examples, and it is, you know, it is,

808
00:40:49,440 --> 00:40:51,960
it's all data structures all the way down.

809
00:40:51,960 --> 00:40:54,600
All right.

810
00:40:54,600 --> 00:40:56,000
Yeah.

811
00:40:56,000 --> 00:41:01,800
So, one thing that people come from, like, you know, Scala people, or people used to,

812
00:41:01,800 --> 00:41:06,640
even just Java's level of static typing, there's a little bit of uncertainty, so you do need

813
00:41:06,640 --> 00:41:11,040
a little more, and again, I think this goes back to the sort of senior programmer mentality.

814
00:41:11,040 --> 00:41:15,800
Certainly it's easy, maybe not easy, but it happens all the time, dynamic languages can

815
00:41:15,800 --> 00:41:18,680
be abused, you can make a little suit for yourself.

816
00:41:18,680 --> 00:41:23,560
It helps that Clojure is very function-oriented, and instead of classes, you have namespaces,

817
00:41:23,560 --> 00:41:27,380
and there's already sort of, it's almost like microservices in your code, you know, it encourages

818
00:41:27,380 --> 00:41:32,720
and stylistically is encouraged by the community to separate concerns and have very clear responsibilities

819
00:41:32,720 --> 00:41:35,660
and single, immutable, idempotent functions.

820
00:41:35,660 --> 00:41:38,220
So that helps a lot in that regard.

821
00:41:38,220 --> 00:41:41,400
And if you just are a more experienced programmer, have a little discipline, you know, you learn

822
00:41:41,400 --> 00:41:47,040
how to, you have doc strings, and you have good tests, and it all kind of just works.

823
00:41:47,040 --> 00:41:48,040
Works together.

824
00:41:48,040 --> 00:41:52,240
Yeah, I'm gonna have to take a look at this, just, you know, just for thinking in a different

825
00:41:52,240 --> 00:41:53,240
way, right?

826
00:41:53,240 --> 00:41:54,240
Yeah.

827
00:41:54,240 --> 00:41:57,080
Thinking about code as data structures and being more in the list.

828
00:41:57,080 --> 00:42:00,080
I spend most of my time working in C family languages.

829
00:42:00,080 --> 00:42:02,240
Yeah, you know, that's part of it, too.

830
00:42:02,240 --> 00:42:06,960
It's funny, I think that turns a lot of people off, and that's fair, ALGOL just won.

831
00:42:06,960 --> 00:42:11,160
That style of syntax seems to be mostly what we learn, and so that's what feels intuitive

832
00:42:11,160 --> 00:42:12,160
to us.

833
00:42:12,160 --> 00:42:16,880
So it's probably healthy, even if you never intend to build a real project with it, learning

834
00:42:16,880 --> 00:42:17,880
some kind of Lisp.

835
00:42:17,880 --> 00:42:22,440
Clojure is nice because it has so many libraries, it's easy to do a toy project that's actually

836
00:42:22,440 --> 00:42:26,440
useful as compared to maybe something like Racket, which is a little more academic.

837
00:42:26,440 --> 00:42:28,280
But go learn some weird stuff, right?

838
00:42:28,280 --> 00:42:34,400
It's nice to learn an ML family language, Prologues, interesting Erlang, Lisp, like there's

839
00:42:34,400 --> 00:42:35,760
all kinds of crazy languages.

840
00:42:35,760 --> 00:42:41,940
Forth is a cool, you know, concatenative stack-based languages are neat.

841
00:42:41,940 --> 00:42:42,940
People still learn Haskell?

842
00:42:42,940 --> 00:42:48,520
I remember that used to be like the hot non-C family, although this is definitely more foreign

843
00:42:48,520 --> 00:42:49,520
than Haskell.

844
00:42:49,520 --> 00:42:50,520
Yeah.

845
00:42:50,520 --> 00:42:52,040
I mean, yes and no.

846
00:42:52,040 --> 00:42:54,800
It's definitely more foreign on the surface, I would say.

847
00:42:54,800 --> 00:43:00,200
Haskell has a lot of deepness to it because it is like just a rich playground for implementing

848
00:43:00,200 --> 00:43:03,440
all sorts of ideas from type theory, which is cool, which is neat, like they do a lot

849
00:43:03,440 --> 00:43:06,760
of cool stuff.

850
00:43:06,760 --> 00:43:09,360
One thing I love about Clojure is it just tries to be simple.

851
00:43:09,360 --> 00:43:10,360
I'm like simple.

852
00:43:10,360 --> 00:43:15,080
There's one of the classic talks in the community is simple, not easy.

853
00:43:15,080 --> 00:43:19,880
And to prefer simplicity, ease is great, it's not that ease is bad, but simplicity is what

854
00:43:19,880 --> 00:43:23,920
helps scale and simplicity is what helps come back and review code and understand what's

855
00:43:23,920 --> 00:43:24,920
happening.

856
00:43:24,920 --> 00:43:30,440
So once you, there is a big gap of familiarity, but if you can get across that, like I don't

857
00:43:30,440 --> 00:43:33,720
know if you've followed any of the drama from like the Scala side of things, just all the

858
00:43:33,720 --> 00:43:38,040
incompatibilities between Scala versions and having to build multiple times and configure

859
00:43:38,040 --> 00:43:42,080
SPT to emit for different Scala versions and all of that, it just doesn't happen in

860
00:43:42,080 --> 00:43:43,080
Clojure.

861
00:43:43,080 --> 00:43:47,100
There's been like one or two breaking changes over the entirety of its 10-year record.

862
00:43:47,100 --> 00:43:48,100
That's pretty good.

863
00:43:48,100 --> 00:43:49,100
Yeah.

864
00:43:49,100 --> 00:43:50,100
I mean, that's, yeah, that's, yeah.

865
00:43:50,100 --> 00:43:55,240
It's also, so it can be a little unsettling for people too because you see a Clojure library

866
00:43:55,240 --> 00:43:58,240
and part of it is because of just the stability of the language and part of it is because

867
00:43:58,240 --> 00:44:02,840
a lot of the libraries end up just wrapping, like a popular HTTP library wraps the Apache

868
00:44:02,840 --> 00:44:05,160
HTTP library from Java.

869
00:44:05,160 --> 00:44:09,600
So you just get these libraries that don't ever really see a 1.0 release, but it's because

870
00:44:09,600 --> 00:44:14,400
they were already, there's such a thin little wrapper and layer to make it slightly more

871
00:44:14,400 --> 00:44:17,680
palpable to a Clojure programmer that you don't have to worry about it and it doesn't

872
00:44:17,680 --> 00:44:19,440
need that many changes.

873
00:44:19,440 --> 00:44:21,960
It just works.

874
00:44:21,960 --> 00:44:22,960
That is super cool.

875
00:44:22,960 --> 00:44:23,960
Yeah.

876
00:44:23,960 --> 00:44:24,960
But very different.

877
00:44:24,960 --> 00:44:25,960
So I was turned off at first.

878
00:44:25,960 --> 00:44:26,960
Yeah.

879
00:44:26,960 --> 00:44:27,960
I was like, what is happening?

880
00:44:27,960 --> 00:44:33,520
Well, it's a good exercise though, for frankly, myself and the listeners break out of your

881
00:44:33,520 --> 00:44:40,280
C-sharp Java, God forbid JavaScript bubble and give something like Clojure a shot, right?

882
00:44:40,280 --> 00:44:41,280
Yeah.

883
00:44:41,280 --> 00:44:42,280
Just to learn.

884
00:44:42,280 --> 00:44:43,320
Taste something strange.

885
00:44:43,320 --> 00:44:47,200
So where can folks find you and learn more about this crazy data structure love?

886
00:44:47,200 --> 00:44:48,200
Oh yeah.

887
00:44:48,200 --> 00:44:52,160
You can find me over at Westpane on Twitter or check out some of the other JB shows I

888
00:44:52,160 --> 00:44:53,840
sometimes appear on.

889
00:44:53,840 --> 00:44:54,960
Check out TechSnap this week.

890
00:44:54,960 --> 00:44:56,500
It's been tons of fun.

891
00:44:56,500 --> 00:44:59,260
We had special guest Martin Wimpress on.

892
00:44:59,260 --> 00:45:01,600
So we had, we just had a riotous time.

893
00:45:01,600 --> 00:45:03,120
One of the wimpy.

894
00:45:03,120 --> 00:45:04,120
Yeah, exactly.

895
00:45:04,120 --> 00:45:05,120
Exactly.

896
00:45:05,120 --> 00:45:06,400
Friend of the network.

897
00:45:06,400 --> 00:45:07,400
What about you, Mike?

898
00:45:07,400 --> 00:45:11,520
Where can they get more of you besides this here coder radio, a coder.show, right?

899
00:45:11,520 --> 00:45:13,540
HTTP colon slash slash coder.show.

900
00:45:13,540 --> 00:45:14,540
That's right.

901
00:45:14,540 --> 00:45:18,800
You can find me at Dumanuco on Twitter and yeah, check out the calendar for the recording

902
00:45:18,800 --> 00:45:19,800
schedule.

903
00:45:19,800 --> 00:45:20,800
It's going to be weird for a few weeks.

904
00:45:20,800 --> 00:45:21,800
Yeah.

905
00:45:21,800 --> 00:45:22,800
But don't worry.

906
00:45:22,800 --> 00:45:25,000
Nothing can stop Coder Radio.

907
00:45:25,000 --> 00:45:44,880
And that with Clojure.


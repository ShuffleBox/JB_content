WEBVTT

00:00.000 --> 00:08.000
This is Koda Radio, episode 364, for July 1st, 2019.

00:31.000 --> 00:45.000
Hello, and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business of software development and related technologies.

00:45.000 --> 00:55.000
My name is Wes, and I'm very pleased to be joined by that Floridian gentleman who we won't call crazy, Mr. Michael Dominic. Hi, Mike.

00:55.000 --> 01:00.000
Hello, Wes, and the reports are true. I am Florida Man.

01:00.000 --> 01:08.000
Well, we wouldn't have you any other way. I mean, I kind of like that we're on opposite sides of the country in that way. We're bringing different perspectives, and that's what makes it fun.

01:08.000 --> 01:11.000
National representation.

01:11.000 --> 01:22.000
We got a lot in this show today, so we might as well just come in hot. There's no better way. Let's start with some news that we should get out of the way so we can get into the meatier stories we really want to talk about.

01:22.000 --> 01:32.000
And that's all the business around Johnny Ives' exit from Apple. And just like any update that happens around Johnny Ives, there's been a lot of news.

01:32.000 --> 01:38.000
Oh, sure there has. So Sir Johnny Ives, as he's known by his friends.

01:38.000 --> 01:40.000
Oh, yes, of course.

01:40.000 --> 02:05.000
Is leaving Apple to start a new design firm called from love, which amazing name bonus points. There has been a I mean it started with a big Wall Street Journal story of Johnny Ives being disincentivized or disinterested, I think is the correct term someone will correct us in the work at Apple due to kind of a.

02:05.000 --> 02:13.000
I'm trying to put this in a non combative way, Wes. Pain in the ass accounting being counter mindset. Is that fair?

02:13.000 --> 02:25.000
Sure. And I mean, he's functioning at a very high level as a high level designer responsible for a lot of stuff. I can see how, you know, if you're overly constrained and Apple at this point is a pretty large organization.

02:25.000 --> 02:32.000
At some point, you just want, you know, you want more agility, you want to focus on your creative work, and maybe the bureaucracy is constraining.

02:32.000 --> 02:40.000
Well, sure. And like, I can tell you, accountants just create busy work, right? Everything is paperwork, everything is right. Maybe we don't get into my pep.

02:40.000 --> 02:50.000
And I mean, there's, there's often reason for that. But that doesn't make it fun. And in many cases, there's, you know, excesses there that just inefficiencies built into the system.

02:50.000 --> 03:01.000
The reasonable opinions of West do not necessarily reflect the opinions of Mike, or the quarter radio program. No, I think your opinions more reflect accurately the actual programming.

03:01.000 --> 03:12.000
It's, I don't know, like, I have to be honest with you, this announcement makes all of the crappy decisions made by Apple make a lot more sense to me because yeah, the accounts are in control.

03:12.000 --> 03:23.000
So yes, we released a shitty keyboard. But no, we can't have a new keyboard because, well, we've already paid for the tooling on the factory and God forbid we, you know, not show year over year growth.

03:23.000 --> 03:25.000
Now, West, tell me why I'm wrong.

03:25.000 --> 03:36.000
You know, I'm really not sure you are our whole I mean, we have a larger problem in our society, I would say with focus on short term gains quarterly capitalism.

03:36.000 --> 03:42.000
Yeah, exactly. It's I mean, it's really cork from DS nine says it best, you know, it's it is all it's all about the short term quarterly gains.

03:42.000 --> 03:54.000
And you just don't care about sustainability or long term growth. And you would hope Apple has has been a company that's been, you know, better about that than many others and not necessarily only ruled by stock price fluctuations.

03:54.000 --> 04:01.000
But maybe it sounds like it's getting worse. I try to avoid controversial statements. I'm not sure that's true, but lay it on us, Mike.

04:01.000 --> 04:08.000
So like, I actually believe that accountants, finance and operations people should never be out be allowed to become CEOs.

04:08.000 --> 04:23.000
They just lack a vision and a quest for excellence, right? Like I would rather a drunk former poet or a mad scientist who is going to create the Green Goblin than someone who knows how to

04:23.000 --> 04:29.000
actually like balance an account and notes the difference between checks and balances. And by the way, it means different things in a different context.

04:29.000 --> 04:42.000
Of course it does. Accounting sucks. Right? Like, I personally would eliminate the IRS and I would also eliminate all CPAs. But that's just me.

04:42.000 --> 04:53.000
Well, I like your point earlier about, you know, you're right. Like you need, you need accounting, you need the realities, you need information about how your finances stand, but you need someone in this.

04:53.000 --> 04:54.000
That was not my point.

04:54.000 --> 05:04.000
Right, right. You need someone in charge, you know, a CEO, whatever, that gets the higher goal, that understands that. I think that's where you see a lot of larger companies start to stagnate, right?

05:04.000 --> 05:10.000
You lose people with the vision, you lose the agility of a smaller organization, and you're too focused on compliance and stock price.

05:10.000 --> 05:19.000
I guess what I'm suggesting is that once a company reaches the point where an operations guy or an accountant could actually be the CEO, it means the company is too big and needs to be broken up.

05:19.000 --> 05:28.000
And you need someone who has a vision and aggression and will indeed accidentally or intentionally cheat on accounting rules because he either doesn't know or doesn't care.

05:28.000 --> 05:29.000
Whoopsie.

05:29.000 --> 05:45.000
No, but it just is the point, right? You know, Tim Cook, great guy, to me, kind of a Mary Sue, could never have created the IMAC, could never have saved Apple. If Tim Cook ran Apple, he would have looked at the numbers and said, I'm going to sell to Dell during the 90s.

05:45.000 --> 05:46.000
That's what I'm talking about.

05:46.000 --> 05:51.000
Yeah, you're right. You need that sort of relentless pursuit of vision that you just don't get.

05:51.000 --> 05:57.000
Well, you need someone crazy. Like Steve Jobs, his biggest strength was that he was actually an egocentric megalomaniac.

05:57.000 --> 06:06.000
I am a little curious what you think about this exit that Johnny Ives gets to do and how that might compare with, you know, someone like you or me and how we would exit.

06:06.000 --> 06:20.000
So I did an exit like this once. This is basically someone slacked or, in my time, hip-chatted someone in a rage because, like, Johnny Ives should have been the CEO or should have left when Steve Jobs died, right?

06:20.000 --> 06:33.000
So, by the way, it's not just me saying this. They literally pay him more than any executive. They gave him a fake promotion just to keep him there so it wouldn't hurt the share price having Steve Jobs die and him leave at the same time.

06:33.000 --> 06:40.000
It just is the case that working with an accountant or an operations guy is a nightmare.

06:40.000 --> 06:53.000
I got to tell you something. Every time I have to send an invoice to an accounting person, I cry because they care about nonsense, right? They would rather see their servers crash than not have a PO, you know, exactly detailed on each line item.

06:53.000 --> 06:57.000
It's such a waste of time. I realize that's not the answer you wanted.

06:57.000 --> 07:00.000
I mean, not really, but I'll take it.

07:00.000 --> 07:07.000
All right, let me rephrase. I'll rephrase. I think accountants and finance people ought to serve the creative people, right? It shouldn't be the other way.

07:07.000 --> 07:18.000
As an engineer or as a designer, you should not have to write your documents to satisfy the accountant. The accountant should figure out what's right, say, this is what I think I should pay you and pay you.

07:18.000 --> 07:22.000
It should not be your responsibility to effectively do their job.

07:22.000 --> 07:43.000
Yeah, no, you're right. I mean, their role is to keep things running, right? And there are essential services to perform, but that's just there as, you know, something you have to get done. It's not the spirit or the heart of the work, which is, as you say, what the, you know, what the creative people, the designers, the engineers, the people making the primary product of whatever organizations involved.

07:43.000 --> 07:54.000
But it's deeper than that, right? Apple's opening a credit card. So they are effectively going to become a financial services company. And this has happened before. Remember General Motors, a little car company. I don't know if you've heard of them.

07:54.000 --> 07:55.000
I have.

07:55.000 --> 08:05.000
Their biggest business was giving auto loans and personal loans, right? So we should move on from this. But yeah, Mike hates accountants and finance people. That's the lesson today.

08:05.000 --> 08:17.000
Well, let's move on to something that maybe you don't hate. It's time, that's right, for our check in on your weekly programming challenge. This time, we're gabbing about Go.

08:17.000 --> 08:45.000
Yeah, I hate Go too, so this is going to go downhill. So no, I'm kidding. So Go, you know what, my first comment in the doc is Go is C++ plus three pluses, three pluses more power. There's a lot to like here, Wes. One, there's no accountants. Two, there is Go routines, which are, I want to be careful how I say this, but I also need to say in 30 seconds.

08:45.000 --> 08:57.000
So they are effectively on a conceptual level threads. But they're not like LLVM threads that we would normally think about, right? They're managed completely by the Go runtime.

08:57.000 --> 09:13.000
Yes, right. So the difference here is that you're not using the underlying kernel primitives on whatever operating system you're doing. These are so called green threads, user land threads managed entirely within Go. And so that usually means cooperative multitasking.

09:13.000 --> 09:30.000
When I read that, and I started working with them, I kind of raised an eyebrow like, well, wait, is that is that going to be slower? In fact, it's faster. Because the Go routines give you the ability to completely control the threads. For instance, I know people are going to say this is like a nerdy trivial thing to care about, but mutexes.

09:30.000 --> 09:51.000
The fact that I can lock a variable or really any data type, like, I mean, there's a whole thing we're gonna get into here about what is a variable in Go, but lock it to one Go routine, and then unlock it when it's done, prevents a lot of threading, or what we would normally in other languages call concurrency threading issues, right?

09:51.000 --> 10:09.000
For instance, let's take a simple example, we have some variable called, you know, glass, we want to mutate some value of that, right, whether it be size or temperature. Well, we might have two threads using quotes here, that are trying to operate on it and might mutate it in a way we don't expect.

10:09.000 --> 10:23.000
And each thread can actually verify the value. Using the mutex functionality in Go, we can say, this is locked until, you know, Go Routine A is done. Then when Go Routine A is done, Go Routine B can then operate on it.

10:23.000 --> 10:39.000
Yeah, I'm curious what you think, you know, as someone who's used certainly plenty of.NET stuff, as well as, you know, Ruby, which I would say has a much worse concurrency story. What do you think of this sort of concurrency first design of Go?

10:39.000 --> 10:43.000
Well, concurrency in Ruby is just not good, right? I mean...

10:43.000 --> 10:45.000
No, no, it's not. Really, it's awful.

10:45.000 --> 10:55.000
Yeah, so, I mean, your question jumps to kind of my end thing here, although we have a few things I'd like to go through. Go is solving problems that I just don't have, right?

10:55.000 --> 11:05.000
Like, the root problem that Go seems to solve is, I need a better C++ in terms of concurrency and large distributed systems.

11:05.000 --> 11:17.000
Which is just not the arena I'm working in. But I could see how, again, like, if you think about languages and platforms, you know, let's take Rails, which I think we're going to talk about a little later.

11:17.000 --> 11:29.000
Rails is not optimizing for performance. It's not optimizing for really anything but developer time, right? It's to minimize the amount of dev time you have to buy.

11:29.000 --> 11:40.000
Yeah, everything, you know, convention over configuration, all the defaults that exist. Yeah, it's just easy to get going to make it easy for humans and, well, just, you know, buy more servers if you need to.

11:40.000 --> 11:51.000
Right, just throw money at RAM. Where Go is kind of the opposite. Like, the equivalent Go application is going to take you a bit longer to write, but the performance is going to be much better.

11:51.000 --> 11:57.000
And if you happen to be Google or someone at scale, it makes a lot of sense. And I'm not even being, like, critical here.

11:57.000 --> 12:05.000
I actually think Go has its place, much like I think Rust has its place, although I wouldn't use Go the way I'm using Rust.

12:05.000 --> 12:08.000
Yeah, maybe you could compare and contrast real briefly there.

12:08.000 --> 12:17.000
Yeah, like, Rust, I feel like, is more, okay, you're going to write this one microservice component in Rust. It's going to process a lot of data very quickly.

12:17.000 --> 12:22.000
You know, I'm doing a lot with OBJs and STLs right now. I've been working, I mean, we've talked about this a few times, right?

12:22.000 --> 12:25.000
Oh, yes, right. Your 3D render files, etc.

12:25.000 --> 12:38.000
Yeah, we're doing a lot of processing and analytics on them, and the reality is just, like, running a small server or, although I have been playing with Azure Functions, too, in AWS LAMP instances,

12:38.000 --> 12:53.000
in Rust, it's just a lot more performant than doing that in the Rails app, even versus doing it in the Rails app and using FFI for Rust or for C++, I guess, would be an option.

12:53.000 --> 12:57.000
Right, trying to offload your hot paths out to something faster.

12:57.000 --> 13:09.000
Right, it's just better to throw it on a serverless instance, frankly. I could see Go. See, Go, to me, is a little different than that, where I see Rust as kind of a utility that you have in your tool belt.

13:09.000 --> 13:15.000
Go feels like I'm building a giant system, it needs to be performant, and I'm building the whole damn thing in Go.

13:15.000 --> 13:19.000
Sure, right? I mean, Kubernetes is a great example of a giant Go project.

13:19.000 --> 13:23.000
Exactly. I'm pretty sure Docker's written in Go.

13:23.000 --> 13:33.000
Yeah, there's tons of stuff, like the Snap daemon, lots of stuff that just runs as a lean little executable that needs to provide some network services.

13:33.000 --> 13:45.000
You know, Go's put in some good time to get a low overhead garbage collector, and that's where I was kind of curious, you mentioned, well, it might take you longer to write your project in Go.

13:45.000 --> 13:55.000
How much, coming from Ruby, which is maybe the exact opposite, how much impedance was there compared to stuff like Objective-C or C-Sharp or Java?

13:55.000 --> 14:10.000
And I also wonder if you worry about large code bases. Some people are concerned about the current lack of generics and some of the other difficulties in lacking some of the higher abstractions that Go lacks with the purpose of keeping it simple.

14:10.000 --> 14:22.000
Yeah, I mean, the comparison to Objective-C, I think, is a little unfair because Objective-C would be a front-end language. I'm thinking of kind of back-end data processing things.

14:22.000 --> 14:32.000
You know, I'm in a particular position that gives me a particular perspective, right? I'm selling development services.

14:32.000 --> 14:46.000
So I just can't sell Go because I can't say that something that could take 250 hours in Rails, or Ruby, rather, is going to take 350 or 400 in Go.

14:46.000 --> 14:53.000
Like that, there's no way for me to sell that in my current market.

14:53.000 --> 15:13.000
Now, if I were developing internal products, I might say, well, the long-term server cost is cheaper, but from my now 12-plus years running a dev shop, I can tell you that when I look at a new language or new platform, it's how can I get those dev hours as low as possible?

15:13.000 --> 15:18.000
Because, frankly, that's how you beat the other dev shops, right?

15:18.000 --> 15:23.000
Right, that's what you're billing on to bring it back to accounting, and so that's what you need to minimize.

15:23.000 --> 15:29.000
Right, you need to minimize that. So I'm going to be careful how I say this, but, eh, f*** it, I'll just say it bluntly.

15:29.000 --> 15:37.000
Better doesn't matter. It's can I get past the purchasing agent, right? Like that's kind of the biggest thing.

15:37.000 --> 15:44.000
Right, so it'd be great, it's okay, it'd be great to have a faster language, but you need it not to impose a bunch more burdens on you.

15:44.000 --> 16:00.000
Right, so you need to be able to cheat in some places, right? You really do need object-oriented stuff to do a bunch of inheritance, although I have to agree that Go's use of interfaces and structs is a lot better conceptually than OO languages.

16:00.000 --> 16:08.000
It's also a lot more scientific. The other problem Go has is that it's a harder language to hire for since we're comparing it to Ruby.

16:08.000 --> 16:12.000
Although it does seem to be growing pretty rapidly, so I wonder if that'll change.

16:12.000 --> 16:21.000
Yeah, but the average base pay is significantly higher right now, right? And that could change, right? Somebody's listening to this 10 years from now, that might be different.

16:21.000 --> 16:35.000
You know, one of the things I think we fail to do, Wes, is take these coding challenges from particular points of view, not just the platonic, like, how good is this technology, but also how practical is this for us?

16:35.000 --> 16:44.000
Right, because always you're in a context, and languages need to be fit with those. You have a tool that matches that particular task.

16:44.000 --> 16:54.000
Right, and I'm basically in a very, you know, LSC kind of, if I can't hit a certain bid, I can't win the job context.

16:54.000 --> 17:13.000
So something like, like even Rust, I have to tell you, the only reason I'm able to sell Rust is because I don't say I'm selling Rust. I sell Ruby or.NET, and then we run Rust serverless services, which is really hard to say, to process large amounts of data, right?

17:13.000 --> 17:27.000
You could not be competitive selling Go or, frankly, Rust for your generic, I need a web application that serves data to my business, right?

17:27.000 --> 17:31.000
Right, as long as Rails is fast enough, that's always going to be easier and quicker to make.

17:31.000 --> 17:37.000
But replace Rails with, you know, Java Play,.NET Core, right? There's a million things that are fast enough.

17:37.000 --> 17:41.000
Right, right. Django, some Node.js app, whatever.

17:41.000 --> 17:42.000
Absolutely, yeah.

17:42.000 --> 17:43.000
Okay, interesting.

17:43.000 --> 17:51.000
But I do like Go. I mean, I don't want to be too negative. I just, I'm finding a hard, and this is the problem I had, like, who is this for?

17:51.000 --> 18:03.000
Which I put in the doc because maybe if you are working in a very tech-driven enterprise and you are being paid a salary, this makes sense.

18:03.000 --> 18:14.000
Yeah, right. So, like, from the context of someone who works at an enterprise dev shop, you're on a team of ten people or something, you're working on some microservice, and it's written in Go.

18:14.000 --> 18:23.000
Right, where you're not having to compete with a more, you know, for the lack of a second argument, batteries-included solution.

18:23.000 --> 18:24.000
Right, yeah.

18:24.000 --> 18:31.000
But I do like it. I mean, I feel like I came off negative here. I mean, it does feel like a C++ as though it were thought of in the 2000s.

18:31.000 --> 18:41.000
What did you think of the error handling? You know, they make it pretty explicit rather than the sort of try-catch stuff that's in vogue these days.

18:41.000 --> 18:48.000
Yeah, I thought it was a little annoying, to be honest with you. Again, it's one of those things that I feel like adds to the cost.

18:48.000 --> 18:53.000
You weren't pleased that you had to sort of consider the errors at every little interaction?

18:53.000 --> 19:05.000
No, so this is – I mean, I can't wait until next week and you look at Objective-C, because one of the beauties of Objective-C is you can just ignore errors if you are confident that they won't exist in reality.

19:05.000 --> 19:13.000
Oh, my. Well, Objective-C is almost the opposite of this, where it's a language optimized for, like, I need to hit a low bit.

19:13.000 --> 19:16.000
Oh, yeah, sure. Okay, that kind of makes sense.

19:16.000 --> 19:31.000
And Rust, I got to tell you, I have some of the same trouble in Rust that I did looking ago, and I use Rust in production. It's like, I do charge a premium anytime I think I have to do Rust Dev, only because I do have to catch all those errors and I can't just, like, pretend they don't exist, right?

19:31.000 --> 19:45.000
It's kind of the opposite. I'm wondering maybe if you would compare to, say, Elixir, right, which is how we started off this challenge, which kind of takes the opposite, let it crash approach, while still having a very similar focus on concurrency to go.

19:45.000 --> 19:51.000
And I wonder, would there be less, could you do something in Elixir that you couldn't go that would be similar to Ruby?

19:51.000 --> 20:10.000
I think from a guy who owns a dev shop perspective, I would be much more comfortable selling Elixir, not because I think it's more stable, and don't get me wrong, Elixir is very stable, but because the estimate that I would come up with would be in the realm of acceptability to the client, right?

20:10.000 --> 20:23.000
Where if from my two weeks, week and a half, whatever, looking at Go, everything costs a thousand hours or more. It just does. I can't see a way to actually function.

20:23.000 --> 20:32.000
Now maybe I have wildly misunderstood Go, or I have focused too much on the concurrency limitations, and I'm going to take that back because people are going to write in,

20:32.000 --> 20:41.000
Yeah, what do you mean here, Mike? I mean the discipline that gives you good concurrency and gives you a lot of power, but also requires you to actually do a lot of work, right?

20:41.000 --> 20:54.000
Sure, you still have to think about it. Which right, circling back to, I think you put my point more elegantly than I did context, right? The context that I live in, I just can't sell a web service for 2000 hours.

20:54.000 --> 21:03.000
Right, your problem is not optimizing performance, you just need to optimize ability to rapidly prototype and ship some products to customers.

21:03.000 --> 21:09.000
Well, I have vicious toad-like competitors here, and if you look up where I live, you know what I'm talking about.

21:09.000 --> 21:10.000
Oh.

21:10.000 --> 21:13.000
Who will underbid me just to get the continuing work.

21:13.000 --> 21:17.000
Right, even if they're taking a loss on it, they'll just want to keep the contract going.

21:17.000 --> 21:27.000
Oh, you and I should talk offline. It just is the case that my main problem is people don't want to pay more than 300 hours for anything.

21:27.000 --> 21:35.000
Yeah, that'll happen. Okay, one last point I want to hit on before we should move on, and I should give you your next language.

21:35.000 --> 21:47.000
So one of the things I'm always pleased at, and I think this is a use case maybe you are not in at the moment, but is one that I see Go used a lot in, and that's as like command line application.

21:47.000 --> 21:55.000
Because you can take Go and using the Go compiler, you just get these nice little mostly statically linked executables out of it.

21:55.000 --> 22:09.000
So I can go to a GitHub releases page, download a zip file, and just copy it under my home derbin, and I'm away. And that's another thing that Rust has, but languages like Python and Ruby can't really compete with, right?

22:09.000 --> 22:14.000
You can do stuff. If you're shipping a Docker container, it's fine or whatever.

22:14.000 --> 22:17.000
But for little command line applications, and I shouldn't say little, right?

22:17.000 --> 22:23.000
I mean, tons of people use Docker or Snap or LXD or Cube CTL.

22:23.000 --> 22:24.000
Oh yeah, sure, sure.

22:24.000 --> 22:30.000
These are interfaces, so they're kind of important, and I think Go and Rust really excel there, especially being able to ship stuff.

22:30.000 --> 22:35.000
Yeah, again, I am not trying to say Go is bad. I feel like I've come off as too negative.

22:35.000 --> 22:39.000
You know what, it's just, Wes, can I play the old man card?

22:39.000 --> 22:41.000
I think you're going to anyway, so please do.

22:41.000 --> 22:42.000
Thank you.

22:42.000 --> 22:50.000
All my command line scripts are already written in Ruby, but they're not the same type of command line script you're talking about, right?

22:50.000 --> 22:54.000
So I certainly use Go every day.

22:54.000 --> 23:00.000
In fact, before I knew what Go was in 2010, I was using it every day because I'm using Docker.

23:00.000 --> 23:01.000
Of course.

23:01.000 --> 23:10.000
And I'm using a bunch of Docker command line tools I've pulled off of GitHub, which are all, just like Wes is saying here, Go scripts.

23:10.000 --> 23:12.000
Yeah, I think that's great.

23:12.000 --> 23:27.000
I mean, listen, writing small terminal programs in a language that is as performant, please don't email, I don't want to see your benchmarks, but relatively as performant as C++, but much easier to work on.

23:27.000 --> 23:35.000
You know what, I am doing a C++ job right now, Wes, and let me tell you something, Go is infinitely easier to work on.

23:35.000 --> 23:37.000
There's no doubt.

23:37.000 --> 23:39.000
There's just absolutely no doubt.

23:39.000 --> 23:47.000
Right, but you could still just ship something for many use cases, maybe not all, sure, but many use cases you could compete with.

23:47.000 --> 23:52.000
Well, yeah, so my issues with Go, my negativity on Go is mostly around the tooling.

23:52.000 --> 24:01.000
We need the DHH of Go to say it just is the case that you have to be able to get a web service done in 150 to 200 hours, right?

24:01.000 --> 24:04.000
Right, some frameworks that make it easier.

24:04.000 --> 24:10.000
I'm curious, did you have problems getting stuff set up in terms of IDEs, et cetera?

24:10.000 --> 24:18.000
I know they've struggled with some of their module system and getting and installing dependencies, whereas Rust, say, has the excellent Cargo.

24:18.000 --> 24:26.000
I will say that Cargo is wonderful, and yeah, Go needs something like Cargo.

24:26.000 --> 24:28.000
I know.

24:28.000 --> 24:34.000
Oh, you're teasing, because, all right, we're going to do a segue here. Are you ready?

24:34.000 --> 24:36.000
So, before I broke my Darter Pro.

24:36.000 --> 24:42.000
Oh my, Mike, you just, okay, we're not going to get into that. I'm sorry for anything you own.

24:42.000 --> 24:50.000
Getting Go set up on Pop!OS, which, for those who don't know, is just basically a skin of Ubuntu, right?

24:50.000 --> 24:54.000
Is that fair skin? I don't want to be unfair to the Pop!OS people.

24:54.000 --> 25:00.000
I mean, I would say it's a separate distribution with Ubuntu as one of their upstreams.

25:00.000 --> 25:04.000
All right, sure, it's like a Linux Mint, right? It's based on Ubuntu. Fair enough.

25:04.000 --> 25:10.000
It was relatively painless. It's exactly what I would do for any other toolchain on Linux.

25:10.000 --> 25:17.000
On a other operating system, it was very hard to get the Go toolchain set up.

25:17.000 --> 25:25.000
And full of weird errors that I ended up just fixing by doing the rest of it on Mac.

25:25.000 --> 25:31.000
That other operating system, it's not a door. It's not a cellar.

25:31.000 --> 25:33.000
It's Windows!

25:33.000 --> 25:37.000
Yeah, let's talk about that, because this week, I was a little bit busy.

25:37.000 --> 25:43.000
We had a Linux Academy Company Summit down in Texas, so, you know, a little preoccupied.

25:43.000 --> 25:49.000
But I couldn't help noticing you were sending some provocative tweets out, Mr. Nominick,

25:49.000 --> 25:53.000
talking about moving things to Windows.

25:53.000 --> 25:59.000
And in particular, it kind of sounds like you're doubling down on the Windows subsystem for Linux.

25:59.000 --> 26:03.000
All right, well, okay.

26:03.000 --> 26:10.000
So, it is true that for a job I am doing, I did pick up a Dell XPS 15.

26:10.000 --> 26:13.000
Oh, those are nice. Running Windows 10.

26:13.000 --> 26:16.000
Actually, they attract dust and fingerprints like they're going out of style.

26:16.000 --> 26:19.000
Oh, really? Okay. I mean, talk about that if you want.

26:19.000 --> 26:23.000
All touchscreens are bad. That's where I would leave it.

26:23.000 --> 26:26.000
You know, you don't have to touch them. You can just ignore that part.

26:26.000 --> 26:30.000
I didn't. It just attracts dust in the air.

26:30.000 --> 26:36.000
I'll send you a picture on our Slack. It's crazy. I've been wiping it off once a day.

26:36.000 --> 26:41.000
And it's because it's plastic and whatever the material they use.

26:41.000 --> 26:45.000
It is running Windows 10. And I am using, we have the link in the show notes,

26:45.000 --> 26:49.000
Penguin, who we talked about in the show a few weeks ago,

26:49.000 --> 26:54.000
which is a Debian-based interface, shall we say, to the Windows subsystem for Linux.

26:54.000 --> 26:59.000
Yeah, I mean, it's a distribution built, designed for, you might say,

26:59.000 --> 27:01.000
the Windows subsystem for Linux.

27:01.000 --> 27:06.000
I would like to say that Windows 10 is not the best distribution of Linux I've ever used.

27:06.000 --> 27:08.000
I would really like to say that.

27:08.000 --> 27:10.000
No. Really?

27:10.000 --> 27:12.000
It just is. And in fact, I am not even...

27:12.000 --> 27:15.000
Are you using that sexy new terminal?

27:15.000 --> 27:18.000
I am not, because I'm not on the insider ring.

27:18.000 --> 27:24.000
I refuse to download the terminal until the actual real Linux kernel goes mainstream.

27:24.000 --> 27:30.000
But when it does, I don't understand why people who have to deploy to Linux

27:30.000 --> 27:32.000
wouldn't just use Windows 10.

27:32.000 --> 27:35.000
You get the best IDE in the world, which I've been saying this for years,

27:35.000 --> 27:39.000
so no one can say I'm a shill, is Visual Studio,

27:39.000 --> 27:43.000
and you can run games and crap natively.

27:43.000 --> 27:46.000
Yeah, but don't you... Okay, so another picture you sent out was

27:46.000 --> 27:48.000
everyone's favorite Windows updates.

27:48.000 --> 27:50.000
So aren't there some downsides?

27:50.000 --> 27:55.000
If you listen to Chris, it's better to just run Windows

27:55.000 --> 27:59.000
in a PCI pass-through or some virtualization.

27:59.000 --> 28:03.000
Why should I pivot to using Windows as the full-time OS?

28:03.000 --> 28:06.000
Well, first of all, I am not a Windows evangelist at all,

28:06.000 --> 28:10.000
so it is not my goal to convince you to use Windows.

28:10.000 --> 28:13.000
So if you're asking me why you should use it, my answer is you shouldn't.

28:13.000 --> 28:17.000
But you must have some reasons in your context to be using it.

28:17.000 --> 28:20.000
The reasons in my context is I spend a lot of time at Visual Studio,

28:20.000 --> 28:26.000
and the performance is just significantly better natively than on a VM.

28:26.000 --> 28:31.000
And the problem you raised about Windows constantly wanting to update and restart is,

28:31.000 --> 28:34.000
well, you don't turn it off and just let it restart every night.

28:34.000 --> 28:41.000
It's not ideal, but, you know, I don't know, it works.

28:41.000 --> 28:46.000
I can run all my Linux tooling and my VS environment,

28:46.000 --> 28:49.000
and both of them run at near-native performance.

28:49.000 --> 28:50.000
That's nice.

28:50.000 --> 28:57.000
Penguin, I've seen no significant difference between that and Pop OS, let's say.

28:57.000 --> 29:01.000
Whereas when running Pop OS and I had Windows and a VM,

29:01.000 --> 29:06.000
I had significant issues, let's say, with screen tearing and things like that.

29:06.000 --> 29:11.000
Wow, I mean, that's an interesting report from the field, Mr. Dominic.

29:11.000 --> 29:13.000
I'm glad, I mean, I guess at the end of the day,

29:13.000 --> 29:18.000
should we just be happy that Linux runs really darn well on Windows?

29:18.000 --> 29:21.000
And that just means that you can have the best of both worlds?

29:21.000 --> 29:25.000
Or should I be a little more worried that you've destroyed your Pop systems

29:25.000 --> 29:28.000
and are now dancing with the devil?

29:28.000 --> 29:30.000
Well, why are you worried? Why are you worried?

29:30.000 --> 29:32.000
Let me ask you this. What is Linux?

29:32.000 --> 29:35.000
Is Linux Gnome? Is it KDE?

29:35.000 --> 29:36.000
I mean, you're right.

29:36.000 --> 29:39.000
Really what I'm talking about is Linux on the desktop.

29:39.000 --> 29:44.000
If Windows 10 has a real Linux kernel, which it will in a few months, right,

29:44.000 --> 29:49.000
it's not running just a very strange, distant cousin.

29:49.000 --> 29:51.000
It's like a family reunion of Linux.

29:51.000 --> 29:55.000
Your code is running natively. It's actually running on a Linux kernel.

29:55.000 --> 29:57.000
You cannot say it's a translation layer.

29:57.000 --> 29:59.000
Yeah, I mean, I guess you're right.

29:59.000 --> 30:05.000
And to some extent, it doesn't really matter which one is really running on the host CPU

30:05.000 --> 30:10.000
and which one is cheating a little bit because it just doesn't matter.

30:10.000 --> 30:13.000
Well, it's not cheating, though. It's not cheating.

30:13.000 --> 30:18.000
So with the WSL2, it is a native Linux kernel.

30:18.000 --> 30:21.000
So the WSL1 is cheating. It's doing a translation layer.

30:21.000 --> 30:26.000
The WSL2, which is in Super Insider Alpha Preview or whatever,

30:26.000 --> 30:30.000
which is, granted, I am not running because this is a production machine.

30:30.000 --> 30:32.000
When that comes to production,

30:32.000 --> 30:38.000
Windows will legitimately be an operating system that is running a full Linux kernel,

30:38.000 --> 30:42.000
just like Ubuntu, just like Mint, just like Fedora.

30:42.000 --> 30:47.000
What's the difference, other than personal preferences?

30:47.000 --> 30:50.000
I mean, there's a little bit of difference, right,

30:50.000 --> 30:54.000
in that you're booting into Windows rather than the Linux kernel.

30:54.000 --> 30:57.000
You're booting into both. It boots both kernels.

30:57.000 --> 30:59.000
Yeah, but one of them is, like, isn't –

30:59.000 --> 31:03.000
Linux is technically in a Hyper-V session, just like a minimal one.

31:03.000 --> 31:04.000
I do take your point.

31:04.000 --> 31:07.000
Like, it doesn't really matter if you're going to run both operating systems,

31:07.000 --> 31:10.000
which, as you say, like, if you deliver software from Windows,

31:10.000 --> 31:12.000
you kind of have to, right?

31:12.000 --> 31:16.000
So, I guess, if you're already in that position, it just doesn't matter.

31:16.000 --> 31:19.000
Like, you should just – whichever experience gives you the best of both worlds

31:19.000 --> 31:22.000
so that you can use both systems well, that's what you should do.

31:22.000 --> 31:25.000
Did you see the controversy that literally happened

31:25.000 --> 31:27.000
before we started recording today?

31:27.000 --> 31:28.000
I think I might have missed it.

31:28.000 --> 31:33.000
Regarding Microsoft wanting Windows to join the Linux distro mailing list.

31:33.000 --> 31:37.000
Oh, yeah, you know, I think I did see a few stories floating around about that.

31:37.000 --> 31:39.000
You did see it, right?

31:39.000 --> 31:41.000
Because this is their argument.

31:41.000 --> 31:43.000
And I have to say, I read their argument,

31:43.000 --> 31:46.000
and if I can run Visual Studio natively,

31:46.000 --> 31:49.000
if I can deploy it to my Linux IoT devices,

31:49.000 --> 31:52.000
my Linux services – rather, servers –

31:52.000 --> 31:55.000
or online services, I guess,

31:55.000 --> 31:59.000
while coding to those type of things using a Linux –

31:59.000 --> 32:02.000
native Linux kernel and toolchain, great.

32:02.000 --> 32:05.000
If I don't have to VM Windows, great.

32:05.000 --> 32:08.000
I mean, honestly, I think the missed story here

32:08.000 --> 32:10.000
that all the tech pundits haven't gotten is,

32:10.000 --> 32:12.000
why the hell didn't Mac do this?

32:12.000 --> 32:14.000
They're already running a Unix kernel.

32:14.000 --> 32:16.000
They're running the Darwin BSD kernel.

32:16.000 --> 32:20.000
Why have the – or, I'm sorry, the mock kernel in a Darwin environment?

32:20.000 --> 32:21.000
Yeah, yeah, it's complicated.

32:21.000 --> 32:23.000
But they've got, like, a POSIX environment.

32:23.000 --> 32:27.000
But, like, seriously, Mac could have easily ripped out the BSD side of that,

32:27.000 --> 32:29.000
put in a Linux kernel, and said,

32:29.000 --> 32:31.000
we are the ultimate dev station.

32:31.000 --> 32:32.000
And you know what?

32:32.000 --> 32:34.000
Because – can I fry some bacon?

32:34.000 --> 32:37.000
Oh, lay it on us, Mr. Dominic.

32:37.000 --> 32:41.000
All right, so this bacon's out of London for Canonical.

32:41.000 --> 32:44.000
Have you noticed that Canonical's not pushing the desktop anymore?

32:44.000 --> 32:47.000
They're pushing servers, and they're a partner with Microsoft?

32:47.000 --> 32:51.000
Have you also noticed that a Microsoft developer came out in public and said,

32:51.000 --> 32:54.000
yes, Azure is a majority Linux at this pace?

32:54.000 --> 32:56.000
I did see that.

32:56.000 --> 32:59.000
So maybe Microsoft is setting Windows 10 up

32:59.000 --> 33:02.000
as the best Linux development environment you could possibly have?

33:02.000 --> 33:04.000
I mean, it does make sense.

33:04.000 --> 33:09.000
They are – you know, Azure is a key component of their long-term business model,

33:09.000 --> 33:10.000
because of course it is.

33:10.000 --> 33:12.000
It's the cloud.

33:12.000 --> 33:16.000
And, well, if you're running on Azure, you're probably running a Linux system,

33:16.000 --> 33:19.000
and you need a good way to target that.

33:19.000 --> 33:23.000
And to Microsoft's credit, as you say, right, I mean, they know dev tooling.

33:23.000 --> 33:25.000
They are very good at that.

33:25.000 --> 33:28.000
So they can provide some of these first-class integrations,

33:28.000 --> 33:30.000
not only between Windows and Azure,

33:30.000 --> 33:34.000
but between Windows, Linux, and Azure all in one complicated little three-way.

33:34.000 --> 33:35.000
Right.

33:35.000 --> 33:38.000
And no one's going to, like, attack GNOME or KDE.

33:38.000 --> 33:40.000
No one's going to stop you from running desktop Linux.

33:40.000 --> 33:42.000
I mean, it –

33:42.000 --> 33:45.000
I'm on KDE Plasma as we're doing the show right now.

33:45.000 --> 33:46.000
Right.

33:46.000 --> 33:50.000
And then I'm on what I call Windows 10 Plasma.

33:50.000 --> 33:54.000
My future prediction – and then we should get to the end of the show –

33:54.000 --> 33:59.000
Windows 10 and Linux are going to be the only two viable operating systems

33:59.000 --> 34:01.000
for real developers.

34:01.000 --> 34:04.000
Designers will stick to Mac because of weird things like, you know,

34:04.000 --> 34:08.000
400 nano, whatever, in the Mac display.

34:08.000 --> 34:15.000
But it is going to become effectively the case that as a server developer,

34:15.000 --> 34:19.000
a back-end developer, Windows 10 becomes, if not as viable,

34:19.000 --> 34:22.000
more viable than any desktop Linux distro.

34:22.000 --> 34:27.000
It's strange days, I will admit, but I think you're right.

34:27.000 --> 34:29.000
And I've been actually playing with this, too.

34:29.000 --> 34:32.000
I've set up an insider preview Windows environment.

34:32.000 --> 34:33.000
Traitor.

34:33.000 --> 34:34.000
See, burn him.

34:34.000 --> 34:35.000
He's the traitor.

34:35.000 --> 34:36.000
I was never on your side.

34:36.000 --> 34:39.000
I think realistically, thinking pragmatically,

34:39.000 --> 34:41.000
the more people that use Linux, the better.

34:41.000 --> 34:43.000
Desktop Linux is, at least for the immediate future,

34:43.000 --> 34:45.000
going to be just a small little niche,

34:45.000 --> 34:51.000
and we should instead celebrate the amazing success of Linux on the server

34:51.000 --> 34:55.000
and just how, you know, I mean, it's a legitimately great way to run that stuff.

34:55.000 --> 34:58.000
So if Microsoft's on board with that, too, great.

34:58.000 --> 35:01.000
And the more people that can easily be exposed to Linux,

35:01.000 --> 35:03.000
the better because maybe someday they also say,

35:03.000 --> 35:04.000
oh, do I want to run this on the desktop?

35:04.000 --> 35:05.000
They'll try it out.

35:05.000 --> 35:06.000
They'll play with it.

35:06.000 --> 35:08.000
Maybe they'll buy a Raspberry Pi and run it on there.

35:08.000 --> 35:10.000
It really doesn't matter.

35:10.000 --> 35:12.000
The future is already guaranteed.

35:12.000 --> 35:14.000
Again, I mean, we should wrap this up.

35:14.000 --> 35:17.000
But again, I just want to reiterate the point that like maybe I'm wrong,

35:17.000 --> 35:20.000
but in my mind, and I think this is what Linus believes

35:20.000 --> 35:22.000
because I saw an interview with him years ago,

35:22.000 --> 35:26.000
Linux has nothing to do with Ubuntu, Gnome, or Fedora.

35:26.000 --> 35:28.000
Linux is a kernel.

35:28.000 --> 35:33.000
So if you are running the Linux kernel, you are running Linux, period, right?

35:33.000 --> 35:37.000
Whether it's a headless Raspberry Pi that's making coffee for you

35:37.000 --> 35:41.000
or it's indeed a Windows Dev instance that you're running all Linux tools

35:41.000 --> 35:43.000
and using the app to get to install,

35:43.000 --> 35:46.000
using the Debian interface with a native Linux kernel,

35:46.000 --> 35:48.000
you are running Linux, right?

35:48.000 --> 35:51.000
Gnome, KDE, I don't know.

35:51.000 --> 35:53.000
They kind of had their time.

35:53.000 --> 35:55.000
Had their time?

35:55.000 --> 35:57.000
Wow, Mr. Dominic.

35:57.000 --> 35:59.000
I mean, that time might still be now.

35:59.000 --> 36:00.000
But you're right.

36:00.000 --> 36:02.000
We should move on.

36:02.000 --> 36:05.000
There's plenty of time for Flame Wars later in the show.

36:05.000 --> 36:08.000
Let's wrap things up a little bit with two points

36:08.000 --> 36:10.000
on some languages we frequently discuss.

36:10.000 --> 36:14.000
Yes, that's, of course, Ruby and Python.

36:14.000 --> 36:19.000
So first up, many of you probably saw the big news out of Stripe,

36:19.000 --> 36:22.000
and that's the open sourcing of Sorbet,

36:22.000 --> 36:26.000
a fast, powerful type checker for Ruby.

36:26.000 --> 36:27.000
They write,

36:27.000 --> 36:30.000
We designed Sorbet to be used at Stripe,

36:30.000 --> 36:33.000
where the vast majority of our code is written in Ruby.

36:33.000 --> 36:36.000
We spent the last year and a half

36:36.000 --> 36:39.000
developing and adopting Sorbet internally,

36:39.000 --> 36:42.000
and we're finally confident that Sorbet

36:42.000 --> 36:46.000
is not just an experimental internal project.

36:46.000 --> 36:51.000
We're ready to share Sorbet with the entire Ruby community.

36:51.000 --> 36:55.000
In fact, we've already had 30 companies beta test Sorbet

36:55.000 --> 36:57.000
and provide feedback.

36:57.000 --> 36:59.000
So right now, what you get,

36:59.000 --> 37:03.000
it's the core static type checker,

37:03.000 --> 37:06.000
tooling to create new Sorbet projects,

37:06.000 --> 37:08.000
and, interestingly,

37:08.000 --> 37:14.000
tooling to gradually adopt Sorbet in existing projects.

37:14.000 --> 37:17.000
And, Mike, that's kind of what I'd like to talk about with you today.

37:17.000 --> 37:22.000
You know, when we were talking about Go earlier,

37:22.000 --> 37:24.000
there's additional constraints, right?

37:24.000 --> 37:26.000
And you were talking about how Ruby is a great fit

37:26.000 --> 37:29.000
for being able to just rapidly produce stuff.

37:29.000 --> 37:34.000
But everyone knows Ruby can get, let's just say, a little sloppy.

37:34.000 --> 37:36.000
Something like Sorbet might be able to help clean that up,

37:36.000 --> 37:38.000
and if you do have a great success,

37:38.000 --> 37:40.000
you do have a long-running project,

37:40.000 --> 37:43.000
maybe Sorbet could help you maintain it in the long term.

37:43.000 --> 37:45.000
Yeah, that's interesting.

37:45.000 --> 37:47.000
I mean, I did look at Sorbet.

37:47.000 --> 37:51.000
It's one of these things that I feel like would be great

37:51.000 --> 37:53.000
when you're starting a project,

37:53.000 --> 37:55.000
but going back and then implementing it

37:55.000 --> 37:58.000
and trying to have to go back and check all your types

37:58.000 --> 38:01.000
is going to be time-consuming and painful.

38:01.000 --> 38:03.000
Having said that, honestly,

38:03.000 --> 38:05.000
if you're doing a large-scale Ruby on Rails

38:05.000 --> 38:07.000
or Ruby project in general,

38:07.000 --> 38:11.000
and you need to, you know,

38:11.000 --> 38:13.000
get a little more type safety, right?

38:13.000 --> 38:15.000
Make your code a little more safe.

38:15.000 --> 38:17.000
I would check out Sorbet.

38:17.000 --> 38:19.000
I mean, Stripe's been using it. I have played with it.

38:19.000 --> 38:22.000
If I was starting a new project, I probably would use it.

38:22.000 --> 38:24.000
And, you know, I'm always starting new projects.

38:24.000 --> 38:27.000
So, yeah, I would definitely include this.

38:27.000 --> 38:29.000
Just to have...

38:29.000 --> 38:31.000
You know, it's almost like having

38:31.000 --> 38:33.000
just a little more compiler checking

38:33.000 --> 38:35.000
is really what it is, right?

38:35.000 --> 38:38.000
Because Ruby's not a strong-type language.

38:38.000 --> 38:42.000
No, and it's an incredibly dynamic language, right?

38:42.000 --> 38:45.000
I mean, tons of stuff happens and is available at runtime.

38:45.000 --> 38:47.000
So this is just a way that you can have the compiler,

38:47.000 --> 38:49.000
you know, where it makes sense,

38:49.000 --> 38:51.000
where you don't need as much flexibility.

38:51.000 --> 38:53.000
You can sort of start to lock down, you know,

38:53.000 --> 38:55.000
maybe internal core data types

38:55.000 --> 38:57.000
and objects and structures that you're using

38:57.000 --> 38:59.000
and have some extra guarantees

38:59.000 --> 39:02.000
that you're not going to run into random errors around nil

39:02.000 --> 39:04.000
or any other little type mismatch.

39:04.000 --> 39:06.000
What's interesting, I think, is that it's,

39:06.000 --> 39:08.000
you know, this is one space, like,

39:08.000 --> 39:11.000
you know, obviously TypeScript is a big success.

39:11.000 --> 39:14.000
Facebook's had Hack for PHP for a long time now.

39:14.000 --> 39:17.000
And Python even has type annotations

39:17.000 --> 39:19.000
as part of the language now,

39:19.000 --> 39:21.000
not to mention some of the other available systems.

39:21.000 --> 39:24.000
So it's interesting to see Ruby catching up.

39:24.000 --> 39:26.000
Yeah, I think it's a...

39:26.000 --> 39:28.000
I think it's a useful tool

39:28.000 --> 39:30.000
that's going to be more and more useful

39:30.000 --> 39:32.000
as some of these legacy Ruby applications

39:32.000 --> 39:34.000
get, you know, just, you know how it is.

39:34.000 --> 39:36.000
They get exponentially bigger over time, right?

39:36.000 --> 39:39.000
Yeah, and many people, you know, you want to...

39:39.000 --> 39:41.000
They say, like, oh, well, we switched to Go

39:41.000 --> 39:43.000
partially because these types.

39:43.000 --> 39:45.000
So you can still make Ruby work.

39:45.000 --> 39:48.000
It might be, you know, everyone knows the pain of a rewrite.

39:48.000 --> 39:50.000
So if you can instead suffer a little less pain

39:50.000 --> 39:52.000
and still get partial benefits,

39:52.000 --> 39:55.000
well, that might be a huge win.

39:55.000 --> 39:58.000
One problem Ruby and Python share,

39:58.000 --> 40:00.000
and we touched on this earlier,

40:00.000 --> 40:02.000
it's application distribution.

40:02.000 --> 40:05.000
And if you're shipping a snap

40:05.000 --> 40:07.000
or you're shipping a Docker image, it doesn't really matter

40:07.000 --> 40:09.000
because you basically write a script

40:09.000 --> 40:12.000
that imperatively,

40:12.000 --> 40:14.000
and that's kind of part of the problem here,

40:14.000 --> 40:16.000
builds your system for you, right?

40:16.000 --> 40:18.000
You say, like, oh, yeah, okay, here's my...

40:18.000 --> 40:20.000
Maybe you're using Bundle and you got, like, you know,

40:20.000 --> 40:22.000
the gems that you wanted to install for you

40:22.000 --> 40:26.000
or you're doing pip and setting up a virtual env in Python.

40:26.000 --> 40:29.000
Either way, when you're setting these things up,

40:29.000 --> 40:32.000
you've got to go get and install this stuff.

40:32.000 --> 40:34.000
And that works okay.

40:34.000 --> 40:36.000
If you're just running stuff for yourself,

40:36.000 --> 40:38.000
really, it's not that big of a deal.

40:38.000 --> 40:40.000
And if you're just running scripts that you make for yourself

40:40.000 --> 40:42.000
on your own system or systems you deploy to, fine.

40:42.000 --> 40:44.000
It's still not great.

40:44.000 --> 40:46.000
It's not always totally deterministic

40:46.000 --> 40:48.000
or you have to go through some extra hoops

40:48.000 --> 40:50.000
to make it that way, but it works.

40:50.000 --> 40:52.000
But it's particularly troublesome

40:52.000 --> 40:54.000
when you've hacked together a nice little script

40:54.000 --> 40:56.000
or you've tried to write a nice command line

40:56.000 --> 40:58.000
that you want to share with someone

40:58.000 --> 41:01.000
and you're like, how do I distribute this application?

41:01.000 --> 41:03.000
Yeah, sure.

41:03.000 --> 41:07.000
That's where a new Python project called PyOxidizer

41:07.000 --> 41:09.000
comes into play.

41:09.000 --> 41:12.000
I think this is interesting because there are already

41:12.000 --> 41:14.000
some solutions to this in Python.

41:14.000 --> 41:18.000
In particular, Twitter has a project called Pex,

41:18.000 --> 41:20.000
which is a Python executable.

41:20.000 --> 41:23.000
There's another one called Shiv out there and Platter.

41:23.000 --> 41:25.000
There's a number of these that sort of help to try

41:25.000 --> 41:28.000
to re-bundle some of your virtual environment.

41:28.000 --> 41:31.000
Right now, though, most of those end up relying on

41:31.000 --> 41:34.000
having a Python interpreter on the system already.

41:34.000 --> 41:37.000
And to most cases, that's true, right?

41:37.000 --> 41:39.000
That's one of the things that makes Python a great choice

41:39.000 --> 41:41.000
for writing some of these applications

41:41.000 --> 41:44.000
because you can usually rely on a Linux

41:44.000 --> 41:47.000
or even a Mac system to have Python.

41:47.000 --> 41:50.000
PyOxidizer is different because it's everything.

41:50.000 --> 41:52.000
So it's using Rust.

41:52.000 --> 41:54.000
I figured we just had to include it in the show

41:54.000 --> 41:56.000
for that reason alone, right?

41:56.000 --> 41:58.000
I appreciate it a lot, actually.

41:58.000 --> 42:00.000
And it actually produces a single executable

42:00.000 --> 42:03.000
that includes a virtual end that gets mapped into memory

42:03.000 --> 42:06.000
so it can actually load faster than a traditional one

42:06.000 --> 42:08.000
that has to read in from the disk,

42:08.000 --> 42:10.000
and a Python interpreter.

42:10.000 --> 42:13.000
So it's just all-in-one use of the interpreter,

42:13.000 --> 42:15.000
loads it up with access to the virtual end files.

42:15.000 --> 42:17.000
You know, that sounds very good to me a lot.

42:17.000 --> 42:21.000
I mean, I, for years, struggled with how do you package things on Linux,

42:21.000 --> 42:23.000
and I ended up being a snappy.

42:23.000 --> 42:25.000
Is that the wrong word?

42:25.000 --> 42:27.000
Yeah, you know, snap, snap packages,

42:27.000 --> 42:29.000
snapty, snapcraft.

42:29.000 --> 42:31.000
No, no, I call them snappies.

42:31.000 --> 42:33.000
No, it's not cute enough. Snappies.

42:33.000 --> 42:35.000
I call the other ones flatties.

42:35.000 --> 42:37.000
Snappies and flatties. I like it, Mr. Dominic.

42:37.000 --> 42:39.000
That's just the part of the show where Wes is like,

42:39.000 --> 42:41.000
he's just messing with me now, isn't he?

42:41.000 --> 42:43.000
You are an ultimate troll.

42:43.000 --> 42:46.000
Yeah, you know, I have to be honest with you.

42:46.000 --> 42:48.000
I hate Python.

42:48.000 --> 42:50.000
It ruined my Rubyism.

42:50.000 --> 42:52.000
You mean because it tempted you?

42:52.000 --> 42:55.000
Because it's just better than Ruby in almost every way.

42:55.000 --> 42:57.000
We're getting a lot of feedback on the show.

42:57.000 --> 42:59.000
Yeah, I mean, you're coming in hot.

42:59.000 --> 43:00.000
I'm coming in hot.

43:00.000 --> 43:02.000
I mean, they're similar.

43:02.000 --> 43:04.000
I admit similar opinions.

43:04.000 --> 43:07.000
They're mostly close enough.

43:07.000 --> 43:09.000
This could be a big advantage.

43:09.000 --> 43:11.000
Whoa, whoa, whoa.

43:11.000 --> 43:12.000
What do you mean close enough?

43:12.000 --> 43:14.000
You're so diplomatic, Wes.

43:14.000 --> 43:16.000
You know, I listen to you on all your other shows,

43:16.000 --> 43:18.000
but you're Mr.

43:18.000 --> 43:21.000
Tell me what you really think of Ruby and no holds barred.

43:21.000 --> 43:23.000
I mean, I don't like it as much as Python,

43:23.000 --> 43:27.000
but there's many things about it I do like sort of aesthetically.

43:27.000 --> 43:28.000
I like the use of nil.

43:28.000 --> 43:31.000
I like some of like using question marks and other things.

43:31.000 --> 43:33.000
It's pretty flexible.

43:33.000 --> 43:38.000
I would say I generally prefer Python's explicitness,

43:38.000 --> 43:41.000
explicit nature to Ruby's sort of magic.

43:41.000 --> 43:43.000
Now, you're going to say, and you're right,

43:43.000 --> 43:45.000
that a lot of that came out of the Rails community,

43:45.000 --> 43:48.000
but it's just still kind of part of that,

43:48.000 --> 43:52.000
and it just feels a little looser.

43:52.000 --> 43:53.000
I've not tried Sorbet.

43:53.000 --> 43:54.000
That might help.

43:54.000 --> 43:57.000
Python's not great, you know, with some of the extension methods

43:57.000 --> 43:59.000
with double underscore and that sort of thing.

43:59.000 --> 44:02.000
I really like languages that have interfaces

44:02.000 --> 44:04.000
and other sorts of utilities like that,

44:04.000 --> 44:06.000
and I think those are missing from these languages.

44:06.000 --> 44:08.000
But otherwise, while I prefer Python generally

44:08.000 --> 44:10.000
and have more experience in that realm,

44:10.000 --> 44:13.000
I guess what I mean is you can switch between them

44:13.000 --> 44:15.000
relatively easy.

44:15.000 --> 44:17.000
Both of them have libraries for basically anything

44:17.000 --> 44:19.000
you want to do,

44:19.000 --> 44:22.000
and the design doesn't have to change that much between them.

44:22.000 --> 44:25.000
You were actually much nicer than I thought you'd be.

44:25.000 --> 44:29.000
Okay, I mean, I would say that Ruby never could get out

44:29.000 --> 44:31.000
of the shadow of Rails, right?

44:31.000 --> 44:34.000
Where Python has become, and this is not me just trolling

44:34.000 --> 44:36.000
for, you know, to be a dick.

44:36.000 --> 44:39.000
Python is dominant in data science.

44:39.000 --> 44:41.000
Python is dominant in ML now.

44:41.000 --> 44:43.000
Yes, I know ML.net exists.

44:43.000 --> 44:45.000
Please don't email me again, Microsoft people.

44:45.000 --> 44:48.000
And you can totally write all that stuff in F sharp and C sharp,

44:48.000 --> 44:50.000
but really, you're running into Python.

44:50.000 --> 44:52.000
Where Ruby is like,

44:52.000 --> 44:54.000
yeah, we kind of can write a Rails app.

44:54.000 --> 44:58.000
Like, Ruby, in a weird way, Ruby got,

44:58.000 --> 45:00.000
I don't want to say destroyed,

45:00.000 --> 45:03.000
but kind of co-opted by the Rails community.

45:03.000 --> 45:06.000
Am I making sense at all, or does that sound completely insane?

45:06.000 --> 45:08.000
No, I think you're right.

45:08.000 --> 45:10.000
I mean, part of the success of Ruby

45:10.000 --> 45:12.000
was having that killer application that was Rails.

45:12.000 --> 45:14.000
But you're right, it just, you know,

45:14.000 --> 45:16.000
like many problems we see economically,

45:16.000 --> 45:18.000
it was sort of a single thing it did really well.

45:18.000 --> 45:20.000
And so if you want to run it for that,

45:20.000 --> 45:23.000
Python has all kinds of applications and utility.

45:23.000 --> 45:25.000
And I guess, I mean, we should end here,

45:25.000 --> 45:27.000
but I guess to put a finer point on it,

45:27.000 --> 45:29.000
the development of the Ruby language

45:29.000 --> 45:32.000
has effectively been co-opted by what is best for Rails.

45:32.000 --> 45:34.000
Which has, you know, limited it, right?

45:34.000 --> 45:36.000
Python has many other domains, and they are,

45:36.000 --> 45:39.000
you know, we can argue about technical limitations,

45:39.000 --> 45:42.000
but they are effectively equivalent languages.

45:42.000 --> 45:45.000
Python kept a broad, this is a language,

45:45.000 --> 45:47.000
not a web framework.

45:47.000 --> 45:49.000
Right, and I suppose another way

45:49.000 --> 45:51.000
to talk about what you're saying is,

45:51.000 --> 45:53.000
like in the design discussions of Python,

45:53.000 --> 45:55.000
these other communities, right?

45:55.000 --> 45:58.000
Like the big data machine learning communities,

45:58.000 --> 46:00.000
the shell scripting communities,

46:00.000 --> 46:02.000
they're all present.

46:02.000 --> 46:05.000
And in the Ruby universe, it's mostly just the Rails web dev.

46:05.000 --> 46:07.000
It's just Rails, right.

46:07.000 --> 46:10.000
I mean, people will say they do Sinatra or Patrino,

46:10.000 --> 46:12.000
or they do, like I have Rails scripts,

46:12.000 --> 46:15.000
but I mean, effectively, everything is geared towards Rails.

46:15.000 --> 46:17.000
But yay, Python.

46:17.000 --> 46:19.000
Yay, Objective-C.

46:19.000 --> 46:21.000
Maybe our audience has opinions

46:21.000 --> 46:23.000
about some of the neat stuff we've talked about.

46:23.000 --> 46:25.000
Maybe you're thinking about adopting Sorbet

46:25.000 --> 46:27.000
in your project.

46:27.000 --> 46:29.000
Or you're thankful to finally have

46:29.000 --> 46:31.000
a great way to ship Python.

46:31.000 --> 46:33.000
Go try out PyOxidizer,

46:33.000 --> 46:37.000
and then let us know what you think.

46:37.000 --> 46:40.000
coder.show slash contact.

46:40.000 --> 46:42.000
You can also head over to coder.show

46:42.000 --> 46:44.000
to find our whole backlog

46:44.000 --> 46:46.000
and an easy way to subscribe.

46:46.000 --> 46:48.000
We've got an RSS feed.

46:48.000 --> 46:50.000
Super simple.

46:50.000 --> 46:52.000
It's the best way to make sure you get

46:52.000 --> 46:54.000
every single Coder Radio episode.

46:54.000 --> 46:56.000
If you want to catch us live,

46:56.000 --> 46:58.000
yeah, we do this show live every Monday,

46:58.000 --> 47:00.000
12 p.m. Pacific.

47:00.000 --> 47:03.000
If you don't know what that is in your time zone of choice,

47:03.000 --> 47:07.000
well, head on over to jupiterbroadcasting.com slash calendar,

47:07.000 --> 47:09.000
where our magic Google bots

47:09.000 --> 47:11.000
will automatically convert it

47:11.000 --> 47:13.000
to your time zone.

47:13.000 --> 47:15.000
jupiterbroadcasting.com also has

47:15.000 --> 47:17.000
all the other fine

47:17.000 --> 47:19.000
Jupyter Broadcasting productions.

47:19.000 --> 47:21.000
If you want to get caught up on the

47:21.000 --> 47:23.000
latest Linux and open source news,

47:23.000 --> 47:25.000
well, Linux Action News.

47:25.000 --> 47:27.000
Or if you're new to this whole Linux world,

47:27.000 --> 47:29.000
go check out Choose Linux,

47:29.000 --> 47:31.000
which is a show that captures

47:31.000 --> 47:34.000
the experience of discovering Linux.

47:34.000 --> 47:36.000
If you just can't wait and none of that

47:36.000 --> 47:38.000
is enough content for you, well, don't worry.

47:38.000 --> 47:40.000
Mike and I are both on Twitter.

47:40.000 --> 47:42.000
Mike especially.

47:42.000 --> 47:45.000
He's at Dimenuco.

47:45.000 --> 47:47.000
And I'm at Westpane.

47:47.000 --> 47:49.000
The whole network's there too, of course,

47:49.000 --> 47:52.000
at Jupyter Signal.

47:52.000 --> 47:55.000
Thank you so much for joining us today.

47:55.000 --> 47:57.000
Please do try and join us live if you can.

47:57.000 --> 47:59.000
We'd love to have you.

47:59.000 --> 48:02.000
Until then, see you next week.

48:29.000 --> 48:46.000
jupiterbroadcasting.com


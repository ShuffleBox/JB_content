This is Koder Radio, episode 370, for August 12th, 2019.
Hello, and welcome to Koder Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business, software development, and related technologies.
My name is Wes, and I'm pleased to be joined once again by Mr. Michael Tominick. Welcome back, Mike.
Hello, Wes. How are you?
Oh, I'm doing great. Actually, it's nice to talk to you.
You were absent last episode. You were sick as a dog, so I heard.
But, you know, we had Chris back on the show. You missed him. It was still a lot of fun. If you missed that episode, go check it out.
But, you know, you're really the spirit of this show, so we're happy to have you back.
Yes, I'm the raging wraith of the show.
If Jar Jar's the spirit creature, you're the spirit human, I guess.
Well, first of all, denying Jar Jar's humanity is just wrong. Jar Jar is a person like anybody else.
But second of all, I noticed Chris admitting to a poisoning plot against me.
Oh, you listened? I didn't expect that.
Oh, I listened.
Dang. Okay, we didn't plan for that at all.
This is going to be a great show, Wes. We have something in this show that I am dying to hear you talk about.
Oh, I mean, I think that might just be that I've been playing with F-sharp. Is that what you're excited about?
It could be.
Yeah, okay. I expect so. Something tells me you're a little fond of it.
Oh, I'm just a touch.
But before we can get to that excellent topic, well, we've got a few other things to talk about first.
That's right. We have to eat our Emacs vegetables.
Yeah, yeah. We've gotten, I mean, would you say a ton of feedback about, I mean, all the functional stuff we've been talking about?
You tried Clojure in a previous episode. We doubled down and just did a whole functional episode.
The feedback's been awesome. And DJ sent us some tips about Emacs, which honestly, that's fairly appreciated.
Yeah, that's awesome. That was great feedback.
Yeah, I particularly like the section about the Emacs, basically language you can write in being fairly functional and a good introduction.
Yeah, DJ writes, another point for the show is a soft intro to functional programming.
Wes mentioned Emacs because, you know, the nice packages supporting Clojure development.
But I just wanted to point out that Elisp seems to be a fairly intuitive and well-documented little functional language in its own right.
And it might make an excellent soft intro to functional programming.
I think you were more familiar with some of the functional aspects, but the Lispisms, you know, the strange way of actually talking to the machine, that was what was different.
So I could see, you know, for some people in the right boat, maybe experienced Emacs users or people just curious about Lisp in a softer environment, Emacs might make sense.
I could see it. Yeah.
We love feedback like this. So if you've got some, well, head on over to coder.show slash contact and we've got a little form you can fill out.
Send us the latest and greatest or just tell us what we're doing wrong.
Another way you can provide us feedback is over at the Coder Radio subreddit.
And someone pointed out something I'm not supposed to tell you, Mike.
And well, that's a version of Ruby written in Rust.
This is very exciting to me. This is like a turducken of glory.
Yeah. Oh, man, I love I love me a turducken. Of course I do. Oh, it's a thing.
Yes. So a version of Ruby written in Rust.
I mean, let's just just take everything I like, put it together and call it artichoke.
And you know what? It is indeed real. I've yet to try it out, but damn, if it doesn't look fabulous.
And there's some some pretty impressive performance statistics.
Now, I always take these with a grain of salt because, you know, 900 percent of statistics on tech podcasts and tech blogs are made up.
But it could be good. Rust is very fast. I could I could see a new implementation of Ruby being fairly performant.
Yeah. Right. And we've already seen multiple implementations of of Ruby.
Right. I mean, there's there's Ruby on the JVM. There's just other versions of it.
So perhaps with some new foundations, Ruby can continue to live on.
And Rust seems like a good choice to implement a language in these days.
If you're going to need, you know, low level compatibility, be able to do stuff where you reach out and use faster code if you need to.
And since you've already been exploring, you know, writing that in Rust, I imagine that would also be possible in artichoke.
It would be. I wouldn't say that this is something I would use in production, though.
Oh, certainly not yet. No. Yeah.
But definitely, you know, an interesting alternative to saying writing performance hungry components in Rust is that you could write a Ruby backed by Rust, which certainly theoretically is going to be at least some kind of performance gain.
Right. I'm I'm hedging a little because I haven't tried it out myself, but I was very excited to read it in the subreddit.
The other thing it makes me think of is, you know, it's just even if no one ever uses this in production, it's probably not a bad thing just to sort of flex the Rust muscles.
You know, one, implementing a language is interesting for the working on it.
But also, there may be areas in Rust that could be improved and, you know, actually trying to implement something complicated and existing like Ruby.
Well, you might just find some of those areas where you need a new library or need to add something to an existing Rust library that would make implementing future languages easier.
So we've been following a story for, what would you say, Wes, about three months, maybe?
Something like that. Maybe a little longer. But I mean, it's kind of hard to escape from. It's a big deal, at least here in the Pacific Northwest.
And I'm sure it's a big deal for you, too.
It is. As a guy who writes software for aviation, it's it's a thing. The whole Boeing 737 Max situation.
Quick recap for those who don't recall or haven't listened before.
There was an issue with the 737 Max where basically there was a technical computer error that caused the plane to, is it fair to say, misinform the pilot?
It wasn't clear to the pilots what was going on and when this system that was supposed to help because of the change in engine position and wings, you know, prevent stalls of the plane, but was not a clear override to the pilots, at least in certain circumstances.
You also saw some issues around, you know, optional lights and indicators that some planes had and some didn't.
So, you know, there's just a lot of change going on. And now they're saying they need to make another change before this thing's actually going to get back in the air.
Yeah, that's right. So they're going to add a system where they have two separate basically flight computers that will read out the same values or I'm sorry, will attempt to read out the same values.
And the pilot will be warned on their display if the values disagree. And I should say pilots because there's usually, you know, pilot, co-pilot. Big enough plane for that.
That's an interesting way to solve this problem. And I honestly don't know how I feel about that.
So basically, the idea, Wes, is you have two computers running. They're running the same software. But the whole idea is it's going to warn you if the two the two instances of the software don't agree on the values.
Oh, okay. Just just as a second one, sort of a safety check. That makes a lot of sense. I mean, it doesn't feel like it's the I don't know, in a clean room design is I don't know that that would come up with although it does, you know, multiple machines disconnected from one another. That does add a layer of robustness.
Right, I guess the assumption is some of the issues that were happening were basically bad information being fed to the pilot and he and the pilot was causing, you know, issues or responding poorly, we should say, not not because it was their fault, because, you know, pilots tend to fly by their instruments, right?
Pretty rare for that not to be the case.
Yeah, I mean, it's a complicated machine, you have all of this infrastructure available to you. And most of the time, you can trust what it's telling you.
So it's an interesting story. I mean, this is one of those stories that when it first came out really brought into the whole, you know, software engineering, licensure stuff, and kind of standards as an engineering field.
I can't say that this is a great solution, because theoretically, all it's telling you, according to this, this Yahoo News article is if they don't agree.
But, you know, I guess it's better than nothing, right? I mean, it's interesting. See, it's interesting that Boeing hasn't come out and said, like, why they can't have the right values returned.
Yeah, I'm curious if you have any insight there. It's just such a foreign world. There's not that many manufacturers or people in play. And there's so many regulations.
It's interesting how much more, you know, as the software layers have been added and added and added. It's just different than, you know, web services that someone uses to send work messages.
A key point of background on the story is that Boeing wanted to compete with an Airbus. That was basically, there's a whole thing where you don't have to recertify a plane. If you're just modifying existing model.
It's not like you do from a from a plane from scratch.
From, let's say, like you said, a clean room implementation. It seems, I mean, and this is, again, this could be argued and they have argued in their defense that not really.
But a lot of the aviation space commentators and people who would know better than I, for sure, have said they really push the envelope on, you know.
In the rails, we have a term called monkey patching, right? Monkey patching their existing design because they needed to compete with Airbus.
So it's like every software project that really did just come down to money.
Right. And then there's also there's an issue on the other side, too, right, where airlines probably like this, where pilots also need to be certified differently on a, you know, a modification of an existing plane versus a new plane.
Yes, less. It's less. Right. So. So it's cheaper for the airlines. It's cheaper for Boeing.
And I mean, this is not an entirely software story because there's there was also some concerns about some components and hardware. But for the purposes of this show, it's definitely interesting how their solution is to run a parallel instance of the same software on a separate piece of hardware.
Yeah, it's interesting. And as we should be clear to point out, you know, this is serious stuff and already far too many people have died and and that's terrible.
Yeah, people have lost their lives. Yeah, this is a serious issue.
All right. Well, let's move on to something also serious and relatively terrible and relatively terrible. I'm curious what you think about this. This is kind of happening over on your side of the country.
Experts thought that the contract for what's known as Jedi, which is just a fun coder radio name, but the Joint Enterprise Defense Infrastructure, which is a big investment by the government into all kinds of resources.
Well, everyone expected that was just going to go to AWS. But Oracle has had their hands and wanted to have their hands in this pie for a long time. And it seems like they've got friends in the right places.
So there's this New York Times article about the Jedi is a very large government contract. I think the number is like $10 billion or something ridiculous like that. Oh, boy.
And basically, it needs to go to a cloud database provider, among other things. Oracle, being Oracle, really wants this contract.
And they do have a cloud, you know, in case people may not know that because I sure didn't for a while.
But like, you know, AWS in the enterprise, like governmenty space is kind of the big boy, at least when you think of these cloud tech companies.
Right. I mean, they've even got GovCloud. Isn't that what they call the services they sell the government?
Yeah. And there's been stories about them selling cloud to the CIA. AWS has been pretty much the leader here.
And Microsoft Azure has tried to get in the game. And it's not that they failed, but certainly, you know, it's Amazon, Microsoft.
And then maybe way down the list is Oracle. I mean, Oracle has a lot of legacy.
So how would you frame the story, Wes? Because I want to be a little careful.
Because, you know, government bidding on contracts can be challenging, if I can tell you that.
Right. And I mean, so I will say, and as people are quoted, it's important that, you know, we try to maintain a fair and competitive process for defense contracts.
Right. I mean, I don't know that that's where we are. I'm pretty sure we're absolutely not there.
So in one sense, I guess, like, AWS seems like the obvious choice. It probably does make sense to, you know, review bids and perhaps even especially consider other options.
That said, I don't know, the fact that it's Oracle is one of the major other bidders here still leaves me with a weird feeling.
It's a little weird. Now, if it were Microsoft, I would be more like, well, you know, Azure has come a long way and blah, blah, blah.
They have a lot of great stuff with the cognitive engine. Who knows what they're really trying to do with this Jedi project. Right.
So, like, the implication in this New York Times article is that this has nothing to do with the technical merits of Amazon's proposal.
Right. That's a little weird.
Yeah, it is a little weird. Right. I mean, because there's there are some things we know the current president doesn't exactly love Jeff Bezos.
I thought they just had a tea. No. Yeah, I guess not.
Maybe a tea time even? No, maybe a tea time. That would make more sense, wouldn't it?
So there's some issues there, right? And obviously, Bezos now owns the Washington Post, which perhaps reports unfavorably at times on the current administration.
So it does seem like, you know, as always, there's there's just a lot of politics here.
And I bet that Oracle's technical offering is is probably worse.
It doesn't seem like their cloud is doing particularly well. They just lost the leader over to Google.
You know what? I think you can just assert that is true. I'm just going to throw that.
Well, I was trying to be careful like you, Mr. Dominic. Yeah, but I mean, again, Microsoft, IBM, maybe IBM.
I'm not even sure. But you're right. Microsoft would be a good analog here, right?
If they were if they were in this and it was Amazon v Microsoft, that would kind of seem more par for the course.
I'm curious if you have any insights just from your own like, you know, what what should be happening here?
Well, so one big government contracting is different than little government contracting.
So on the on the little jobs and I can only tell you for like the small business jobs, that's all I really know.
You are judged first on does your proposal actually hit the spec within a reasonable budget?
Right. Which makes sense. Like a misconception is that always the lowest bid wins.
That's actually not true. Someone comes in with a lower bid, but they say they can't hit some of the requirements.
You could still win even if you're higher. But because I'm in the small business arena, there's a lot of credit given to business owners,
depending like if it's an economic development zone and you're equal to that person, they'll get it.
There's, you know, all kinds of inclusion stuff. So race, gender, stuff like that.
Veterans and disabled veterans, since I mostly do military style stuff, get a get a big boost.
But in my case, small business owners also, if you're because Tampa is considered that it's like a growing area, you get a boost there.
So it's weird because what ends up happening is you end up actually being like little brother to a bigger contractor all the time
because they want you to get in there and bid so that you get the small business credit.
But, you know, if you're a five to 10 man company, you can't like actually have a hangar full of planes, speaking from what I know of here.
Right, right. Yeah. So you have to partner up now in the big world of contracting.
Yeah, there's a lot more relationships and politics going on, right?
Like I usually don't meet the people I'm sending the RFPs to unless I get the job or like the very end of the process.
I see. You're just sort of down there in the weeds and there's a there's a big tree all the way up to where it's actually happening.
Yeah. And that's that's pretty common in the small business world, which is yeah, which is which is fine.
I mean, I'm not complaining. I guess we should all be happy we don't have Amazon's problem here.
That certainly seems like it would be an issue.
Yeah. Yeah, that is that is true. It's also interesting that, you know, there's a lot of the Times article notes that, you know,
Microsoft is interested here and actually maybe benefiting from all the lawsuits and things that are going and basically what they call Oracle stalling tactics
because Microsoft doesn't actually currently have all the security certificates that would be required to, you know, to meet the spec on this.
But they are working on them. And that just adds another layer, right?
Like there's there's few players originally and there's few qualified players at that.
Yeah. And that does actually seem true.
So oftentimes you will see even in these small business proposals or like to do a component of a project, they say the proposal deadlines.
I'm just going to make something up, right? September 15th. But then something will happen where like there'll be a question internally
and that will change the requirements and be the net, you know, in the first quarter of the following year.
Well, we'll see. You know, none of this is resolved yet, but it is always interesting.
These are these are big contracts, important updates. And last but not least, you know, a lot of the stuff that's going to be stored there is important.
So probably behooves anyone who's a U.S. citizen that this gets done right.
Yeah, I'm going to say like Oracle, really. Just throwing it out there.
No offense to any Oracle employees who may be listening, but maybe a little bit.
Yeah, maybe a little bit, although I'm sure the money's good.
Oh, I'm sure it is. So if you don't want to bid on these contracts, couldn't you just say F sharp it?
Oh, that's that might be the best segue we've ever had. And you're right, Mike. It's probably time we do another seven languages check in.
This time it's my turn. You challenged me a bit ago with checking out F sharp, which is one of your favorite languages.
So the horrors that are enterprise level dotnet applications written in C sharp.
Yes. Tell me about it.
That is why I chose F sharp. Well, C sharp is a little religious about OO.
For the listeners, if you are a Java developer, it's like that.
As things get bigger, you get a lot more tight coupling between objects.
You get a lot of can we say like side effects, which is exactly the right word to say, right?
Side effects in your code. Right.
And I mean, it's literally so F sharp was like my gateway to functional because I kept inheriting these applications.
So I would get a contract on to like, hey, our software does this thing. It's written in dotnet.
Can you come in and do right. Add a feature, fix something, whatever.
And every time I would try to like literally pull apart the spaghetti strands of the C sharp code, I found myself just like in the worst type of brownfield development.
Just, you know, very frustrated, struggling a lot.
And somebody I think literally at a at a at a show in.
I want to say sort of Orlando or was it New York?
I can't remember. It was either right when I moved down here or right before introduced me to F sharp.
And sure enough, it just rewriting components and modules and F sharp to kind of I won't say replace everything,
but like extricate the business logic out of that spaghetti code type coupling world.
Again, not trying to dunk on C sharp developers.
I literally wrote C sharp yesterday. I'm not like, you know, not being a functional leaders,
but it made those applications that of course I was inheriting much easier to keep working on, keep modifying and keep adding components to.
Sorry for the functional lecture. Take it away.
No, but I mean, I think that's that has to be part of what we're talking about, right?
Because F sharp basically describes itself as a functional programming language that runs on dot net.
And, you know, they talk about a lot of those a lot of these like functional stuff that we think about functions and modules, pipelines,
pattern matching, type inference, recursion, option types, record types, discriminated unions.
So it is, you know, that's where F sharp fits. And honestly, I've been really impressed with a lot of the just like sort of getting started with F sharp documentation.
You can tell that, you know, existing C sharp developers are definitely a target because a lot of the docs just right on the site,
they have side by side comparisons from C sharp to F sharp.
And honestly, getting used to sort of the F sharp style took me a little while, you know, got to sort of get the intuition built up.
And not that I'm like a, you know, C sharp programmer, but having those side by side examples, just to see it in sort of a, you know, classic,
imperative object oriented sort of language. That was a nice contrast.
It was a little confusing to get started, though, because there's multiple implementations of dot net, right?
And maybe you could clear this up as someone who's followed it a little bit more.
I mean, I follow it too, but I, you know, until now, I don't have been using it all the time.
So I was a little confused because the guides, you know, on Linux in particular, they'll just tell you to install F sharp right from many package repositories,
which is awesome. But also that installs the mono version.
We also have dot net core running on Linux, right?
So what should I actually be targeting if I was going to try to make, you know, like, let's say a server side F sharp app running on Linux?
It's so funny. So the beginning of this month, we're kicking off a dot net project over at the Mad Botter for a customer.
And yeah, everything new we're kicking off is dot net core in terms of at least web server side web software.
There's nothing nothing against mono. I also have written lots of mono.
But at this juncture, Microsoft and the Dotnet Foundation, which I guess disclosure, I'm a member of the Dotnet Foundation.
I've been pretty clear that dot net core is going to be the way to go, particularly if and this is what I'm curious if you're because for me,
when I'm writing F sharp, my target platform is actually usually Linux now.
Right. I'm not. So these are not running on like IAS or whatever it's called.
Right, right. Like unless you're actually building like a desktop app or something, it's going to run on a Linux server.
Well, so that's also funny. You mentioned the desktop. So September 23rd to 25th is the Microsoft Ignite.
They have so many conferences, I can't remember to keep the name straight, but Dotnet Core 3 is coming out with desktop support.
And I'll give you one more product I sponsor called Avalonia can bridge between them using the Dotnet standard.
And that runs on, let's see, the web, Linux, Mac, PC and I think mobile.
We also had the guys from Project Uno on the show right before you jumped on with us.
We're with me, Wes. Same deal. They'll do WebAssembly, Windows, Mac and mobile.
Everything you'd expect. Great implementation. All using Dotnet standard.
It gets complicated because Dotnet standard is basically neutral Dotnet. So everything implements it.
The idea being if your library is written to Dotnet standard, you can basically use it everywhere.
If you're on the web and doing server side stuff, you want probably Dotnet Core, but your libraries will probably be Dotnet standard.
When they say Dotnet standard, it's literally the standard, right? It's the accepted standard of Dotnet.
Hmm. Okay. I see. That's interesting. So how is your onboarding experience?
Were you doing this in a VM on Windows or did you stick with your normal?
No, of course not. Come on. Do you know me? Actually, I just blew away the last Windows VM I had.
So I don't even have a Windows VM at the moment to play with.
I will get you on WSL. Don't worry. It's my mission for the show now.
Challenge accepted. So I just got started. I went the mono version just because it was in the repository.
It seemed like the most common one, although I did get the Dotnet version installed too.
And then I already had VS Code installed. So then I got Ionide. Am I saying that right?
Which is a cross-platform F sharp editor tool that has VS Code support.
Oh, yeah. That was nice. That was really nice. I was impressed.
I mean, one, it's always nice being in, you know, like a rich statically inferred typed language like F sharp, you know,
with a good ML background in the Henry Milner type inference.
And it's just nice. The autocomplete is amazing.
You really feel like you're engaged with the compiler. The errors, I thought, were mostly actually not that bad.
You know, sometimes you get like those type errors in statically typed languages and you're just like, what now?
You know, unless you have done a lot and really understand the sort of type hierarchies and the foundations of how that language was implemented.
At least I've had that problem a couple of times, like learning Rust, playing with Rust, getting in a situation.
I'm like, I don't understand all these things. And at least in my initial, you know, foray into F sharp, I didn't really have that problem.
You know, you're a closure guy. You're a deep functional guy.
Did you feel maybe that it was like the sugar free version of your favorite candy or did you actually think it was truly functional?
Well, it's definitely not Haskell, right?
Well, nothing is.
Few things anyway. I can think of at least one and probably a few others that, you know, of course go beyond.
But honestly, I was really impressed. You know, the docs are all very, you know,
they push a lot of the functional stuff, pure functions, idempotency, talking about, you know, minimizing state and side effects.
But at the same time, it felt very pragmatic.
It didn't feel like, you know, a theory class or a language designed to sort of teach the principles.
It felt like something that I could use if I just wanted to go get some work done and hopefully, you know, minimize me having to fight with this different paradigm.
And, you know, honestly, it was nice because Clojure kind of takes the same approach, right?
Where you, you know, you should make your functions pure, but that doesn't happen all over the place.
And there are going to just be pragmatic exceptions.
Yeah, I mean, F sharp is really, I mean, at least in the way I'm using it, it is a way for me to go into existing large code bases,
like I kind of mentioned in the intro here, but not continue to, I mean, use a strong word, pollute the code base, right?
I don't think either of us is really a functional zealot, but there is a certain, I would say, project size where a very object oriented approach becomes painful.
And it just is the case that in a lot of legacy.net projects, that tends to be the size of the project.
Yeah, I was pleased with how much, you know, talking about data was also stressed.
And I think that's one of the nice things.
And one of the things I've seen problems with in large legacy OO code bases is it's hard to understand where the actual data is because you just have all these, you know,
interacting objects and multiple levels of hierarchies, maybe you've got, you know, several abstract classes and different implementations.
And you have to look in like six files to actually figure out what's going on.
And, you know, F sharp with the unions was really nice.
I always enjoy well supported pattern matching just right out of the gate.
That can be a nice way to reason about things.
I was curious, I noticed it mentioned, you know, rich concurrency support.
It even said I think that it had like an actor sort of system built in.
I didn't get far enough to play with that.
Do you know anything about it?
Yeah.
OK, so this is where I've become unpopular with the dot net people.
It does have kind of that actor model support you were talking about.
But it is still running on the CLR.
So one thing you really when you're in the world, you really have to keep in mind is that all of these language, much like in the Java world, right?
Where you're compiling to an intermediate step or intermediate languages.
So in theory, it is 100 percent actually in practice.
I think people have done it.
You can write the same F sharp, C sharp program that compile into the same thing.
It's a IR code, which is the CLR's equivalent to bytecode.
Right. The code that the CLR actually then runs.
So yes, it does have developer facing a, I would think, pretty nice and very good actor model that you're used to from a functional point of view.
Is it the case that the CLR is not just implementing things in kind of a more legacy way?
Well, that's where we start to get into.
So what version of dot net are you on?
Oh, right.
So this is where my mono choice might come back to rear its head.
It won't bite you. It will not bite you.
No fangs here.
There might be some very mild performance differences.
And I will fully admit this is a controversial opinion.
I hate talking about performance unless something's really bad.
And I don't think this is really bad, but I'm only mentioning it because I can feel the Reddit and YouTube comments coming.
It is the case that all implementations of dot net are not created equal.
In particular, the deeper you go into the functional stuff with F sharp, the better off you are in the dot net core dot net standard world.
It will all work. It will all be still relatively performant.
But, you know, one of the big gains in dot net core three that's coming out is it's faster and it's embracing a lot more the CLR.
It is defined as the CLR here is embracing a lot more of the kind of functional way of life.
I mean, there are years of work that went into getting to dot net standard and dot net core, right?
There was the Roslyn compiler, which is partially what's actually doing all the magic and visual studio code that you're liking.
Right, right.
OK, I have a dreamless that Count Satya will come down from his Sith tower and just like strike down all the older implementations of dot net.
But just as a word of caution, if you are walking into like a dot net.
Early for late three dot net framework, not not dot net standard project, you may you may not, depending on how exactly you're doing things, see the type of performance gains you might expect using F sharp.
I know there's a lot of weasel words in there and because one, it depends on your code, right?
Depends on everything you've done in the project besides that.
But at least to my satisfaction, the people who have written these white papers up, which I don't care to do.
They've convinced me personally that it just is the case that the dot net core three, even dot net core two two and the newest version of dot net standard,
particularly if you're running on Linux, are not significant, well, somewhat significantly more performant, particularly if you're going the functional route.
That felt really confusing, but I hope it made sense to people.
I see. I see. So you just do need to be aware.
And if you want to use a lot of fancy functional stuff, probably better to be on a newer version.
That's right. So that's a simplified version, right?
The more functional you want to be, the more modern you want your version of dot net to be done.
That's the simple explanation.
Right. And that kind of makes sense, right?
I mean, a lot of the functional stuff is higher level and you do end up relying on either a compiler or a VM, you know,
something down there to optimize that stuff and actually be able to compete with the imperative model.
Right. Exactly.
It was nice. I think if I was, you know, doing more dot net stuff, I just happened to ended up, you know, kind of doing more JVM things
or being more familiar at the moment with the JVM, although I have no problem with dot net.
I would definitely be using F sharp. And it seems like it's almost the Scala.
This is bad. This is a bad metaphor, but like it's the Scala of the CLR.
I mean, I would say Clojure, but I think Scala is like a better comparison in some ways in that, you know, it keeps the static type nature.
I think one of the hard things about like going Java to Clojure in particular is, I mean, you know, you have this transition to dynamic types.
And I think doing that successfully, especially in larger projects, requires embracing a lot of the things that make Clojure different.
Right. Like really embracing the mutability and like data orientation and the ways that you separate concerns and keep things in small modules and,
you know, have sanity and checks at the interfaces between layers.
F sharp seems like a nice way to go, you know, all right, you're familiar with C sharp.
You're familiar with a lot of these tools.
Here's a new language that's going to teach you some new ways to do things.
But it's not throwing everything out.
But what I like is that I enjoyed learning Scala for all the neat functional stuff.
And, you know, there's lots of cool cool like lens libraries and all sorts of super neat monadic stuff.
But I've also seen plenty of Scala code that was like a weird hybrid that was like either just kind of like fancy Java or somewhere weird in between.
Right. Lovecraftian nightmare.
Yeah, Lovecraftian nightmare. Yeah, exactly.
And it feels like F sharp manages to retain a familiarity, you know, has a lot of open hands and bridges extended to the C sharp communities.
But doesn't get things as muddled.
I haven't done Scala in over seven years, so it's a little unfair for me to do the value comparison.
But I would say my experience onboarding from Java to Scala was much more painful than C sharp to F sharp.
And just real time follow up, Conan Kudo in the chat is mentioning that the newest or I guess most recent versions of mono are actually implementing dot net core.
So the performance may not be in that version anymore.
So, yeah. Oh, interesting. Thanks, Neil.
Yeah, I have I have been having a lot of fun playing with F sharp.
And I do think if I would, you know, if I was doing more dot net, I would be using it.
I'm curious. I ran into some interesting article and some some discussion about the problems or perceived problems with F sharp evangelism.
And I wonder what you think of people trying to convince C sharp developers, you know, C sharp to F sharp route versus.
You know, just F sharp standing alone as its own language.
I mean, obviously, you want to be able to utilize the rich dot net ecosystem, but you totally can.
It's right. So, I mean, I read this article.
He's actually debunking many of these problems. Right.
But he is mentioning certainly that a few of them are real.
You know, I've never met a programmer that if you tell them you want them to write in a different language, didn't grumble a little bit and complain that they could have done it in their language of choice five times faster.
I usually hear about Python. Of course, I kind of don't buy it.
You know what? You're still running on the dot net framework.
F sharp, I think to its detriment goes out of its way to be friendly to C sharp.
That was what I was picking up. Right.
In fact, I think like the biggest problem with F sharp is that it's a little too compromised.
Right. It's not functional enough in a lot of ways.
What would you like to see be more functional about it?
I'm curious. Well, so it gets down to all the like because it needs to follow the common dot net patterns of like interfaces and factories and all the common C sharp stuff.
Right, right. If you're using C sharp stuff, well, they're going to have, you know, different styles of APIs than you might write from F sharp to F sharp.
You have to keep in mind, Microsoft and the dot net foundation seem to be pretty eager to not break any compatibility at all.
So that means you're supporting all of these old patterns forever, which I don't want to get in a religious war about like pattern A versus pattern B because I think it's a waste of time.
And I have a feeling you and I would agree more than either of us in the random listener if I just took a bet.
But, you know, it's funny, actually, I blame you for this a little bit as you've had me and I can't can't wait to hear what you picked for me this week as you've had me go down this functional rabbit hole even deeper.
F sharp has started to lose a little bit of its luster for me because it, you know, I feel the compromises more.
I feel the oh, you know, so when I write someone in F sharp library, they can implement it in a horrible factory because it just allows that because that's how it works.
Right. And I'm making fun of factories. I know a lot of people don't do them anymore, but I'm trying to pick an example that's neutral to a lot of languages and obvious, right?
I also don't understand the resistance of if you're an experienced dot net developer, why would you be afraid of F sharp?
If anything, it's just another tool in your toolbox. I don't do pure F sharp programs.
I'll be straight up. For instance, if I'm doing a Xamarin project, much of the UI is in C sharp.
Either it's in XAML in C sharp or the code behind or it's in the weird C sharp script thing that you can do.
But the either the business logic or the data processing is in F sharp, much like my Rails applications now have some more the intense business logic or performance intensive stuff in Rust.
But, you know, the vast majority of the applications in Ruby. So I don't know, I'm not a purist either way, but I definitely have.
Particularly when interviewing people, definitely had some resistance. Yeah.
Yeah. OK, I can see that.
What about you, Wes, when you're talking to people about Clojure when they're coming from, let's say, I guess it would be Java.
Do you get pushback a lot other than me?
Yeah, I mean, I think there's a lot of things. Clojure is particularly hard, right? Because it's a Lisp.
Yeah, it's Lisp. It's dynamically typed. It's just different.
You know, I mean, like you ran into this, too. If you haven't tried the sort of interactive REPL based development model, it's just not like most other mainstream languages.
So it can take a long time to really get the handle of and appreciation of.
And, you know, even just trying it for a week or two, I think, may not, depending on how much time you devote to it, may not give you the full experience.
And that's probably true for, you know, many languages, especially when you're radically deviating from what you're trying until you've really built something with them.
You know, had to make changes, refactor, maintain. It's hard to understand just how good or bad it might be.
Yeah. And again, the terms good or bad, I think, are problematic.
Yes, they are. You're right.
I mean, I still think objectivity is great.
How well it suits the problem at hand and what you're trying to solve and within what constraints.
I will also add F Sharp has been around for a while as part of.NET.
And the whole development is sort of an interesting microcosm of the larger state of software in the world and what languages and how we think about it.
And in the show notes, we'll have this great PDF that Microsoft has called the early history of F Sharp.
And it's a little bit thick. There's a lot going on.
But if you're curious, you want to learn more about how all this happened, how people think about this and just the evolution of object oriented programming and functional programming.
It's just a great history of all of that.
So you had something interesting as your pick. Top Shell, is that a Ninja Turtles reference?
You know, I was hoping it was when I stumbled on it, but I don't think so.
It is, however, a purely functional reactive scripting language implemented in Scala.
And I don't know that I'm going to be, you know, switching to this from any other scripting language I'm currently using, but it's an interesting take.
And I'm glad to see people playing with stuff like I didn't mention it, but one of the things I found enjoyable about F Sharp was the pipeline operator.
You know, I mean, Clojure has similar things and you see that in a lot of functional stuff, but it's just a nice feature.
And there's definite analogs with, you know, with Unix pipes.
So it's interesting to see Top Shell has that. But with, you know, you get all the benefits of having, you know, structured data.
It just seemed to fit because there's also things like PowerShell, right, where you can interface with a lot of the dot net environments and also has some of these advantages.
And I don't really think we've hit a reasonable maximum. You know, Bash is great.
You can do Python if you need more than Bash, but there's it can be difficult to find the right balance.
And I think anything that we try will probably struggle because we're so entrenched in the tools we have.
But it's probably still worth doing because the command line interface is particularly productive, I think, for many people.
But we're hitting the limits of, you know, pushing around raw, unstructured text. Should be easy to install.
You might give it a try. I've got it going and they've got actually some decent documentation and examples, too.
So you can actually use it on your system and take advantage of fancy stuff like some types and pattern matching.
So where can people find you this week, Wes?
Well, they can find me over at Wes Payne or maybe check out Linux Unplugged, another fine Jupiter broadcasting production.
What about you, Mike?
At Dumanuco on Twitter and visit themadbotter.com.
Oh, you're always posting fun things over there.
That's right.
If you'd like to find more Coder radio, well, we've got that covered. Coder.show.
Yeah, that's right. We've got like a whole bunch of stuff there.
The whole back catalog, the notes for all the shows, easy ways to get in touch as well.
Also, head on over to JupiterBroadcasting.com to find a whole bunch of other great podcasts and crucially, a calendar.
That'll tell you when we're here live. That's right. We do this show live.
It's way more fun to be here live. So check it out if you can.
That calendar will use internet magic to convert whatever time we're doing it to the local time zone near you.
Thanks so much for joining us and see you next week.
This is Coder Radio, episode 370 for August 12th, 2019.

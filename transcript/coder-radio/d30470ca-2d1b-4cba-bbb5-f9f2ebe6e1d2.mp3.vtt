WEBVTT

00:00.000 --> 00:07.000
This is Koder Radio, episode 370, for August 12th, 2019.

00:31.000 --> 00:44.000
Hello, and welcome to Koder Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business, software development, and related technologies.

00:44.000 --> 00:50.000
My name is Wes, and I'm pleased to be joined once again by Mr. Michael Tominick. Welcome back, Mike.

00:50.000 --> 00:53.000
Hello, Wes. How are you?

00:53.000 --> 00:56.000
Oh, I'm doing great. Actually, it's nice to talk to you.

00:56.000 --> 01:01.000
You were absent last episode. You were sick as a dog, so I heard.

01:01.000 --> 01:06.000
But, you know, we had Chris back on the show. You missed him. It was still a lot of fun. If you missed that episode, go check it out.

01:06.000 --> 01:10.000
But, you know, you're really the spirit of this show, so we're happy to have you back.

01:10.000 --> 01:12.000
Yes, I'm the raging wraith of the show.

01:12.000 --> 01:16.000
If Jar Jar's the spirit creature, you're the spirit human, I guess.

01:16.000 --> 01:21.000
Well, first of all, denying Jar Jar's humanity is just wrong. Jar Jar is a person like anybody else.

01:21.000 --> 01:26.000
But second of all, I noticed Chris admitting to a poisoning plot against me.

01:26.000 --> 01:29.000
Oh, you listened? I didn't expect that.

01:29.000 --> 01:30.000
Oh, I listened.

01:30.000 --> 01:32.000
Dang. Okay, we didn't plan for that at all.

01:32.000 --> 01:39.000
This is going to be a great show, Wes. We have something in this show that I am dying to hear you talk about.

01:39.000 --> 01:44.000
Oh, I mean, I think that might just be that I've been playing with F-sharp. Is that what you're excited about?

01:44.000 --> 01:45.000
It could be.

01:45.000 --> 01:49.000
Yeah, okay. I expect so. Something tells me you're a little fond of it.

01:49.000 --> 01:50.000
Oh, I'm just a touch.

01:50.000 --> 01:55.000
But before we can get to that excellent topic, well, we've got a few other things to talk about first.

01:55.000 --> 01:58.000
That's right. We have to eat our Emacs vegetables.

01:58.000 --> 02:05.000
Yeah, yeah. We've gotten, I mean, would you say a ton of feedback about, I mean, all the functional stuff we've been talking about?

02:05.000 --> 02:10.000
You tried Clojure in a previous episode. We doubled down and just did a whole functional episode.

02:10.000 --> 02:18.000
The feedback's been awesome. And DJ sent us some tips about Emacs, which honestly, that's fairly appreciated.

02:18.000 --> 02:21.000
Yeah, that's awesome. That was great feedback.

02:21.000 --> 02:29.000
Yeah, I particularly like the section about the Emacs, basically language you can write in being fairly functional and a good introduction.

02:29.000 --> 02:34.000
Yeah, DJ writes, another point for the show is a soft intro to functional programming.

02:34.000 --> 02:39.000
Wes mentioned Emacs because, you know, the nice packages supporting Clojure development.

02:39.000 --> 02:47.000
But I just wanted to point out that Elisp seems to be a fairly intuitive and well-documented little functional language in its own right.

02:47.000 --> 02:51.000
And it might make an excellent soft intro to functional programming.

02:51.000 --> 03:00.000
I think you were more familiar with some of the functional aspects, but the Lispisms, you know, the strange way of actually talking to the machine, that was what was different.

03:00.000 --> 03:11.000
So I could see, you know, for some people in the right boat, maybe experienced Emacs users or people just curious about Lisp in a softer environment, Emacs might make sense.

03:11.000 --> 03:13.000
I could see it. Yeah.

03:13.000 --> 03:20.000
We love feedback like this. So if you've got some, well, head on over to coder.show slash contact and we've got a little form you can fill out.

03:20.000 --> 03:24.000
Send us the latest and greatest or just tell us what we're doing wrong.

03:24.000 --> 03:28.000
Another way you can provide us feedback is over at the Coder Radio subreddit.

03:28.000 --> 03:31.000
And someone pointed out something I'm not supposed to tell you, Mike.

03:31.000 --> 03:36.000
And well, that's a version of Ruby written in Rust.

03:36.000 --> 03:39.000
This is very exciting to me. This is like a turducken of glory.

03:39.000 --> 03:44.000
Yeah. Oh, man, I love I love me a turducken. Of course I do. Oh, it's a thing.

03:44.000 --> 03:47.000
Yes. So a version of Ruby written in Rust.

03:47.000 --> 03:52.000
I mean, let's just just take everything I like, put it together and call it artichoke.

03:52.000 --> 03:57.000
And you know what? It is indeed real. I've yet to try it out, but damn, if it doesn't look fabulous.

03:57.000 --> 04:01.000
And there's some some pretty impressive performance statistics.

04:01.000 --> 04:09.000
Now, I always take these with a grain of salt because, you know, 900 percent of statistics on tech podcasts and tech blogs are made up.

04:09.000 --> 04:17.000
But it could be good. Rust is very fast. I could I could see a new implementation of Ruby being fairly performant.

04:17.000 --> 04:21.000
Yeah. Right. And we've already seen multiple implementations of of Ruby.

04:21.000 --> 04:26.000
Right. I mean, there's there's Ruby on the JVM. There's just other versions of it.

04:26.000 --> 04:31.000
So perhaps with some new foundations, Ruby can continue to live on.

04:31.000 --> 04:35.000
And Rust seems like a good choice to implement a language in these days.

04:35.000 --> 04:41.000
If you're going to need, you know, low level compatibility, be able to do stuff where you reach out and use faster code if you need to.

04:41.000 --> 04:46.000
And since you've already been exploring, you know, writing that in Rust, I imagine that would also be possible in artichoke.

04:46.000 --> 04:50.000
It would be. I wouldn't say that this is something I would use in production, though.

04:50.000 --> 04:52.000
Oh, certainly not yet. No. Yeah.

04:52.000 --> 05:07.000
But definitely, you know, an interesting alternative to saying writing performance hungry components in Rust is that you could write a Ruby backed by Rust, which certainly theoretically is going to be at least some kind of performance gain.

05:07.000 --> 05:12.000
Right. I'm I'm hedging a little because I haven't tried it out myself, but I was very excited to read it in the subreddit.

05:12.000 --> 05:20.000
The other thing it makes me think of is, you know, it's just even if no one ever uses this in production, it's probably not a bad thing just to sort of flex the Rust muscles.

05:20.000 --> 05:23.000
You know, one, implementing a language is interesting for the working on it.

05:23.000 --> 05:31.000
But also, there may be areas in Rust that could be improved and, you know, actually trying to implement something complicated and existing like Ruby.

05:31.000 --> 05:39.000
Well, you might just find some of those areas where you need a new library or need to add something to an existing Rust library that would make implementing future languages easier.

05:39.000 --> 05:44.000
So we've been following a story for, what would you say, Wes, about three months, maybe?

05:44.000 --> 05:50.000
Something like that. Maybe a little longer. But I mean, it's kind of hard to escape from. It's a big deal, at least here in the Pacific Northwest.

05:50.000 --> 05:52.000
And I'm sure it's a big deal for you, too.

05:52.000 --> 05:58.000
It is. As a guy who writes software for aviation, it's it's a thing. The whole Boeing 737 Max situation.

05:58.000 --> 06:03.000
Quick recap for those who don't recall or haven't listened before.

06:03.000 --> 06:14.000
There was an issue with the 737 Max where basically there was a technical computer error that caused the plane to, is it fair to say, misinform the pilot?

06:14.000 --> 06:28.000
It wasn't clear to the pilots what was going on and when this system that was supposed to help because of the change in engine position and wings, you know, prevent stalls of the plane, but was not a clear override to the pilots, at least in certain circumstances.

06:28.000 --> 06:35.000
You also saw some issues around, you know, optional lights and indicators that some planes had and some didn't.

06:35.000 --> 06:44.000
So, you know, there's just a lot of change going on. And now they're saying they need to make another change before this thing's actually going to get back in the air.

06:44.000 --> 06:56.000
Yeah, that's right. So they're going to add a system where they have two separate basically flight computers that will read out the same values or I'm sorry, will attempt to read out the same values.

06:56.000 --> 07:06.000
And the pilot will be warned on their display if the values disagree. And I should say pilots because there's usually, you know, pilot, co-pilot. Big enough plane for that.

07:06.000 --> 07:11.000
That's an interesting way to solve this problem. And I honestly don't know how I feel about that.

07:11.000 --> 07:27.000
So basically, the idea, Wes, is you have two computers running. They're running the same software. But the whole idea is it's going to warn you if the two the two instances of the software don't agree on the values.

07:27.000 --> 07:42.000
Oh, okay. Just just as a second one, sort of a safety check. That makes a lot of sense. I mean, it doesn't feel like it's the I don't know, in a clean room design is I don't know that that would come up with although it does, you know, multiple machines disconnected from one another. That does add a layer of robustness.

07:42.000 --> 08:00.000
Right, I guess the assumption is some of the issues that were happening were basically bad information being fed to the pilot and he and the pilot was causing, you know, issues or responding poorly, we should say, not not because it was their fault, because, you know, pilots tend to fly by their instruments, right?

08:00.000 --> 08:03.000
Pretty rare for that not to be the case.

08:03.000 --> 08:10.000
Yeah, I mean, it's a complicated machine, you have all of this infrastructure available to you. And most of the time, you can trust what it's telling you.

08:10.000 --> 08:22.000
So it's an interesting story. I mean, this is one of those stories that when it first came out really brought into the whole, you know, software engineering, licensure stuff, and kind of standards as an engineering field.

08:22.000 --> 08:32.000
I can't say that this is a great solution, because theoretically, all it's telling you, according to this, this Yahoo News article is if they don't agree.

08:32.000 --> 08:42.000
But, you know, I guess it's better than nothing, right? I mean, it's interesting. See, it's interesting that Boeing hasn't come out and said, like, why they can't have the right values returned.

08:42.000 --> 08:52.000
Yeah, I'm curious if you have any insight there. It's just such a foreign world. There's not that many manufacturers or people in play. And there's so many regulations.

08:52.000 --> 09:02.000
It's interesting how much more, you know, as the software layers have been added and added and added. It's just different than, you know, web services that someone uses to send work messages.

09:02.000 --> 09:14.000
A key point of background on the story is that Boeing wanted to compete with an Airbus. That was basically, there's a whole thing where you don't have to recertify a plane. If you're just modifying existing model.

09:14.000 --> 09:17.000
It's not like you do from a from a plane from scratch.

09:17.000 --> 09:26.000
From, let's say, like you said, a clean room implementation. It seems, I mean, and this is, again, this could be argued and they have argued in their defense that not really.

09:26.000 --> 09:35.000
But a lot of the aviation space commentators and people who would know better than I, for sure, have said they really push the envelope on, you know.

09:35.000 --> 09:43.000
In the rails, we have a term called monkey patching, right? Monkey patching their existing design because they needed to compete with Airbus.

09:43.000 --> 09:48.000
So it's like every software project that really did just come down to money.

09:48.000 --> 09:59.000
Right. And then there's also there's an issue on the other side, too, right, where airlines probably like this, where pilots also need to be certified differently on a, you know, a modification of an existing plane versus a new plane.

09:59.000 --> 10:05.000
Yes, less. It's less. Right. So. So it's cheaper for the airlines. It's cheaper for Boeing.

10:05.000 --> 10:22.000
And I mean, this is not an entirely software story because there's there was also some concerns about some components and hardware. But for the purposes of this show, it's definitely interesting how their solution is to run a parallel instance of the same software on a separate piece of hardware.

10:22.000 --> 10:32.000
Yeah, it's interesting. And as we should be clear to point out, you know, this is serious stuff and already far too many people have died and and that's terrible.

10:32.000 --> 10:34.000
Yeah, people have lost their lives. Yeah, this is a serious issue.

10:34.000 --> 10:45.000
All right. Well, let's move on to something also serious and relatively terrible and relatively terrible. I'm curious what you think about this. This is kind of happening over on your side of the country.

10:45.000 --> 10:58.000
Experts thought that the contract for what's known as Jedi, which is just a fun coder radio name, but the Joint Enterprise Defense Infrastructure, which is a big investment by the government into all kinds of resources.

10:58.000 --> 11:11.000
Well, everyone expected that was just going to go to AWS. But Oracle has had their hands and wanted to have their hands in this pie for a long time. And it seems like they've got friends in the right places.

11:11.000 --> 11:21.000
So there's this New York Times article about the Jedi is a very large government contract. I think the number is like $10 billion or something ridiculous like that. Oh, boy.

11:21.000 --> 11:32.000
And basically, it needs to go to a cloud database provider, among other things. Oracle, being Oracle, really wants this contract.

11:32.000 --> 11:38.000
And they do have a cloud, you know, in case people may not know that because I sure didn't for a while.

11:38.000 --> 11:47.000
But like, you know, AWS in the enterprise, like governmenty space is kind of the big boy, at least when you think of these cloud tech companies.

11:47.000 --> 11:52.000
Right. I mean, they've even got GovCloud. Isn't that what they call the services they sell the government?

11:52.000 --> 12:00.000
Yeah. And there's been stories about them selling cloud to the CIA. AWS has been pretty much the leader here.

12:00.000 --> 12:10.000
And Microsoft Azure has tried to get in the game. And it's not that they failed, but certainly, you know, it's Amazon, Microsoft.

12:10.000 --> 12:15.000
And then maybe way down the list is Oracle. I mean, Oracle has a lot of legacy.

12:15.000 --> 12:21.000
So how would you frame the story, Wes? Because I want to be a little careful.

12:21.000 --> 12:27.000
Because, you know, government bidding on contracts can be challenging, if I can tell you that.

12:27.000 --> 12:38.000
Right. And I mean, so I will say, and as people are quoted, it's important that, you know, we try to maintain a fair and competitive process for defense contracts.

12:38.000 --> 12:43.000
Right. I mean, I don't know that that's where we are. I'm pretty sure we're absolutely not there.

12:43.000 --> 12:54.000
So in one sense, I guess, like, AWS seems like the obvious choice. It probably does make sense to, you know, review bids and perhaps even especially consider other options.

12:54.000 --> 13:02.000
That said, I don't know, the fact that it's Oracle is one of the major other bidders here still leaves me with a weird feeling.

13:02.000 --> 13:07.000
It's a little weird. Now, if it were Microsoft, I would be more like, well, you know, Azure has come a long way and blah, blah, blah.

13:07.000 --> 13:13.000
They have a lot of great stuff with the cognitive engine. Who knows what they're really trying to do with this Jedi project. Right.

13:13.000 --> 13:20.000
So, like, the implication in this New York Times article is that this has nothing to do with the technical merits of Amazon's proposal.

13:20.000 --> 13:24.000
Right. That's a little weird.

13:24.000 --> 13:31.000
Yeah, it is a little weird. Right. I mean, because there's there are some things we know the current president doesn't exactly love Jeff Bezos.

13:31.000 --> 13:35.000
I thought they just had a tea. No. Yeah, I guess not.

13:35.000 --> 13:42.000
Maybe a tea time even? No, maybe a tea time. That would make more sense, wouldn't it?

13:42.000 --> 13:50.000
So there's some issues there, right? And obviously, Bezos now owns the Washington Post, which perhaps reports unfavorably at times on the current administration.

13:50.000 --> 13:54.000
So it does seem like, you know, as always, there's there's just a lot of politics here.

13:54.000 --> 14:00.000
And I bet that Oracle's technical offering is is probably worse.

14:00.000 --> 14:04.000
It doesn't seem like their cloud is doing particularly well. They just lost the leader over to Google.

14:04.000 --> 14:09.000
You know what? I think you can just assert that is true. I'm just going to throw that.

14:09.000 --> 14:16.000
Well, I was trying to be careful like you, Mr. Dominic. Yeah, but I mean, again, Microsoft, IBM, maybe IBM.

14:16.000 --> 14:20.000
I'm not even sure. But you're right. Microsoft would be a good analog here, right?

14:20.000 --> 14:26.000
If they were if they were in this and it was Amazon v Microsoft, that would kind of seem more par for the course.

14:26.000 --> 14:31.000
I'm curious if you have any insights just from your own like, you know, what what should be happening here?

14:31.000 --> 14:36.000
Well, so one big government contracting is different than little government contracting.

14:36.000 --> 14:43.000
So on the on the little jobs and I can only tell you for like the small business jobs, that's all I really know.

14:43.000 --> 14:50.000
You are judged first on does your proposal actually hit the spec within a reasonable budget?

14:50.000 --> 14:54.000
Right. Which makes sense. Like a misconception is that always the lowest bid wins.

14:54.000 --> 14:59.000
That's actually not true. Someone comes in with a lower bid, but they say they can't hit some of the requirements.

14:59.000 --> 15:07.000
You could still win even if you're higher. But because I'm in the small business arena, there's a lot of credit given to business owners,

15:07.000 --> 15:13.000
depending like if it's an economic development zone and you're equal to that person, they'll get it.

15:13.000 --> 15:17.000
There's, you know, all kinds of inclusion stuff. So race, gender, stuff like that.

15:17.000 --> 15:25.000
Veterans and disabled veterans, since I mostly do military style stuff, get a get a big boost.

15:25.000 --> 15:34.000
But in my case, small business owners also, if you're because Tampa is considered that it's like a growing area, you get a boost there.

15:34.000 --> 15:40.000
So it's weird because what ends up happening is you end up actually being like little brother to a bigger contractor all the time

15:40.000 --> 15:44.000
because they want you to get in there and bid so that you get the small business credit.

15:44.000 --> 15:53.000
But, you know, if you're a five to 10 man company, you can't like actually have a hangar full of planes, speaking from what I know of here.

15:53.000 --> 15:58.000
Right, right. Yeah. So you have to partner up now in the big world of contracting.

15:58.000 --> 16:00.000
Yeah, there's a lot more relationships and politics going on, right?

16:00.000 --> 16:08.000
Like I usually don't meet the people I'm sending the RFPs to unless I get the job or like the very end of the process.

16:08.000 --> 16:14.000
I see. You're just sort of down there in the weeds and there's a there's a big tree all the way up to where it's actually happening.

16:14.000 --> 16:21.000
Yeah. And that's that's pretty common in the small business world, which is yeah, which is which is fine.

16:21.000 --> 16:29.000
I mean, I'm not complaining. I guess we should all be happy we don't have Amazon's problem here.

16:29.000 --> 16:31.000
That certainly seems like it would be an issue.

16:31.000 --> 16:39.000
Yeah. Yeah, that is that is true. It's also interesting that, you know, there's a lot of the Times article notes that, you know,

16:39.000 --> 16:47.000
Microsoft is interested here and actually maybe benefiting from all the lawsuits and things that are going and basically what they call Oracle stalling tactics

16:47.000 --> 16:54.000
because Microsoft doesn't actually currently have all the security certificates that would be required to, you know, to meet the spec on this.

16:54.000 --> 16:57.000
But they are working on them. And that just adds another layer, right?

16:57.000 --> 17:02.000
Like there's there's few players originally and there's few qualified players at that.

17:02.000 --> 17:06.000
Yeah. And that does actually seem true.

17:06.000 --> 17:14.000
So oftentimes you will see even in these small business proposals or like to do a component of a project, they say the proposal deadlines.

17:14.000 --> 17:22.000
I'm just going to make something up, right? September 15th. But then something will happen where like there'll be a question internally

17:22.000 --> 17:28.000
and that will change the requirements and be the net, you know, in the first quarter of the following year.

17:28.000 --> 17:33.000
Well, we'll see. You know, none of this is resolved yet, but it is always interesting.

17:33.000 --> 17:41.000
These are these are big contracts, important updates. And last but not least, you know, a lot of the stuff that's going to be stored there is important.

17:41.000 --> 17:46.000
So probably behooves anyone who's a U.S. citizen that this gets done right.

17:46.000 --> 17:52.000
Yeah, I'm going to say like Oracle, really. Just throwing it out there.

17:52.000 --> 17:56.000
No offense to any Oracle employees who may be listening, but maybe a little bit.

17:56.000 --> 18:00.000
Yeah, maybe a little bit, although I'm sure the money's good.

18:00.000 --> 18:06.000
Oh, I'm sure it is. So if you don't want to bid on these contracts, couldn't you just say F sharp it?

18:06.000 --> 18:15.000
Oh, that's that might be the best segue we've ever had. And you're right, Mike. It's probably time we do another seven languages check in.

18:15.000 --> 18:24.000
This time it's my turn. You challenged me a bit ago with checking out F sharp, which is one of your favorite languages.

18:24.000 --> 18:29.000
So the horrors that are enterprise level dotnet applications written in C sharp.

18:29.000 --> 18:31.000
Yes. Tell me about it.

18:31.000 --> 18:37.000
That is why I chose F sharp. Well, C sharp is a little religious about OO.

18:37.000 --> 18:41.000
For the listeners, if you are a Java developer, it's like that.

18:41.000 --> 18:45.000
As things get bigger, you get a lot more tight coupling between objects.

18:45.000 --> 18:50.000
You get a lot of can we say like side effects, which is exactly the right word to say, right?

18:50.000 --> 18:52.000
Side effects in your code. Right.

18:52.000 --> 18:59.000
And I mean, it's literally so F sharp was like my gateway to functional because I kept inheriting these applications.

18:59.000 --> 19:04.000
So I would get a contract on to like, hey, our software does this thing. It's written in dotnet.

19:04.000 --> 19:08.000
Can you come in and do right. Add a feature, fix something, whatever.

19:08.000 --> 19:21.000
And every time I would try to like literally pull apart the spaghetti strands of the C sharp code, I found myself just like in the worst type of brownfield development.

19:21.000 --> 19:24.000
Just, you know, very frustrated, struggling a lot.

19:24.000 --> 19:29.000
And somebody I think literally at a at a at a show in.

19:29.000 --> 19:34.000
I want to say sort of Orlando or was it New York?

19:34.000 --> 19:40.000
I can't remember. It was either right when I moved down here or right before introduced me to F sharp.

19:40.000 --> 19:49.000
And sure enough, it just rewriting components and modules and F sharp to kind of I won't say replace everything,

19:49.000 --> 19:54.000
but like extricate the business logic out of that spaghetti code type coupling world.

19:54.000 --> 19:57.000
Again, not trying to dunk on C sharp developers.

19:57.000 --> 20:03.000
I literally wrote C sharp yesterday. I'm not like, you know, not being a functional leaders,

20:03.000 --> 20:11.000
but it made those applications that of course I was inheriting much easier to keep working on, keep modifying and keep adding components to.

20:11.000 --> 20:13.000
Sorry for the functional lecture. Take it away.

20:13.000 --> 20:19.000
No, but I mean, I think that's that has to be part of what we're talking about, right?

20:19.000 --> 20:26.000
Because F sharp basically describes itself as a functional programming language that runs on dot net.

20:26.000 --> 20:32.000
And, you know, they talk about a lot of those a lot of these like functional stuff that we think about functions and modules, pipelines,

20:32.000 --> 20:39.000
pattern matching, type inference, recursion, option types, record types, discriminated unions.

20:39.000 --> 20:49.000
So it is, you know, that's where F sharp fits. And honestly, I've been really impressed with a lot of the just like sort of getting started with F sharp documentation.

20:49.000 --> 20:57.000
You can tell that, you know, existing C sharp developers are definitely a target because a lot of the docs just right on the site,

20:57.000 --> 21:01.000
they have side by side comparisons from C sharp to F sharp.

21:01.000 --> 21:08.000
And honestly, getting used to sort of the F sharp style took me a little while, you know, got to sort of get the intuition built up.

21:08.000 --> 21:15.000
And not that I'm like a, you know, C sharp programmer, but having those side by side examples, just to see it in sort of a, you know, classic,

21:15.000 --> 21:20.000
imperative object oriented sort of language. That was a nice contrast.

21:20.000 --> 21:28.000
It was a little confusing to get started, though, because there's multiple implementations of dot net, right?

21:28.000 --> 21:31.000
And maybe you could clear this up as someone who's followed it a little bit more.

21:31.000 --> 21:37.000
I mean, I follow it too, but I, you know, until now, I don't have been using it all the time.

21:37.000 --> 21:45.000
So I was a little confused because the guides, you know, on Linux in particular, they'll just tell you to install F sharp right from many package repositories,

21:45.000 --> 21:51.000
which is awesome. But also that installs the mono version.

21:51.000 --> 21:54.000
We also have dot net core running on Linux, right?

21:54.000 --> 22:02.000
So what should I actually be targeting if I was going to try to make, you know, like, let's say a server side F sharp app running on Linux?

22:02.000 --> 22:09.000
It's so funny. So the beginning of this month, we're kicking off a dot net project over at the Mad Botter for a customer.

22:09.000 --> 22:17.000
And yeah, everything new we're kicking off is dot net core in terms of at least web server side web software.

22:17.000 --> 22:21.000
There's nothing nothing against mono. I also have written lots of mono.

22:21.000 --> 22:29.000
But at this juncture, Microsoft and the Dotnet Foundation, which I guess disclosure, I'm a member of the Dotnet Foundation.

22:29.000 --> 22:38.000
I've been pretty clear that dot net core is going to be the way to go, particularly if and this is what I'm curious if you're because for me,

22:38.000 --> 22:41.000
when I'm writing F sharp, my target platform is actually usually Linux now.

22:41.000 --> 22:45.000
Right. I'm not. So these are not running on like IAS or whatever it's called.

22:45.000 --> 22:51.000
Right, right. Like unless you're actually building like a desktop app or something, it's going to run on a Linux server.

22:51.000 --> 22:59.000
Well, so that's also funny. You mentioned the desktop. So September 23rd to 25th is the Microsoft Ignite.

22:59.000 --> 23:06.000
They have so many conferences, I can't remember to keep the name straight, but Dotnet Core 3 is coming out with desktop support.

23:06.000 --> 23:13.000
And I'll give you one more product I sponsor called Avalonia can bridge between them using the Dotnet standard.

23:13.000 --> 23:22.000
And that runs on, let's see, the web, Linux, Mac, PC and I think mobile.

23:22.000 --> 23:27.000
We also had the guys from Project Uno on the show right before you jumped on with us.

23:27.000 --> 23:35.000
We're with me, Wes. Same deal. They'll do WebAssembly, Windows, Mac and mobile.

23:35.000 --> 23:39.000
Everything you'd expect. Great implementation. All using Dotnet standard.

23:39.000 --> 23:45.000
It gets complicated because Dotnet standard is basically neutral Dotnet. So everything implements it.

23:45.000 --> 23:52.000
The idea being if your library is written to Dotnet standard, you can basically use it everywhere.

23:52.000 --> 23:59.000
If you're on the web and doing server side stuff, you want probably Dotnet Core, but your libraries will probably be Dotnet standard.

23:59.000 --> 24:04.000
When they say Dotnet standard, it's literally the standard, right? It's the accepted standard of Dotnet.

24:04.000 --> 24:09.000
Hmm. Okay. I see. That's interesting. So how is your onboarding experience?

24:09.000 --> 24:14.000
Were you doing this in a VM on Windows or did you stick with your normal?

24:14.000 --> 24:20.000
No, of course not. Come on. Do you know me? Actually, I just blew away the last Windows VM I had.

24:20.000 --> 24:24.000
So I don't even have a Windows VM at the moment to play with.

24:24.000 --> 24:28.000
I will get you on WSL. Don't worry. It's my mission for the show now.

24:28.000 --> 24:34.000
Challenge accepted. So I just got started. I went the mono version just because it was in the repository.

24:34.000 --> 24:39.000
It seemed like the most common one, although I did get the Dotnet version installed too.

24:39.000 --> 24:44.000
And then I already had VS Code installed. So then I got Ionide. Am I saying that right?

24:44.000 --> 24:49.000
Which is a cross-platform F sharp editor tool that has VS Code support.

24:49.000 --> 24:53.000
Oh, yeah. That was nice. That was really nice. I was impressed.

24:53.000 --> 25:00.000
I mean, one, it's always nice being in, you know, like a rich statically inferred typed language like F sharp, you know,

25:00.000 --> 25:05.000
with a good ML background in the Henry Milner type inference.

25:05.000 --> 25:08.000
And it's just nice. The autocomplete is amazing.

25:08.000 --> 25:14.000
You really feel like you're engaged with the compiler. The errors, I thought, were mostly actually not that bad.

25:14.000 --> 25:20.000
You know, sometimes you get like those type errors in statically typed languages and you're just like, what now?

25:20.000 --> 25:27.000
You know, unless you have done a lot and really understand the sort of type hierarchies and the foundations of how that language was implemented.

25:27.000 --> 25:32.000
At least I've had that problem a couple of times, like learning Rust, playing with Rust, getting in a situation.

25:32.000 --> 25:40.000
I'm like, I don't understand all these things. And at least in my initial, you know, foray into F sharp, I didn't really have that problem.

25:40.000 --> 25:44.000
You know, you're a closure guy. You're a deep functional guy.

25:44.000 --> 25:52.000
Did you feel maybe that it was like the sugar free version of your favorite candy or did you actually think it was truly functional?

25:52.000 --> 25:56.000
Well, it's definitely not Haskell, right?

25:56.000 --> 25:58.000
Well, nothing is.

25:58.000 --> 26:04.000
Few things anyway. I can think of at least one and probably a few others that, you know, of course go beyond.

26:04.000 --> 26:10.000
But honestly, I was really impressed. You know, the docs are all very, you know,

26:10.000 --> 26:19.000
they push a lot of the functional stuff, pure functions, idempotency, talking about, you know, minimizing state and side effects.

26:19.000 --> 26:22.000
But at the same time, it felt very pragmatic.

26:22.000 --> 26:29.000
It didn't feel like, you know, a theory class or a language designed to sort of teach the principles.

26:29.000 --> 26:39.000
It felt like something that I could use if I just wanted to go get some work done and hopefully, you know, minimize me having to fight with this different paradigm.

26:39.000 --> 26:43.000
And, you know, honestly, it was nice because Clojure kind of takes the same approach, right?

26:43.000 --> 26:49.000
Where you, you know, you should make your functions pure, but that doesn't happen all over the place.

26:49.000 --> 26:52.000
And there are going to just be pragmatic exceptions.

26:52.000 --> 27:01.000
Yeah, I mean, F sharp is really, I mean, at least in the way I'm using it, it is a way for me to go into existing large code bases,

27:01.000 --> 27:10.000
like I kind of mentioned in the intro here, but not continue to, I mean, use a strong word, pollute the code base, right?

27:10.000 --> 27:22.000
I don't think either of us is really a functional zealot, but there is a certain, I would say, project size where a very object oriented approach becomes painful.

27:22.000 --> 27:31.000
And it just is the case that in a lot of legacy.net projects, that tends to be the size of the project.

27:31.000 --> 27:37.000
Yeah, I was pleased with how much, you know, talking about data was also stressed.

27:37.000 --> 27:38.000
And I think that's one of the nice things.

27:38.000 --> 27:47.000
And one of the things I've seen problems with in large legacy OO code bases is it's hard to understand where the actual data is because you just have all these, you know,

27:47.000 --> 27:54.000
interacting objects and multiple levels of hierarchies, maybe you've got, you know, several abstract classes and different implementations.

27:54.000 --> 27:57.000
And you have to look in like six files to actually figure out what's going on.

27:57.000 --> 28:01.000
And, you know, F sharp with the unions was really nice.

28:01.000 --> 28:05.000
I always enjoy well supported pattern matching just right out of the gate.

28:05.000 --> 28:07.000
That can be a nice way to reason about things.

28:07.000 --> 28:14.000
I was curious, I noticed it mentioned, you know, rich concurrency support.

28:14.000 --> 28:17.000
It even said I think that it had like an actor sort of system built in.

28:17.000 --> 28:20.000
I didn't get far enough to play with that.

28:20.000 --> 28:22.000
Do you know anything about it?

28:22.000 --> 28:23.000
Yeah.

28:23.000 --> 28:28.000
OK, so this is where I've become unpopular with the dot net people.

28:28.000 --> 28:33.000
It does have kind of that actor model support you were talking about.

28:33.000 --> 28:37.000
But it is still running on the CLR.

28:37.000 --> 28:44.000
So one thing you really when you're in the world, you really have to keep in mind is that all of these language, much like in the Java world, right?

28:44.000 --> 28:48.000
Where you're compiling to an intermediate step or intermediate languages.

28:48.000 --> 28:51.000
So in theory, it is 100 percent actually in practice.

28:51.000 --> 28:53.000
I think people have done it.

28:53.000 --> 28:58.000
You can write the same F sharp, C sharp program that compile into the same thing.

28:58.000 --> 29:03.000
It's a IR code, which is the CLR's equivalent to bytecode.

29:03.000 --> 29:06.000
Right. The code that the CLR actually then runs.

29:06.000 --> 29:20.000
So yes, it does have developer facing a, I would think, pretty nice and very good actor model that you're used to from a functional point of view.

29:20.000 --> 29:26.000
Is it the case that the CLR is not just implementing things in kind of a more legacy way?

29:26.000 --> 29:28.000
Well, that's where we start to get into.

29:28.000 --> 29:30.000
So what version of dot net are you on?

29:30.000 --> 29:32.000
Oh, right.

29:32.000 --> 29:36.000
So this is where my mono choice might come back to rear its head.

29:36.000 --> 29:38.000
It won't bite you. It will not bite you.

29:38.000 --> 29:39.000
No fangs here.

29:39.000 --> 29:43.000
There might be some very mild performance differences.

29:43.000 --> 29:48.000
And I will fully admit this is a controversial opinion.

29:48.000 --> 29:51.000
I hate talking about performance unless something's really bad.

29:51.000 --> 29:58.000
And I don't think this is really bad, but I'm only mentioning it because I can feel the Reddit and YouTube comments coming.

29:58.000 --> 30:04.000
It is the case that all implementations of dot net are not created equal.

30:04.000 --> 30:14.000
In particular, the deeper you go into the functional stuff with F sharp, the better off you are in the dot net core dot net standard world.

30:14.000 --> 30:18.000
It will all work. It will all be still relatively performant.

30:18.000 --> 30:27.000
But, you know, one of the big gains in dot net core three that's coming out is it's faster and it's embracing a lot more the CLR.

30:27.000 --> 30:33.000
It is defined as the CLR here is embracing a lot more of the kind of functional way of life.

30:33.000 --> 30:38.000
I mean, there are years of work that went into getting to dot net standard and dot net core, right?

30:38.000 --> 30:44.000
There was the Roslyn compiler, which is partially what's actually doing all the magic and visual studio code that you're liking.

30:44.000 --> 30:46.000
Right, right.

30:46.000 --> 30:59.000
OK, I have a dreamless that Count Satya will come down from his Sith tower and just like strike down all the older implementations of dot net.

30:59.000 --> 31:06.000
But just as a word of caution, if you are walking into like a dot net.

31:06.000 --> 31:20.000
Early for late three dot net framework, not not dot net standard project, you may you may not, depending on how exactly you're doing things, see the type of performance gains you might expect using F sharp.

31:20.000 --> 31:24.000
I know there's a lot of weasel words in there and because one, it depends on your code, right?

31:24.000 --> 31:26.000
Depends on everything you've done in the project besides that.

31:26.000 --> 31:37.000
But at least to my satisfaction, the people who have written these white papers up, which I don't care to do.

31:37.000 --> 31:47.000
They've convinced me personally that it just is the case that the dot net core three, even dot net core two two and the newest version of dot net standard,

31:47.000 --> 31:56.000
particularly if you're running on Linux, are not significant, well, somewhat significantly more performant, particularly if you're going the functional route.

31:56.000 --> 31:59.000
That felt really confusing, but I hope it made sense to people.

31:59.000 --> 32:01.000
I see. I see. So you just do need to be aware.

32:01.000 --> 32:07.000
And if you want to use a lot of fancy functional stuff, probably better to be on a newer version.

32:07.000 --> 32:09.000
That's right. So that's a simplified version, right?

32:09.000 --> 32:14.000
The more functional you want to be, the more modern you want your version of dot net to be done.

32:14.000 --> 32:16.000
That's the simple explanation.

32:16.000 --> 32:17.000
Right. And that kind of makes sense, right?

32:17.000 --> 32:24.000
I mean, a lot of the functional stuff is higher level and you do end up relying on either a compiler or a VM, you know,

32:24.000 --> 32:29.000
something down there to optimize that stuff and actually be able to compete with the imperative model.

32:29.000 --> 32:30.000
Right. Exactly.

32:30.000 --> 32:38.000
It was nice. I think if I was, you know, doing more dot net stuff, I just happened to ended up, you know, kind of doing more JVM things

32:38.000 --> 32:43.000
or being more familiar at the moment with the JVM, although I have no problem with dot net.

32:43.000 --> 32:49.000
I would definitely be using F sharp. And it seems like it's almost the Scala.

32:49.000 --> 32:54.000
This is bad. This is a bad metaphor, but like it's the Scala of the CLR.

32:54.000 --> 33:02.000
I mean, I would say Clojure, but I think Scala is like a better comparison in some ways in that, you know, it keeps the static type nature.

33:02.000 --> 33:09.000
I think one of the hard things about like going Java to Clojure in particular is, I mean, you know, you have this transition to dynamic types.

33:09.000 --> 33:16.000
And I think doing that successfully, especially in larger projects, requires embracing a lot of the things that make Clojure different.

33:16.000 --> 33:23.000
Right. Like really embracing the mutability and like data orientation and the ways that you separate concerns and keep things in small modules and,

33:23.000 --> 33:28.000
you know, have sanity and checks at the interfaces between layers.

33:28.000 --> 33:32.000
F sharp seems like a nice way to go, you know, all right, you're familiar with C sharp.

33:32.000 --> 33:34.000
You're familiar with a lot of these tools.

33:34.000 --> 33:40.000
Here's a new language that's going to teach you some new ways to do things.

33:40.000 --> 33:42.000
But it's not throwing everything out.

33:42.000 --> 33:47.000
But what I like is that I enjoyed learning Scala for all the neat functional stuff.

33:47.000 --> 33:55.000
And, you know, there's lots of cool cool like lens libraries and all sorts of super neat monadic stuff.

33:55.000 --> 34:02.000
But I've also seen plenty of Scala code that was like a weird hybrid that was like either just kind of like fancy Java or somewhere weird in between.

34:02.000 --> 34:04.000
Right. Lovecraftian nightmare.

34:04.000 --> 34:06.000
Yeah, Lovecraftian nightmare. Yeah, exactly.

34:06.000 --> 34:15.000
And it feels like F sharp manages to retain a familiarity, you know, has a lot of open hands and bridges extended to the C sharp communities.

34:15.000 --> 34:17.000
But doesn't get things as muddled.

34:17.000 --> 34:23.000
I haven't done Scala in over seven years, so it's a little unfair for me to do the value comparison.

34:23.000 --> 34:32.000
But I would say my experience onboarding from Java to Scala was much more painful than C sharp to F sharp.

34:32.000 --> 34:42.000
And just real time follow up, Conan Kudo in the chat is mentioning that the newest or I guess most recent versions of mono are actually implementing dot net core.

34:42.000 --> 34:45.000
So the performance may not be in that version anymore.

34:45.000 --> 34:48.000
So, yeah. Oh, interesting. Thanks, Neil.

34:48.000 --> 34:52.000
Yeah, I have I have been having a lot of fun playing with F sharp.

34:52.000 --> 34:57.000
And I do think if I would, you know, if I was doing more dot net, I would be using it.

34:57.000 --> 35:08.000
I'm curious. I ran into some interesting article and some some discussion about the problems or perceived problems with F sharp evangelism.

35:08.000 --> 35:15.000
And I wonder what you think of people trying to convince C sharp developers, you know, C sharp to F sharp route versus.

35:15.000 --> 35:19.000
You know, just F sharp standing alone as its own language.

35:19.000 --> 35:25.000
I mean, obviously, you want to be able to utilize the rich dot net ecosystem, but you totally can.

35:25.000 --> 35:30.000
It's right. So, I mean, I read this article.

35:30.000 --> 35:34.000
He's actually debunking many of these problems. Right.

35:34.000 --> 35:37.000
But he is mentioning certainly that a few of them are real.

35:37.000 --> 35:47.000
You know, I've never met a programmer that if you tell them you want them to write in a different language, didn't grumble a little bit and complain that they could have done it in their language of choice five times faster.

35:47.000 --> 35:51.000
I usually hear about Python. Of course, I kind of don't buy it.

35:51.000 --> 35:54.000
You know what? You're still running on the dot net framework.

35:54.000 --> 35:59.000
F sharp, I think to its detriment goes out of its way to be friendly to C sharp.

35:59.000 --> 36:02.000
That was what I was picking up. Right.

36:02.000 --> 36:09.000
In fact, I think like the biggest problem with F sharp is that it's a little too compromised.

36:09.000 --> 36:12.000
Right. It's not functional enough in a lot of ways.

36:12.000 --> 36:15.000
What would you like to see be more functional about it?

36:15.000 --> 36:25.000
I'm curious. Well, so it gets down to all the like because it needs to follow the common dot net patterns of like interfaces and factories and all the common C sharp stuff.

36:25.000 --> 36:33.000
Right, right. If you're using C sharp stuff, well, they're going to have, you know, different styles of APIs than you might write from F sharp to F sharp.

36:33.000 --> 36:45.000
You have to keep in mind, Microsoft and the dot net foundation seem to be pretty eager to not break any compatibility at all.

36:45.000 --> 36:53.000
So that means you're supporting all of these old patterns forever, which I don't want to get in a religious war about like pattern A versus pattern B because I think it's a waste of time.

36:53.000 --> 37:02.000
And I have a feeling you and I would agree more than either of us in the random listener if I just took a bet.

37:02.000 --> 37:13.000
But, you know, it's funny, actually, I blame you for this a little bit as you've had me and I can't can't wait to hear what you picked for me this week as you've had me go down this functional rabbit hole even deeper.

37:13.000 --> 37:20.000
F sharp has started to lose a little bit of its luster for me because it, you know, I feel the compromises more.

37:20.000 --> 37:30.000
I feel the oh, you know, so when I write someone in F sharp library, they can implement it in a horrible factory because it just allows that because that's how it works.

37:30.000 --> 37:40.000
Right. And I'm making fun of factories. I know a lot of people don't do them anymore, but I'm trying to pick an example that's neutral to a lot of languages and obvious, right?

37:40.000 --> 37:50.000
I also don't understand the resistance of if you're an experienced dot net developer, why would you be afraid of F sharp?

37:50.000 --> 37:55.000
If anything, it's just another tool in your toolbox. I don't do pure F sharp programs.

37:55.000 --> 38:03.000
I'll be straight up. For instance, if I'm doing a Xamarin project, much of the UI is in C sharp.

38:03.000 --> 38:12.000
Either it's in XAML in C sharp or the code behind or it's in the weird C sharp script thing that you can do.

38:12.000 --> 38:23.000
But the either the business logic or the data processing is in F sharp, much like my Rails applications now have some more the intense business logic or performance intensive stuff in Rust.

38:23.000 --> 38:31.000
But, you know, the vast majority of the applications in Ruby. So I don't know, I'm not a purist either way, but I definitely have.

38:31.000 --> 38:37.000
Particularly when interviewing people, definitely had some resistance. Yeah.

38:37.000 --> 38:39.000
Yeah. OK, I can see that.

38:39.000 --> 38:44.000
What about you, Wes, when you're talking to people about Clojure when they're coming from, let's say, I guess it would be Java.

38:44.000 --> 38:48.000
Do you get pushback a lot other than me?

38:48.000 --> 38:53.000
Yeah, I mean, I think there's a lot of things. Clojure is particularly hard, right? Because it's a Lisp.

38:53.000 --> 38:56.000
Yeah, it's Lisp. It's dynamically typed. It's just different.

38:56.000 --> 39:07.000
You know, I mean, like you ran into this, too. If you haven't tried the sort of interactive REPL based development model, it's just not like most other mainstream languages.

39:07.000 --> 39:11.000
So it can take a long time to really get the handle of and appreciation of.

39:11.000 --> 39:19.000
And, you know, even just trying it for a week or two, I think, may not, depending on how much time you devote to it, may not give you the full experience.

39:19.000 --> 39:28.000
And that's probably true for, you know, many languages, especially when you're radically deviating from what you're trying until you've really built something with them.

39:28.000 --> 39:35.000
You know, had to make changes, refactor, maintain. It's hard to understand just how good or bad it might be.

39:35.000 --> 39:40.000
Yeah. And again, the terms good or bad, I think, are problematic.

39:40.000 --> 39:41.000
Yes, they are. You're right.

39:41.000 --> 39:43.000
I mean, I still think objectivity is great.

39:43.000 --> 39:50.000
How well it suits the problem at hand and what you're trying to solve and within what constraints.

39:50.000 --> 39:55.000
I will also add F Sharp has been around for a while as part of.NET.

39:55.000 --> 40:05.000
And the whole development is sort of an interesting microcosm of the larger state of software in the world and what languages and how we think about it.

40:05.000 --> 40:11.000
And in the show notes, we'll have this great PDF that Microsoft has called the early history of F Sharp.

40:11.000 --> 40:14.000
And it's a little bit thick. There's a lot going on.

40:14.000 --> 40:23.000
But if you're curious, you want to learn more about how all this happened, how people think about this and just the evolution of object oriented programming and functional programming.

40:23.000 --> 40:26.000
It's just a great history of all of that.

40:26.000 --> 40:31.000
So you had something interesting as your pick. Top Shell, is that a Ninja Turtles reference?

40:31.000 --> 40:36.000
You know, I was hoping it was when I stumbled on it, but I don't think so.

40:36.000 --> 40:44.000
It is, however, a purely functional reactive scripting language implemented in Scala.

40:44.000 --> 40:52.000
And I don't know that I'm going to be, you know, switching to this from any other scripting language I'm currently using, but it's an interesting take.

40:52.000 --> 41:00.000
And I'm glad to see people playing with stuff like I didn't mention it, but one of the things I found enjoyable about F Sharp was the pipeline operator.

41:00.000 --> 41:05.000
You know, I mean, Clojure has similar things and you see that in a lot of functional stuff, but it's just a nice feature.

41:05.000 --> 41:09.000
And there's definite analogs with, you know, with Unix pipes.

41:09.000 --> 41:17.000
So it's interesting to see Top Shell has that. But with, you know, you get all the benefits of having, you know, structured data.

41:17.000 --> 41:24.000
It just seemed to fit because there's also things like PowerShell, right, where you can interface with a lot of the dot net environments and also has some of these advantages.

41:24.000 --> 41:30.000
And I don't really think we've hit a reasonable maximum. You know, Bash is great.

41:30.000 --> 41:35.000
You can do Python if you need more than Bash, but there's it can be difficult to find the right balance.

41:35.000 --> 41:41.000
And I think anything that we try will probably struggle because we're so entrenched in the tools we have.

41:41.000 --> 41:48.000
But it's probably still worth doing because the command line interface is particularly productive, I think, for many people.

41:48.000 --> 41:55.000
But we're hitting the limits of, you know, pushing around raw, unstructured text. Should be easy to install.

41:55.000 --> 42:00.000
You might give it a try. I've got it going and they've got actually some decent documentation and examples, too.

42:00.000 --> 42:08.000
So you can actually use it on your system and take advantage of fancy stuff like some types and pattern matching.

42:08.000 --> 42:11.000
So where can people find you this week, Wes?

42:11.000 --> 42:20.000
Well, they can find me over at Wes Payne or maybe check out Linux Unplugged, another fine Jupiter broadcasting production.

42:20.000 --> 42:21.000
What about you, Mike?

42:21.000 --> 42:24.000
At Dumanuco on Twitter and visit themadbotter.com.

42:24.000 --> 42:27.000
Oh, you're always posting fun things over there.

42:27.000 --> 42:29.000
That's right.

42:29.000 --> 42:34.000
If you'd like to find more Coder radio, well, we've got that covered. Coder.show.

42:34.000 --> 42:37.000
Yeah, that's right. We've got like a whole bunch of stuff there.

42:37.000 --> 42:43.000
The whole back catalog, the notes for all the shows, easy ways to get in touch as well.

42:43.000 --> 42:51.000
Also, head on over to JupiterBroadcasting.com to find a whole bunch of other great podcasts and crucially, a calendar.

42:51.000 --> 42:56.000
That'll tell you when we're here live. That's right. We do this show live.

42:56.000 --> 43:00.000
It's way more fun to be here live. So check it out if you can.

43:00.000 --> 43:07.000
That calendar will use internet magic to convert whatever time we're doing it to the local time zone near you.

43:07.000 --> 43:30.000
Thanks so much for joining us and see you next week.

43:37.000 --> 44:03.000
This is Coder Radio, episode 370 for August 12th, 2019.


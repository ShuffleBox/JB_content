This is Koda Radio, episode 359 for May 27th, 2019.
Hello and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show, taking a pragmatic look
at the art and business of software development and related technologies.
My name is Wes and yes, I'm back and very pleased to be joined once again with Mr. Michael
Dominic.
Hello, Mike.
Buenas tardes, se√±or Wes.
Oh, Mike, I was in Barcelona where they speak Catalan, not Spanish.
But nice try.
Yes.
Big, big shout out to the one, the only Mr. Chris Fisher for covering for me last week.
I was attending KubeCon slash CloudNativeCon, that's a really big mouthful, in the EU over
in Barcelona.
That was, that was lots of fun, but I was sad to be gone from this here show, though
you guys did a great job and only talked about the Mac Pro a teeny tiny bit.
Yes, we showed an admirable restraint.
However, Wes, you did leave me for more than 24 hours.
Yeah, I know.
And there are consequences to that.
So I'm prepared.
I may have wandered into a white place.
Well, we'll get you back.
And maybe the best way to do that is let's just start out with some feedback.
Now, this is feedback about the previous episode, so I'm going to claim no responsibility.
But still, it's great feedback over at our subreddit, coderadio.reddit.com.
That's how you get there.
Our longtime friend, Mr. Tom Enom writes to us about Marzipan and Electron.
In the discussion of Marzipan and Electron, honestly, I think the answer is WKWebView,
which just arrived in Mac OS 10.10.
Now before we go any deeper, Mike, can you tell me a little bit more?
What is this WKWebView?
On Cocoa Touch for iOS, there was a class called UIWebView, which is exactly what it
sounds like, right?
It's a view that has a, oh, God, what did Apple call their rendering engine back then?
It's not Gecko, right?
No, no, that's Firefox.
But okay, so it's just a, it's a UIView that has a little web browsing component in it.
Yeah, but it was, you know, because it was Apple, it was basically a very, very nerfed
WebView.
So WKWebView is basically a real WebView.
I don't even know how to put it.
I mean, there's a bunch of performance implications of it over UIWebView.
It brings iOS much more on par with, say, Android and, you know, I won't say mobile
versions of Windows, but like Windows in a touch interface and how they handle PWAs.
But, you know, it's iOS.
So there's still, it's a lot better, and I definitely, I think, I think Tom Manam makes
a lot of good points in his post.
But yeah, I mean, let's just simplify this down, right, because we don't need to go into
like how mobile Safari does or doesn't embrace web standards.
I would say WKWebView is a more standards compliant, much more performant, significantly
more performant WebView than UIWebView, which was its predecessor and previously the only
way to put embedded web content in iOS.
Okay.
I see.
So instead of using something maybe like Electron, then you could use this more, more native
component where I guess there'd just be less overhead?
Well, no, not exactly.
So anytime in iOS, and let's say you were writing an Objective-C back in the bad old
days, your only choice for any kind of web interface was UIWebView.
So it doesn't matter what like JavaScript dependencies you're using.
Ah, yes, okay, I see.
You're confined to the performance and to the, frankly, the abilities.
And at the time, you have to remember, I'm going back years now.
Mobile Safari just wasn't as standards compliant as the Android equivalent was.
Ah, yes, I remember these complaints.
Right.
Interesting.
Okay.
And, you know, Tom also points out some stuff.
Windows has things like WinForms and WPF applications.
And of course, on kind of the other side of the fence, Google's been making some big moves
with Flutter.
Now, I haven't really had a chance, Tom hasn't either, to play too much with Flutter.
But now that they've got, you know, some desktop environment, you know, they can render things
out to the desktop, that sounds pretty compelling, at least for perhaps Electron haters out there.
Have you tried it at all, Mike?
Not yet.
I mean, there's, you know, can I make a confession?
Yes, you can.
All right.
Well, trust me, Father, for I have sinned.
I'm actually coming around to Electron.
Oh, now I've been waiting for this.
Okay.
Okay.
You heard it right here.
Episode 359.
Please go on.
What do you mean?
What does what is coming around mean?
Where did you start and where are you now?
I run Mac OS and desktop Linux, right, in the form of Pop OS.
On both of those platforms, and frankly, even on Windows, you're running a ton of Electron
apps, right?
A la Slack.
Yes.
Yes.
I mean, I'm certainly in that position.
Right.
And I have like, 10 Slack teams, like I'm, you know, there's so many apps on Windows,
my email client is Electron on Mac, or I'm sorry, on Pop.
It's the same one because it's mail spring.
So I've just kind of embraced Electron.
Now I still have lots of criticisms that I'm not going to go over again, because they're
well documented.
But the answer to like, the vast majority of my problems with Electron is WebAssembly.
If it were just less resource intensive, I think I would be okay.
And frankly, I think we are I mean, I'm curious, actually, Wes, if you would agree with this
statement.
JavaScript performance is just going to be solved by time, right?
As WebAssembly is adopted more, this becomes a negligible problem.
Yeah, I think it depends on what you mean by JavaScript performance.
If you mean sort of runtimes associated with JavaScript, and there's probably some limitations.
I mean, V8 is already pretty, pretty amazing technology.
I do think you're right, the combination of WebAssembly and existing JavaScript techniques,
you can, you know, because they kind of play in the same space, you can have success stories
of oh, I took my, you know, super optimized C++ application, got it to run on WebAssembly.
It did some of the really needed, you know, the hot paths of code stuff, you really had
to get fast.
And then JavaScript, JavaScript sits on top and sort of orchestrates everything.
Now we'll probably also see some pure WebAssembly stuff, but I imagine that'll be the minority.
Well, I'm not sure that it will be though, right?
So in fact, you just like dovetailed into where I was going with it.
I look at projects like Project Uno, which is a XAML.NET UWP ish port for WebAssembly
and other platforms.
And granted, if you're not a.NET lover like I am, you know, pick your technology.
I'm sure there's a WebAssembly port of it.
Why shouldn't people in let's say two to three years just target WebAssembly and run it in
some sort of electron-like container, right?
I'm using air quotes that you can't see, but maybe electron in name is not going to work
out.
But the idea of just compiling to this open standard of WebAssembly and running it basically
wherever the hell you want, there will be compromises.
I'm not, you know, I'm not being naive, like it's not going to be perfect.
Like if somebody sits there and like finally crafts an elementary OS or a Mac OS app, sure,
that will be better than your WebAssembly app in terms of user experience.
But if you're just building a line of business software and you want a desktop application,
I struggle to see too many cases where I would ever recommend to somebody that they not look
at a WebAssembly solution.
Now that doesn't necessarily mean JavaScript, right?
Just like with my platform Uno example or Avalonia, those are.NET powered examples.
I don't know.
I think this is maybe in two to three years where we're all going to be.
And frankly, I think it's a beautiful world.
You're a developer, you enjoy certain technologies, do what you like and compile it to WebAssembly
and you will get reasonable performance and reasonable access to native APIs.
No, I mean, I think you're spot on.
I hadn't quite thought about it that way, but you're right.
I mean, it's sort of what Java maybe could have been in some ways if we do have this
dream of a, you know, a nice universal minimal runtime layer that you can target and still
get, you know, very efficient things that lets you bottom out into really nice optimized
code.
And it does seem like when we're talking about Electron, right, we've already kind of thrown
out native apps out of the window, or at least totally native applications.
But what about Marzipan, Wes?
But what about Marzipan?
Yeah.
No, I think you guys had some pretty astute observations there and yeah, okay, maybe it'll
let you get a couple more sales on the Mac, but it's not, it doesn't feel like it's going
to have the same sort of universal appeal.
At least that's what's my take.
Yeah.
I mean, having said that, I believe this once before when I was super junior running Java
applets, and again, I am still sorry for what I did.
But yeah, it'll, this time will be different, right, guys?
Oh, I can certainly hope so.
It's interesting to hear you say that, though.
I mean, I guess, is that the main objection most people have to Electron?
I know there's, it seems like there's kind of two camps.
One is there's a sort of the philosophical camp that we shouldn't be doing things this
way.
It's bloated and wasteful, and it just sort of feels gross.
And then there's the other camp, like maybe you just run on a machine and you have a lot
of that, and so it's a practical argument that I just don't like having 10 copies of
Chrome running at once.
Yeah, I mean, you know, the philosophical argument, maybe there will always be a market
for like high end native applications, sure.
And maybe there will be some use cases where native is going to be better.
But I think the strongest argument against Electron right now is that you're running
10 instances of Chrome, just like you said.
You know, for me, I don't know how I could do my job without running Electron, right?
I work in VS code all the time.
I have Slack open constantly.
If the computer's on, Slack is open.
And God knows what else is like, mail springs Electron, right?
There's all these other applications that are on Electron that I'm probably using without
knowing.
Right.
I mean, just the idea, the barrier to entry is so much lower if you can combine all these
web technologies that you're already fluent in and ship them without having to learn several
new, you know, native development environments, it's just not going to happen.
And then what?
Then you start making decisions because you have limited manpower of which platforms do
you target instead of using something like Electron and being able to target all of them.
Yeah.
And I also think as a, again, as we move towards the WebAssembly future, Electron is a pretty
good stop app.
And there's no reason Electron apps couldn't eventually embrace WebAssembly, which I think
it's where they're going.
Well said.
And really, this kind of touches on a lot of topics.
We've covered everything from, you know, like web development to native app development.
I saw you put out a little poll recently on Twitter, Mr. Dominic, and it might have a
few implications for this here show.
Yeah.
So, I was asking our audience, now I know only a small percentage actually follows on
Twitter.
But, you know, what do you want to see more of on the show?
Mobile Dev, Web Dev, Esoteric Languages, and Indie Biz Dev topics.
Amazingly, Web Dev came in at 35% as the winner, but Biz topics came in at 32%.
Those are pretty close.
Yeah.
Esoteric Languages followed a little bit, lagging way behind is Mobile Dev down there
at 11%.
Is this what you expected, or is this interesting to you?
So, going in, I thought Esoteric Languages was going to win.
I was actually surprised.
I thought Dead Last was going to be Indie Biz Topics, and Mobile was going to be second
to last.
And it turned out it was Web Dev that won, Esoteric Languages, I'm sorry, Biz Topics
second, Esoteric Languages, and then 11% Mobile Dev.
Which is disappointing for someone who's been writing an iOS app that is going to be launching
in about a month.
Is that just because mobile's become sort of passe, even though we're still all using
it?
You know, I mean, we're still installing applications, we still use our phones every darn day.
Or is that just because more and more has shifted to the back end, and mobile clients
are sort of thin clients?
Well, I mean, certainly some of it probably has to do with audience composition, right?
But I would argue that mobile has become an implementation detail.
I mean, granted, this coming Monday is WWDC's keynote, so maybe Apple will launch something
that's like so earth shattering that we'll have to do an emergency live, whatever.
I doubt that very much.
Like I think you're going to have to endure me talking about a Mac Pro.
And I will dunk on Marzipan, that'll probably be about it.
I want to be wrong, though.
I would love more productivity iPad APIs so that we can have our Star Trek future.
Yeah, I mean, that would be nice.
I need that interface, man.
I need it.
Yeah, but you know, I mean, I don't want to get into this again, because we've talked
about it on tons of episodes, but just the limitations that iOS puts up make some of
those types of productivity functionality very challenging, I think.
So I don't know.
I think, I don't know.
What are your thoughts?
I mean, I guess I'm just saying mobile is mature, but that might be a lame answer.
Yeah, that's fair.
I guess it's not changing that much.
So if you've already sort of figured it out, then okay, there's not that.
There's even less exciting new frameworks and stuff than there might be for regular
programming.
What struck me when I was looking at this is I was just kind of curious.
How do you define web dev?
What fits under that umbrella?
Yeah, I didn't like that category, but I didn't want to complicate it too much.
Basically anything in the browser, but I also felt that WebAssembly should have been its
own category.
You're really hot on WebAssembly.
I like this.
I am.
Have you shipped anything in it yet?
Oh, no.
Nothing other than like little tinker toys to play around with it.
And do you have one use case you've been looking forward to that you expect to be using?
Either it enables something fundamentally different or you can offload.
It seems like there's this new universal runtime where there's different workflows and there's
also people just offloading JavaScript to make it faster.
Yeah.
I mean, I think in mixed OS environments, it's going to be a way to deliver a line of
business apps that are much more performant and frankly less crappy than what we currently
can do without writing natively or using some weird bridge framework.
Well said, sir.
Well said.
All right.
Well, you can go contribute, take that poll if you like, and of course, reach out to us
and let us know about how you like what we're covering or the areas that maybe we should
be covering more.
You can find the best ways to get in touch over at coder.show.com.
Mike, it's unfortunate, but I think we need to talk about titles.
And maybe we could start with me asking you because I don't really know.
I tend to make up titles for you.
But how do you describe yourself to others?
Are you a programmer, an entrepreneur, an independent consultant?
What are you and what do you think about titles in our industry?
Well, I usually describe myself as extremely tired.
But beyond that, yeah, I never say programmer.
I don't say entrepreneur unless I really have to or I'm filling out a LinkedIn profile.
I think I say software developer, sometimes software engineer.
I don't say app developer because if you've ever been to a cocktail party, you tell people
you're an app developer, they don't leave you alone.
Service-wise, a little precautionary principle in play.
Yeah.
Well, how about you?
How do you put it?
Yeah, I guess, I mean, programmer is not very well recognized and it sounds a bit simplistic.
You have software developer, and that's true, but I mean, developer is just sort of a weird
term.
I mean, it doesn't really capture stuff.
So I think the industry, I'll oftentimes end up falling back on engineer.
But as an article you pointed me at over at the Atlantic points out, and I think rightfully
so, if we are engineers, it's a very different sort of engineering than what that term has
come to mean in, oh, I don't know, every other industry.
And I'm more curious because I think you might have an interesting take on this as someone
who works in aviation-related fields that are kind of exemplars of the discipline and
practices enjoyed in those other engineering fields that just don't really apply to software.
Yeah, I definitely have some takes on this.
So we had an episode where we discussed this years ago, right after the healthcare marketplace,
the what is it, the Affordable Care Act marketplace launched here in the States.
Lots of big contracts going out to get that built and then huge implementation issues.
Yeah.
And there was a big movement, particularly among the software craftsmanship movement.
And you can go back to the tweets and the blog posts written by people back then to
basically say that software engineering, which I'm just going to use the term to simplify
here, should be a licensed engineering field.
I at the time pretty vehemently disagreed with that.
I still disagree with it.
Even engineers, so the author of this Atlantic post basically is maybe we should be fair
to them, right?
They're making Ian Bogost, I hope I'm saying your name right, Ian, is making the argument
that what he calls engineers are in most states in the United States and most territories
in Europe and in most places, to my knowledge, required to be licensed by the government.
That is true.
That hasn't always been true.
So to me, and first of all, it depends on what type of engineer like and also there
are like lots of engineers who work for a licensed engineer that aren't licensed.
So one, I think he's mostly talking and he talks about building bridges and like basically
basic infrastructure.
He's really talking about civil engineering and Wes is right that in aerospace there are
such a thing as licensed engineers and that's great.
That's a thing that could be good.
I kind of don't believe in licensing as a concept at the risk of like espousing some
crazy libertarian philosophy here.
You know, by Mr. Bogost's requirements here, Leonardo da Vinci would have been disqualified
for any of his work and you know, basically all of his work, right?
It would have been unacceptable.
He's a jackass.
Thank you.
And so would like Euclid.
You know, Euclid, the guy who gave us a bunch of basic arithmetic and geometry we have now.
I sort of think this is like yes, Silicon Valley bros who are making stupid apps about
like making the lives of 20 somethings easier to like do nothing are not really engineers
in my mind, but it is not some mortal sin that they call themselves engineers.
And you know, now would we really have to make some sort of delineation?
So like for instance, I'm writing an iOS app to sell under the mad botter.
So that would be code monkey work.
But when I'm writing radars for fighter jets, I'm an engineer.
Is that like the, am I an engineer sometimes, but not other times?
Right.
That's a great, that makes me think.
I mean, part of this is software is just big and flexible, right?
So if you're in the industry of making big structures, bridge building or you know, building
skyscraper or something, I wonder how much more or less variance there is, right?
It's from app development, say to writing software for planes, right?
Those can be very different fields.
I do wonder, is there something to this argument though, and maybe it has to do with some of
the specificity here that, you know, there's just not that many playbooks.
I mean, you can go buy a number of books that you want, but I'm not sure we have the same
level of agreed upon practices or standards in the industry.
Software just feels so fluid.
And there's been a lot of progress on stuff like formal verification and, you know, statically
typed languages and fancier compilers to try to make that less so.
But I'm just not sure we've outgrown the sort of notion that we are just, you know, we're
making web apps.
If we break stuff, it's not that big a deal.
I mean, we'll fix it.
We've got to move fast and keep adding features.
And is that sort of fundamentally different than sort of purity and approach to things
that is more considered and practiced?
It could be, I mean, but I wouldn't even say we've outgrown or we haven't outgrown the
notion because in the 70s, anything we would have called the software engineer today wasn't
in fact an engineer by Bogost's definition, right?
So I don't know.
I would almost argue, like to me, his argument is weak because it's the wrong argument.
Like I don't agree with what I'm about to say, but I can make a very strong argument
for it that software engineers ought to be licensed, right?
I think that would destroy innovation and be terrible.
But to me, that's a much stronger position than saying the Silicon Valley bros, which
is basically who is complaining about here, shouldn't call themselves engineers.
It's like getting mad at people who, you know, like wear things they maybe don't have the
right to wear.
You know, I know a guy who gets very mad when he sees some kids, young kids at a style where
like derelict or imitation like military jackets, right?
And some people get all pissed off about that.
It doesn't matter, right?
Like is it really, let me ask you, Wes, does it really hurt anyone if some frankly dumbass
or douchebag working on some stupid hookup app in California calls himself an engineer,
even though he's just writing JavaScript?
Hey, hey, we need that hookup app, Mike.
Don't get judgmental on us.
No, it's not.
That's my point.
It doesn't matter.
I mean, there's, there is something that matters about the discourse, but you're right.
Like arguing against it in this way is probably not going to change anything.
I wonder if it makes some interesting distinctions in the different tech fields though.
Say network engineering comes to mind.
That feels like it's a little closer, right?
Oftentimes there are best practices that are standardized, right?
Or you have big playbooks from equipment vendors that you're provided.
Software at least in, you know, in new industries is a little more, you hit it on the head there,
you know, craftsman like.
There is this unlike in engineering, say software is oftentimes reinventing itself or at the
forefront of what is current best practices.
And really we haven't been doing this very long, right?
I mean, how long has modern software existed?
70s basically.
In a blink of a blink of an eye.
Yeah, exactly.
So it seems like we're still also having to experiment a lot to just figure out what the
heck we're even doing.
Yeah.
You know, what's interesting to me and what I'm a little surprised he doesn't call for
in this post in the Atlantic is I would agree, like, you know, I used to be adamantly against
the software craftsmanship people, but I was just wrong.
Wester's right.
Who is right?
Wester's right.
Oh, it's even worse.
You know, some sort of more formalized processes of like apprenticeship or, you know, these
are the way we do things, focusing on how you get things done, not just hacking things
together and getting them done would be very beneficial.
And Bogos, again, correctly says there have been a number of disasters, right?
The healthcare marketplace, Equifax was a software issue.
And this is all getting more important, right?
Like software is only becoming more and more a part of our lives and tied into systems
that matter more as a result.
Absolutely.
A bug in a credit rating agency's web portal could actually stop you from buying a house
or buying a car.
Yeah, yeah, you're absolutely right.
That's terrifying.
That's devastating.
Especially as someone who's worked in software like that.
That is just scary because I mean, software doesn't work.
Is that too strong?
Yeah, no, everything's broken and burning on fire.
What's the next topic?
So you don't see any long-term title or nomenclature changes coming out of this argument?
No, I mean, I used to be scared of the title software engineer because I was afraid of
being forced to go through licensing and stuff like that.
That might be bad for me.
But I've been doing this so long that I just don't care.
If people want to call themselves software engineers, fine.
More and more, I think I have been doing it myself because I just really don't want to
say like app developer, one, because it's partially not true.
I don't spend that much time writing mobile apps.
But yeah, I don't know.
I mean, what would the correct title be, I guess?
I'm not sure we have an agreed upon one and that's sort of what's missing from this argument,
I guess.
It's easy to say we shouldn't be using this, but I don't know where we go from there.
So I expect things will stay the same.
Like ironically, the title I hate most is coder.
Yes.
Right, which for the host of Coder Radio is great, but...
Software engineering radio, you mean?
That exists and that's somebody else.
So we had to, you know, second choice option, maybe third choice.
Because it's that stupid Jonathan Coulton song, code monkey get up, yeah, that one.
Yes, exactly.
Well, all right, I think by and large, I agree with you.
I am curious to see how the practice of software development and engineering proceeds.
And if we do reach a place of more rigorous standards, or, you know, at least more consensus
within industry, but it doesn't seem to be happening anytime soon.
They can't agree on tabs or spaces, so good luck.
Now one area there has been some consensus, not entire consensus, but at least a majority.
That's where you keep your code.
And by and large, these days, where else, it's GitHub.
Now while I was off gallivanting around Europe, some news came out, GitHub announced something
called sponsors.
What's going on here, Mike?
Yes, so you can now throw some change at your favorite open source projects and maintainers.
And I just found this out today, GitHub will match, I think it's up to $5,000 per project,
or I guess they define a project as a repo.
But wow, that's...
Oh yeah, they're right, they're right.
To supercharge community funding, GitHub created the GitHub Sponsors Matching Fund, which matches
up to $5,000 per sponsored developer in their first year of sponsorship.
Make it rain, baby.
So what's your take on this?
I mean, is this a good thing?
It seems like yes, in the sense that we want open source projects to be sustainable and
for developers putting a lot of hard time and effort into doing this, does it make you
at all nervous that this is further centralizing and entrenching GitHub as the only place to
do open source software development?
So I like this idea, and yes, it is further centralizing GitHub.
But I think it was eventually going to become a natural monopoly.
Things consolidate, that just seems to be the nature of our industry.
I still think on balance, and I actually don't think the consolidation is too bad in this
case, people are providing hundreds of thousands, if not millions of dollars of value with these
open source projects and not being compensated.
And I know there's like the whole beard, Unix beard philosophy thing, but that does not
pay your rent or buy you food.
So yes, you should give them some money.
And if this is an easy way to give them some money, since you are basically piggybacking
on the work they've already done, I am all for that.
Yeah, and I suppose it maybe it does make it easier if you are a company or other developer
who already right has a GitHub account, you don't have to go use some sketchy third party
service that you have to sign up for and give credit card details to in order to send a
couple dollars someone's way.
If you're already on GitHub, you probably already trust it and they have a lot of your
details already.
That sounds like a pretty low barrier to entry.
And oftentimes, unfortunately, it seems like those little tiny details are what gets in
the way of a donation or not.
And I'm curious to see how successful this is after the initial hype period.
Well, I'll put the question to you, Wes, do you think GitHub, which is, of course, Microsoft,
is maybe gaining too much influence on the open source community as a whole?
You know, there was some other news, right there, they have some more dependency tracking
and upgrading stuff that they announced recently as well.
It's becoming a very full featured platform.
And it's clear Microsoft cares a lot about I mean, they paid a fair amount for it.
But it seems like it's developing and releasing stuff at an even faster pace now.
And it's becoming a very nice spot to be.
On one hand, it seems like they're giving more away for free.
You know, there is more features that you can use and that they're being very friendly
to open source communities and projects.
I still have this little feeling in the back of my mind that makes me just like a little
bit nervous about it.
I'm curious if we'll see any more good faith moves, you know, maybe some open source releases
from some of the GitHub codebase or some of their tools.
Microsoft does seem to be playing that game.
And I don't really doubt their intentions.
It just seems so, so centralized, like it's, there is such a pressure to be there.
Eventually, if prices get ratcheted back up, what happens, right?
I mean, do you lose this stuff?
Or do you have to go then get out of GitHub?
I don't really have an end game there.
I'm not personally that worried about it.
It's not going to change my day to day habits.
But every time there's a feature, I can't be just excited for it.
And I don't like that.
I mean, I don't see how they would have any pricing power.
Because you know, some time ago, we did have the GitLab CEO on here.
You know, we at TMP do use GitLab as well.
It does exist, right?
It's very good.
It is very good.
Yes, that's absolutely, that is absolutely true.
But is it I mean, does it have the same sort of discovery?
GitHub's a name, you know, even if you don't do software very much.
And I don't know that GitLab can say the same.
So the the integration for GitHub that would scare me is if they integrated it with LinkedIn
and GitHub became basically how you get employed as a, you know, kind of, kind of starting
out developer engineer, whichever term we choose to use trying to break into the industry.
Because one day recruiters are going to figure GitHub out.
They don't seem to have yet.
But it's going to happen.
And if they ever do that, may God have mercy on those of us that ever emails public.
Oh, boy, I'm, I'm scared for bad recruiting emails already.
Oh, yeah.
Yeah, I guess we're just gonna have to wait and see.
And I mean, don't get me wrong.
Probably I should just be happy about this.
If it if it nets more money in the hands of open source developers, if it makes more open
source projects sustainable, well, that's just got to be a good thing.
Now, okay, moving right along something I think I have a little bit more right to be
skeptical about maybe and maybe you can help here because this is over in the C sharp area
and that's Mr. Dominic's domain.
But it's lying to the compiler.
Now the compiler is supposed to be our friend, right?
It's supposed to be there to guide us and say, oh, oh, hey, buddy, you got that wrong
or you missed that edge case.
But sometimes you got to lie or at least play some games to get things to work right.
Yeah.
So John Skate, very, very famous, very, very talented.net developer.
I think he's like number one on Stack Overflow for questions.
Put this great post lying to the compiler.
For those who don't know, C sharp eight is adding nullable references, technically nullable
reference types.
We've talked a little bit on this here show.
We did we did.
If you've done Swift at all, it's basically it's not exactly like optionals, but for the
purposes of this conversation, it functions like optionals, right?
It's fine.
And in fact, it has the same syntax, question marks and exclamation points.
So unfortunately, turns out if you have like large code bases and you upgrade them to C
sharp eight, guess what the compiler does, Wes?
I imagine it gives you all kinds of crap.
Yeah, it gives you a bunch of warnings, which it's pretty common in the dotnet world to
treat warnings as errors.
So basically you can't like build or deploy.
Right.
Suddenly all these things break up your build, little light goes red somewhere and you're
going what's happening and how do I make sense of it?
You know, I've been talking about more in the context of Swift because Swift was kind
of what made this mainstream.
You know, it's obviously good if something could possibly be null to like handle that
case.
Right.
The compiler is sort of to force you to think about it instead of making you do it yourself.
Right.
Which I think is great.
But I also predicted that this is exactly what's going to happen, right?
Eventually people would just be like, wow, this is actually a tremendous pain in the
ass and I have a ton of code that's already written.
So let me pull a bunch of tricks to basically get around that.
And that's what John Skeet is writing about.
And it's a very thoughtful blog post.
I'm not going to summarize the whole thing, but I would strongly recommend even if you're
not a dotnet developer that you check it out.
Yeah, this is a problem, right?
I've been writing a lot of Swift recently and I can tell you that just kind of looking
at some open source projects I was evaluating, a lot of people are just going around this
crap.
They're doing a larger refactoring that would have this architected in like a cleaner way.
Is this just because of old code or is it something inherent to some of the new styles?
Yeah, it seems in the dotnet world there's just tons of old code that doesn't play nice
with this.
But even like I'm looking at things that are recently written that let's say last six months
in the Swift world, which obviously this was a Swift 1.0 thing five years ago.
You know, sometimes it is just the case that you want to force unwrap something, right?
Which is again the Swift terminology.
Sure, it's annoying and stuff, but could one argue that really this is just telling you
that your old code was fundamentally unsound?
Yeah, I don't actually know what I think about that yet.
There is a big philosophical question here of should your code be 100% safe?
We all have run into problems where we should have been checking for null values or we didn't
understand the exact semantics of the value we were talking about.
But clearly, I mean, just based on your experiences and John's experiences, there's also cases
where that sort of level of certainty goes beyond like we've figured out our own ways
of dealing with that already and internalize them.
So there's some areas where we have problems and we need more rigorous checking and there's
some other areas where we could be more rigorous, but in practice, it just doesn't matter as
much and adding those extra checks, at least with our current compiler technology, adds
an onerous burden on top.
Yeah, and I would also add that I think as new patterns or even existing patterns are
modified to more embrace this, let's say, null aware or safety aware programming style,
these things will be less of an issue.
I mean, right, like with Kotlin, for instance, since they've had that from the start, you're
seeing there was less old code, at least for stuff developed Kotlin first, now Interopt,
that's another story.
Yeah, well, Kotlin is actually the perfect example, Wes, right?
As soon as you Interopt with a classic Java library, it's like a holy crap.
Oh, hello there, null.
Yes, oh, null, ooh, there you are.
Yeah, that's interesting.
Well, definitely go check out that post if you are someone playing with some of these
new fancier type systems and null checking abilities, and just because Chachansky's blog
posts are always enlightening.
Speaking of language styles and different ways of programming, Mike, you've had a fun
idea for the next couple of shows, and I think it's great.
It all stems from a book by Bruce A. Tate, Seven Languages in Seven Weeks.
That's right.
So, and longtime listener Sean McBride has been tweeting about this and blogging about,
he is doing this challenge which comes from this book where, and I read this book years
ago, basically you do somewhat non-trivial but not super hard exercises in seven languages
over seven weeks.
And the book has seven prescribed languages that are very much an artifact of when it
was written.
And I'd like to twist this a bit, Wes, for us.
Ooh, tell me more.
So starting now, for the next seven weeks, I will pick a language for you to study up
on and do an example in.
Uh-oh.
And you will pick one for me.
Now a couple of rules.
Something tells me I know what the first one's going to be.
Oh, I can't imagine what.
So it has to be something we can do on our standard OSs, right, which I think we both
run Linux and I run Mac.
Okay, so no like legacy small talk VMs or anything crazy obscure.
Yeah, no legacy small talk, no like old vBasic that someone would have to, yeah.
Okay, yeah.
That's fair.
Yeah.
And that's it.
So the idea would be we'd each come with a little example.
Maybe we throw it on a GitHub gist and can share it on the show if we have that ability.
And will we be trying to implement maybe the same challenge each week or something?
I think that's good.
We should actually just have a default challenge that we're implementing.
I don't know, maybe something like scraping Twitter for mentions of Coderadio.
I have no idea.
Yeah.
We could maybe also pick one of those fun advent of code challenges.
Oh, that's good.
I like that.
Yeah, right.
Something that's a little bit fun but stresses some built-in data structures or some of the,
you know, main constructs of the languages and perhaps even a little concurrency.
Damn.
Wes is making it hard.
All right.
I mean, we don't have to go that far, but I guess we'll figure it out as we go along.
But Wes, have you thought of a language for me?
See, I don't know if I want to save it for the end or if I should just start off with
something, you know, like a little bit easier.
It's up to you.
Yeah, okay.
Yeah, okay.
I think I have thought of one.
Should we announce them now?
Go for it.
Well, all right, Mr. Dominic.
I'd like you to try Elixir.
Elixir?
I am shocked at that.
I mean, I'm just curious what you take from, you know, maybe you can try playing with Phoenix,
which is their seemingly excellent web framework.
I'd be curious to hear what you think as someone who's done a lot of Rails because I think
those two developer communities in particular have a lot in common.
Okay.
Okay.
So what will I be playing with?
Well, I'm going to start with something easy.
I would like you to try TypeScript.
Oh, okay.
I like it.
Excellent.
All right.
So we'll have to decide on some challenges.
We'll find something good that we both agree seems like fun and demonstrates, you know,
some strengths or weaknesses of the particular language chosen.
And just make sure you come back here for Coder Radio 360.
We'll have our first report.
What?
Yeah, yeah, yeah.
All right.
Well, that's a great idea.
I'm excited.
And we'll keep announcing what we're doing and we'll tweet about whatever challenge we
decide on.
And that way, you guys out there in the audience, why not join us?
Pick one of the two.
Do both.
We'll all have a lot of fun.
Great.
And I think we should keep the repos open, too, so people can laugh at my Elixir.
Yeah.
Right.
Well, we're going to embarrass ourselves for sure.
Oh, yeah.
This is going to be bad.
Something tells me the way smarter and more knowledgeable audience will show up and test
set us straight.
I think so.
All right.
Well, we better get out of here because I got to go install TypeScript.
I got to install Elixir.
What the hell is Elixir run on?
Yeah.
Right.
You got to go figure that out.
I'm curious to see what you think already.
I think I'm going to be reading a lot.
So I think you will.
That'll do it for this episode.
We've got lots to do.
But you know, you can find more of the show at coder.show.
We've got the whole backlog.
Maybe go check out 343, which is the episode where we previously talked about C-Sharp 8.0
and the nullable reference types.
Or hey, go to Jupiterbroadcasting.com and find all the other great shows on the network.
You can also find us both on Twitter.
I'm at Westpane and Mr. Dominic, you're at Domenico.
The network's there too, of course, at Jupiter Signal.
Thank you all for joining us.
You can also catch us live every Monday, just about at 12 p.m. Pacific.
Head on over to Jupiterbroadcasting.com slash calendar to convert that to a time zone near
you.
Thanks for joining.
We'll see you right here next time.

1
00:00:00,000 --> 00:00:08,000
This is Coder Radio, episode 350, for March 25th, 2019.

2
00:00:31,000 --> 00:00:42,000
Hello, and welcome to Coder Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business of software development and related technologies.

3
00:00:42,000 --> 00:00:49,000
My name is Wes, and I'm joined once again by the Swamp Master himself, Mr. Michael Dominic. Hello, Mike.

4
00:00:49,000 --> 00:00:59,000
Yo, yo, yo, we got WWW, Mr. Worldwide, that's right, Worldwide Wes. You heard about the Worldwide Web, forget about that. It's all about the Worldwide Wes, son. How you doing, Wes?

5
00:00:59,000 --> 00:01:10,000
I'm doing fantastic. I'm Worldwide, didn't you know, because we're streaming live at jblive.tv, as we do every week. It's a little bit more fun than listening to the recorded version. Sure, that's good, too. It's super convenient.

6
00:01:10,000 --> 00:01:18,000
But when you're here live, you get to interact with our IRC room, yell at Mike and I for getting stuff wrong, which it turns out, Mike, sometimes we do.

7
00:01:18,000 --> 00:01:27,000
Just little things like countries. Like, for instance, Wes, did you know, because I didn't, and I'm the one on the tape, that Ethiopia is not Nigeria?

8
00:01:27,000 --> 00:01:38,000
It turns out that is a fact, and we said the wrong thing, and unfortunately, it's a live show, things happen off the cuff, and neither of us caught it.

9
00:01:38,000 --> 00:01:58,000
Things happen. And in Wes's defense, the we is me. So it is in fact the case that we mentioned Ethiopia, or Nigeria, rather, and it turns out it's the opposite, right? So this is in regards to the 737 Max story we had last week, which there's some developments on, but again, we're going to let that go.

10
00:01:58,000 --> 00:02:12,000
Ethiopia is not Nigeria. We are sorry. Thank you for the person right again, who was very kind and, you know, just a little correction. Obviously, with a live show, sometimes we mistake things. No biggie, no malice intended.

11
00:02:12,000 --> 00:02:22,000
Yeah, really. I mean, it's just a great chance to go to coder.show slash contact. Please do let us know because, you know, we just get things wrong, and we'd like to set the record straight when we can.

12
00:02:22,000 --> 00:02:30,000
Continuing the trend of failure. Did you know, Wes, that I have been drinking myself into a stupor for no reason?

13
00:02:30,000 --> 00:02:34,000
Well, that's a little bit depressing for you to just share right here, but how can I help?

14
00:02:34,000 --> 00:02:55,000
Well, apparently Objective-C is not dead, one of our listeners shared with us. And sure enough, we have a red monk leak. Thank you listener who shared this. Objective-C is originally, it was originally in 2012 when we started the show, it was like number three or four on the programming index. Now it's back up to number 10.

15
00:02:55,000 --> 00:03:05,000
Back up to number 10, you say. Okay, so number 10. Can you give us a little more background? What are we talking about? What do these actually mean? Where's this data coming from?

16
00:03:05,000 --> 00:03:33,000
Yeah, so the data is kind of, it's a survey, right? So one, once you have a survey, you're already talking about a self selecting, selecting set of developers who actually care enough to like, read these websites, listen to podcasts and actually fill out a survey. But having said that, on the same survey about a year ago, Objective-C did not make the top 10. So it's interesting that it rose back up.

17
00:03:33,000 --> 00:03:40,000
Now, having said that, Wes, if you'll indulge me, let's go through the top four languages on this survey.

18
00:03:40,000 --> 00:03:55,000
Oh, yeah, let's do it. Let's break this down and talk about and again, right, like, popularity is not everything. But it is kind of indicative of where what people might look for hiring managers, look at this kind of data, you know, people that probably shouldn't look at this data, look at this data, we might as well look at it too.

19
00:03:55,000 --> 00:04:04,000
Well, and number one tells you that popularity is not everything because who's the number one language? None other than JavaScript.

20
00:04:04,000 --> 00:04:20,000
You know, if you think about that for more than two seconds, it makes sense because, you know, the world runs on JavaScript. Number two is Java, makes sense, enterprise software. Number three is Python, which I'm a little surprised at. Four is PHP.

21
00:04:20,000 --> 00:04:28,000
Out of the top four languages, do you know what they all scream? Actually, let me put to you, what do all four of those languages scream to you, Wes?

22
00:04:28,000 --> 00:04:46,000
I mean, kind of they seem they seem just a little bit old. Now, a lot of them are rather rather dynamic, Java being the exception here with its, you know, oh, so static nature, but they are they are long established languages that we haven't really seen maybe move around on this list, but but not really disappear.

23
00:04:46,000 --> 00:04:57,000
Yeah, I would say they're old, but they're also they're like hyper practical, right? People working in PHP are doing it because they just need to get a job done. And JavaScript, I work in JavaScript because I have to, right?

24
00:04:57,000 --> 00:05:05,000
Exactly. Everyone has to, if you have anything that touches the web, or maybe you have to use node for some reason, like JavaScript is everywhere.

25
00:05:05,000 --> 00:05:20,000
Right? I mean, architect in the chat points out at least 3 billion devices run JavaScript. Makes sense, because every smartphone does write every web browser, every hell you can do embedded JavaScript these days through a number of weird open source libraries.

26
00:05:20,000 --> 00:05:45,000
So I find it interesting that Objective C is back in the top 10. But actually, to be honest with you, the answer to this is, this is not like an Objective C renaissance, right? It's, there are a lot of large scale applications out there, particularly for iOS, Mac, that have tens of thousands of lines of Objective C that need to be maintained.

27
00:05:45,000 --> 00:06:04,000
And porting them to Swift just, you know, unless you know this, it's just not practical, right? You don't port languages, because you want to. You do it because you have to, right? I mean, you have to choose, you know, almost never, almost never just want to do that, because it's going to be it's going to be a huge amount of work that you're going to have to take on.

28
00:06:04,000 --> 00:06:18,000
It's going to be error prone and complicated. Now, maybe there are times where the new language, the new framework is interesting enough or better enough. But even then, that's all time you've spent not working on whatever actual features you were trying to work on.

29
00:06:18,000 --> 00:06:37,000
Yeah, I mean, I agree completely. So I guess there's hope for old men like me. Oh, by the way, Ruby was number eight. Just, you know, just kind of throw that out there for Wes, because I know he's a Ruby fan. They've also included CSS on this list, which feels just like, kind of kind of strange to me. I mean, which makes them lose all credibility.

30
00:06:37,000 --> 00:06:59,000
Yeah, I don't I don't see HTML. So maybe that didn't that doesn't quite make the cut. Did you have any other I mean, it's like some of the stuff that they mentioned specifically is like the rise of TypeScript, which I think, yeah, everyone kind of know, I was surprised to see I mean, it's probably not really meaningful statistically, but go didn't really increase a lot kind of went back just just a hair.

31
00:06:59,000 --> 00:07:28,000
You know, I since I've been tweeting about rust and f sharp, I have had a lot of people telling me that I should look at go much more seriously than I did about. Oh, I want to say two years ago for the show. But go has not, in my estimation, moved very far in terms of market share. I think there is a very passionate go community. And we should say rust is not on this top 15 list we have here at all. So obviously, go is more popular than rust, accordingly.

32
00:07:28,000 --> 00:07:57,000
According to red monk. I don't know, was your expectation that go would have been higher? Oh, yeah, I mean, it just seems maybe we've found all the places that it was good. But there was a time kind of when I don't know, in the last four years, maybe where it felt like go was eating everything in its segment. I'm thinking about like, like all the little canonical tools that come out a lot of the container tools, Kubernetes, anything that just gets distributed as a tiny, you know, little nice binary that go does.

33
00:07:57,000 --> 00:08:14,000
So well, it seemed like it really fit at these sort of mechanistic programming tasks, especially kind of lower level, anything having to do with networking, especially given the great standard library support, right? So like, it just became this thing, you're gonna go write this little, you know, this little rest daemon or some sort of proxy system.

34
00:08:14,000 --> 00:08:27,000
Go was the choice for that, at least if you you know, if you can live within the constraints of go. And maybe, maybe we've just seen, you know, it's eaten that category and isn't as relevant to other stuff.

35
00:08:27,000 --> 00:08:46,000
Maybe I hesitate to say that it's not relevant, I would just say it's not popular. Which, for instance, you know, how many people do we get writing into the show and tweeting at us about how much dotnet? Or I'm sorry, JavaScript sucks, right? Or PHP sucks? Yet, respectively, they are number one for?

36
00:08:46,000 --> 00:09:02,000
Yeah, that's, that's true. I guess, I guess it's a good lesson that languages stick around longer than you might think. And I, for one can often be blamed for living a little bit in too much of the hacker news bubble or other, you know, people that like interesting programming languages.

37
00:09:02,000 --> 00:09:04,000
Well, it's not like you write Clojure.

38
00:09:04,000 --> 00:09:22,000
No, right? No, of course not. And I guess goes kind of on the opposite side of that, because it's just a very practical, relatively simple, no nonsense, no, you know, fancy features, at least, not yet. Maybe I should give it a little more credence. But according to Red Monk, apparently not.

39
00:09:22,000 --> 00:09:34,000
Speaking of open source, Wes, I have decided to contribute my body and soul to the open source. I have volunteered as tribute, we could say, much like my, my girl Katniss Everdeen.

40
00:09:34,000 --> 00:09:46,000
Kind of a little bit cryptic, Mike. I know you already, you know, put in all kinds of good work all over the world. What are you talking about now? Because you've kind of made just this week, today even, a big announcement.

41
00:09:46,000 --> 00:10:07,000
Yes, so I have joined as a supporter and member of the.NET Foundation, which is, before you all freak out and write your, your YouTube comments, it is the open source.NET that supports not only the open source project.NET and.NET Core itself, but also third party open source projects and the open source community.

42
00:10:07,000 --> 00:10:25,000
So I wrote a little post on dominechem.com that we have linked in the show notes. Basically, it's, you know, I use a lot of.NET, I write a lot of.NET and more and more I find myself writing things like C sharp and F sharp on Linux or embedded systems.

43
00:10:25,000 --> 00:10:47,000
And I kind of just want to give something back. It kind of helped the community, particularly in the Linux space, because I feel like there's some, you know, the.NET Foundation has done a lot to get into the open source community, but I feel like they haven't done a great job with the Linux community in particular, like breaking down those walls and saying, hey, actually, we are open source.

44
00:10:47,000 --> 00:11:03,000
Right, because we kind of we saw it was announced, right? Everyone knows that you can now run it on Linux. But I haven't seen a huge amount of traction or, you know, people talking about it a lot of excitement on Twitter or blog posts, or, you know, just reinforcing the day to day realities of how well does it work? Is this a good solution?

45
00:11:03,000 --> 00:11:10,000
And maybe you could talk a little bit about that. Why this stack? Obviously, on Linux, you can choose just about any technology stack you want.

46
00:11:10,000 --> 00:11:32,000
Yeah, I mean, one of the the unusual things about.NET against, let's say, a Ruby, for example, although people were writing because there are weird projects to make Ruby do a lot of weird things, is that.NET runs on mobile, it runs on desktop, it runs in the server, runs in the browser now with things like Blazor.

47
00:11:32,000 --> 00:11:43,000
And Project Uno, which we had in the show several months ago, I'd encourage listeners to go back to the back catalog. Avalonia, which full disclosure, my company, the Mad Potter is a financial supporter of.

48
00:11:43,000 --> 00:11:53,000
That project makes.NET GUI's XAML applications run on Windows, Mac, mobile, web, everywhere you want to go, you can use XAML.

49
00:11:53,000 --> 00:12:14,000
And frankly, my biggest interest, though, is F sharp in embedded devices. So we're talking custom boards, custom IoT devices, you know, I don't know if you remember, Wes, right before you started co-hosting the show with me, I was evaluating the Azure spheres product from Microsoft, obviously.

50
00:12:14,000 --> 00:12:24,000
Yes, I do remember that because I was kind of interested. That's been a project we've watched on Unplugged and other shows on the network. So I was curious to see, you know, you were evaluating it as a first hand thing.

51
00:12:24,000 --> 00:12:34,000
Yeah, I ended up not going with it. I ended up going with a pure Debian Linux based IoT solution. And I can't really give you details on what the job is yet until it's already shipped.

52
00:12:34,000 --> 00:12:53,000
But running mostly F sharp, right, a totally.NET solution, but compiling down into almost native performance. But we get the advantages of developing, you know, in frankly, a platform that's not C++. So it protects us from certain errors that we might make, right?

53
00:12:53,000 --> 00:12:58,000
Right. I mean, you have a really nice high level sophisticated language in F sharp in particular.

54
00:12:58,000 --> 00:13:11,000
And of course, if I want to support or if I want to contract out part of the job, F sharp and C sharp are 100% compatible because it's all the CLR, which is an easier language to work in.

55
00:13:11,000 --> 00:13:23,000
Right. I mean, this is kind of the same advantage that that Java stuff has, right? Whether you're doing Java, or maybe you're implementing the library in Scala or Kotlin, right? So you have that same thing. If you're using F sharp or C sharp.

56
00:13:23,000 --> 00:13:35,000
And I mean, there's other stuff, too. Actually, it's not super popular, but there is even a Clojure version that compiles down to run on.NET, too. So it is a valid and valuable runtime all on its own.

57
00:13:35,000 --> 00:13:55,000
Yeah, it's a serious, there is a lot going on here. And I think, I mean, I hope it will be good for the Linux community. And I understand that there's a lot of bad blood, too, right? Like, I'm not, you know, I'm not Red Riding Hood skipping through the woods here. I understand that this is going to be a hard sell.

58
00:13:55,000 --> 00:14:11,000
But I have myself shipped a product using Avalonia, which is, of course, the open source.NET product that I mentioned before on Linux. And there is no reason, no technical reason that this shouldn't be possible.

59
00:14:11,000 --> 00:14:30,000
So I don't know, I know we're gonna get a lot of hate mail about this, Wes. I'm just saying, this is a very practical environment to work in. And it's completely open source. So I think it's MIT licensed, if I'm not wrong. I think maybe an open mind, we could have as a Linux community, a great toolkit to work in.

60
00:14:30,000 --> 00:14:38,000
Oh, I like that. So what other you have, like responsibilities? I imagine there's like a financial component of this. But do you how else are you involved in the foundation?

61
00:14:38,000 --> 00:14:55,000
Yeah, so there's a donation of $100 a year. I am talking to them now to try to kind of accelerate some open source products. An issue that's very personal to me is kind of education, like engineering education or STEM. I hate to use the buzzword education for young folks.

62
00:14:55,000 --> 00:15:11,000
So I'm trying to see is there a way we could put together a meetup where we teach, you know, younger folks, I'm talking middle school kids, things like that development. I don't know if you know this, a couple years ago, I did a deal with Microsoft where I did a STEM thing with Minecraft where we did like little Minecraft add ons.

63
00:15:11,000 --> 00:15:13,000
Oh, that's a great platform for learning.

64
00:15:13,000 --> 00:15:28,000
Yeah, yeah, it really is. Now I know my now kids are different West. I mean, in three years, kids can change, you know, so I don't know what the new hot thing is. But if you are a kid, you want to email, please let me know.

65
00:15:28,000 --> 00:15:33,000
Mike needs informants here. So yeah, just coder.show slash contact.

66
00:15:33,000 --> 00:15:37,000
I need munchkin spies, hashtag show title.

67
00:15:37,000 --> 00:15:53,000
Well, that's probably the perfect time to transition to our next topic today, which is all about gaming. In particular, we're going to talk about Google's new stadia because did you know this Mike, the future of gaming, it's not a box.

68
00:15:53,000 --> 00:15:59,000
It's a place. It's a place in your heart, as long as you have 25 megabytes per second.

69
00:15:59,000 --> 00:16:09,000
And that is the catch because this is a game streaming service. Maybe you've probably already heard there's been lots of coverage. We mentioned it very briefly on the previous Linux unplugged.

70
00:16:09,000 --> 00:16:17,000
If you haven't, though, close to the latest Linux action news episode 98. There's a great breakdown in addition to what we'll talk about today.

71
00:16:17,000 --> 00:16:24,000
The basic premise is, though, you know, Google, Google has all the GPUs, they've got all the cloud, they've got well connected data centers.

72
00:16:24,000 --> 00:16:36,000
And so instead of you having to have all the hardware, keeping up with the latest and greatest, if you don't need a desktop, maybe you certainly don't need a fancy Nvidia card for your day to day job or, or just, you know, casual computing.

73
00:16:36,000 --> 00:16:47,000
Google is offering to, you know, for for price unknown, probably some sort of subscription type service. Do all that magic for you on their side and just send you the frames.

74
00:16:47,000 --> 00:16:53,000
So before I dive into my haterade, what was your initial impression? Are you a gamer? We should even cover that first.

75
00:16:53,000 --> 00:17:03,000
Yeah, I mean, I'm not I'm not it. I don't know that I would label myself a gamer, but I do really enjoy I have played video games almost all of my life and I do really enjoy them and appreciate them.

76
00:17:03,000 --> 00:17:09,000
I don't have as much time for it these days as I would perhaps like, but I certainly have steam installed.

77
00:17:09,000 --> 00:17:29,000
Okay, so would you? So I have so much skepticism here. One, what about bandwidth, right? Like they said on stage for 1080p, you need about 25 megabits per second or megabytes per second. Doesn't that seem insane for most of the country?

78
00:17:29,000 --> 00:17:42,000
I guess so. That's probably true. I, I'd like to look up some some new figures about this because I wonder how well, you know, obviously, the closer you had a big population centers, the better connections you often have available.

79
00:17:42,000 --> 00:17:52,000
And there's also more people there. So is it feasible for this to roll out to, you know, all the city folk and perhaps ends up as some pressure for rural ISPs to improve?

80
00:17:52,000 --> 00:18:06,000
And maybe that's not true. Maybe there are plenty of, you know, big urban areas that still have connections that aren't up to this. I'm biased. I live in Seattle and obviously, a tech focused city and we have a little bit of ISP choice. So I'm super spoiled and can't really comment.

81
00:18:06,000 --> 00:18:19,000
But you've got to think they've thought about that, right? I mean, they're not. They've been in that game. They have their rather unsuccessful Google fiber attempts. So they clearly have thought and must have some numbers market research about the kind of connections people have before rolling out this service.

82
00:18:19,000 --> 00:18:36,000
I hope so. I mean, I, I'm more interested. I mean, I'm just being a cold blanket on the bandwidth stuff, but I'm more interested on do you think that developers who may or may not want to support stadia might by accident, end up supporting desktop local Linux games?

83
00:18:36,000 --> 00:18:53,000
That is one of the big things here, right? The sort of question, because on the back end, Google is basically saying we're running these on Linux servers, right? Because of course they are. That's how their infrastructure works. And they're using Vulkan. So those are both, those are both good. They sound like good things, right?

84
00:18:53,000 --> 00:19:08,000
And honestly, I'm not sure we don't really have enough details to, to, to say, I'm a little skeptical though. I think at some low level, yes. Like having support for some of that already built into some of the bigger frameworks, right? Like unity, like unreal.

85
00:19:08,000 --> 00:19:23,000
That's probably good. Although, you know, they actually kind of already, already had some of that stuff. What worries me is stadia is going to be a pretty rich environment for a game to run in and somewhat different. So I'm a little skeptical of how much, all right, great.

86
00:19:23,000 --> 00:19:47,000
You've got the like basic graphics part of it all done, but I don't imagine for complicated games, like it's not going to be a couple extra little clicks to export a native Linux client. You're going to have to really design with that intention in mind. And in that case, stadia is going to reach, you know, has the possibility of reaching a way bigger audience than Linux, you know, a native Linux game client ever would.

87
00:19:47,000 --> 00:20:09,000
Yeah, I don't know. I mean, maybe that's too skeptical. I don't know. Color me a fraidy cat, but I'm worried that, I am worried that stadia Linux might become like Amazon Linux where it's basically Debian or some, some, you know, flavor of Debian that you're used to, but like weirdly proprietary, right?

88
00:20:09,000 --> 00:20:25,000
If it was like, and I know this is like super nitpicky, but if it were the case that they were just running Debian or Ubuntu or name your distro of choice here, I'm not trying to be a shill for canonical here.

89
00:20:25,000 --> 00:20:39,000
I would be like, yes, the benefits of developers wanting to cover stadia is going to come downstream to Linux. And as a developer myself, who was, I don't know if you know this, a decade ago used to work in the games industry.

90
00:20:39,000 --> 00:20:42,000
I did not know that. Whoa, interesting.

91
00:20:42,000 --> 00:21:04,000
Yeah, it would make a lot more sense to be a lot easier to pitch that to management that we should cover Linux. However, it is unclear to me whether this is like stock Linux or, you know, is this some weird Google proprietary?

92
00:21:04,000 --> 00:21:13,000
Like I did take a look at what they had for their stadia developer site and they do seem to, obviously as an online service, they have their own API, right?

93
00:21:13,000 --> 00:21:27,000
Like there is a world, and you know, let me put my tinfoil hat ala Chris here, where people are just programming towards stadia rather than towards, or to rather Linux, right?

94
00:21:27,000 --> 00:21:36,000
I don't know, maybe that's too paranoid. I mean, I still miss Google Reader, right? So I'm a little paranoid.

95
00:21:36,000 --> 00:21:48,000
Yeah, there is the other, that elephant in the room of Google's known to sort of drop services. I will admit to having used the inbox service, which is ending in seven days, so my phone tells me.

96
00:21:48,000 --> 00:21:50,000
Oh, sure. Yeah, it is. Yeah.

97
00:21:50,000 --> 00:22:07,000
So I feel that pain myself. I don't know. Yeah, it is interesting. I am honestly hopeful that having Linux and Vulkan as a runtime for what maybe will be a popular service has got to at least bleed out in the effect of like more developers are educated for that.

98
00:22:07,000 --> 00:22:13,000
So if they're interested in supporting that platform in other ways, they can do so.

99
00:22:13,000 --> 00:22:21,000
And of course, you know, we've had a lot of other updates about, you know, with Proton and other stuff. So it seems like it's still things are looking at momentum's building.

100
00:22:21,000 --> 00:22:25,000
We're still a small community and don't have a lot there to leverage.

101
00:22:25,000 --> 00:22:32,000
I don't know, stadia certainly is presenting an interesting take though, because as a casual gamer, I can really see the appeal.

102
00:22:32,000 --> 00:22:36,000
I've seen a lot of skepticism from, you know, maybe more hardcore people.

103
00:22:36,000 --> 00:22:43,000
It also continues most likely this sort of notion. Again, we don't really know, but, you know, more service based, less physical copy.

104
00:22:43,000 --> 00:22:48,000
There is no physical copy. And is it even a sort of thing you own in any sense anymore?

105
00:22:48,000 --> 00:22:56,000
Is there just going to be entirely subscription based? And that's I can see how that be frustrating for, you know, people who are dedicated gamers.

106
00:22:56,000 --> 00:23:05,000
But even then, in the casual side, it still sort of works because maybe I don't care, but I just want to be able to, you know, once a weekend connect up with some buddies and easily play a great game.

107
00:23:05,000 --> 00:23:09,000
No matter if I'm at home or on the road with my laptop.

108
00:23:09,000 --> 00:23:12,000
Yeah, yeah, that would be I mean, that's the dream, right?

109
00:23:12,000 --> 00:23:18,000
Where you own your game content or you license it rather from wherever you are and you can play it wherever you are.

110
00:23:18,000 --> 00:23:25,000
Yeah. And that is a big shift. And I mean, from the you know, from the open source side, from all of that, none of that makes me super happy.

111
00:23:25,000 --> 00:23:30,000
I will be the first to admit, but it's not like we'd made we haven't made that much progress there anyway.

112
00:23:30,000 --> 00:23:38,000
You know, a lot of popular online games all are proprietary anyway and rely on proprietary back end services to really function, at least many of them.

113
00:23:38,000 --> 00:23:47,000
I did see some pretty humorous remarks, though, like noting, oh, yes, well, with Project Stadia, finally, single player games will have lag too.

114
00:23:47,000 --> 00:23:49,000
That's savage. Yeah.

115
00:23:49,000 --> 00:23:59,000
The other thing I wanted to note is I've seen some discussion about like the new executives they brought on for this and sort of their approach because it's it does seem like there are pushing

116
00:23:59,000 --> 00:24:06,000
or are getting ready to push maybe some, you know, Stadia focused content, kind of Netflix style with original programming.

117
00:24:06,000 --> 00:24:15,000
Yeah. And I wonder how that's going to work because that rather than focusing on, you know, just bringing all the sort of, you know, existing big, big titles over,

118
00:24:15,000 --> 00:24:19,000
it seems like they are going to be focused on content, not just platform.

119
00:24:19,000 --> 00:24:28,000
Yeah, I don't know how that's going to work. I mean, I think for developers, the opportunity here is can you be one of the early indie developers on Stadia that gets featured?

120
00:24:28,000 --> 00:24:35,000
Right? Because you know, Google, if they're smart, is going to be looking to feature a few indie developers.

121
00:24:35,000 --> 00:24:39,000
Again, I know that's a very crass kind of droll way to look at this.

122
00:24:39,000 --> 00:24:42,000
But right now you have to do a little bit of hoop jumping to get started.

123
00:24:42,000 --> 00:24:46,000
You've got to, you know, actually sort of have a business basically.

124
00:24:46,000 --> 00:24:51,000
And no, Google won't accept an at Gmail email address to register.

125
00:24:51,000 --> 00:24:52,000
Nope.

126
00:24:52,000 --> 00:24:55,000
Which I thought was just a little bit amusing.

127
00:24:55,000 --> 00:25:01,000
I thought it was great myself. But so, Wes, I hear you hate Rust.

128
00:25:01,000 --> 00:25:04,000
No, Mike. Come on. Don't be dramatic.

129
00:25:04,000 --> 00:25:09,000
So we'd seen some stuff floating around. I mean, you know, you've been you've been hyping up Rust here on the show.

130
00:25:09,000 --> 00:25:13,000
You keep sending me links about it, which is great and appreciated.

131
00:25:13,000 --> 00:25:16,000
Oh, now who's being dramatic? OK, keep going.

132
00:25:16,000 --> 00:25:24,000
Recently, that old there was an old clip of Linus talking about C and how great it is kind of resurfaced and floated around.

133
00:25:24,000 --> 00:25:32,000
And I was also recently watching a good video by the always entertaining, whether you like him or not, Mr. Brian Cantrell,

134
00:25:32,000 --> 00:25:39,000
talking about sort of really it's like a history of operating systems with a little bit about Rust and where it might fit.

135
00:25:39,000 --> 00:25:45,000
And I think there is rightly good pressure to be like, we should write lots of things in Rust now because, you know,

136
00:25:45,000 --> 00:25:51,000
there is additional safety that we can get and we keep seeing incorrect C programs.

137
00:25:51,000 --> 00:25:54,000
So I thought it'd be interesting maybe just to talk about a little bit.

138
00:25:54,000 --> 00:26:03,000
And actually, just today, Drew DeVault, the creator of so many things, but Sway primarily, which just had a 1.0 release.

139
00:26:03,000 --> 00:26:11,000
He's doing lots of Wayland stuff these days. He had a blog post titled Rust is not a good C replacement.

140
00:26:11,000 --> 00:26:18,000
So I thought maybe we could go through this, think about a little bit and consider, especially as you start ramping up on Rust.

141
00:26:18,000 --> 00:26:24,000
Yeah. So walk me through what is like, what are the arguments why Rust is not a good replacement for, say, C?

142
00:26:24,000 --> 00:26:33,000
And I just want to put a pause on this. When he says C, does he mean C proper or like C++ slash ob C as well?

143
00:26:33,000 --> 00:26:35,000
OK, no one means ob C, but C++.

144
00:26:35,000 --> 00:26:38,000
Yeah, I was going to say no one. No one means objective C, Mike. Come on.

145
00:26:38,000 --> 00:26:43,000
No, we're really there's a distinction here. And actually, he starts with that right at the top.

146
00:26:43,000 --> 00:26:51,000
I have a saying that summarizes my opinion of Rust compared to Go. Go is the result of C programmers designing a new programming language.

147
00:26:51,000 --> 00:26:56,000
And Rust is the result of C++ programmers designing a new programming language.

148
00:26:56,000 --> 00:27:02,000
This isn't just a metaphor. Go was designed by a lot of Plan 9 alumni, an operating system written in C.

149
00:27:02,000 --> 00:27:09,000
And Rust was designed by the folks at Mozilla, whose flagship product is one of the largest C++ code bases in the world.

150
00:27:09,000 --> 00:27:20,000
And here's where here's, I think, part of the main point. The values of good C++ programmers are incompatible with the values of good C programmers.

151
00:27:20,000 --> 00:27:29,000
So Rust may be a decent C++ replacement if you have the same goals as C++. But if you don't, the design has some drawbacks.

152
00:27:29,000 --> 00:27:37,000
OK, so there's so much here. One, I have to be a troll. No one hates C++ programmers more than C programmers.

153
00:27:37,000 --> 00:27:45,000
It's just, you know. That does seem to be true. And everybody hates the two of them. They're called objective C programmers.

154
00:27:45,000 --> 00:27:54,000
What does he feel are the values of C++? In your estimation?

155
00:27:54,000 --> 00:27:59,000
Well, both Rust and C++ are sort of kitchen sink programming languages.

156
00:27:59,000 --> 00:28:08,000
And, you know, they solve a lot of problems and they have a lot of language features. So I think part of it is just sort of the simplicity of C.

157
00:28:08,000 --> 00:28:21,000
And you do kind of see that, too, like in the kernel development community for Linux, kind of avoidance of some C features that aren't deemed simple enough or too complicated or perhaps based on overhead as well.

158
00:28:21,000 --> 00:28:30,000
So there is sort of this, you can get a core subset of C. And so some of the other stuff here, obviously C's not changing that much.

159
00:28:30,000 --> 00:28:37,000
Whereas if you look at Rust, obviously it's being very actively developed. A Rust program written last year may already look outdated.

160
00:28:37,000 --> 00:28:44,000
Whereas a C program written 10 years ago has pretty good odds of being just fine. And of course, you know, styles and other things might change.

161
00:28:44,000 --> 00:28:47,000
But by and large, you can probably at least get it to compile.

162
00:28:47,000 --> 00:29:01,000
Could we safely say that C is a more conservative language and C++ and by extension, therefore, its child Rust are a little more, would you say, cutting edge, bleeding edge?

163
00:29:01,000 --> 00:29:08,000
Yeah, I mean, I think so, right? I mean, if you think about C++, there's a lot going on. It's pretty complicated. I'm no expert C++ programmer by any extent.

164
00:29:08,000 --> 00:29:14,000
And there's just a lot of stuff I've never touched in the language because there's just a lot of stuff in the language.

165
00:29:14,000 --> 00:29:27,000
And C, I mean, it certainly takes time to learn C, but I think a lot of that is just because it's so, you know, it's relatively close, not really to the real metal of today, but close to the metal of the sort of old computer that we approximate it on.

166
00:29:27,000 --> 00:29:33,000
So you have to learn a lot about that and memory management, but you learn the core constructs of the language.

167
00:29:33,000 --> 00:29:40,000
Sure, C in particular has a lot of weird edge cases there, but you learn the core constructs pretty fast.

168
00:29:40,000 --> 00:29:51,000
So I don't know, I think this is maybe an argument that not that, you know, Rust isn't good or Rust doesn't fit in many places and not that Rust can't do C things, right?

169
00:29:51,000 --> 00:29:57,000
We've already seen many embedded tools and tool sets start to get Rust support or improved Rust support.

170
00:29:57,000 --> 00:30:04,000
Rust does have pretty good, you know, list of supported targets for a new language because they leverage LLVM on the backside.

171
00:30:04,000 --> 00:30:12,000
But C is always going to be, maybe not always, for now, C is still like the first language you port to a machine or an architecture when you bootstrap it.

172
00:30:12,000 --> 00:30:19,000
It's the thing that you get going. It is often the thing that, you know, serves as an intermediate representation sometimes.

173
00:30:19,000 --> 00:30:27,000
It's just the simple supported thing. And you kind of have a little bit of free rein.

174
00:30:27,000 --> 00:30:33,000
You have a consistent and stable API. You don't have to use a particular build tool or anything like that.

175
00:30:33,000 --> 00:30:39,000
You get a lot of choice. And I don't want that. I don't think you should use that for any sort of necessarily high level language.

176
00:30:39,000 --> 00:30:54,000
But perhaps, perhaps there's an argument that C has been refined enough and polished enough in some particular low level use cases, perhaps operating system development, perhaps other other such embedded applications,

177
00:30:54,000 --> 00:31:00,000
that there are ergonomics for experienced C developers that make it better than Rust.

178
00:31:00,000 --> 00:31:07,000
So if you don't mind, I'm just going to jump to the hottest take in this in this article here.

179
00:31:07,000 --> 00:31:22,000
And I'm quoting now, concurrency is generally a bad thing. Serial programs have X problems and parallel programs have X to Y problems, where Y is the amount of parallelism you introduce.

180
00:31:22,000 --> 00:31:37,000
So, you know, I've read through this earlier today. It seems to me that this article is basically making the argument that we have gone in our language design, particularly in Rust, too far towards accommodating parallelism.

181
00:31:37,000 --> 00:31:39,000
And I'll drop it there. What would you say to that?

182
00:31:39,000 --> 00:31:46,000
Yeah, I mean, concurrency is definitely difficult. There are times, you know, you can often we should be careful what we're talking about.

183
00:31:46,000 --> 00:31:51,000
So he talks about concurrency and obviously that's different than parallel.

184
00:31:51,000 --> 00:31:55,000
Right. To be fair, he uses them interchangeably. Right. So I directly quoted him.

185
00:31:55,000 --> 00:32:05,000
Yeah, that's that's fair. I do think with better languages and so not speaking from to Rust specifically here, but like thinking about Clojure, for instance, in my own life.

186
00:32:05,000 --> 00:32:12,000
Yes, usually, you know, any any sort of parallelism. Well, really, really concurrency.

187
00:32:12,000 --> 00:32:23,000
It's going to make your program more complicated most of the time, but you can there are tools that can make it not nearly that sort of a nightmare. And we have parallel machines now.

188
00:32:23,000 --> 00:32:28,000
So in that respect, we should be thinking about that if we have, you know, if we want our programs to run well.

189
00:32:28,000 --> 00:32:34,000
And so, like when you look at Java has some really nice, you know, concurrent data structures now.

190
00:32:34,000 --> 00:32:44,000
But when you're trying to design some Java program with like threads and locks, that's super unpleasant. And it's hard to get right. Right. There are a whole books about how to do that well.

191
00:32:44,000 --> 00:32:47,000
And when you switch to Clojure, you just don't think about it anymore.

192
00:32:47,000 --> 00:32:51,000
Well, it's hard because it's probably the wrong thing.

193
00:32:51,000 --> 00:33:04,000
Like and this is not me shilling for.NET Foundation at all, but like in.NET, if you are parallel or you want to be, I prefer the word concurrent as well, Wes, but I'm just using the language of the article.

194
00:33:04,000 --> 00:33:15,000
Dropping into C and I'm sorry, dropping into F sharp, C sharp, just by the design of the language will help you avoid many of the concurrency issues that you would have had in C sharp.

195
00:33:15,000 --> 00:33:26,000
And in the Java space, because I used to do a lot of Java place, you have obviously Java. And this is just putting it back in time. This is before Kotlin existed. So we had Java and Scala. Right.

196
00:33:26,000 --> 00:33:43,000
So I would say like where you have C sharp, you have Java, where you have Scala, you kind of have F sharp. F sharp is a much more dramatic shift from C sharp in terms of being more concurrency friendly than Java than Scala is. Right.

197
00:33:43,000 --> 00:33:51,000
I mean, Scala kind of straddles that middle ground where it can be a souped up Java or it can be like a junior Haskell. So whereas F sharp is a little more.

198
00:33:51,000 --> 00:34:02,000
Right. So can I just can I swing the Coderadio episode one hammer? Do it. Yes. And say there are different languages that are designed to solve different problems.

199
00:34:02,000 --> 00:34:16,000
If you are writing a simple program, a non concurrency focused language, a non parallelism to use his words language is a good solution because you just want to get something done. God damn. Right.

200
00:34:16,000 --> 00:34:22,000
There's something wrong with just getting something done. Like I am not I am not a priestess of Haskell over here. Right. I mean, it's the same thing.

201
00:34:22,000 --> 00:34:32,000
Like you can write if you're you know, you need to bang out a quick 50, 100 line Python script. OK, maybe that makes the most sense because you got it done really easy. You didn't have to write a whole bunch of cook. You just you just write your thing.

202
00:34:32,000 --> 00:34:43,000
But that may not be the same thing you want for writing the software that runs on a pacemaker or, you know, is scheduling real time events or like flies a drone, for example.

203
00:34:43,000 --> 00:34:54,000
You may want something a little more parallel, a little more stateless. And that I think the the key that this guy misses, which actually I like this article.

204
00:34:54,000 --> 00:35:01,000
But for this point, I would argue it's not C or C plus plus. It's not C sharp or F sharp.

205
00:35:01,000 --> 00:35:10,000
It's both in the same program, depending on what the need of the module or library, whatever term you choose to give is.

206
00:35:10,000 --> 00:35:20,000
I think you're right about that. It is interesting to you. I'd like to before we get out of this article to talk about, you know, he does say, yes, Rust is more safe. I don't really care.

207
00:35:20,000 --> 00:35:30,000
I suppose for your own work, that's true. I, for one, welcome more things being written in languages that have more tools for verifying memory safety and reasoning about it.

208
00:35:30,000 --> 00:35:46,000
You know, Rust has really taken some stuff that was previously academic research and translated it into useful constructs. And so maybe a lot of his argument, I think, too, and sort of says this at the end, the kitchen sink approach doesn't work.

209
00:35:46,000 --> 00:35:51,000
And I don't I don't know if that's necessarily true. I'm not sure I agree with that. Yeah.

210
00:35:51,000 --> 00:36:06,000
So you may or yeah, people may or may not agree with that. But I think Rust is useful in its own light for pushing these safety things. So perhaps, you know, perhaps there will be another language that takes some of the stuff from go and rust and C and combines it to a more focused hybrid.

211
00:36:06,000 --> 00:36:11,000
But it will probably port the way you know, at least some of the techniques Rust has been using to handle memory.

212
00:36:11,000 --> 00:36:24,000
Yeah, again, I mean, I don't mean to repeat myself, but like, you know, I have been learning Rust and I will tell you, I am never going to write a Rust script or a little Rust program to do something for me because it's too much of a pain in the ass to deal with all the rules.

213
00:36:24,000 --> 00:36:38,000
Right. And I'm ignoring the unsafe keyword or whatever here. I'll do I'll continue to do those kind of things in Ruby or Python. I'm taking actually I'm doing the Linux Academy course on Python scripting right now.

214
00:36:38,000 --> 00:36:52,000
Oh, is that right? That's true, because I'm trying to see, you know, I have a whole pile of Ruby scripts that are kind of on Ruby 1.9. Obviously, that's way out of date for the Ruby world. We're on like 2.5, I think.

215
00:36:52,000 --> 00:37:03,000
Correct me if I'm wrong chat room, but I think it's 2.5 something. And more and more I'm thinking, you know, it's time to sharpen the little Python I've done into something more useful.

216
00:37:03,000 --> 00:37:14,000
But again, both Ruby and Python, for all Wes hates Ruby because, you know, he's a hater. Hey, hey, hey, now that's a little bit strong. I had to go for the kidney punch there. Yeah, OK, that's fair. I deserve it.

217
00:37:14,000 --> 00:37:20,000
Both Ruby and Python compared to Rust are extremely loose languages, right? They're scripting languages effectively.

218
00:37:20,000 --> 00:37:37,000
I would never write a script to process, you know, somebody's Excel file or some, you know, some directory of, you know, some tar GZ of images someone sent me in Rust. I mean, that's just torture. I would do it in Ruby or I do it in Python.

219
00:37:37,000 --> 00:37:41,000
Or if I'm sad and depressed and drunk, I do it on Objective C.

220
00:37:41,000 --> 00:37:50,000
No, that's that is a good point, right? We do. I mean, we we have multiple programming languages. Yes, there is a burden sometimes to adding a new, you know, a new language to a project.

221
00:37:50,000 --> 00:37:56,000
But when when they have specific focuses or, you know, you have multiple needs within a project, sometimes that's the right answer.

222
00:37:56,000 --> 00:38:01,000
And actually back to go way back to the beginning and talk about Go, I think that's been true to like this.

223
00:38:01,000 --> 00:38:05,000
I've seen a number of people working for, you know, Python shops or had a lot of Python code.

224
00:38:05,000 --> 00:38:23,000
Some of that stuff, maybe the more performance sensitive stuff or real time or network stuff that got ported, but you might not port some of your, you know, higher level stuff where you're just crunching a little numbers or outputting something really quick in a short script because it's just not worth the effort and you don't need the extra guarantees somewhere at the time.

225
00:38:23,000 --> 00:38:28,000
Right. If you run a script once a quarter, does it really matter?

226
00:38:28,000 --> 00:38:36,000
I mean, you know, and I'm going to throw the age gauntlet down here. Once you hit a certain age, you realize, you know, there was a perfect language.

227
00:38:36,000 --> 00:38:46,000
It was called Objective C, but times change. And, you know, in your Objective C, maybe hell, it could be V basic, right? It could be V.

228
00:38:46,000 --> 00:38:50,000
You could be a real basic developer, which means you're not a developer.

229
00:38:50,000 --> 00:39:04,000
Blow blow. But, like, you have to move on. You have to, you know, I've been doing this for 12 years now, 13 years. I don't know. I'll actually have to do some math later.

230
00:39:04,000 --> 00:39:13,000
But and that's professional work. And I got to tell you, I change languages more than I change underwear. Now, granted, I sleep on the couch most nights, but you get what I'm getting at.

231
00:39:13,000 --> 00:39:17,000
You change languages approximately as often as you get new laptops, it seems like.

232
00:39:17,000 --> 00:39:23,000
Well, no, I get more laptops. By the way, the Darter Pro, new record, three months.

233
00:39:23,000 --> 00:39:27,000
Congratulations. I think you finally matured into an adult.

234
00:39:27,000 --> 00:39:31,000
I know. I don't, like, put martinis on my laptops anymore.

235
00:39:31,000 --> 00:39:37,000
Yeah, you just get like a nice little, you know, get a nice martini holder section dedicated. Martinis deserve that.

236
00:39:37,000 --> 00:39:41,000
I'm in Florida. I just put it on the nose of the alligator.

237
00:39:41,000 --> 00:39:47,000
Yeah, that's lovely. I do like your sentiment, though. I think you hit it right there. Choose your choose your tools.

238
00:39:47,000 --> 00:39:58,000
I think this applies to all kinds of stuff, not only just like programming languages, but development practices, workflow techniques, project management, even just, you know, are you doing how are you managing your time?

239
00:39:58,000 --> 00:40:02,000
Are you using Pomodoro or just doing bigger, longer sprints?

240
00:40:02,000 --> 00:40:16,000
You have to think about all of those because it's all going to change on whatever your type of work you're doing. And that might be very different whether you're doing high level planning or architecture or really trying to implement some low level Rust code.

241
00:40:16,000 --> 00:40:27,000
That's a lot to think about, though. So maybe we should take a break because I kind of want to take a nap and then I might go play with Rust some more or just start thinking about my tooling.

242
00:40:27,000 --> 00:40:32,000
And I think you, Mr. Dominic, you should probably go finish some more of that Python course.

243
00:40:32,000 --> 00:40:36,000
Oh, yes. I feel the constriction of the snake.

244
00:40:36,000 --> 00:40:46,000
Yeah, that's right. I am pretty excited that Linux Academy has that course available now and we'll have a link in the show notes if you'd like to take it because it's a really great introduction.

245
00:40:46,000 --> 00:40:55,000
I've actually recommended it to a couple of people who are just kind of getting started with programming and they learned a little bit of Java at their, you know, the university course.

246
00:40:55,000 --> 00:41:07,000
And I think this is a good mix of teaching you the basics of Python. And if you're just coming up and programming, it's not going to be way over your head partially because it's Python and it's just really well laid out.

247
00:41:07,000 --> 00:41:12,000
So you can get up to speed quickly if you already do, like Mr. Dominic, know some programming languages.

248
00:41:12,000 --> 00:41:13,000
Only a few.

249
00:41:13,000 --> 00:41:26,000
You can, of course, also find the rest of everything we talked about today linked in our show notes. That's going to be coder dot show slash three five zero coder dot show slash contact for ways to get in touch with us.

250
00:41:26,000 --> 00:41:33,000
And head on over to Jupiter broadcasting dot com if you'd like to find all the other fine shows on the network.

251
00:41:33,000 --> 00:41:44,000
Plus, so you don't miss any. I mean, subscribe to the RSS feeds in whatever podcast player you use. That's just the easiest way. But also you can follow at Jupiter signal on Twitter.

252
00:41:44,000 --> 00:41:53,000
I'm there, too. I'm at West Paine. And Mr. Dominic, I can never remember yours. So I make you say it. You're at Dumanuco on Twitter.

253
00:41:53,000 --> 00:42:18,000
Thank you all for joining us today. It's been lots of fun. Come join us next week for another episode of Coder Radio.


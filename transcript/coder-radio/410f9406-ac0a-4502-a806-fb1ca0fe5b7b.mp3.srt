1
00:00:00,000 --> 00:00:07,000
This is Koda Radio, episode 371, for August 19th, 2019.

2
00:00:31,000 --> 00:00:46,000
Hello and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business of software development and related technologies.

3
00:00:46,000 --> 00:00:51,000
My name is Wes, and of course, I'm joined by Mike. Welcome, Mike.

4
00:00:51,000 --> 00:00:53,000
Mr. Here, round two, Wes!

5
00:00:53,000 --> 00:00:59,000
Oh no, no, it's Jar Jar. I didn't plan for this. Where's Mike? What have you done with Mike, Jar Jar?

6
00:00:59,000 --> 00:01:01,000
I put him back in the legacy bin.

7
00:01:01,000 --> 00:01:05,000
Oh, okay. Well, never mind. Never mind. That's fine. That's where he belongs.

8
00:01:05,000 --> 00:01:08,000
All right. How are you, Wes, now that I'm back?

9
00:01:08,000 --> 00:01:12,000
Get out of here. Stop licking the floor. What are you doing?

10
00:01:12,000 --> 00:01:14,000
Yeah, he's pretty gross, but...

11
00:01:14,000 --> 00:01:17,000
He understands Koda Radio comes first, of course.

12
00:01:17,000 --> 00:01:24,000
Oh, I'm doing great. I'm excited to talk about something a little more abstract today.

13
00:01:24,000 --> 00:01:35,000
But before we do, let's get into some feedback. We got an email from our friend, Bob, who wanted to write to us a little bit about your adventures with Clojure.

14
00:01:35,000 --> 00:01:39,000
Thanks for the great show. I'm really enjoying the Seven Languages segment.

15
00:01:39,000 --> 00:01:47,000
I just wanted to share with Mike that if he's looking for a good free resource for Clojure, check out Clojure for the Brave and True.

16
00:01:47,000 --> 00:01:51,000
You can read it online for free or by the book.

17
00:01:51,000 --> 00:01:57,000
You might also want to check out Living Clojure by Karen Meyer and Getting Clojure by Russ Olson.

18
00:01:57,000 --> 00:02:02,000
And I'll just say here myself, those are all great resources.

19
00:02:02,000 --> 00:02:07,000
I have to say, a few people recommended Clojure for the Brave and True, and it looks very cool.

20
00:02:07,000 --> 00:02:14,000
I'm going to pick it up because, you know, I feel like not knowing a Lisp at all is just a big gap.

21
00:02:14,000 --> 00:02:22,000
And what's nice about that book is it's very approachable. All the examples are very fun and get you coding right away.

22
00:02:22,000 --> 00:02:29,000
It was a little less, in air quotes here, academic than the sort of thing I wanted personally.

23
00:02:29,000 --> 00:02:34,000
So it wasn't my favorite, but I've recommended it to other people who just really love it.

24
00:02:34,000 --> 00:02:37,000
So it's definitely worth checking out.

25
00:02:37,000 --> 00:02:39,000
Bob continues.

26
00:02:39,000 --> 00:02:48,000
At the end of the last show, you mentioned that you had to take some time to think about the code that you were writing in Clojure before you started to code.

27
00:02:48,000 --> 00:02:59,000
I know you may have found this frustrating, but I also think that part of writing good Clojure code is taking the time to think through the problem that you're attempting to solve.

28
00:02:59,000 --> 00:03:04,000
Thinking about the problem could take the form of leveraging the REPL to work out code to solve a problem.

29
00:03:04,000 --> 00:03:12,000
Or you could spend some time away from your computer screen, or in hammock time, working out problems.

30
00:03:12,000 --> 00:03:21,000
If I've learned anything from Clojure's creator, Rich Hickey, it's programming is not about typing. It's about thinking.

31
00:03:21,000 --> 00:03:26,000
Also, in reference to what Mike said about talking more about Lisp and its influences on programming,

32
00:03:26,000 --> 00:03:34,000
two interesting Lisp-slash-scheme languages you might check out are Racket and Extempore.

33
00:03:34,000 --> 00:03:40,000
I've not played with the latter, but Racket is definitely worth looking at if you just want to use a modern scheme.

34
00:03:40,000 --> 00:03:46,000
All right, well that all sounds great. Yeah, I'm definitely looking to look more into Lisp, just to kind of fill that hole.

35
00:03:46,000 --> 00:03:50,000
Yeah, I agree. Yeah, that's fair.

36
00:03:50,000 --> 00:03:54,000
We'll see. Maybe you'll make a Clojure convert out of me yet, Wes.

37
00:03:54,000 --> 00:03:59,000
We'll have links to the handy things Bob linked to us, and I will also say,

38
00:03:59,000 --> 00:04:03,000
thinking more and typing less is something we could all do better at.

39
00:04:03,000 --> 00:04:06,000
Very true. Very true.

40
00:04:06,000 --> 00:04:10,000
Moving right along, a story I wanted to check back in on.

41
00:04:10,000 --> 00:04:16,000
A few weeks ago, we talked about the surprising proof of the sensitivity conjecture.

42
00:04:16,000 --> 00:04:24,000
And I happened to notice a little update over in the comments on Scott Aaronson's blog post about that proof.

43
00:04:24,000 --> 00:04:34,000
Well, no one else but famous Don Knuth showed up to present an even simpler version he'd made after reading the proof,

44
00:04:34,000 --> 00:04:37,000
seeing a couple other suggestions from people in the comments there.

45
00:04:37,000 --> 00:04:44,000
He distilled that all down, and instead of a two-page proof, well, now it's one page.

46
00:04:44,000 --> 00:04:47,000
What can you say to that other than Knuth is key?

47
00:04:47,000 --> 00:04:53,000
Yeah, I just think it's great to see, you know, he's contributed so much to computer science.

48
00:04:53,000 --> 00:04:58,000
And a commenter over on Hacker News, I think, put it really well.

49
00:04:58,000 --> 00:05:01,000
Note what Knuth has done here.

50
00:05:01,000 --> 00:05:05,000
He's taken a published paper, understood it well, thought hard about it,

51
00:05:05,000 --> 00:05:11,000
and come up with what he feels is the best way to present this result.

52
00:05:11,000 --> 00:05:17,000
And this has been his primary activity all his life with the art of computer programming.

53
00:05:17,000 --> 00:05:25,000
Every page is full of results from the research literature that Knuth has often understood better than even the original authors

54
00:05:25,000 --> 00:05:30,000
and presented in a great and uniform style.

55
00:05:30,000 --> 00:05:33,000
He's basically digested the entire computer science literature,

56
00:05:33,000 --> 00:05:38,000
passed it through his personal interestingness filter, and presented it as something interesting.

57
00:05:38,000 --> 00:05:40,000
And that's what he's doing here too.

58
00:05:40,000 --> 00:05:42,000
And I think it's just an interesting reflection.

59
00:05:42,000 --> 00:05:49,000
I think we think a lot about produced work, but thinking is work too.

60
00:05:49,000 --> 00:05:53,000
And oftentimes, even if you're not the original researcher,

61
00:05:53,000 --> 00:05:59,000
being able to look at multiple people's work, distill things, summarize it, improve, refine,

62
00:05:59,000 --> 00:06:02,000
there's kind of multiple roles there.

63
00:06:02,000 --> 00:06:07,000
Some people really excel at just banging code out, getting the first implementation done,

64
00:06:07,000 --> 00:06:13,000
and others excel at taking existing code and tweaking it and refining it and making it better.

65
00:06:13,000 --> 00:06:15,000
And there's value in all those roles.

66
00:06:15,000 --> 00:06:16,000
Yeah, I agree.

67
00:06:16,000 --> 00:06:22,000
I mean, and also what struck me about this is kind of the open-sourcy spirit of this, right?

68
00:06:22,000 --> 00:06:28,000
That another, I won't say academic, but another researcher into the field,

69
00:06:28,000 --> 00:06:32,000
I don't know if he is an academic, I don't know why I wouldn't say that.

70
00:06:32,000 --> 00:06:34,000
Yeah, that's a distinction without a difference.

71
00:06:34,000 --> 00:06:38,000
He published a paper, it was fundamentally sound,

72
00:06:38,000 --> 00:06:43,000
Knuth saw that he could make it better, contributed back the changes.

73
00:06:43,000 --> 00:06:47,000
Is that not the spirit of, let's say, the GPL or hell, even the,

74
00:06:47,000 --> 00:06:50,000
I mean, I know the BSC is a bad example because people can take it away,

75
00:06:50,000 --> 00:06:52,000
but a free software open-source ethos,

76
00:06:52,000 --> 00:06:55,000
is that not the spirit of the whole plan we're trying to do here?

77
00:06:55,000 --> 00:06:57,000
No, it very much is.

78
00:06:57,000 --> 00:07:00,000
And I think there are many kindred spirits and principles

79
00:07:00,000 --> 00:07:04,000
between academia at its best and open-source at its best.

80
00:07:04,000 --> 00:07:10,000
Unfortunately, you know, this is coder radio and we can't be all positive.

81
00:07:10,000 --> 00:07:12,000
That's never going to work.

82
00:07:12,000 --> 00:07:14,000
Especially me, I mean, I could try.

83
00:07:14,000 --> 00:07:17,000
You could try, but you've already failed for this episode

84
00:07:17,000 --> 00:07:22,000
because you wanted to talk about something that I'm sure we've all been frustrated with.

85
00:07:22,000 --> 00:07:27,000
And it sounds like you've got a particular example that motivated this whole discussion.

86
00:07:27,000 --> 00:07:31,000
What we're talking about here are leaky abstractions.

87
00:07:31,000 --> 00:07:35,000
You know, I think the best way just to approach this is real quick,

88
00:07:35,000 --> 00:07:38,000
make sure we define what an abstraction is, right,

89
00:07:38,000 --> 00:07:41,000
before I dive into my little war story here.

90
00:07:41,000 --> 00:07:45,000
And I'm going to give my definition, other people have,

91
00:07:45,000 --> 00:07:49,000
including Joel Olson, not Joel Olson, that's very different,

92
00:07:49,000 --> 00:07:53,000
Joel Spolsky, have defined it and talked about it in greater depth.

93
00:07:53,000 --> 00:07:55,000
We have links to all that in the show notes.

94
00:07:55,000 --> 00:07:59,000
But Wes, would you agree with the definition of a leaky abstraction is

95
00:07:59,000 --> 00:08:08,000
an attempt in a piece of software to kind of fluff away complications in implementation details

96
00:08:08,000 --> 00:08:11,000
and give you a nice interface to other functionality

97
00:08:11,000 --> 00:08:15,000
or running on different operating systems or interacting with different services.

98
00:08:15,000 --> 00:08:18,000
Is that a fair working definition?

99
00:08:18,000 --> 00:08:21,000
Right, and we're just talking about abstraction in general here,

100
00:08:21,000 --> 00:08:24,000
or at least in the common programming sense.

101
00:08:24,000 --> 00:08:27,000
Right, we're purely talking about software engineering here, right.

102
00:08:27,000 --> 00:08:32,000
So I really don't want to make you this happy today, Wes,

103
00:08:32,000 --> 00:08:36,000
because you know what, you just hate Rails.

104
00:08:36,000 --> 00:08:41,000
And it is indeed in Rails, this leaky abstraction.

105
00:08:41,000 --> 00:08:43,000
I see, yeah, okay.

106
00:08:43,000 --> 00:08:46,000
I do think I like your definition.

107
00:08:46,000 --> 00:08:50,000
You know, oftentimes abstractions lift things to a higher level

108
00:08:50,000 --> 00:08:54,000
and, you know, remove some unnecessary details.

109
00:08:54,000 --> 00:08:58,000
You know, oftentimes it's about finding the sort of same thing

110
00:08:58,000 --> 00:09:00,000
or ways that you can have very similar behavior

111
00:09:00,000 --> 00:09:05,000
and not have to worry about what's different at least most of the time, right.

112
00:09:05,000 --> 00:09:08,000
I'm thinking about, you know, a common example might be implementing

113
00:09:08,000 --> 00:09:13,000
a common operation across all kinds of data structures, right.

114
00:09:13,000 --> 00:09:16,000
As long as the performance characteristics are roughly the same,

115
00:09:16,000 --> 00:09:17,000
you don't have to care, right.

116
00:09:17,000 --> 00:09:21,000
As long as you can say, like, hey, I want to add this thing to your structure.

117
00:09:21,000 --> 00:09:23,000
I don't care how you do it.

118
00:09:23,000 --> 00:09:27,000
You cover that up for me, and I'll just walk away

119
00:09:27,000 --> 00:09:30,000
and have a simple interface to understanding this.

120
00:09:30,000 --> 00:09:35,000
So I had a project that uses very large files.

121
00:09:35,000 --> 00:09:37,000
I think I mentioned it in passing a few times,

122
00:09:37,000 --> 00:09:39,000
a lot of ColorobiJs and STL files.

123
00:09:39,000 --> 00:09:41,000
Oh, this is the STL project, I see.

124
00:09:41,000 --> 00:09:48,000
Yes, and it is being deployed to AWS using S3 for storage.

125
00:09:48,000 --> 00:09:50,000
Pretty standard, right?

126
00:09:50,000 --> 00:09:53,000
Nothing controversial there, I would say.

127
00:09:53,000 --> 00:09:57,000
Well, to be clear here, right, you're also, it's running on AWS

128
00:09:57,000 --> 00:10:00,000
and then you're storing large files remotely onto,

129
00:10:00,000 --> 00:10:04,000
I mean, it's still within AWS, whatever, but onto the S3 service.

130
00:10:04,000 --> 00:10:08,000
And then you're having some library here, I assume, or a part of Rails

131
00:10:08,000 --> 00:10:11,000
that's kind of making that somewhat transparent?

132
00:10:11,000 --> 00:10:13,000
Right, so Active Storage, which is a part of Rails,

133
00:10:13,000 --> 00:10:17,000
but you do have to install a gem.

134
00:10:17,000 --> 00:10:22,000
Basically, Active Storage is a file storage and retrieval solution

135
00:10:22,000 --> 00:10:24,000
that's meant, it's really meant for large files,

136
00:10:24,000 --> 00:10:26,000
but a lot of people use it just for everything

137
00:10:26,000 --> 00:10:28,000
because it's relatively easy to use.

138
00:10:28,000 --> 00:10:31,000
And it abstracts away the file store you're using.

139
00:10:31,000 --> 00:10:35,000
So for instance, the basic, you know, 500-word blog post version of it,

140
00:10:35,000 --> 00:10:37,000
you're going to see how to use Active Storage,

141
00:10:37,000 --> 00:10:42,000
it's just saving things to like var slash Rails, whatever, right?

142
00:10:42,000 --> 00:10:45,000
Or like Rails slash storage, and that's it.

143
00:10:45,000 --> 00:10:48,000
Ah, right, just dumping it, whatever, on the local machine.

144
00:10:48,000 --> 00:10:54,000
It will work with AWS S3 as your, the name of the solution escapes me,

145
00:10:54,000 --> 00:10:57,000
but their version of S3.

146
00:10:57,000 --> 00:11:02,000
Minio, which is key here, which Minio is an open source project.

147
00:11:02,000 --> 00:11:05,000
We've mentioned it years ago on the show that they do a lot more

148
00:11:05,000 --> 00:11:07,000
than they used to now, but the way I've been using them

149
00:11:07,000 --> 00:11:12,000
is they implement the S3 API, but you can run it locally.

150
00:11:12,000 --> 00:11:15,000
Ah, local S3.

151
00:11:15,000 --> 00:11:19,000
Is this only for testing or also for production use?

152
00:11:19,000 --> 00:11:21,000
No, Minio is a pretty robust production solution.

153
00:11:21,000 --> 00:11:25,000
So if you're concerned, like they have this whole AI pitch they're doing now,

154
00:11:25,000 --> 00:11:28,000
which I don't know a lot about, I haven't used them for anything like that.

155
00:11:28,000 --> 00:11:33,000
But if you're looking for file storage and you don't want to be external

156
00:11:33,000 --> 00:11:37,000
to your, let's say your intranet, or you just don't want an S3,

157
00:11:37,000 --> 00:11:40,000
but you want all the goodness that comes with S3,

158
00:11:40,000 --> 00:11:44,000
yeah, you can just set up a RAID array or whatever and you're good to go.

159
00:11:44,000 --> 00:11:48,000
I actually have people using it. It works great.

160
00:11:48,000 --> 00:11:52,000
So I thought, okay, because I need to test a lot of this stuff.

161
00:11:52,000 --> 00:11:55,000
These files are big. It takes a long time to load them in S3.

162
00:11:55,000 --> 00:12:00,000
It's also kind of expensive because of how AWS and S3 work.

163
00:12:00,000 --> 00:12:04,000
Let me just set up a Minio instance locally.

164
00:12:04,000 --> 00:12:08,000
And it's the same API calls, and it's all abstracted away by active storage,

165
00:12:08,000 --> 00:12:11,000
which when I first started using Minio, it wasn't.

166
00:12:11,000 --> 00:12:15,000
I used to actually have to use the AWS gem directly.

167
00:12:15,000 --> 00:12:19,000
So I get everything working.

168
00:12:19,000 --> 00:12:24,000
Now, there is a processing step I have to do with these files

169
00:12:24,000 --> 00:12:28,000
that I was using a method in active storage called Path4,

170
00:12:28,000 --> 00:12:31,000
which is pretty simple.

171
00:12:31,000 --> 00:12:35,000
On an active storage object, you can call Path4 and get a temporary file path,

172
00:12:35,000 --> 00:12:40,000
or I guess if you're storing locally in slash rails, it's a permanent file path.

173
00:12:40,000 --> 00:12:45,000
Ah, I see. And if it's not locally, then it's some layer on top there.

174
00:12:45,000 --> 00:12:48,000
Well, that's what I thought. I thought it was supposed to be.

175
00:12:48,000 --> 00:12:52,000
Turns out that is the case in some systems.

176
00:12:52,000 --> 00:12:56,000
In Minio, that is the case. In S3, it just fails.

177
00:12:56,000 --> 00:12:58,000
Really?

178
00:12:58,000 --> 00:13:01,000
Right. And because I was doing this on a background worker process,

179
00:13:01,000 --> 00:13:04,000
it doesn't 500 or anything. It just fails silently.

180
00:13:04,000 --> 00:13:09,000
So it works in testing, works on local host, fails in production.

181
00:13:09,000 --> 00:13:13,000
I'm seeing over at Minio here, they say,

182
00:13:13,000 --> 00:13:18,000
100% open source enterprise grade Amazon S3 compatible objects storage.

183
00:13:18,000 --> 00:13:22,000
It's interesting then that, you know, did something change?

184
00:13:22,000 --> 00:13:27,000
Not on Minio, but not on S3. And in theory, the API is the same, right?

185
00:13:27,000 --> 00:13:30,000
So the API is exactly the same. So the irony is,

186
00:13:30,000 --> 00:13:35,000
it's because of the abstraction in active storage, right?

187
00:13:35,000 --> 00:13:39,000
This method is an active storage, not in the AWS gem.

188
00:13:39,000 --> 00:13:41,000
I see.

189
00:13:41,000 --> 00:13:46,000
And it's funny, in the documents for 4Path on the Rails documentation,

190
00:13:46,000 --> 00:13:49,000
it doesn't mention that it doesn't work in a few of the sources.

191
00:13:49,000 --> 00:13:53,000
With stack overflow, can you see the whales of the desperate?

192
00:13:53,000 --> 00:13:55,000
Of course.

193
00:13:55,000 --> 00:13:58,000
Wondering why this worked on local host or on their whatever weird

194
00:13:58,000 --> 00:14:01,000
testing implementation that I had.

195
00:14:01,000 --> 00:14:06,000
Would they find, oh yeah, it just fails on S3 because Amazon doesn't let you do that.

196
00:14:06,000 --> 00:14:09,000
And they don't for good reasons, right? Security.

197
00:14:09,000 --> 00:14:12,000
But again, if it's an intranet, you don't care.

198
00:14:12,000 --> 00:14:15,000
So, okay.

199
00:14:15,000 --> 00:14:20,000
It took me about half a day to figure out what was going on there.

200
00:14:21,000 --> 00:14:24,000
Not to fix it, right? Because once I figured out what was going on,

201
00:14:24,000 --> 00:14:28,000
there's many solutions. Convert the file to a binary and do it that way.

202
00:14:28,000 --> 00:14:31,000
Yeah, what did the debugging process look like here?

203
00:14:31,000 --> 00:14:34,000
Because when you started, you probably didn't know where the error was happening.

204
00:14:34,000 --> 00:14:37,000
Well, I did what I always do. I roll back the deployment.

205
00:14:37,000 --> 00:14:40,000
I go to the testing environment and I'm like, okay, let me reproduce this.

206
00:14:40,000 --> 00:14:43,000
Spent a significant amount of time doing that.

207
00:14:43,000 --> 00:14:46,000
But again, you said, yeah, you couldn't, right? Because you're using Minio there.

208
00:14:46,000 --> 00:14:51,000
Right. So then I started adding more logging.

209
00:14:51,000 --> 00:14:55,000
Eventually, I was just, we can name drop some gems here.

210
00:14:55,000 --> 00:14:59,000
I was using another gem called Sucker Punch to do some backgrounding on these files.

211
00:14:59,000 --> 00:15:04,000
Sucker Punch basically is another abstraction on doing background processes in Rails.

212
00:15:04,000 --> 00:15:09,000
Turns out the logging on production did catch the error,

213
00:15:09,000 --> 00:15:14,000
but threw it as it didn't like completely error out. It just put it in the log.

214
00:15:14,000 --> 00:15:17,000
And too many things were happening. The log kept refreshing.

215
00:15:17,000 --> 00:15:22,000
So I had to search specifically for a background error.

216
00:15:22,000 --> 00:15:27,000
Eventually, once I had the error, I did what everybody does, right?

217
00:15:27,000 --> 00:15:30,000
I Googled it. Yep, that's exactly what it is.

218
00:15:30,000 --> 00:15:34,000
You can no longer do that in S3. I felt like you used to be able to,

219
00:15:34,000 --> 00:15:39,000
but most of my deployments are internal.

220
00:15:39,000 --> 00:15:44,000
A lot of them are using things like Minio or alternatives to that.

221
00:15:44,000 --> 00:15:49,000
So I was pretty shocked that the Rails documentation

222
00:15:49,000 --> 00:15:54,000
didn't actually say that that method doesn't work.

223
00:15:54,000 --> 00:15:59,000
It doesn't error out in your debugger. It just errors out in production.

224
00:15:59,000 --> 00:16:02,000
Which is always the worst kind of error.

225
00:16:02,000 --> 00:16:05,000
Because this path 4 is supposed to do whatever it needs to do

226
00:16:05,000 --> 00:16:08,000
for each different file hosting environment.

227
00:16:08,000 --> 00:16:10,000
And you don't need to care, as long as you have the credentials,

228
00:16:10,000 --> 00:16:12,000
as long as you have the keys and your environment variables,

229
00:16:12,000 --> 00:16:16,000
or however you want to do that. It doesn't matter.

230
00:16:16,000 --> 00:16:20,000
But there's just one thing in the S3 implementation of this

231
00:16:20,000 --> 00:16:23,000
that this one little piece of functionality doesn't work.

232
00:16:23,000 --> 00:16:26,000
Everything else works fine.

233
00:16:26,000 --> 00:16:30,000
And that is your abstraction leaking.

234
00:16:30,000 --> 00:16:34,000
What do you say, Wes? Is that a leaky abstraction, or do you think not?

235
00:16:34,000 --> 00:16:38,000
It's interesting, right? Because obviously you were using this

236
00:16:38,000 --> 00:16:42,000
active storage method because it was useful, right?

237
00:16:42,000 --> 00:16:45,000
And part of Rails.

238
00:16:45,000 --> 00:16:48,000
Right. And it was abstracting over things for you, right?

239
00:16:48,000 --> 00:16:54,000
How much more difficult was the workaround here?

240
00:16:54,000 --> 00:16:58,000
Is the abstraction still useful, or have you had to abandon it entirely

241
00:16:58,000 --> 00:17:02,000
because of this leak, or is it just sort of a minor leak that you patch up

242
00:17:02,000 --> 00:17:06,000
a little bit in the production case and have to make some modifications?

243
00:17:06,000 --> 00:17:09,000
Does it feel gross to you, what you've had to do to solve it?

244
00:17:09,000 --> 00:17:13,000
And are you still using that method everywhere?

245
00:17:13,000 --> 00:17:16,000
I'm still using active storage. In fact, this is going back to our feedback,

246
00:17:16,000 --> 00:17:18,000
think more, code less.

247
00:17:18,000 --> 00:17:21,000
The challenge was just figuring out where the abstraction was.

248
00:17:21,000 --> 00:17:24,000
Solving it was, I don't love the solution.

249
00:17:24,000 --> 00:17:28,000
It's basically temporarily throwing around binary data.

250
00:17:28,000 --> 00:17:30,000
But it works.

251
00:17:30,000 --> 00:17:33,000
And the nice thing I like about the solution I implemented,

252
00:17:33,000 --> 00:17:37,000
it works in local host, the testing environment, and production.

253
00:17:37,000 --> 00:17:41,000
So there's not this crazy case of doing switches, like compiler flags,

254
00:17:41,000 --> 00:17:44,000
or if-def-ing your way through to say, am I in prod?

255
00:17:44,000 --> 00:17:47,000
I personally hate that. I think that's a huge code smell,

256
00:17:47,000 --> 00:17:50,000
if you're doing stuff like that.

257
00:17:50,000 --> 00:17:53,000
Again, I'm not starting a sort of flame war with anybody.

258
00:17:53,000 --> 00:17:57,000
But yeah, I think it's funny, and it's why when I slacked you,

259
00:17:57,000 --> 00:18:00,000
I was like, we have to talk about leaky abstractions.

260
00:18:00,000 --> 00:18:03,000
Because you would think, in Rails, when you see anything that starts active,

261
00:18:03,000 --> 00:18:07,000
insert other word here, that's usually rock solid.

262
00:18:07,000 --> 00:18:10,000
Right, that's one of the great things about Rails,

263
00:18:10,000 --> 00:18:13,000
is it's just been used to build these kinds of services for so long

264
00:18:13,000 --> 00:18:17,000
and in so many cases that it basically has a good solution for everything.

265
00:18:17,000 --> 00:18:21,000
Exactly, and this was just one case where once you know it,

266
00:18:21,000 --> 00:18:25,000
you know it forever, and you just know you can't call that helper method

267
00:18:25,000 --> 00:18:28,000
on an environment using S3.

268
00:18:28,000 --> 00:18:32,000
But figuring that out, damn, that's...

269
00:18:32,000 --> 00:18:35,000
I mean, that requires you paying deep attention to logs.

270
00:18:35,000 --> 00:18:38,000
You have to already have your logging set up in your production environment,

271
00:18:38,000 --> 00:18:41,000
which I know a lot of people don't do.

272
00:18:41,000 --> 00:18:45,000
So it's a pretty, I want to say annoying,

273
00:18:45,000 --> 00:18:48,000
but it's not the way you want to spend half your day.

274
00:18:48,000 --> 00:18:50,000
No, no, definitely not.

275
00:18:50,000 --> 00:18:52,000
But the alternative is terrible.

276
00:18:52,000 --> 00:18:56,000
The alternative is implementing three solutions for three different environments.

277
00:18:56,000 --> 00:19:00,000
I like this quote you put in the doc kind of relatedly.

278
00:19:00,000 --> 00:19:05,000
Since all non-trivial abstractions are imperfect and will leak in one way or another,

279
00:19:05,000 --> 00:19:10,000
this means any serious programmer should always have at least a minimal knowledge

280
00:19:10,000 --> 00:19:13,000
of the abstractions they use.

281
00:19:13,000 --> 00:19:15,000
This usually means knowing a bit about how your CPU works,

282
00:19:15,000 --> 00:19:19,000
how your network protocols work, how your kernel works, and so on.

283
00:19:19,000 --> 00:19:21,000
Yeah, exactly.

284
00:19:21,000 --> 00:19:22,000
And that seems true, right?

285
00:19:22,000 --> 00:19:27,000
I mean, there's just no way that you can escape thinking about your system.

286
00:19:27,000 --> 00:19:29,000
And abstractions are useful tools,

287
00:19:29,000 --> 00:19:33,000
and I don't think the existence of these of leaky abstractions of problems

288
00:19:33,000 --> 00:19:35,000
where it's frustrating,

289
00:19:35,000 --> 00:19:38,000
there are times maybe where you've chosen the wrong abstraction

290
00:19:38,000 --> 00:19:43,000
or it's just not possible to abstract that in that way under these circumstances.

291
00:19:43,000 --> 00:19:48,000
But even in your case, you'd be able to sort of patch things up and make it work.

292
00:19:48,000 --> 00:19:54,000
Right, and it's a leak you only miss once, right?

293
00:19:54,000 --> 00:19:58,000
So now you know forever that, okay, Amazon S3, active storage,

294
00:19:58,000 --> 00:20:00,000
it doesn't allow the helper method.

295
00:20:00,000 --> 00:20:03,000
I saw another article about this, and they had a great example.

296
00:20:03,000 --> 00:20:05,000
Think about garbage collection.

297
00:20:05,000 --> 00:20:09,000
It hides manual memory management, but as anyone who uses it knows,

298
00:20:09,000 --> 00:20:14,000
sometimes getting peak performance is hard work.

299
00:20:14,000 --> 00:20:16,000
You'd still have to think about it, right?

300
00:20:16,000 --> 00:20:18,000
You pay the cost of garbage collection, of course,

301
00:20:18,000 --> 00:20:20,000
and you may have to go try to tune things.

302
00:20:20,000 --> 00:20:24,000
You may have to try to reuse stuff instead of freeing and reallocating new objects.

303
00:20:24,000 --> 00:20:29,000
You end up having to engage with and think about how the garbage collector works.

304
00:20:29,000 --> 00:20:32,000
But is it unsuitable or just incomplete?

305
00:20:32,000 --> 00:20:34,000
It depends.

306
00:20:34,000 --> 00:20:37,000
It could be an unsuitable abstraction for whatever task you're doing,

307
00:20:37,000 --> 00:20:42,000
saying you're trying to make a very low latency sort of system or building a game,

308
00:20:42,000 --> 00:20:45,000
and you just need to do manual memory management.

309
00:20:45,000 --> 00:20:49,000
Or you could have kind of an incomplete abstraction,

310
00:20:49,000 --> 00:20:52,000
something you need to extend or work with better,

311
00:20:52,000 --> 00:20:55,000
and find the right garbage collector and the right settings for it

312
00:20:55,000 --> 00:20:57,000
so that it works for your particular case.

313
00:20:57,000 --> 00:21:01,000
But you still don't have to think about all of the nitty-gritty of memory management work.

314
00:21:01,000 --> 00:21:06,000
Either way, you end up having to understand some of your problem domain.

315
00:21:06,000 --> 00:21:08,000
Yeah, that's exactly it, right.

316
00:21:08,000 --> 00:21:15,000
You can't just blindly trust the abstraction and hope it'll all work out.

317
00:21:15,000 --> 00:21:19,000
Another common case, I'm not sure it's directly applicable,

318
00:21:19,000 --> 00:21:23,000
and I'm curious what you think, and it kind of ties back in with Rails,

319
00:21:23,000 --> 00:21:26,000
and that's the use of ORMs, right?

320
00:21:26,000 --> 00:21:28,000
Object Relational Mapping.

321
00:21:28,000 --> 00:21:32,000
Because you'll find a subset of people who really just prefer to write the query themselves

322
00:21:32,000 --> 00:21:36,000
and will often say, well, look, I end up having to write the query myself

323
00:21:36,000 --> 00:21:41,000
or waste a bunch of time fighting with the ORM to try to get it to produce the query

324
00:21:41,000 --> 00:21:46,000
that I know that it should be so that it's actually performant on the SQL backend.

325
00:21:46,000 --> 00:21:49,000
But at the same time, you know, you're writing a CRUD app,

326
00:21:49,000 --> 00:21:53,000
and an ORM just like does most of the work for you.

327
00:21:53,000 --> 00:21:56,000
Yeah, I tend to lean on the, I'm curious where you found this,

328
00:21:56,000 --> 00:22:00,000
I tend to lean on the pro ORM side of life here.

329
00:22:00,000 --> 00:22:04,000
So you end up engaging more with the relational idea, I guess, right?

330
00:22:04,000 --> 00:22:07,000
Sort of nature of how those are constructed.

331
00:22:07,000 --> 00:22:11,000
But there are some libraries that try to smooth things over, right?

332
00:22:11,000 --> 00:22:15,000
Like there are cases where the mappings work out pretty cleanly, right?

333
00:22:15,000 --> 00:22:19,000
You have some map or a structure, an object that has some fields,

334
00:22:19,000 --> 00:22:22,000
and those just, you know, they end up just mapping to columns and the rows,

335
00:22:22,000 --> 00:22:26,000
and it all just sort of works for you.

336
00:22:26,000 --> 00:22:30,000
I think it just shows, again, that, you know, anytime this is non-trivial and complex,

337
00:22:30,000 --> 00:22:32,000
it's going to be hard.

338
00:22:32,000 --> 00:22:37,000
But probably there's, you know, a trade-off you have to consider too

339
00:22:37,000 --> 00:22:41,000
with how familiar you are and how familiar you want to be with the system.

340
00:22:41,000 --> 00:22:44,000
Now, performance is almost always going to be the real limiting factor, right?

341
00:22:44,000 --> 00:22:49,000
Like if it doesn't work for the performance that you need, it's not going to work.

342
00:22:49,000 --> 00:22:53,000
But if you're already familiar with SQL, it may be easier for you to use

343
00:22:53,000 --> 00:22:56,000
a sort of more minimal system, right, where you might want some helper method,

344
00:22:56,000 --> 00:22:59,000
something that can easily translate and store an object,

345
00:22:59,000 --> 00:23:04,000
but you don't need these complicated joins being constructed for you to go to that level.

346
00:23:06,000 --> 00:23:11,000
Yeah, I mean, the whole ORM thing is tough, right?

347
00:23:11,000 --> 00:23:16,000
Because most of the time, you don't need it, at least in a Rails application.

348
00:23:17,000 --> 00:23:22,000
I'm sorry, you don't need to drop to raw SQL queries.

349
00:23:22,000 --> 00:23:27,000
But there's usually one or two in every application that you kind of end up doing.

350
00:23:27,000 --> 00:23:32,000
Right, it's on the hot path.

351
00:23:29,000 --> 00:23:34,000
It happens a lot, or for some reason, the ORM is just getting it kind of wrong.

352
00:23:34,000 --> 00:23:39,000
Right, or it's just like the code you have to write

353
00:23:36,000 --> 00:23:41,000
to make ActiveRecord do what you want is so just gnarly.

354
00:23:41,000 --> 00:23:46,000
Right, gross, gnarly, hard to understand.

355
00:23:44,000 --> 00:23:49,000
Right, that having a stored procedure for that is just easier.

356
00:23:49,000 --> 00:23:54,000
But yeah, I tend to try to do everything I can in ActiveRecord.

357
00:23:54,000 --> 00:23:59,000
We really have to go ahead and get a stored procedure.

358
00:23:58,000 --> 00:24:03,000
I think one aspect that you can't ignore when you're talking about leaky abstractions

359
00:24:02,000 --> 00:24:07,000
and abstractions in general, and it's something we kind of talked about a little bit

360
00:24:07,000 --> 00:24:12,000
without naming it in the last episode.

361
00:24:11,000 --> 00:24:16,000
And that's choosing the right level of distraction.

362
00:24:14,000 --> 00:24:19,000
Last week, you were talking a bit about large legacy C sharp code bases.

363
00:24:19,000 --> 00:24:24,000
And I've certainly seen sometimes in large, older OO projects

364
00:24:25,000 --> 00:24:30,000
that things just get abstracted too early and too far

365
00:24:29,000 --> 00:24:34,000
so that you end up with so many layers of abstraction

366
00:24:32,000 --> 00:24:37,000
that it's hard to find where the concreteness is actually happening.

367
00:24:37,000 --> 00:24:42,000
And that's important, right, because abstractions are useful,

368
00:24:42,000 --> 00:24:47,000
but at the end of the day, there's implementations down there,

369
00:24:47,000 --> 00:24:52,000
especially as you're learning a new code base.

370
00:24:50,000 --> 00:24:55,000
And it can be nice to have a layer of abstraction added

371
00:24:53,000 --> 00:24:58,000
if you know that you really need multiple implementations.

372
00:24:56,000 --> 00:25:01,000
But I'm sure you've seen cases where a bunch of abstractions are added

373
00:25:00,000 --> 00:25:05,000
and then there's only ever one implementation for each of them.

374
00:25:04,000 --> 00:25:09,000
This is probably one of the most common disagreements I think developers have, right?

375
00:25:08,000 --> 00:25:13,000
Is what level do you start at in terms of implementing abstractions

376
00:25:13,000 --> 00:25:18,000
to a lower layer, whether that's database or cross-platform, right?

377
00:25:18,000 --> 00:25:23,000
Because even in the cross-platform world, Xamarin, Flutter, whatever it's called,

378
00:25:23,000 --> 00:25:28,000
all of that stuff is just an abstraction, wouldn't you say?

379
00:25:26,000 --> 00:25:31,000
Oh, yeah, of course, right?

380
00:25:27,000 --> 00:25:32,000
It's trying to smooth things over

381
00:25:29,000 --> 00:25:34,000
so you can talk about a generic input element

382
00:25:32,000 --> 00:25:37,000
and not worry that on the Linux desktop, it's totally different than iOS.

383
00:25:37,000 --> 00:25:42,000
I mean, the Linux desktop is iOS though, right? Am I confused?

384
00:25:42,000 --> 00:25:47,000
I think that head injury was more serious than we thought, Mike.

385
00:25:46,000 --> 00:25:51,000
But yeah, you're right.

386
00:25:47,000 --> 00:25:52,000
I mean, of course those are abstractions and they are useful, right?

387
00:25:50,000 --> 00:25:55,000
I mean, look at the popularity of cross-platform frameworks like that

388
00:25:58,000 --> 00:26:03,000
or things like React Native, Electron.

389
00:26:02,000 --> 00:26:07,000
There are a lot of things you just don't want to think about

390
00:26:07,000 --> 00:26:12,000
and that can be useful.

391
00:26:08,000 --> 00:26:13,000
I don't know, you just always have to end up thinking about some aspect of it

392
00:26:12,000 --> 00:26:17,000
or you need to be aware.

393
00:26:13,000 --> 00:26:18,000
And so that's why the case you ran into is kind of interesting

394
00:26:16,000 --> 00:26:21,000
because I'm sure if you'd seen a little caveat declared for that,

395
00:26:20,000 --> 00:26:25,000
or maybe a table of backends that are supported with that that works,

396
00:26:27,000 --> 00:26:32,000
that would have been very useful knowledge upfront

397
00:26:30,000 --> 00:26:35,000
because it's okay that there's no denying that it can't work,

398
00:26:35,000 --> 00:26:40,000
but it's still a useful abstraction for a majority of use cases.

399
00:26:39,000 --> 00:26:44,000
It just has its natural limits.

400
00:26:42,000 --> 00:26:47,000
Right, for the vast majority of, yeah.

401
00:26:45,000 --> 00:26:50,000
There's just this one operation where it doesn't make sense.

402
00:26:49,000 --> 00:26:54,000
This is one of those things that I do think about,

403
00:26:52,000 --> 00:26:57,000
I hate to say the E word, but Electron, right?

404
00:26:55,000 --> 00:27:00,000
A story came out today where there's some,

405
00:26:58,000 --> 00:27:03,000
it's on Ars Technica and I'll find the link,

406
00:27:03,000 --> 00:27:08,000
but I think we are both currently running.

407
00:27:06,000 --> 00:27:11,000
I mean, how much bigger of an abstraction can you get than that, right?

408
00:27:11,000 --> 00:27:16,000
It does also show, right, though, like I think about the popularity.

409
00:27:14,000 --> 00:27:19,000
And I imagine there's many,

410
00:27:17,000 --> 00:27:22,000
I'm thinking of this as a desktop Linux user here,

411
00:27:19,000 --> 00:27:24,000
but probably many applications

412
00:27:23,000 --> 00:27:28,000
that wouldn't necessarily target the Linux desktop

413
00:27:26,000 --> 00:27:31,000
without that level of abstraction being available, right?

414
00:27:31,000 --> 00:27:36,000
Without the abstractions, you have to end up learning more.

415
00:27:34,000 --> 00:27:39,000
When they work, they can really successfully hide things from you

416
00:27:38,000 --> 00:27:43,000
and the Linux desktop or whatever small market

417
00:27:42,000 --> 00:27:47,000
doesn't usually have the necessary weight

418
00:27:45,000 --> 00:27:50,000
to demand that level of resource to go implement

419
00:27:48,000 --> 00:27:53,000
basically something that could be abstracted over

420
00:27:50,000 --> 00:27:55,000
because it wasn't fundamentally different.

421
00:27:54,000 --> 00:27:59,000
Yeah, and there's tons of examples, right?

422
00:27:59,000 --> 00:28:04,000
It's actually in itself an abstraction,

423
00:28:02,000 --> 00:28:07,000
though I would argue operating in a much lower layer,

424
00:28:05,000 --> 00:28:10,000
although maybe not, right?

425
00:28:06,000 --> 00:28:11,000
C++ is an abstraction, which is the language

426
00:28:08,000 --> 00:28:13,000
you tend to be developing when using Qt.

427
00:28:12,000 --> 00:28:17,000
Objective-C is an abstraction,

428
00:28:14,000 --> 00:28:19,000
although it's amazing and glorious

429
00:28:15,000 --> 00:28:20,000
and we should all be using it.

430
00:28:17,000 --> 00:28:22,000
Yeah, I mean, really, our whole world is based on that, right?

431
00:28:21,000 --> 00:28:26,000
I mean, even if you're programming in assembly language,

432
00:28:26,000 --> 00:28:31,000
it's compiled to the real operations going on under the hood.

433
00:28:31,000 --> 00:28:36,000
I liked the way this was put over at the principles wiki.

434
00:28:36,000 --> 00:28:41,000
A solution is bad if A, the leakiness of abstractions is ignored,

435
00:28:42,000 --> 00:28:47,000
B, the benefits of the abstraction cannot justify

436
00:28:46,000 --> 00:28:51,000
the disadvantages created by the leakiness,

437
00:28:51,000 --> 00:28:56,000
C, the abstraction is just more leaky than necessary,

438
00:28:56,000 --> 00:29:01,000
meaning you've maybe chosen the wrong abstraction.

439
00:29:00,000 --> 00:29:05,000
Yeah, completely agree.

440
00:29:01,000 --> 00:29:06,000
So where do you fall in the abstraction hierarchy?

441
00:29:04,000 --> 00:29:09,000
Do you start, like I think I'm pretty clear,

442
00:29:07,000 --> 00:29:12,000
I start at the high level and move down when I need to.

443
00:29:10,000 --> 00:29:15,000
Is that how you also operate, Wes,

444
00:29:12,000 --> 00:29:17,000
or do you prefer to somewhere in the middle, low level?

445
00:29:17,000 --> 00:29:22,000
Somewhere in the middle.

446
00:29:20,000 --> 00:29:25,000
I think they're very valuable.

447
00:29:22,000 --> 00:29:27,000
One thing about, say, Python that I think that it could do to have better

448
00:29:29,000 --> 00:29:34,000
is some of these abstraction toolings.

449
00:29:31,000 --> 00:29:36,000
I mean, you've got the double underscore methods and all that,

450
00:29:33,000 --> 00:29:38,000
but I think Java interfaces are just a good way to think about things

451
00:29:40,000 --> 00:29:45,000
in many cases, or the Clojure version is protocols, right?

452
00:29:45,000 --> 00:29:50,000
Groupings of methods that operate on,

453
00:29:48,000 --> 00:29:53,000
that can be implemented by different data types.

454
00:29:51,000 --> 00:29:56,000
It's reasonable to want to abstract early with the,

455
00:29:55,000 --> 00:30:00,000
especially if you're thinking about

456
00:29:58,000 --> 00:30:03,000
what's going to go wrong later,

457
00:30:00,000 --> 00:30:05,000
or are we going to add more backends for this, right?

458
00:30:02,000 --> 00:30:07,000
Like, oh, I need to talk to this service,

459
00:30:03,000 --> 00:30:08,000
but we might want to have a second service

460
00:30:05,000 --> 00:30:10,000
that does the same thing as a backup

461
00:30:06,000 --> 00:30:11,000
or to talk to both of them at the same time.

462
00:30:11,000 --> 00:30:16,000
And that's fine.

463
00:30:12,000 --> 00:30:17,000
I would just caution that

464
00:30:16,000 --> 00:30:21,000
you should also be trying to keep things flexible enough

465
00:30:19,000 --> 00:30:24,000
and easy to change enough

466
00:30:22,000 --> 00:30:27,000
that adding abstractions later shouldn't be difficult, right?

467
00:30:27,000 --> 00:30:32,000
I guess I'm in the middle where you should be thinking about it

468
00:30:30,000 --> 00:30:35,000
and programming in a way that allows for it to be added,

469
00:30:33,000 --> 00:30:38,000
but not necessarily adding it concretely all the time.

470
00:30:38,000 --> 00:30:43,000
I mean, it's so funny.

471
00:30:40,000 --> 00:30:45,000
That's exactly one of the use cases

472
00:30:42,000 --> 00:30:47,000
that Active Storage is meant to help.

473
00:30:44,000 --> 00:30:49,000
If you want to have a duplicate service implemented, right?

474
00:30:48,000 --> 00:30:53,000
There's actually, right in the config file,

475
00:30:49,000 --> 00:30:54,000
you can set a mirror so you can do S3 and, again,

476
00:30:52,000 --> 00:30:57,000
whatever Azure's version is,

477
00:30:53,000 --> 00:30:58,000
or Minio and something else, right?

478
00:30:56,000 --> 00:31:01,000
Right, or I mean,

479
00:30:57,000 --> 00:31:02,000
DigitalOcean has one that's S3 compatible.

480
00:30:59,000 --> 00:31:04,000
There's tons of them.

481
00:31:00,000 --> 00:31:05,000
Yeah, DO has one now, right?

482
00:31:02,000 --> 00:31:07,000
So whatever is,

483
00:31:07,000 --> 00:31:12,000
implementing the second service is quote, unquote, free.

484
00:31:10,000 --> 00:31:15,000
Exactly. That's a good way to put it.

485
00:31:13,000 --> 00:31:18,000
This is hard stuff because it's just so context dependent

486
00:31:18,000 --> 00:31:23,000
and it depends a lot on what you're doing,

487
00:31:21,000 --> 00:31:26,000
how long it's going to live,

488
00:31:23,000 --> 00:31:28,000
and how much it might grow,

489
00:31:25,000 --> 00:31:30,000
and those aren't always clear

490
00:31:26,000 --> 00:31:31,000
at the time you're actually creating it.

491
00:31:29,000 --> 00:31:34,000
We'll, of course, have links

492
00:31:30,000 --> 00:31:35,000
to all the things we talked about,

493
00:31:35,000 --> 00:31:40,000
or guides, or, you know,

494
00:31:36,000 --> 00:31:41,000
ways to think about the right level of abstraction,

495
00:31:39,000 --> 00:31:44,000
or favorite tools to deal with leaky abstractions.

496
00:31:43,000 --> 00:31:48,000
If so, let us know.

497
00:31:45,000 --> 00:31:50,000
We're at coder.show slash contact.

498
00:31:49,000 --> 00:31:54,000
Now, Mike, we took a little bit of a break.

499
00:31:52,000 --> 00:31:57,000
You were traveling.

500
00:31:53,000 --> 00:31:58,000
There was a lot of things going on

501
00:31:54,000 --> 00:31:59,000
behind the scenes for both of us.

502
00:31:57,000 --> 00:32:02,000
But it's time again

503
00:31:59,000 --> 00:32:04,000
for our seven languages challenge,

504
00:32:04,000 --> 00:32:09,000
I do.

505
00:32:06,000 --> 00:32:11,000
I know you're just jonesing for it and

506
00:32:08,000 --> 00:32:13,000
hands are shaking.

507
00:32:09,000 --> 00:32:14,000
Who am I to stand in your way?

508
00:32:11,000 --> 00:32:16,000
I mean, look at you.

509
00:32:12,000 --> 00:32:17,000
You look horrible.

510
00:32:13,000 --> 00:32:18,000
You need something to play with

511
00:32:15,000 --> 00:32:20,000
to get excited by.

512
00:32:16,000 --> 00:32:21,000
Sweating, I'm crying.

513
00:32:18,000 --> 00:32:23,000
It's terrible.

514
00:32:19,000 --> 00:32:24,000
And I know, you know,

515
00:32:20,000 --> 00:32:25,000
you were just kind of burned

516
00:32:22,000 --> 00:32:27,000
by rails here,

517
00:32:23,000 --> 00:32:28,000
so I thought we'll keep you

518
00:32:25,000 --> 00:32:30,000
kind of close to rails in Ruby,

519
00:32:27,000 --> 00:32:32,000
but also mix everything up.

520
00:32:32,000 --> 00:32:37,000
Crystal.

521
00:32:33,000 --> 00:32:38,000
You know I like my gemstone

522
00:32:34,000 --> 00:32:39,000
named languages, right?

523
00:32:36,000 --> 00:32:41,000
Oh, I sure do.

524
00:32:37,000 --> 00:32:42,000
Crystals build as a language

525
00:32:39,000 --> 00:32:44,000
that's fast as C and slick as Ruby.

526
00:32:43,000 --> 00:32:48,000
I've been lied to before.

527
00:32:45,000 --> 00:32:50,000
Yeah, but you'll also find

528
00:32:46,000 --> 00:32:51,000
that Crystals statically typed

529
00:32:48,000 --> 00:32:53,000
and seemingly very efficient.

530
00:32:52,000 --> 00:32:57,000
Got non-nullable things,

531
00:32:54,000 --> 00:32:59,000
null checks,

532
00:32:55,000 --> 00:33:00,000
so you've got that safety added.

533
00:33:00,000 --> 00:33:05,000
And green threads,

534
00:33:03,000 --> 00:33:08,000
also known as fibers,

535
00:33:06,000 --> 00:33:11,000
as a concurrency model.

536
00:33:07,000 --> 00:33:12,000
So that's exciting.

537
00:33:08,000 --> 00:33:13,000
That's something you encountered

538
00:33:10,000 --> 00:33:15,000
in a somewhat different variant

539
00:33:12,000 --> 00:33:17,000
over when you were playing

540
00:33:13,000 --> 00:33:18,000
with Elixir.

541
00:33:15,000 --> 00:33:20,000
True, true.

542
00:33:16,000 --> 00:33:21,000
Yeah, you know,

543
00:33:17,000 --> 00:33:22,000
I did take a brief look at Crystal,

544
00:33:18,000 --> 00:33:23,000
and I have to say,

545
00:33:19,000 --> 00:33:24,000
I cannot deny that my heart

546
00:33:21,000 --> 00:33:26,000
has desired this,

547
00:33:22,000 --> 00:33:27,000
ala Galadriel here.

548
00:33:23,000 --> 00:33:28,000
Yeah, you know,

549
00:33:24,000 --> 00:33:29,000
it seemed like it might make sense

550
00:33:29,000 --> 00:33:34,000
to do something with Rust.

551
00:33:30,000 --> 00:33:35,000
So perhaps something that has

552
00:33:32,000 --> 00:33:37,000
some of the similar properties,

553
00:33:33,000 --> 00:33:38,000
a nice robust type system,

554
00:33:35,000 --> 00:33:40,000
but can also target

555
00:33:37,000 --> 00:33:42,000
somewhat more lower-level tasks

556
00:33:41,000 --> 00:33:46,000
might be something

557
00:33:42,000 --> 00:33:46,000
you would actually use

558
00:33:43,000 --> 00:33:48,000
in your toolkit.

559
00:33:44,000 --> 00:33:49,000
Sounds good.

560
00:33:45,000 --> 00:33:50,000
Looking forward to it.

561
00:33:48,000 --> 00:33:53,000
So I saw you had a pick

562
00:33:49,000 --> 00:33:54,000
for us this week, Wes,

563
00:33:50,000 --> 00:33:55,000
or two, even.

564
00:33:52,000 --> 00:33:57,000
Well, one of them

565
00:33:53,000 --> 00:33:58,000
is really a supplement

566
00:33:58,000 --> 00:34:03,000
to Ruby, yeah, exactly, exactly.

567
00:34:01,000 --> 00:34:06,000
I mean, this whole episode

568
00:34:02,000 --> 00:34:07,000
has been, you know,

569
00:34:03,000 --> 00:34:08,000
it kind of started off

570
00:34:03,000 --> 00:34:08,000
in the Ruby world,

571
00:34:04,000 --> 00:34:09,000
and we might as well

572
00:34:05,000 --> 00:34:10,000
end it that way, too.

573
00:34:07,000 --> 00:34:12,000
And that's why I've picked

574
00:34:09,000 --> 00:34:14,000
Effect,

575
00:34:10,000 --> 00:34:15,000
an algebraic effects library

576
00:34:14,000 --> 00:34:19,000
for Ruby.

577
00:34:16,000 --> 00:34:21,000
Yeah, okay.

578
00:34:17,000 --> 00:34:22,000
If you're not really

579
00:34:18,000 --> 00:34:23,000
familiar with that,

580
00:34:19,000 --> 00:34:24,000
let's say you're trying to do

581
00:34:20,000 --> 00:34:25,000
some, you know,

582
00:34:21,000 --> 00:34:26,000
more functional Ruby,

583
00:34:26,000 --> 00:34:31,000
you want more of it,

584
00:34:27,000 --> 00:34:32,000
but Ruby pays your bills.

585
00:34:29,000 --> 00:34:34,000
Well, Effect is a tiny

586
00:34:31,000 --> 00:34:36,000
Ruby gem, providing a way

587
00:34:33,000 --> 00:34:38,000
to isolate and handle

588
00:34:35,000 --> 00:34:40,000
side effects in

589
00:34:36,000 --> 00:34:41,000
functional programs.

590
00:34:38,000 --> 00:34:43,000
Effect implements

591
00:34:39,000 --> 00:34:44,000
algebraic effects in Ruby,

592
00:34:41,000 --> 00:34:46,000
but can also be used

593
00:34:42,000 --> 00:34:47,000
to implement other patterns

594
00:34:43,000 --> 00:34:48,000
like object-oriented programming,

595
00:34:46,000 --> 00:34:51,000
inversion of control,

596
00:34:47,000 --> 00:34:52,000
and dependency injection.

597
00:34:50,000 --> 00:34:55,000
They've got some

598
00:34:50,000 --> 00:34:55,000
nice examples here,

599
00:34:55,000 --> 00:35:00,000
is pushing I-O

600
00:34:57,000 --> 00:35:02,000
to the boundaries,

601
00:34:58,000 --> 00:35:03,000
or other, you know,

602
00:34:59,000 --> 00:35:04,000
stateful stuff, right?

603
00:35:00,000 --> 00:35:05,000
And we've talked about this

604
00:35:01,000 --> 00:35:06,000
before, too, where that stuff's

605
00:35:03,000 --> 00:35:08,000
hard to test, right?

606
00:35:04,000 --> 00:35:09,000
You end up needing to do,

607
00:35:05,000 --> 00:35:10,000
you know, integration stuff

608
00:35:07,000 --> 00:35:12,000
or crazy mocking and stubbing,

609
00:35:09,000 --> 00:35:14,000
and it just gets rough.

610
00:35:11,000 --> 00:35:16,000
So one of the advantages

611
00:35:12,000 --> 00:35:17,000
of a library like this

612
00:35:13,000 --> 00:35:18,000
is you can use its facilities

613
00:35:16,000 --> 00:35:21,000
to do this for you,

614
00:35:18,000 --> 00:35:23,000
because instead of actually

615
00:35:19,000 --> 00:35:24,000
sending I-O, say,

616
00:35:24,000 --> 00:35:29,000
and then it's actually going to

617
00:35:25,000 --> 00:35:30,000
go do all of that for you,

618
00:35:26,000 --> 00:35:31,000
so you can test your stuff

619
00:35:28,000 --> 00:35:33,000
just by, you know,

620
00:35:29,000 --> 00:35:34,000
making sure that you've sent

621
00:35:30,000 --> 00:35:35,000
the right information

622
00:35:31,000 --> 00:35:36,000
to the library.

623
00:35:33,000 --> 00:35:38,000
Okay, okay, I'm down with that.

624
00:35:36,000 --> 00:35:41,000
Behind the scenes,

625
00:35:38,000 --> 00:35:43,000
well, there's kind of

626
00:35:40,000 --> 00:35:45,000
a lot going on.

627
00:35:41,000 --> 00:35:46,000
It's a cool concept,

628
00:35:42,000 --> 00:35:47,000
algebraic effects,

629
00:35:44,000 --> 00:35:49,000
and really at this stage,

630
00:35:45,000 --> 00:35:50,000
it's more of a research

631
00:35:47,000 --> 00:35:52,000
programming language feature.

632
00:35:52,000 --> 00:35:57,000
Yeah, I mean, you're probably

633
00:35:53,000 --> 00:35:58,000
not going to run this in production,

634
00:35:54,000 --> 00:35:59,000
and in fact,

635
00:35:55,000 --> 00:36:00,000
you probably shouldn't.

636
00:35:56,000 --> 00:36:01,000
But I think it's a useful model,

637
00:35:58,000 --> 00:36:03,000
and it's nice to play with

638
00:36:00,000 --> 00:36:05,000
new ways of thinking

639
00:36:01,000 --> 00:36:06,000
about things, right,

640
00:36:02,000 --> 00:36:07,000
and trying to add tools

641
00:36:04,000 --> 00:36:09,000
that help you separate concerns,

642
00:36:06,000 --> 00:36:11,000
push state to the edges,

643
00:36:08,000 --> 00:36:13,000
and keep things pure.

644
00:36:10,000 --> 00:36:15,000
So, you know,

645
00:36:11,000 --> 00:36:16,000
maybe don't go deploying effect

646
00:36:13,000 --> 00:36:18,000
wherever you need it to be.

647
00:36:15,000 --> 00:36:20,000
But I think it's a practical

648
00:36:16,000 --> 00:36:21,000
example of actually

649
00:36:21,000 --> 00:36:26,000
using it and has a bunch of math.

650
00:36:23,000 --> 00:36:28,000
But I saw that this came out,

651
00:36:25,000 --> 00:36:30,000
and I thought,

652
00:36:26,000 --> 00:36:31,000
if anyone's actually interested,

653
00:36:27,000 --> 00:36:32,000
they want to go play with this,

654
00:36:28,000 --> 00:36:33,000
you can still read a bunch

655
00:36:29,000 --> 00:36:34,000
of nerdy PDFs,

656
00:36:31,000 --> 00:36:36,000
and you can try to use it

657
00:36:33,000 --> 00:36:38,000
in some toy programmings

658
00:36:34,000 --> 00:36:39,000
and see what it might be like.

659
00:36:36,000 --> 00:36:41,000
And as always,

660
00:36:37,000 --> 00:36:42,000
Wes is trying to educate you,

661
00:36:39,000 --> 00:36:44,000
and I'm trying to make you

662
00:36:40,000 --> 00:36:45,000
not have to know things.

663
00:36:41,000 --> 00:36:46,000
So my pick is Minio.

664
00:36:43,000 --> 00:36:48,000
Pretend like those servers

665
00:36:45,000 --> 00:36:50,000
and S3 instances aren't there.

666
00:36:50,000 --> 00:36:55,000
Like all over the place?

667
00:36:51,000 --> 00:36:56,000
Oh, Minio, several years.

668
00:36:52,000 --> 00:36:57,000
Several years.

669
00:36:53,000 --> 00:36:58,000
It's actually funny,

670
00:36:54,000 --> 00:36:59,000
I haven't been to their main

671
00:36:57,000 --> 00:37:02,000
non-GitHub website

672
00:36:59,000 --> 00:37:04,000
for a few years since today.

673
00:37:02,000 --> 00:37:07,000
I had no idea that they had

674
00:37:04,000 --> 00:37:09,000
this whole AI library thing

675
00:37:06,000 --> 00:37:11,000
going on, too.

676
00:37:07,000 --> 00:37:12,000
Oh, it's 2019 now, Mike.

677
00:37:09,000 --> 00:37:14,000
Everyone does.

678
00:37:11,000 --> 00:37:16,000
I have Alice.

679
00:37:13,000 --> 00:37:18,000
I keep deciding if C Sharp

680
00:37:18,000 --> 00:37:23,000
is going to be there

681
00:37:18,000 --> 00:37:23,000
for the next few weeks.

682
00:37:20,000 --> 00:37:25,000
But yeah, they have a lot going on.

683
00:37:23,000 --> 00:37:28,000
I can't vouch for anything else,

684
00:37:24,000 --> 00:37:29,000
but I can tell you,

685
00:37:26,000 --> 00:37:31,000
as an open source,

686
00:37:28,000 --> 00:37:33,000
make your own little rate array

687
00:37:29,000 --> 00:37:34,000
and store your files, top shelf.

688
00:37:32,000 --> 00:37:37,000
Thanks for the great pick

689
00:37:33,000 --> 00:37:38,000
this week.

690
00:37:34,000 --> 00:37:39,000
Thank you.

691
00:37:35,000 --> 00:37:40,000
Now, where can people find you

692
00:37:37,000 --> 00:37:42,000
to learn more about

693
00:37:38,000 --> 00:37:43,000
computer science and calculus?

694
00:37:40,000 --> 00:37:45,000
Oh, you can find me rambling

695
00:37:42,000 --> 00:37:47,000
about things over on Twitter

696
00:37:47,000 --> 00:37:52,000
but they can find you

697
00:37:48,000 --> 00:37:53,000
trolling the universe

698
00:37:50,000 --> 00:37:55,000
over there, too, right?

699
00:37:51,000 --> 00:37:56,000
That's on Twitter

700
00:37:52,000 --> 00:37:57,000
at Domenico

701
00:37:53,000 --> 00:37:58,000
and visit dominechem.com.

702
00:37:55,000 --> 00:38:00,000
I will be writing up the horrors

703
00:37:56,000 --> 00:38:01,000
of abstractions this week.

704
00:37:58,000 --> 00:38:03,000
Oh, I'm looking forward to that.

705
00:38:00,000 --> 00:38:05,000
You can also find the whole

706
00:38:02,000 --> 00:38:07,000
network over at Jupiter Signal

707
00:38:04,000 --> 00:38:09,000
or jupiterbroadcasting.com

708
00:38:06,000 --> 00:38:11,000
where you'll also find

709
00:38:08,000 --> 00:38:13,000
the calendar.

710
00:38:09,000 --> 00:38:14,000
That'll let you know

711
00:38:10,000 --> 00:38:15,000
when we're doing this show live

712
00:38:11,000 --> 00:38:16,000
and if you have the time available,

713
00:38:16,000 --> 00:38:21,000
just tune in live

714
00:38:17,000 --> 00:38:22,000
when you have a chance.

715
00:38:19,000 --> 00:38:24,000
Of course, there's also a ton

716
00:38:20,000 --> 00:38:25,000
of other great Jupiter

717
00:38:21,000 --> 00:38:26,000
broadcasting shows,

718
00:38:22,000 --> 00:38:27,000
so check those out, too.

719
00:38:24,000 --> 00:38:29,000
Or if you just want Coder Radio,

720
00:38:25,000 --> 00:38:30,000
well, coder.show.

721
00:38:27,000 --> 00:38:32,000
There you can contact us

722
00:38:28,000 --> 00:38:33,000
or just subscribe to the RSS feed

723
00:38:30,000 --> 00:38:35,000
which is the easiest way

724
00:38:32,000 --> 00:38:37,000
to make sure you always

725
00:38:33,000 --> 00:38:38,000
get the latest episode.

726
00:38:36,000 --> 00:38:41,000
Thank you all so much

727
00:38:37,000 --> 00:38:42,000
for joining us

728
00:38:38,000 --> 00:38:43,000
and we'll see you right back here

729
00:38:43,000 --> 00:38:49,000
for another episode of

730
00:38:49,000 --> 00:39:18,000
Jupiter Radio.

731
00:39:19,000 --> 00:39:23,000
radio.com


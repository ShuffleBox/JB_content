This is Koda Radio, episode 354, for April 22, 2019.
Hello and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business of software development and related technologies.
My name is Wes, and I'm very pleased to be joined once again by Mr. Michael Dominick, the man with just one too many house guests who's taking the time to join us today.
Hello, Mr. Payne, and I hope the Easter Bunny was extra good to you.
Yeah, you know, I didn't have any chocolate, really, but I did make a pork shoulder for myself, and well, that was just darn good.
I have a 12-year-old in my house, a 12-year-old boy. Are you familiar with Genghis Khan?
Oh, yeah, vaguely. I mean, I've seen some of his work.
Yeah, it's roughly the same. I would say 12-year-old boys are the TypeScript to Genghis Khan as TypeScript is to JavaScript.
Well, I'm glad. I'm sure your house has been totally destroyed.
Completely.
I'm surprised, honestly, just given your track record, I'm just surprised that you have any computers left at all to which to join us today.
He is surprisingly conscientious with tech hardware, unlike someone we all know and love.
That's good. He obviously got the good genes.
Exactly.
Well, happy Earth Day. It's Earth Day today, and we're celebrating that by, you know, doing some livestream, but we swear we promise we'll turn our computers off later.
That's right.
In the spirit of that, I think we'd better just get rolling because we got lots to talk about today.
First up, we've got some fantastic feedback from you, our dear audience.
And the easiest way to go do that, if you like the feedback or you don't like the feedback, us, the show, whatever your thoughts, well, coder.show slash contact.
You can also go to coderradio.reddit.com.
First up today, we got an email, a little clarification from our friend Sikar.
He writes, hi, talking here about Coder Radio episode 349, and I just wanted to let you know that AWS Elastic Beanstalk, the retirement you mentioned,
well, you sort of implied that the entire Elastic Beanstalk product was being retired.
But in fact, Elastic Beanstalk is retiring only some platform versions with software components that have reached end of life.
So before we got on this, I re-listened to that episode, or at least the portion I talked about, I'm sorry, well, AWS, but EB.
You know, I always mess that up, Wes.
AWS Elastic Beanstalk.
Naming things is hard, but AWS EB, yeah, it just doesn't feel natural.
So it is true.
Like, and I did not mean to, but I definitely understand how that could have been misunderstood to imply that all of Elastic Beanstalk was going away.
However, some very core pieces of functionality that I would be willing to bet a large percentage of the subset of our listeners that use EB use is going away.
For instance, this is probably the biggest one, older versions of NGINX, and you have some mandatory upgrade.
There is a long list that you can Google for that other people have written up for you on the components or the, quote unquote, you know, platforms that are coming away.
Or at least need to be upgraded is probably more accurate.
I don't think it's worth the time here to run through that list.
Other than to say, because you're almost certainly using NGINX, that is the one I was thinking of.
So it's not that NGINX is going away, it's just that there's a major version bump and the one that maybe people are relying on and maybe they wrote the config for like three years ago and haven't really touched that part of the application since, that part's going away.
Exactly.
So the minimum required version of NGINX has basically been bumped up a few versions, that's all.
It is a big deal if you are depending on the older version of NGINX.
And it is not just NGINX, which is something I do want to stretch, but I don't think it's very good radio for us to read through a list of things that are, you know, that you need to update.
If you have this problem, you would have gotten one or several emails from Amazon and I would encourage you to, if you haven't, but you think you might, just do a quick DuckDuckGo search and you will find other people who are more conscientious than me and have written up lists.
But good feedback, happy to clarify, Elastic Beanstalk is indeed alive and well.
Excellent. And thank you to Sagar for letting us know. We always want to be clear when we can.
Next up, we've got something more of a question and Mike, I'm really curious to hear your thoughts on it. So this is from Ashton.
Hey guys, I've been listening for a while and actually contacted you before regarding how to showcase some of my dark matter projects to potential employers.
This has actually proven to be very beneficial. So thank you for the advice. However, I run into another issue that I just don't know how to tackle.
Maybe you can give me a little more insight.
I'm a four year C sharp slash dot net dev with a consulting firm and looking to go somewhere more leading edge and software oriented.
This is my main issue, though, seen as for my current work with my current employer, we're just so far behind everyone else.
Ninety eight percent of our applications are built using, yes, wait for it, Mike, WinForms, and they are not willing to entertain any MVC or web based applications.
Here's where it gets interesting to recruiters have told me the same thing, which amounts to, yes, you have some great experience, but in things no one really uses.
Now, they do clarify here. I know how ASB MVC and dot net core work and have made a few things here and there with them.
But the professional experience seems to be a must have for every employer I've spoken with.
I don't want to think that the past few years have been for nothing, but it's beginning to seem that way.
Hope you can share your wisdom. Thanks.
There's just so much here. It depends on what you want to do, which is I know the lame answer we always give on the show.
But I can tell you that don't let recruiters be your guide. No offense to any recruiters who may listen to the show.
Although if you are a recruiter and you listen to the show, you might be the best recruiter in your city.
So a recruiter is a sales guy, right? I mean, I guess we should dive into this a little bit.
So the recruiter is going to give you advice that makes his life as easy as possible.
Of course, think about it from the hiring manager's perspective. You have a position open.
I don't know exactly what you're looking for, but let's you know, let's just make it up, right?
You want to be a more modern dot net developer, not wind forms. Right.
Well, the easiest person, if I'm the recruiter, for me to sell to that hiring manager is someone who literally works at his competitor or a related company
doing that exact job. Right.
Ideally, you have someone who is already doing that job, who's been doing it before that requires basically no training except for, you know,
whatever business specific differences there are and just jumps in and gets to work day one, or at least that's the fantasy.
It's a fantasy, but it's also I mean, it's the biz dev guys fantasy, right? It's a lie.
I mean, any experienced software engineer can transition technologies in a matter of like months.
It's just you have to do it. I mean, objectivity is wonderful, but sometimes you have to change, you know, in your case, wind forms.
It's definitely had its time in the sun. And yeah, you need to walk away from that.
You know, if you want to remain a dot net guy, there's literally plenty of options, right?
Dot net foundation. Look them up. I remember. It's great. There's tons of stuff you can do.
Having said that, why are you using recruiters? If you're like, I'm a little confused because they're going to take a VIG off of what you make.
In many cases, if you're kind of an experienced developers and you have done a little bit of networking,
it shouldn't be super hard to go out and find companies that want talented developers.
This is a problem we've had a team be like we've had people who we thought were kind of our bottom percentile get hired by very large companies that you've heard of
because there's just like such a desire for anyone who can basically use get. Oh, interesting.
I know it's a little reductive and I'm trying to be a little bit funny, but it's it's just not like I don't mean to just dunk on recruiters.
And I know how this sounds, but I would not pay a middleman if I was you and, you know, the person hiring you probably knows less than you.
There's a way to, let's say, present your experience, not as a WinForms developer. I would I would never mention WinForms, to be honest with you.
I just don't bring that up. I would call it enterprise level desktop applications.
That's what I would say. And I would put that on my resume. And I would say that I'm experienced developer in dot net.
If you can find a way to pseudo legitimately mentioned dot net core, great.
Anything modern and sexy. The idea is most people hiring you, especially if you're looking at big companies, are just checking off boxes in an Excel spreadsheet.
So, right. I mean, there's always that question, too, of like how how connected are they really to the specific development going on?
The other thing I would say is at least when I've been involved with interviewing or applications or looking at prospective candidates,
unless you have like a really fixed job that's going to be very boring and not challenging,
being able to learn and adapt and grow is an essential skill of a software engineer because, you know, the business needs are going to change.
You need a new API. Suddenly you have to integrate with a partner and they only have an SDK that supports this platform or whatever it might be.
So not only does that say like, OK, well, what is this business doing and why are they so static?
And then also, when you're looking at prospective companies, sure, you don't necessarily you know, not every position is right for someone who has like not direct experience in a particular thing,
depending on timelines and what their needs are as a company. But if they're not willing to invest in someone who is interested and capable,
they're probably not a place that you want to work. And you you might not see a lot of growth or mentorship there and doesn't seem like a great option.
Right. And I would also add just kind of riffing off of what you said, because you spark something, you know, I get a lot of calls for people who need pre arc,
which is an automatic automatic reference counting on Mac OS and iOS, meaning you have to do your own, you know, retain release cycles for memory management,
sort of lower level stuff, right? Lower level Objective C development. Why?
Because as Swift has become popular in various cross platform solutions, which, which I mean, I do more, I do more Xamarin than I do Objective C work right easily.
But there's so few people who can actually still do that work in my area, in my area being like the eastern United States that want to do that work, at least that at some point,
knowing the older technologies, but frankly, as an asset, think about, I know, it sounds crazy. And I know, like old iOS and old Mac is maybe not the best illustrative case.
But Fortran developers, something that's not so well kept secret is Fortran developers make a ton of money right now, because there's just not that many of them.
And some of the biggest banks and government institutions in the country, hell in the world, run on Fortran.
Yeah, that is absolutely the case. And perhaps, unfortunately, although Fortran has certainly has its place, like, you know, anywhere you have matrices to multiply.
Bring this back around a little bit. You mentioned, you know, things like the.NET Foundation and using, you know, careful diction around how you describe your experiences.
And sometimes, yeah, that when the tech isn't always a mismatch, right? I like to focus on abilities to learn new things, times that you've been able to do that, experiences you can show with that.
And then, you know, the other half, a lot of this stuff is doing your own project management and having an experience of actually finishing things, right?
It's all well and good if you, you know, you have some person who just graduated school, knows all the complexity for all the algorithms.
They've implemented A-star like six times that day. But that doesn't mean that they have the sort of experiments where you've shipped a lot of solutions and supported them.
So if you have some more actual experience in the field and can speak to that instead of perhaps the direct technologies, that might also help.
Yeah, hell, just email me your resume. I'll rewrite it for you. Don't worry about it.
That's amazing. And of course, you know, there's always the routes too of just trying to do more personal projects, maybe collaborate on an open source project.
Just get something out there to say like, yeah, I haven't, you know, I don't have five years of experience in this, but I've been a developer and look, I know my way around.NET.
Yeah, not to be a shill.
Well, it's too late for that, Mike.
Thanks. I know. But what kind of shill am I today? We have to spin the wheel.
No, so I'm a member of the.NET Foundation. It's charity, open source, blah, blah, blah.
They have like a list of projects that need help.
So if you are an experienced.NET developer, these are all FOSS projects that are in need of just like development support, QA support, whatever.
Maybe look at one of them and just like your contributor.
For instance, I'm a sponsor of the Avalonia project. I haven't written really any code for Avalonia. I've written a little bit.
I've done some patches for certain Rust projects.
Like if you really need just like a couple of things to make the HR manager happy, one line of code makes you a contributor to a project.
And it can be like a simple correction.
And I am not trying to, I know we're going to get like hate mail on that, but I'm not trying to say that like you should scam this, but obviously you should help the projects.
But these people, especially these larger companies that are looking at your resume, don't know the difference between line of store vaults and a guy who just updates the documentation for Ubuntu from color with a U to color without a U.
They can't tell.
Absolutely.
This is the same reason you see stuff for brand new languages and job postings say that, you know, we require five to seven years of experience in TypeScript.
That's why Swift exists.
Oh, yes. Yeah, you're right.
Oh boy, Mike, you were really on a Swift hatin' bandwagon these weeks, huh?
You know, I've been very consistent for the last, what is it, four years, five years now?
I feel like there's been at least one or two times where you've, you know, reconsidered a little bit.
Everybody goes crazy every once in a while, Wes.
But I think we have some sad news.
I don't want to bring the party down here.
Yeah, no, it is true.
Unfortunately, there has been some sad news.
And if you've been listening to some of the episodes that I've been on here at our little program, you know, I'm a fan of, how might you describe it, Mike?
Slightly more esoteric programming languages.
I would call you a wizard with a long beard in a giant white Haskell closure tower.
Is that fair?
Yeah, absolutely.
And a lot of that, I think, is just, I mean, I'm interested in it technically, the computer science, the math, the theory, different techniques.
But there's a certain excitement that computers, computer science, technology still holds for me.
And it can be complicated, I think, especially when you mix, you know, things that you're interested in organically with your professional career.
And many of us, many people listening to the show have done that, right?
Like, you like computers.
That's probably why you got into this field.
But now you actually have a job, and that's what you're doing, right?
So you work on some boring features.
You implement yet another API.
There's lots of other more interesting jobs to do, of course.
But they're just rote tasks, and we have to do it.
We have to get that work done.
And oftentimes, whatever Java C, Objective C perhaps, the standard choice is just what you want to go with.
That's always going to be the case.
But I think we need to not just lull ourselves into thinking there's only one way to do things.
Or, you know, I just learned the design patterns from the design pattern book, and I don't ever think about it again.
And I just go implement that.
Don't get me wrong.
I don't want to come across saying, like, you need to, like, really overengineer everything.
You absolutely should not.
But it pays dividends, I think, continually, which is why we were just talking about TypeScript, right?
Like, a lot of this stuff has been developing out of academia since the 60s and 70s and slowly percolating into everyday programming use.
As we've decided, you know, which of these things actually make sense?
Is this being too restrictive?
Can we still get our work done?
And a lot of it has just been figuring out all the ergonomics.
And so while there are practical benefits to doing that, for me, it just comes down to excitement, you know?
Like, it's such an interesting world, the ways that we've tricked sand into thinking.
And, you know, we've created these magical devices where suddenly, just at the powers in your fingertips, you can summon whole worlds into existence.
And one person who really inspired me in that realm, even though I know I talk about things like Erlang and Elixir,
I have only used them just, you know, in my own spare time, not ever professionally.
I just think they're interesting as a technology choice and philosophy behind them.
One of those people that is so inspiring has been one of the Erlang's co-creators, Joe Armstrong.
And so I'm very sad to report that this week we learned that Joe Armstrong has passed away.
Yeah, obviously, you know, for those who don't know, he's, you know, there's a whole generation of old software engineers that are going to start passing soon.
And he's definitely one of the big ones.
If you've never heard of Erlang, Wes, you're probably better to actually describe Erlang than I am because I think I'd oversimplify.
Yeah, sure.
So Erlang evolved out of actually I think it was first implemented in Prologue of all things, but a lot of it evolved out of Joe's work on his thesis when he was at Ericsson.
And so Ericsson makes all kinds of VoIP, telephone, telephony systems.
And those are some of the earliest examples of these sorts of big distributed systems that have to maintain high uptime.
And that was the world that he was existing in and the problems of his employer and the problems he was working on every day.
So Erlang grew out of that, totally targeted at these applications that, you know, people get really upset when their like branch office phone system goes down and, you know, no one can call anyone.
Especially these are still the days where we didn't, you know, we didn't have fiber links places.
We had even if we were on some sort of Internet or whatever, like this was mostly all just going over the same phone systems.
Yeah, I mean, that's absolutely correct.
I mean, I think some of the more hipster current uses of Erlang that at least I've heard of are we love us some concurrency, right?
Because that was one of the big needs of those old telephony systems was concurrency.
And Erlang just doesn't blow up as easy.
It's weird.
And I'll prepare for the hate mail here, but in a lot of ways, Rust reminds me of a more modern, maybe not implementation, but a more modern.
Let's say a great, great grand niece of Erlang.
I mean, I think there are definitely some some things that have inspired both languages.
And one of those is acknowledging and this is something that that Joe would often talk about acknowledging that programmers are going to make mistakes.
Right. So in Rust, a lot of that's like, look, you just can't manage memory by yourself.
You're going to mess it up. Maybe not you.
But, you know, out of 10 of you, most of you are going to just get this wrong.
Out of 10 of you, 12 of you will screw up the memory management.
Correct. Yeah.
And Rust also has some stuff for reasoning about concurrency and deadlocks, which is which is really neat.
Actually, we don't talk about nearly enough on the show.
Yeah. As long as you don't use that unsafe keyword. Right.
That's actually the comparison I was trying to draw.
Wesley, I think you put it a lot better that it's the idea of managing your concurrency in a safe way and obviously being memory safe.
Where, you know, one thing in all the time we've been doing the show, we do not talk about the bad things.
Maybe we should one day, Wes, that can happen when your memory is not safe and when you really screw up other than just like your your little app crashes.
Right. There can be particularly in the context where one might have used Erlang running, you know, a big phone system perhaps for a major carrier or a major.
I guess they weren't carriers, but a major phone company at the time.
That's important. Right. Those those little memory bugs can increment to be a catastrophic failure.
Yeah, especially when you have this long uptime, it's running for four days and it has to maintain, you know, does this this complicated stateful thing.
Right. And people don't accept that their phone call didn't get through.
I mean, this is yeah, this I mean, yeah.
Dr. Armstrong was a in a weird way.
I mean, obviously everybody works in a team, but in a weird way, he was a pioneer because he was so present.
I mean, you have one of his posts that I just hate in the doc today.
Why? Oh, sucks. Thank you, Wes, for that.
But most everything he did, like if you are working in a you know, I'm going to go on a limb here.
My opinions do not necessarily reflect those of JB Linux Academy or Westpain.
I think without Dr. Armstrong F sharp, which is my preferred functional language rust, which is like neck and neck with it, but it's not really functional.
We could fight about that later. Just simply wouldn't exist.
Right. The ideas that were invented in Erlang, though, yes, Erlang is a little older and a little more, I would say, an esoteric language.
The ideas invented there have influenced, frankly, all of the cool hipster languages that we're using now, even Haskell.
But certainly things like, you know, like I said, rust, F sharp, Elixir, things like that.
Yeah, no, that's that's absolutely the case. I think one of the big ones, you know, as we were talking about, developers are making mistakes.
As as with concurrency, there's a there's a library that goes along that's very popular in the Erlang community called the Open Telecom Platform or OTP.
And a lot of that it really embraces that you're going to make mistakes.
It's going to happen. And as they like to say in the Erlang community, just let it crash.
Right. It's just going to crash. Let it crash. And they've built in this notion of the supervision trees.
Right. And many people run into this if you're doing maybe like a Django app or something with Ruby where you've got workers that you're managing and you have some process supervisor that sits there and restarts them when they die and make sure you have enough of them running for however many CPUs, whatever, all that stuff.
It's just like a bad version of Erlang because you've built it in and much like in like the Rust world or Haskell, when you started using some of these monads, you know, you're doing stuff like either where you are thinking it's for the compiler is forcing you to think about, yes, this might be null sometime.
Right. And in the same way here, you're like, this might crash. You're going to have to start thinking about, do you want it to be restarted? What does it mean?
Do you need to restart the supervisor above that? And I think the big theme there is a systems thinking. Even when Erlang only ran on a single box, it was distributed systems thinking.
Absolutely. Absolutely. So it's so funny you mentioned the Ruby case. I have a real world example here, and I think I mentioned it briefly about a month ago.
I have a relatively large Rails app that processes extremely large STL CAD files. So these are files that are scanned. It's actually kind of cool. Hopefully I can talk about it in more detail in a few months. But there's these things called light scanners, Wes. Have you ever heard of them?
No. Tell me more.
So a white light scanner is like a handheld scanner that scans objects like physical objects and creates a CAD file off of them or from them. I guess there's a more accurate way to say that.
Oh, yeah. Okay. I just hadn't heard the term. But basically, yeah, you shoot a bunch of lasers or whatever at an object, measure reflections. I'm sure there are many techniques.
Yes, the lasers. I love it. Okay. So I had a beautiful little Ruby helper in my giant Rails app that did this. Unfortunately, you know, randomly when we had a lot of usage, STL files weren't being processed.
It's just like nothing happened. Why? Well, because the concurrency model in Ruby is I don't want to hit this too hard, but absolutely terrible.
Oh, yeah. I mean, it almost doesn't exist.
So here's what happens. If the worker, and I'm not going to go into like delayed jobs and all this stuff.
Oh, delayed jobs. You're triggering me, Mike.
Yeah, no, I'm going to keep it at a high level because I know it first physically hurts Wes when I go too far into the Ruby world. Are you familiar with the cowboy movie Shane?
No, I'm not.
So, you know, I don't want to spoil the ending, but let's just say if anything went in any way wrong with the worker thread, and I'm using that loosely, it would just kind of ride off into the sunset with no warning, no error, no nothing.
Right. Nothing got told. It just silently dies, and there's no way to fix it. So I forked and rewrote what I needed in Rust, and actually I owed them a patch back. I forgot. I will. Sorry, guys.
Look at this. We're keeping you accountable right here on the air.
Keeping me accountable. No, I meant to PR the patch back to fix the – I found a bug in the little – well, not little, but the Rust project.
Not Rust lang, but the Rust library that I'm using for this. I wrote a simple Rust program that implements this library that does what I need it to do for my application, calling into this open source library.
I cut my memory usage by 90% on each STL, and I have not yet seen a case where it crashes, other than like if you intentionally give it like a bad path, right? Like a bad, you know, a file that's not an STL file.
Yeah, right. Input that basically hasn't been validated.
It was a harder program to write than the Ruby equivalent, for sure, but –
Why was that?
Well, Rust – I like your word accountability, right? Rust keeps you accountable. You can't just like, you know, write off and just throw variables, cast variables willy-nilly.
You have to – you can't throw memory around. I don't even – I don't want to go into too much detail about how this program works.
Basically, it's – if you think about the size of your average STL file, and you think about how the Ruby garbage collector works, you're going to have a problem.
Let's say 70 megs is what we're talking about here.
Okay, yeah.
Where Rust is like, no, I want this memory, and I need it, and then I will tell you when I don't need it. It's just fantastic.
Also, the performance – I mean, just the baseline performance difference between Ruby and Rust is kind of, you know, huge, right?
Right, yeah. So you had to spend a little more time diving in, handling some things for yourself that you might not otherwise.
But in this case, because of just the nature of the work and the problem space and the fit of the language, a little more work means a lot less work later supporting it.
Well, yeah, right. And the other hero here is, of course, the kind of Unix model of you can just have two programs that make up your wider system and, you know, literally pass information from one program to the other and then pass it back.
So that's effectively what I did. But bringing it back to Dr. Armstrong, like the entire Rust language – and I'm not trying to shortchange the Rust community or the Rust team here even – just wouldn't exist if it wasn't for Erlang and therefore, by extension, Dr. Armstrong.
I mean, that's – I will die on this hill.
Yeah, I mean, I think there's obviously lots of inspiration. Another one that comes to my mind immediately is Akka, right? The Scala framework for doing actors and stuff.
All that stuff, while not necessarily invented in Erlang, was fleshed out and developed and brought into the real world.
What about your language of choice?
You know, Clojure, you mean?
No, of course I mean Clojure.
Well, you know, it's interesting because, as I said, I don't do a ton of Erlang. Really, I've played the most with Elixir.
And I just see some parallels because both – so Rich Hickey, the founder of Clojure, is another developer, speaker, writer, thinker, whatever you want to say, whose work and thoughts I admire.
And they're different, right? I mean, they've made very different languages. And in particular, I don't think that Rich really likes the actor style of programming very much.
But both of them have very much valued this de-complexing things to, you know, minimize state, keep track of that.
And that's one thing that, like, when you're programming with an actor framework can happen because instead of, you know, having all this shared memory that you're all immutably messing with, you're sending messages between different processes.
Even beyond that, though, I think they're both thinking about things from an outsider's perspective and willing to come at ideas fresh and both be excited and talk about them and develop conversations that others might think are solved problems.
And they both remain excited. So you can get into all the specifics, but even without me, you know, knowing that much about Erlang or knowing any of the frameworks, all of Dr. Armstrong's talks are just great.
I'll have a couple that I like linked in the show notes. So here's an example, actually, from one of his talks where he's talking about trying to work on his presentation and ran into some updating problems, right?
Where, oh, no, well, keynotes not working due to some update from Apple. And, oh, gosh, so he started looking into making this stuff with HTML.
And so I Googled a bit and I found a project that said you can make nice slideshows in HTML and they can produce decent PDF.
And so I downloaded this program and I followed the instructions and it said I didn't have grunt installed.
And I'm an old guy, so I didn't really know what grunt was and my grunt files weren't right or something. So I Googled a bit and I found out what grunt was.
Grunts, I still don't really know what it is. So I downloaded this thing and I installed grunt and it said grunt was installed.
And then I ran the script that was going to make my slides and it said unable to find local grunt, but I just installed grunt.
So I turned to Twitter and tweeted, you know, I'm having a really bad day here. It's unable to find the local grunt.
And Twitter is very helpful because people say, well, your grunt path is incorrect, you know, set your grunt path.
And so I gave up. And I just love that. I mean, sure, in one way, you can see that as, you know, trying to fight with this dumb new software.
But really, we all have had those frustrations. And the way I read his attitude is, you know, he's playing with this.
Even as an older person at the time of this talk, as someone very experienced in development, coming at these new tools,
he had this willingness to learn and embrace and, you know, even into the later stages of his life was excited about that.
And one example I liked from the post talking about this over in the programming subreddit, a nice comment from someone.
The real John Freeman writes, about two weeks ago, I came across Dr. Armstrong's blog for the first time and poked around at a few posts.
I noticed he had recently discovered tiddlywinky and rewritten his blog in it.
His post talking about his eureka moment with tiddlywinky had just the feel of a very young, excited writer.
And so I was so surprised to later discover his age and hear of his passing.
And I just thought that was so true because there are some people and Dr. Armstrong was definitely a case of this that are, you know, just lifelong learners.
And it's a value I hold very dear to my heart. And I think many in our communities do.
And it's just, it's so easy to get jaded, especially, I mean, how frustrating and dumb are computers on an everyday basis.
And the more software you write and layers you peel back, you just, I don't know about you, Mike, but I'm always so frustrated.
And just like we've layered so many levels of abstractions and wrong choices over the years.
So I find it really nice to have wisdom from people who've been there, who've helped develop some of those processes and aren't jaded,
who want to fix things, who are arguing to make things better, simpler, de-complected, but are not doing so in a vitriolic way.
You know, if I personally could learn one thing from Dr. Armstrong, it's be less of a jerk.
I mean, if I've read many of his posts, I've listened to a lot of him on YouTube before I even knew who he was.
Yeah, right. I mean, you see them and you're like, hmm.
Yeah. And even when he didn't like something, he was always, you know, good guy, you know, good guy Joe, right? Joe Armstrong.
I think we could all be better at this. I really do.
You know, sometimes this is neither here nor there, not a topic for this show because we have like, what, three Linux shows on the network now?
Yeah, that's right.
Some of the feedback on 1904, Ubuntu 1904 for folks who aren't Linux users, has been mostly positive from my understanding.
But, you know, every five or six Reddit comments, there's the crazy guy who hates it for some reason.
And he may have a legitimate, like, problem.
Like, I've had my share of problem with Misa utils that we talked about.
Oh, yeah, absolutely. And no distribution or release is going to be perfect.
You know, one thing I'm going to try for myself at least is if we can go forward in a more productive way, right?
Not saying, OK, this stupid, what is it, grunt? Was grunt the JavaScript thing he needed to?
Yeah. I mean, I do believe that all of that's bad.
As we've discussed a little bit. Yeah.
Right. At length. Right. Like, listen to episode was at once. I'm sure Chris will put it in the chat room.
164, I think. Maybe it's too. I don't know. He'll figure it out. The Swift one.
There's maybe a more productive way to convince people to do things differently.
Particularly those of us who work in a Linux world and an open source world.
I think this is kind of the lesson. Just have an open mind.
You know, if someone says, hey, there's this cool thing like Marzipan coming out on Mac OS in the summer, right?
You know, we're going to cover Marzipan on this show because we are.
Have an open mind, right? Even if it's something as simple as, you know, Microsoft contributing all these snaps to the snap project into Ubuntu.
I think somehow that by being a little more open minded, the tech community,
but also more importantly, the open source community as a whole would actually do more impressive things a lot faster.
Does that make sense, Wes? Or does that sound crazy? No, I think I completely agree.
And it's it's those values, that approach being available, always excited.
We'll have some links to some other eulogies for people's thoughts on Dr. Armstrong.
And one thread I kept pulling out is, you know, how available you can see his talks.
And if you if you were lucky enough to go to any of the conferences that he was attending, then you know that he was just an excited person.
It wasn't didn't think about status or or, you know, records or achievements or any of that stuff.
He was just genuinely excited about life.
One of the links is a great little write up by one of his day to day co-workers just talking about what he was like to be in the office and how, you know,
he would find some idea that would happen in and would just want to discuss it, would make noises out loud until someone would come over.
You know, he would just get so excited until he draw someone in and they would want to talk about it with them.
So that I think the twin things of being, you know, having an excited spirit about making things better and discovery and renewal.
And then at the same time, keeping an eye towards simplicity, simplicity and systems thinking.
They're just going to be Dr. Armstrong's legacy for, I think, time immemorial.
And I've just got one more clip from from that same talk that I think speaks to that.
Right. So we've made all this mess.
Dijkstra said that computing was about controlling complexity and we have failed miserably.
OK, I think one way to do that by I think about 128 kilobytes of stuff is about the limit to what the human brain can can can do.
The only way to make reliable systems and modular composable systems is to make them out of small units which we can validate and then connect them together.
I think we know how to do it in a way. We actually need to reverse entropy.
We need to take we need to do the opposite of you see GitHub is sort of cloning off things and it's getting bigger and bigger.
We need mechanisms to make things smaller and smaller.
Quantum mechanics does set these kind of upper bounds on what is possible.
So when we're figuring out the complexity of algorithms, we need to be aware of that.
And we also need to be aware of the state space of what we're doing is is enormous.
And that's why I mean, if we relate the complexity of the program to the number of atoms on the planet, we'll see the very, very small program has as many possible states as the number of atoms on the planet.
It's just enormously complex. We need to abolish names and places and replace them with hashes.
And we need to set up global distributed hash tables and things like that.
And then we need to make lower power computers that don't do environmental damage.
We don't really want to fry the planet in answering all our questions.
We need to make these carbon neutral powered by solar panels and things like that.
We need to get down the energy of computation. Computers are becoming a big environmental threat.
They're using more energy than air traffic and things like that.
And this is something while we can probably do without.
Well, no, we need both air traffic and we need computers. One is capable of going down to a very low energy.
The other is not. And computers can be made to operate at extremely low power.
We need to do so with a degree of urgency.
So that's what we've got to do. We've got to clean up the mess we've made.
Thank you.
And I think he's just spot on and we just all need to go get to work doing that.
Can't agree more.
All right. Well, unfortunately, we've got to move on with our program.
This week, I saw an interesting little article and we're not going to dive into it or anything.
But just making the point that if you were going to be a writer, right, you're trying to become an author.
What do people tell you to do? Like the first thing, right? I mean, obviously you have to write, but you also you need to read.
And so this article kind of laid out some of the importance of if you're trying to become a more experienced software engineer,
developer programmer of any kind. Yes, you need to practice the actual act of your craft.
But it is just as important to go out and look at how others work, because, you know, we all interact with programs on an everyday basis.
But that's very different than taking something that you've never touched and becoming familiar with it and reading it and understanding it.
So I like this article had some good tips about, you know, actually go get the code and and run it and then maybe start writing tests to try to help you break it down
and do some deep dives and analyze how the control flow works. I just thought it was it was a good little moment to reflect on.
You need you need to check things out because I'm always surprised by the little things I learned.
I remember like when I was first starting up, I think it was VB6 and I remember like going to some forums and this was before, you know,
any sort of like nice online version control. So it's just like browsing little like a snippet website that would have these like terrible visual
basic snippets that I would copy and paste. But that was enough to, you know, get me going.
And I could take that and I could learn from that. And it's something I really still try to do today.
So really, I just want to bring it up because I've got some I've got some stuff, dear audience, if you're interested, that you might enjoy reading.
And one reason I like Clojure is yes, sure, weird syntax, but it's very concise. And I find that makes it very easy to read.
So I saw this pop up over in the Clojure subreddit this week. And it's just it's like a it's a nice little Web app for Tetris.
It's almost complete in terms of like Tetris functionality. You can totally go play it.
And honestly, that's what I did just for the first, you know, 10 minutes of looking at this thing.
But the other nice part is it's just right up on GitHub. It's totally self-contained.
You can go check it out and clone it and get it set up. And the main the whole heart of it.
Is like a 500 line file, just just a 500 line file. And you can just read it straight down, you know, like an article.
It starts off at the top and define some data structures to describe the actual Tetris blocks and how they're laid out in the grid.
You can go read about the collision detect detection algorithm. It's just all right there.
And unlike, say, maybe like a Java library or a dependency that you're looking at where you have like, I don't know,
a thousand different files and different folders and arbitrary hierarchies that you have to try to trace and keep in your head.
This does seem like a nice self-contained thing that you could understand.
And I know a lot of people are interested in games and stuff or maybe just want to get learn more about how to create that sort of thing in the Web.
Check this out over on GitHub. DJ Blue is implementation of Tetris.
And I've also linked by another Clojure community member, Sean LeBron, who made the very nice power infer plugin, which is the topic for another day.
But he's actually got an interactive Clojure script presentation.
So it's a Web presentation that builds Tetris in the browser as you go through the presentation.
And you can interact with it and play with it and tweak the code. It's great.
That sounds amazing. And I heard that you're going to be out and about pretty soon.
Oh, yes, that's right. If you haven't heard and I feel like if you listen to these shows, I don't know how you how you didn't.
Linux Fest, Northwest, JB's home conference is coming up this weekend. Yes, that's right.
So we're having basically a big old JB blowout. People are coming in, I think, starting tomorrow.
The first the first people arrive. So there's going to be people all over the studio.
You're definitely going to want to check out JBLive.tv throughout basically this whole week and the weekend, because we're going to be doing some live streaming, like check out the Friday stream that's coming up 2 p.m.
or so on this Friday live JBLive.tv. And of course, we're going to be doing our Linux Fest Northwest live streaming.
So there's lots of good content. If you're interested in that, you couldn't make it out this year, but you still want to see all of these wacky characters that you know and love.
Well, we'll have it for you and a whole lot more over at jupiterbroadcasting.com. Sounds amazing.
Catch a beer with the JB guys. Yeah, exactly. And I'm finally going to meet some of these people that I get to talk to, but I've never seen before.
That's right. So also, if you are a middle school or high school student or you know one and that student is technically inclined, my company, the Mad Vodder, is throwing a little Earth Day contest with us.
Oh, really? Tell me more. That's neat. So we're taking submissions for a month.
We're taking it from middle school and high school students, a technical solution that has to be powered by Linux to help mitigate global warming.
If you can solve it, fantastic. And the prize, we're going to pick one from the middle school age and one from the high school age.
The prize is a System76 Darter prize. Oh, see, that's a prize I could get behind. You said that I have to be a middle or high school student. I can't enter, right?
You do. Yeah, neither can Chris because I'm sure he's foaming at the mouth over there. Yeah.
Well, that's great. So how long do they have to send this in?
They have a full month. So we're going to pick the winner at the end of May and we're going to send out machines and announce it the first or second week in June, depending on shipping and stuff like that.
Well, that is fantastic. We'll have that linked, of course, coder.show slash 354. But also you can find that over at the company's Twitter, right? What is that?
That's at the Mad Vodder Inc. on Twitter.
That is great. And you know, I've heard you're there too, Mike.
At Jumanuco. That's right. If you're looking for a good fight with Kara Swisher, I'm your man.
Oh, you know that I am. And I might just have to join in. I'm at Westpane and you can find the whole network there too. We're at Jupiter Signal.
That's going to bring us to the end of today's Coder Radio. Thank you so much. We'll see you next time.
Thank you.

This is Coder Radio, episode 372, for August 26th, 2019.
Hello, and welcome to Coder Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business, software development, and related technologies.
My name is Wes, and I'm joined by everyone's favorite Floridian, Mr. Michael Dominic. Welcome back to the show, Mike.
Welcome back, Mr. Payne.
Boy, a lot has happened. You know, the last two episodes, they were pre-recorded, but this one is live once again. And not only is it nice to hear you, but I'm excited to hear what you thought about all the things going on in the world.
Yeah, so I, you know, of course, a week where we pre-record, everything drops. Why not, right?
Sounds like you were having some particular problems with G Suite. Am I right?
Pro tip, guys, using proprietary solutions that are hosted somewhere else, unless they're for me, then you should definitely buy them.
Well, that's a problem if, let's say, your entire business runs on G Suite and Slack, but you only talk to customers on G Suite.
And you have to go back to, like, the dark ages of having to explain to people that will actually, can you just, like, I don't know, Dropbox this to me, and then you have to, like, open a Dropbox account because you really need files for a demo.
So for those who aren't G Suite addicts, last week, G Suite had an outage for about half a day.
It was everything from Gmail to Drive. It was the whole kit and caboodle, anything that authed with Google.
I don't know if it extended to the non-commercial G Suite accounts. I probably did. Why wouldn't it?
But it was, I'd like to complain, but honestly, there was no Google chat pings. There was no emails for, like, four hours. It was glorious.
Oh, that sounds nice. Sometimes you just need a little break.
And I suppose that's the flip side of the benefit of they manage everything for you, and while it's frustrating when you can't control it, it also means it's not on you to fix it. You just get a sit and wait.
Yeah, I mean, the reality of the situation is it was fine, right? But then that evening, of course, was chaos responding to emails and going through documents.
And I'm going to just say that I probably have an over-reliance on G Suite right now. But having said that, I've been using it for over 10 years, and this is maybe the third or fourth outage I've ever experienced.
Not so bad considering. I mean, not ideal, but...
All things considered, right?
Yeah, that makes sense.
So how about you? Were you partying it hard?
There's been all kinds of stuff. It was nice to have a little bit of some time away to reflect on all the fun we've had. I've particularly been enjoying the coding challenges, and it sounds like a lot of you guys out there have too, which makes me really happy.
Because, you know, it takes a lot of time and effort to sort of actually sit down and review and try out all these new languages, but there's also a lot of insights and a lot of features.
It's made me think about what I want and need from a language differently. So we'll get into that a little bit more in the show because you've got a check in for us. I'm particularly excited about Mike.
Oh, okay. Well, I can't wait to hear why you're excited, but I sure do. And it was a... Let me just say my explanations will be crystal clear.
So before we do that, let's set up some feedback. First in our feedback basket today is a letter from Reid. Dear Wes and Mike, I'm a fourth year math PhD student and have always had a hobbyist's interest in coding and software development.
While I plan to stay in academia, I realize it's always good to have a backup plan. Do either of you have any insights as to how the software development community would feel about someone with a math PhD but no industry coding experience as a job applicant?
Any advice would be appreciated. Love the show. You guys make a great duo. Well, thanks much, Reid.
I'm curious, you know, maybe you might not have some specific expertise about academia, Mike, but I'm sure you run across many of green coders fresh out of school and I imagine a lot of those same lessons apply.
Yeah, I mean, you know, it's funny in the pre-show I couldn't remember, but I have had previous experience of a place who specifically wanted, I think, master's degrees and now I hate to be specific, but I'm almost sure it was like statistic. They were doing some fintech to use the buzzword things and they would basically be willing to teach you Python.
But that is definitely the rare case for the kind of stuff that I've been doing. It's a lot more, like you said, folks coming in from undergrad or even boot camps or associate programs that might know, particularly the folks coming from CS undergrads, know or remember a lot more of their Knuth and their math.
Right, random algorithmic quiz questions.
Right, although if you are like me and don't have that background, great books by Rob Connery, I think it's called Computer Science for Imposters, which basically will teach you all the basic algorithms you need to know. I'll throw it in the show notes.
Oh, that's a great title.
I think I misquoted the title. It was something imposters. But these young people come out, they're great, they know how do I get through a linked list, which I keep forgetting because the one true language objective seed did not have them. Now they're just Ruby.
I think that speaks a lot for both of them.
Oh, don't even lay the closure on me. But like, you know, undergrads, how can we say this nicely, Wes? We'll blow up your Git history so fast, you'll cry?
I mean, it just there's a lot of there's a lot of practical knowledge, working in a team dealing with maybe larger frameworks than you're accustomed to, especially if you're just writing, you know, one off scripts to accomplish a single task for like a personal use. There's also not always a huge, I think that's changing, but not always a huge emphasis on stuff like testing and reliability in school. What else? What else do you see newbies kind of struggle with or just not have a background in if they haven't worked in industry?
I mean, I could tell you, like the two most common things I've seen are really not getting how important aggressive use of source control is. And by aggressive, I mean frequent, frequent commits.
Right.
And the other thing is maybe a little bit of a cavalier attitude towards legacy. So there was a perfect case a couple years ago that I can think of right off the top of my head. We had this huge iPad app. And because of when it was started, and when I say huge, this is enterprise level. This app is effectively a custom tool for this company. And it's just like, they run their business, their shop, floorman, all have iPads, right? And this app was in production already for like three or four years.
So it was a big old bucket of Objective-C with a ton of CocoaPods. And you know, Swift had come out, the world had changed. CocoaPods kind of, I mean, people still use CocoaPods. But I think at the time, Carthage was becoming more popular. I don't know how familiar you are with Carthage.
Oh, not really.
It's basically just another package management tool. There are reasons that it maybe is a bit more modern than CocoaPods. And actually now Swift does its own things too. But back then, it was really Carthage and CocoaPods. And this, you know, very well meaning new developer decided he was going to rip out our CocoaPods dependencies and try to replace them at Carthage.
Well, we had pinned some of our dependencies to specific versions, because of course, part of this app was not using automatic reference counting, because it was so old.
You did say legacy at the start of this.
We're talking like circa, when did Swift come out? 2014? So this must have been like 2015. And the app started in like, 11 or 12. So there was just a lot of stuff that had gone on in the Cocoa Touch ecosystem since this project was kicked off.
So that was a build breaking experience. Luckily, through the powers of Git, we were able to undo everything. But he had a hard time and it was kind of a conversation about, yes, you're probably right that there are memory leaks in the manual memory code. But they're small enough, they don't matter.
And two, the investment required to actually rewrite all of this legacy code and get it to the tested production standard accepted by the end users, you know, level that we needed at just isn't going to be worth it until they release, you know, well, almost like what they're doing now with Swift UI, right?
Until there's a major platform paradigm shift, where we don't have a choice.
Once you already have to rip everything else apart. Yeah.
Right. But what about you? What's your what's your war story?
Well, I was more I was more thinking of positive things to go along with your your war stories here.
Of course.
And I think there's many developers who kind of shy away from some of the more math oriented things, you know, you go through you slog through maybe you're like couple terms where you do like you do a bunch of graph stuff and prove some theorems. And then you know, then you're back to like, implementing stuff or testing stuff or writing some Java. And that's okay.
I think having familiarity with math, especially if you're going to work on, you know, more complicated algorithmic sort of problems that can be really handy. So read, you might want to sort of just stay current in in that sort of areas, especially maybe some machine learning areas where more math and computer science start to mix, you could be especially effective there.
Also, just start looking at projects and in languages or projects that you're interested at, because one of the one of the skills that you may not get in academia, but that you'll definitely need an industry is being able to just struggle through a bunch of someone else's bad code and understand how to work with it and make whatever changes you might have to because you as Mike's talking about you often aren't in the best ideal sort of scenarios, but you're still going to have to make it work.
There's always going to be legacy. And if you can figure out good tools, get some practice in learning how to modify that, knowing that most of the stuff you're going to work on, it'll likely be supported for years. That'll be useful.
Yeah, I like that. And I have to say I was not a huge mathy person. And in the last couple years, I've started having to go back and be like, okay, maybe I didn't need to burn through the canoe quite as much reckless abandon.
Yes. You know, you might also just be interested in some more of the functional languages, maybe some, some stuff like Haskell, or even more esoteric languages than that. Also, a lot of a lot of math in school can often be problem solving. And those skills I find translate really well. So focus on that to be able to break down a problem, model it and work your way through each of the steps. That's a useful skill everywhere.
I admire your discipline, sir.
Okay, well, thank you for the email read. Let's move right along just a little bit of feedback we got about one of our last episodes over on our subreddit coderadio.reddit.com.
User Ninja Aaron has a little FYI, and I totally should have mentioned this FYI about wanting interfaces in Python, that you basically just want abstract base classes. And I totally should have mentioned that user jam 163 notes, I agree with what's his point about preferring interfaces in abstractions. It seems to me that abstractions targeting interfaces are more reliable than abstractions deriving functionality from base objects.
So I think there's some there's some interesting intersections there and probably kind of why I didn't think to mention abstract base classes. It's just not the preferred way I have of modeling. And I kind of like the polymorphism and other stuff, all the cart that you can get when you break those things apart. But Python definitely has that functionality. Thank you guys for pointing it out. That's very useful.
Also, as a small little side here, I've been playing more and more with like some of the later Python three releases. And it's really, it's really getting to be a nice language. Again, I mean, I've always liked Python, but some of the modernness and some of the newer API styles and libraries that have come around, it's, it's, it's a pleasant place to be.
I don't know. Python is like a mean Ruby, as far as I'm concerned, but we could just keep moving.
Yes, well, that's a natural segue to our final little bit of feedback today from Dex asking about breaking and changes.
I developed a niche Python package that has some user following in the network security realm, but I'm at a crossroads.
A change I want to make will subtly break scripts that work in previous or in current versions. The end result of my pending change is good for the project, but I fear it'll ruin the workflow of all the existing users.
Other than my GitHub page, I don't know how to query or inform the users of this pending change.
What do I do?
Well, what do you think, Mike? You know, this is an interesting question. It comes up a lot and just step one, asking this question, thinking about it. Well, that's good.
Yeah, this is a tough one. I mean, I think if you're thinking about it and not just either protecting a legacy forever or making breaking changes willy-nilly, you're already 10 steps ahead of most people.
What I have done in the dark old days when I used to maintain an Objective-C networking library, yes, it's all Objective-C today, kids.
Oh, interesting story.
I did briefly, and briefly is defined as I think three months, support the non-ARC version of it on a different branch.
This is before people were using CocoaPods and fun stuff like that. This is way back in the bad old days.
So people would just literally like the way you got it. It was 10 classes. You just downloaded the, you know, git sub modules. I hope most of you know about that, right?
Oh, yes.
But eventually, I was pretty clear that this is a 90-day extension. I'm not going to delete it or break it. But after 90 days, you know, I'm not going to support it.
That's one way to do it. I can't say that I didn't get any mean emails. I don't know. But remember, you're doing this for free, which is, I think, something we're going to cover in a future topic here.
And, you know, it's really not a service to your users or, I'm sure, yourself to pin your code, your library, whatever it is, to an older version indefinitely, right?
This is one of those hot topics that I'm very hesitant on because I'm pretty aggressive. I'm liking to push things forward when I'm maintaining them. But Wes, maybe you're more conservative?
Well, you know, it always sucks when stuff you rely on breaks. So clarity is good. It is an interesting question of how to communicate this.
You know, it's a little easier if you're working in like a business relationship or in a team relationship where you can kind of sort of force everyone to have a meeting. But that model doesn't work so well in open source, necessarily.
If you can avoid breaking, I would say do so. Sometimes you can keep legacy functionality around and just sort of mask it or rebuild it on top of newer features.
Another option might be if you're not already using something, you could consider more rigorous use of something like semantic versioning.
Or another option might be to just make a new project, you know, fork this off. If it really is going to be different, if it's going to break things, make a note in the old one, say that you're deprecating support for this existing version.
You know, maybe a link in the README to the new one and then go happily develop not considering anything else over in the new repository and you'll have total freedom.
Now, it sucks like we're very particular about names and you have to come up with a new name. That's the hardest part. But if it's a new thing, if it's different enough to be breaking, maybe it deserves a new name.
Yeah, that's a powder keg in itself, too.
Yeah, it is. It's a tricky situation. But I would say if you if you can just make a new one, then then do it. Otherwise, make it clear how people can use their existing stuff.
It's probably trickier to that it's a script like you don't have maybe don't have all the tooling that nice package managers do to pin versions and other stuff that you that your users could rely on.
If they're just grabbing the latest code from GitHub that that will break.
I mean, maybe a unpopular anti RMS suggestion here is, you know, there used to be lots of businesses that what they did was like customize open source things for other people.
You could totally if you're getting complaints from someone who has the means or the desire to pay for that, say I will, you know, say I'll do it for a fork for you.
But you'll have to pay for the time that contribution takes. That's not unreasonable, right? People are paid to contribute to open source.
Absolutely. Another option here, too, might be just to start the conversation, make an issue with the pending changes and your proposed implementation changes.
Possibly users out there will have some sort of compromise that'll work for everyone, but you won't know till you try.
Or if someone else could pick it up. Yeah, like Wes was saying, someone else might just pick up the mantle.
Exactly. All right. Well, speaking of interesting changes, Mike, I saw you chatting away about some stuff in rail six.
And it's been a while since I've used rails and I haven't used six at all. So maybe you can break down what's so interesting over there.
Yes. So rail six is, you know, interesting, like buying a new Subaru. It's a little nicer.
You've got maybe one or two features you're not so sure about, but it's basically the same.
You're familiar with the brand and most of the models and it's just the latest version.
I mean, they're pretty keen to tell you about Action Cable Testing and Action Mailbox.
I think most people, particularly in Action Mailbox, I think most people are using like SendGrid.
Action Text is interesting. So you can have like fancy text content, bridging it to rails a little better than you could before.
Oh, yeah. Here, listen to this. Action Text brings rich text content and editing to rails.
So it includes the Trix editor and then it sounds like it's got some like rich text model already made for you in the back end that you can tie it to.
Oh, yeah. And then any embedded images are automatically stored using active storage and associated.
So you want to have fancy text. It's a one stop shop. Interesting.
I mean, there's a few removals. None of them are devastating, although I think the one.
So there used to be a thing where you could do config dot secret token, which is exactly what it sounds like.
You could have manly just, you know, in plain text, put in your secret token.
That is a deprecation that is going to catch a lot of people with their pants down, I think.
But yeah, you should not be doing that in 2019. So I think it's a good idea to remove that.
And to be clear, that's a straight removal, not a deprecation.
In fact, if you've been using Rubocop or any other kind of rails linter, you have been getting yelled at for using that.
Good. My biggest thing is actually that it's including Webpack now in rails.
So Webpack, the JavaScript packaging tool. I'm mixed on this.
The applications I tend to develop are pretty much, you know, build the HTML, JavaScript and all that horrible crap I don't like to deal with on the back end and send it to the front end.
But, you know, rails does have to compete with the, you know, with the hot new kids and more and more, especially for, I would say, consumer facing things.
You want to have a little richer JavaScript experience.
I mean, we talked a bunch of the languages we've done in the coding challenge, you know, have compiled the JavaScript.
God forbid you're using ClojureScript.
Yeah, absolutely. Let's hope you are.
Oh, geez.
Or Fable, right?
You could be using Fable, again, if you're using Fable and rails together, I have to wonder what happened.
But sure, you could.
So they listen to like Mirror Universe, Michael Dominic, I think.
Yes, that's like when I'm on one of my dot net kicks.
I don't want to downplay this release because I think it's actually a pretty important release.
There are changes if you're coming from Rails 5.
So, you know, it's not nothing, but this isn't like Python 2 to Python 3, the world is ending, right?
Or this isn't even like, you know, dot net 4 to dot net core 2 big.
This is more.
OK, we're deprecating some things you shouldn't have been doing anyway, or we're straight up removing them in some cases.
We're adding better integration for work.
It's almost like adding a blessed, quote unquote, railsy way to do rich JavaScript finance,
which I kind of like because now I don't have to think about that.
Yeah, that's what I was going to ask.
I mean, were you using other sort of JavaScript compilers, transpilers, packers, minimizers,
or did you just have to learn Webpack as a result?
Neither.
So a lot of the Rails stuff we're doing are backends processing JSON requests from other frontends,
either mobile apps or desktop applications.
Sure.
Some of them are written in JavaScript, but, you know, like if it's Ionic, you're using whatever comes with Angular, right?
So that's a big difference.
That's actually the best example here.
If you're using something like Bootstrap, instead of installing a Bootstrap gem on the backend,
you could actually Webpack it with Bootstrap and have it all be on the client side.
It just kind of gives you an additional layers of toolkits that you have access to now.
Well, if you're a consumer facing site with heavy traffic, that's definitely going to help you out quite a bit
because Rails is not known for being particularly performant.
And also, you know, that processing is now happening on the browser rather than your server.
Right, yeah.
So overall, are you finding Rails still to be like a productive environment,
a place that you want and trust to build applications on top of?
Yeah, I mean, Rails is kind of my, I need to get this done, and I need it to be solid
because this is the kind of thing that's either going to get audited or, you know, it's my default
unless somebody asks me for something else.
Big or you need performance.
Right, because making Rails fast requires, I know we're going to get email,
but Wes is right that it's not that fast.
Wes was right.
I knew that was getting clicked. I knew it.
Sorry. But I mean, you were asking for it.
I really was, wasn't I?
Oh, I guess the other thing that the Ruby people are going to be mad,
yes, there's better testing support for Action Cable.
What's the implication there?
I kind of think Action Cable is a little overhyped.
I'm not familiar with it. Can you break it down?
Yeah, so Action Cable basically was a, oh, I'm going to pick my words very carefully here.
Please do, please do.
I would say Action Cable was a way to breach some of the HTML5 modern web functionality
that maybe wasn't exactly native to Rails.
One of the side issues with that is testing it is very,
or traditionally has been completely challenging.
And I can break that down a little better for you.
So let's say you're using RSpec for testing, which most people are.
Right, right.
The support for Action Cable was virtually non-existent.
There are hundreds of hipsters with gold MacBooks on YouTube
who would love to tell you how they've managed to get 100% test coverage of their Active Action.
Yeah, they've really got to stop using Active and Action.
Action Cable code.
Action Cable also does, if you're familiar with like ZMQ and PubSub models,
you could do that in Action Cable.
That's actually what I think is the best use of Action Cable.
But other people have done lots of other interesting things, chat rooms, things like that.
I can't say I've never used it. I can't say it's bad.
I can say that these types of things are hard to test because conceptually they're just,
the way most Rails testing has gone is really a byproduct of most people using RSpec.
And RSpec was written in a time when it was request, response, server, client.
So now that you're having subscriber-publisher relationships, your metaphors don't match up.
I don't even know how to say it without getting into the deep of RSpec literally expects there to be a request and a response.
Right. It's just hard that the models that they're designed under don't play well together
and you don't get all the nice leverage that RSpec has in other arenas.
And to the RSpec's team credit, they are fixing that.
It's going forward.
Rails 6 makes this a lot cleaner to test.
I've never felt that this was exactly something you needed to kill yourself over not testing.
I don't know.
I'm less of a TDD jealous zealot than most of the people who use Ruby all the time.
But I guess if it makes you happy and you know what?
I mean, don't get me wrong.
Now that it's easier, I will be testing my action cable code.
I'm not saying I'm not going to do it.
I'm just saying I was never going to be one of these people writing my own little testing shim because action is just hard.
To me, that was not a good use of resources.
But we can move on because we're getting out of fact and way into opinion here.
Sometimes that's fun, but let's move on to something that maybe you're a little more excited about and that's our old friend Rust.
I saw an interesting video come out over from the Open Source Technology Summit about Intel and their relationship with Rust.
I mean, we've spoken a lot about Rust for some of your applications, Michael.
Yes.
And we've talked a bit about running it for all kinds of stuff and where it might be a good fit.
Systems programming is obviously one of its design goals and Intel, well, I mean, they design and run a lot of systems.
We haven't talked too much about exactly what they've been working on.
I enjoyed this talk by their principal engineer, Josh Triplett.
I thought maybe we could go over a few of the interesting points therein.
Make it Rusty.
They're going to start and talk about the evolutions of systems and embedded and lower level programming.
As you know, Mike, it's hairy and sure, we've got C now, but for a long time, you just had to mess with assembly.
Systems programming makes many demands on programming languages.
Systems programming, because of that, needs both capability as well as safety.
To talk about what I mean by that, I want to go into a little historical advancement in systems programming.
This pattern of advancement applies to many different types of systems,
but let's look specifically at BIOS, at firmware, and at bootloaders.
All of these things were originally written very heavily in assembly language long after other software wasn't,
with some extensions, with a small smattering of assembly, but in general, C worked its way down the stack.
Now even the BIOS is written almost entirely in C with a little bit of assembly here and there.
That took a surprisingly long time, but it was really only possible because C actually had some features that were worth upgrading for.
In order to make that move, they had to be confident in two different ways to switch from one programming language to another.
First of all, the language has to be sufficiently compelling,
to have sufficiently compelling features to warrant moving in the first place.
It can't just be a little bit better, it has to be substantially better to warrant the effort and engineering time needed to move.
Now C had a lot of compelling features to offer assembly developers.
It provided some degree of type safety, at least enough to not easily mix integers and pointers.
It made developers more productive with higher level constructs, with more readable code,
but just as important as that, the language also has to provide parity.
Developers had to feel confident that C was no less capable than assembly language.
And that is a huge point, and I think it's been an evolving episode in, does Rust have all of that?
And I think the whole sort of endeavor here and what this talk is about is also just sort of an interesting microcosm that happens all the time, right?
We do move on to other languages, we change the tools that we use,
and it's fun to sort of examine how does that actually happen in practice?
I'm curious if you agree, if you found that there are some things that Rust had that you liked,
but maybe some other areas that it was sort of still advancing when you have been playing with it.
You know, I actually think Rust is getting better and better all the time.
I kind of think Rust is going to be around for a while as a systems programming language,
and I think it's going to beat things like Go.
It was a little frustrating, like those first couple weeks of using it, how strict the compiler was, if that makes sense?
Sure, right, yeah. I mean, that's a big advantage, but you've got to learn.
It's having a conversation with a whole new entity, and you've got to learn how to talk to it and what it expects.
Right, and it's maybe a little tighter than what I was kind of used to.
Yes.
I have to say, the output has been very performant and very reliable.
Again, the use case, or the primary one that is at least the most code, is processing STL and OBJ files that I had,
and it worked great, which was a pretty intensive task that if not for Rust, I probably would have had to do in C++,
which I would have found, one, much more error-prone because the non-strict compiler.
And I don't see a reason to really hate on Rust, I'm sorry.
No, that's great.
Josh actually shared some reasons that you and many others, including Intel, are finding it a pleasure to work with.
So, the same properties that make Rust work well for Mozilla to build a browser engine,
also make it appealing for many other companies and projects that are building large, complex systems.
So that includes a lot of companies that you already know, many companies that are represented here, even.
Microsoft, Google, Facebook, Amazon, Dropbox, Chef, Fastly, Baidu, a huge number of companies beyond that.
You can find a long list online, and hundreds of companies are using it to build all sorts of different software.
There's a lot more to it than that.
So, Rust actually has a long and interesting history.
It was started four years ago today, in fact.
This is the fourth anniversary of Rust 1.0, the stable release.
It was started years before that, and beyond that, for those last four years,
it's been the most loved language on Stack Overflow.
People always say, well, I've started using it, and I want to keep using it.
It has the most loyalty in that way.
Beyond that, there are a lot of published security studies about the properties that Rust provides.
This isn't just a thing that they advocate as, oh, you should use it because it has these properties.
There was a study from Microsoft saying that 70% of security bugs are memory safety issues of some kind,
and exactly the same type of issues that Rust fixes.
A number of developers from Microsoft expressed interest in driving those types of security fixes using Rust.
Mozilla did a study that showed that if they'd written one component of Firefox in Rust from the beginning,
they'd have avoided 73% of its historical security issues.
Mozilla went back and looked at every CVE in that component and said,
which of them would still have existed, and which of them were fixed by writing it in Rust?
Well, those are some pretty decent numbers, I would say.
Yeah, I would say that's almost okay, right?
Yeah, absolutely.
But, of course, that doesn't mean everything is working, especially if you're doing low-level stuff,
or maybe you need to produce super-duper optimized bytecode,
and people at Intel do have some of those needs from time to time.
I thought it was interesting that the talk kind of ends after going into more of the history of Rust
and some of the nitty-gritty technical stuff.
It just ends on a good summary of all the stuff that Intel is trying to work on
to make that open-source ecosystem better for them and for others.
I want to give a summary of what we're trying to work on.
We need full parity with C to support the long tail of system software,
and we have a Rust working group working towards that goal.
And every feature that we add covers more of the space of systems programming.
We want to make sure that all developers have a choice of languages,
not just app developers but systems programmers as well,
and nobody is stuck with only one language that will do what they need.
So we want to make sure that no matter what language you're using,
C or Rust or anything else, that it runs best on Intel hardware
and that it gives you access to the full capabilities of your hardware.
And we would love to have your feedback to help drive what C features
that we add to Rust next.
So please do get in touch if you want to do systems programming
in higher-level languages.
And please, please, please, don't buy AMD.
Right.
Well, of course, you've got to sneak that little sales pitch in there.
Yeah.
No, but that's pretty interesting.
I mean, if you are, there's nothing wrong with Intel wanting to support your project.
Right.
And it's just kind of interesting to see because this is all in the open,
and Rust has done a good job of having a lot of the language evolution done
in a particularly transparent way, I would say.
We get to sit here and watch and talk about it.
Now, this is an example of open source work being done by Intel,
obviously a very large corporation.
But, Mike, you were pretty fired up about an article over in Wired
by Keith Negley that reminds us that that's not always the case.
Yeah.
So I am an old man, so I subscribe to a number of print magazines,
including Wired.
Oh, look at you.
You got the physical thing right there in your hands.
Damn right.
And they had this article, this last issue,
about the tragedy of commons in FOSS, right?
And, damn, it was heartbreaking.
All these stories, the most telling one was of the open SSL team
barely making a few thousand dollars a year.
Right.
I mean, this was kind of a reminder of what the situation was like
before Heartbleed.
Right, during Heartbleed.
And just how, while it is absolutely true that the open source community
can do great things, it's also true that, you know,
I wouldn't even say corporate America, right, like corporate,
I don't know, federation, like the Star Trek federation,
are really leveraging the crap out of the community here.
Right.
And, I mean, on one side of that, that's kind of good and expected
because you're putting it out there in the open to be used.
But it sort of has, you know, hidden externalities, hidden reliances
that we're not always doing a proper job of maintaining.
And in the long run, that's not good for the businesses that rely on it
or the people trying to make the software.
Yeah, it's, you know, I more put this in for this week
to kind of throw it out there to the audience
and maybe get some feedback for next week.
What do we think of this, you know, companies making millions
and billions of dollars off open source projects
where the maintainers are just hacking on it nights and weekends
and, you know, not making anything?
I mean, the best case he had, the author,
was someone who ran a software consultancy,
but they never even, you know, they never made a million in revenue.
Meanwhile, some of the biggest Fortune 500s in the world
depended on their project.
Right, yeah.
You know, I wonder, too, it seems like, I don't know if you'd agree,
that more mainstream culture reporters, news organizations
sort of discovered open source,
and I think the wider world is still trying to make sense of it, too.
And in this case, it's kind of nice
because it points out some things that we don't talk about probably often enough.
Yeah, I think Heartbleed, in particular,
kind of took off some blinders for the mainstream.
I would even say the mainstream tech press, right?
So the tech press was not necessarily, you know,
even in the development kind of Linux-y, Voss-y community.
I don't know.
Again, I am not going to jump into the GPL versus BSD debate here,
but I will say that it doesn't make a lot of sense.
And I think we've seen this in the Linux world, too,
where some projects, notably this year,
I can't remember the names off the top of my head,
but I'm sure you do, have been shutting down or switching maintainership
just because of, you know, it's not worth it, right?
The maintainers are getting a little older, maybe,
they have families, whatever, and they just can't do this.
Right, I mean, you know, life gets in the way sometimes,
and if we don't have a robust base of support to either let that continue
or other people to, you know, sort of continue the work,
well, we're going to lose things that we care about or find useful.
One of the most haterade cases of this, I think,
for our community at JB is going to be,
remember, Mac is Darwin BSD.
I mean, yes, they've mutated it quite a lot,
but underneath it's the mock kernel running Darwin.
They've done a lot to it, granted.
There used to be FOSS Darwin BSD, like, alternatives.
Yeah.
Right, and there's a little show called BSD Now.
Just saying.
BSDNow.tv, if you'd like to check that out.
It is a place to be for all things BSD.
Where they all run Windows 7. Oops, sorry.
I mean, sometimes people got to run Windows, Mike.
You're one to talk.
Oh, I know, I know.
Next best Linux distro, Windows 10.
Now, if you're all fired up like I am about what Mike just said,
please do leave us feedback.
You can do that either over at our subreddit coder radio.reddit.com
or just go to coder.show directly or coder.show slash contact,
and we've got a handy dandy little form that sends us an email.
Now, Mike, let's move right along.
There's no avoiding it.
It's time for our language check-in.
This week it's your turn, and you've been checking out Crystal.
It's so shiny.
I think it's kind of perfect to talk about
because we've just been talking about systems programming and Rust,
and one of Crystal's stated language goals is be able to call C code
by writing bindings in pure Crystal.
What?
But before we get there, tell me more.
How has it been?
What's it like, and is it as cool as the little spinning Crystal
on their homepage makes it look?
All right, so I have to give it to the Crystal team.
They know how to brand things.
First of all, their website is just amazing.
Second of all, their tagline, fast to see, slick as Ruby.
Let's just drop our mics right now.
Oh, boy.
Yeah, wow.
So Crystal could trick you on a cursory look
and have you think you're writing Ruby.
Yeah, look at this, server equals http server dot news,
and then like the whole do block right from Ruby.
What's going on?
It is, by design, meant to be very syntactically
and in a general methodology and pattern sort of way like Ruby,
but there's a couple big differences.
This is kind of, well, let's get the obvious ones
right out of the way here, right?
So first off, it is a static language.
Static typing, maybe.
Ah, so that's a big difference from Ruby right away.
That's a big difference.
Now, it goes out of its way not to slap you in the face with that,
so most of the time you don't need to manually declare the types.
It figures it out.
So it's a modern type language with nice handy inference
to help you out so that most of the time you can just kind of,
not forget about it, but not have to annotate every last little thing.
Right, but it does enforce it
as though it were a traditional static type language.
Excellent.
So it infers it the first time, and then after that,
it just assumes you know what you're doing.
And if it doesn't compile time, it fails,
which by the way, unlike Ruby, it compiles.
Now, I know there are weird implementations of Ruby
that people have run through compilers.
Sure, of course.
We're talking mainline Ruby here, right?
Yeah, it compiles, and you're running binaries
that are compiling to your native platform,
which means you have to care about your native platform.
Yeah, that's a big difference right there.
It's not just this high-level interpreted language anymore.
But of course, as we all know,
compiled languages are in general faster
than their interpreted equivalents, right?
Which makes sense if you understand what the compiler actually does.
So that's where it gets a lot of its speed.
Oh, and also it consumes C directly, so yay.
That is cool.
Part of the static typing I noticed that they've got nice null handling.
All types are non-nullable,
and nullable variables are represented separately
as a union between that type and nil.
So they've got some nice modern handling there.
Right, huge departure from Ruby,
where hey, you can throw nil around like it's candy.
And I find that that's less of a problem.
In my own work with Ruby anyway,
I don't find nil to be the sort of problem
that null is in some Java code bases.
But still, this is nice to have.
More and more I'm liking things to be a bit stricter
on the whole null, nil front.
I don't mind it.
In some of my reading around the forums and asking people,
some people had issues with that.
I don't understand why.
I kind of don't think your way of validating your logic
should be checking for nil, but that's just me.
Right.
I can't say I've never done it.
That's how Objective-C, that was a very common pattern.
It's not, you know, with age comes wisdom.
A couple things I don't like
before we get into some love here.
Yeah, okay, yeah.
So with static typing comes a lot of safety.
You do lose some of the flexibility that you have in Ruby.
Again, Crystal is its own language.
It's just meant to look like Ruby.
It's not a derivative of Ruby.
It's not trying to be derivative.
It's not trying to be compatible, yeah.
The dot each iterator
does not do what you would like it to do in Ruby.
It is actually much more complex.
You have to know what your collection is going in
where in Ruby you can basically iterate over a ham sandwich.
There's a whole enumerable module in Ruby
that everything has, yeah.
I think this is good,
although people who've been using it a long time
know I was very upset when Swift removed it.
Yeah, you don't need for loops.
You know what? I know they're like Comp Sci 100.
Everybody has to learn for loops.
You don't need for loops.
So Crystal's down with that.
You don't get no for loops.
So if you want to iterate over a collection,
you actually have to create the right type of collection
and iterate over it.
Oh, interesting, yeah, okay.
That'll be different for some people
that maybe have not worked with such a low-level language.
But I'm going to just like, again,
like many of the things in Rust,
the enforcement of just a little extra discipline
actually can protect you from
just like a wide array of common errors, right?
See what I did there? Iteration mentioned an array.
I just like that.
Yes.
But then we get into what I can only describe as
don't call me Ruby gems. Shards.
Shards are exactly what you think they are.
They are the equivalent of Ruby gems.
Oh, that's a cute name.
Right. They work differently because it's compiled,
but you really don't care.
It's a command. You run on the command line.
You install it. It gives you dependencies.
I mean, they're doing great work with it,
but it's just like every package manager
for every language, right?
Kind of what the check these days, I think,
is like, did they mess it up?
Did you get this wrong?
It works fine.
Yeah, you're right. They didn't mess it up.
It's boring. We just move on.
Fibers, which are their concurrency model,
are interesting and complex.
And another reminder that this is a compiled language
running on native code
and that you really have to care about
what form you're on,
and you have to know what you're doing.
Again, I'm going to draw the parallel to Rust.
You can do great concurrency in Rust,
but you have to really know what you're doing.
I also think fibers are probably,
other than the native performance,
one of the primary reasons one would use Crystal
if you have a highly concurrent workload,
which lots of things are these days, right,
in our multi-threaded, multi-GPU...
I'm sorry, not multi...
really multi-CPU world, yeah.
Macros.
So macros are evil and wrong,
just like monkey patching and DSLs on Ruby.
Don't do it.
I was intrigued. You don't see
this kind of style of macro
in all statically typed languages?
I mean, it reminds me a little bit
of the GLISP style macros almost.
Did you write one?
Did you play with that at all?
I did. So there was an example
of someone who was very annoyed.
I didn't post in the doc
because I felt the tone was a little too snarky,
which, if you've listened to the show,
tells you a lot.
Yeah, so someone was really mad
and wrote a macro to add four loops back.
Of course.
It's... it's bad.
We call this monkey patching in Ruby, right?
I think there's a proper name,
but that's kind of the mean slang name.
No, I think it is really called
monkey patching in the docs now.
I'll put that up and comment on Reddit.
Basically, you can add functionality
to the language.
Great for DSLs, right?
That's what everybody says.
What you usually see is not DSLs,
but people adding crap that's bad.
I have done it.
I don't think you should do it.
I understand why Crystal has it as a...
By the way, this language is not even 1.0 yet.
So if you're thinking of, like,
popping this out in prod,
I saw there's some companies who are using it.
I don't think it'll be 1.0
unless it's a really special case role.
So for me, I would not use this in production right now.
Totally reasonable.
But I definitely get
why such a young language
would need something like macros
because I'm sure there are plenty of the shops
and individual developers using this
that simply wouldn't use it
if they couldn't add on their own functionality.
Right. That's the thing, right?
Like, macros enable you to sort of expand the language.
You're right if you have, I think,
some particular problems in Ruby with monkey patching
is that it is easily used
for very widespread things, right?
You can just end up adding these methods
that show up on objects everywhere
practically.
It seems like macros
are best used, at least in my experience,
for very limited cases. Yeah, stuff where you...
You know, it's obvious that you're doing some sort of
complicated transformation here.
It is neat that basically in Crystal,
macros are just methods that receive
AST nodes at compile time
and then produce code that gets pasted right back
so it's much like macros
you might be familiar with from other languages.
That's cool. You know, macros are
kind of like AppSynth.
You can...
You can have a little bit, but you really got...
That's like a once a year thing. Yeah.
Yeah, once in a while.
So one thing that looks a little bit similar
to Ruby is in Crystal,
everything is in objects, right?
And basically they say the things you can know
about it is that it has a type
and it can respond to some methods
and that's it.
Yeah, I personally like that, but I like Ruby.
If you don't like that, then you won't like it here either.
Personally, I think that makes reasoning about
your code very, very...
I won't say simple, but
it kind of gives you a...
Just like a set of rules that you can follow
and reason through. Yeah.
Constrains the interface and API that you're
using to talk between all these things.
I definitely understand why there's a whole set of people
who wouldn't like that kind of thing.
I'm not sure how much you would or wouldn't like this.
I'm very curious.
For me, this is...
When this hits 1.0, I would
probably use this where I might use Rust.
Right? As a more
performant augmentation to a
large scale application written in Ruby.
I see.
Having said that, I'm really enjoying
using Rust for that. I hate
to say it, and I could
change my mind later because, yay.
I don't see me
picking this up. And obviously,
my 1.0 rule, I won't pick it up
now. Right. Let's say it was ready to go.
You were comfortable with its stability.
But I wouldn't discourage anybody, especially if you're
just hacking for fun or doing
a toy program for yourself.
Honestly, the only thing I really
don't like is macros, but lots of languages
that I do like have it, i.e. Ruby,
and I think I just don't use
it because I don't like it.
One thing I noticed that was interesting just looking at it,
if you go take a peek at their GitHub,
I think as a consequence of having macros,
most of Crystal is implemented
in Crystal at this point.
And you don't need macros for that sort of thing,
but it can make it easy because you can
start with a few special primitives and sort of
build the language upon itself from there.
I don't want to hit the macro thing too hard
because in reality, if I for some reason
decided to use this, I am sure I would eventually
have to write some macros for myself too.
I'd be curious how you might compare it to Go
as well, because it seems like
right now the advantages or at least things you might be
interested in as compared to Rust would be
the really strong concurrency model.
I know Rust has been working on async
08 sort of style stuff, and there's various
different proposals out there, but Crystal
is up front, like, look, we've got
fibers, we've got green threads, have
at it, and
it might not be suitable to target exactly
as all the low-level things, or at least right now,
I'm thinking stuff without a runtime or OS level
stuff that Rust can also sort of
play at, but if you want
a tight little, you know, static
executable, reasonably fast,
efficient, pretty low-level stuff,
it seems like this would be competing with
Go as well in that regard.
Yeah, I could see that.
Is the argument then that you just get a syntax that maybe
you like more?
Well, you know, I would be maybe a little more
optimistic than that.
I mean, I think, you know, not many people were doing
a whole lot of Ruby until Rails came along.
Having said that, I don't think
this is a great thing for the type of application
you would write in Rails.
No, no, probably not, right? It's a little lower level than that.
But I could see something
coming along where,
you know, there's not a lot of
people use, well, I won't say not a lot, but
Erlang is not one of the biggest languages out there,
but there are domains where it makes a ton of
sense.
Yeah, that's the other thing this would seem to be sort of targeting, right?
I mean, you tried Elixir to kick off this whole language
challenge, and they have similar
concurrency models here.
And they both got that Ruby, yeah, that Ruby DNA almost.
Now, I know there's been some interest
over in the Erlang world
because you can write, you know, basically extensions
out from the Erlang VM, so you can
implement sort of stuff that needs to be faster, lower
level things. But there's always the
risk, at least when they're implemented classically in C,
of that ruining a lot of your
safety, right? When you build it on their nice Beam VM,
you get all this nice managed safety for you.
But if your C extension then like crashes the
whole thing, well, that won't work. So there's been
some interest in using Rust. I wonder
how Crystal might work in the same regard.
As always, Rust is the right answer.
Oh, Mike.
So, Wes, we forgot to mention
on the last recording, you are doing a challenge.
Yeah. Now,
what have you picked for me? Because you've given
a great report here on Crystal. I might just have to
play with it myself as an aside because
I'm curious. It's got me interested.
But I need a language.
I need something to be working on.
So, you know what? I had
a language in mind, but I think you've actually
changed my mind. Oh,
what? I don't think we've done Go yet,
have we? Didn't you do Go?
Oh, I did do Go, didn't I?
But I haven't. Now, we did
get some, we did get some, there was a
feedback item I saw somewhere. Maybe it was on,
maybe it was on Reddit. Someone suggested
I try Julia. That might be interesting.
That's a language I've been looking at,
but have not actually played with. I mean, I think you'll
hate it. So that's part of the...
Perfect. All right. Do you want to do Julia?
Yeah, it sounds good. I mean,
we must be close to seven by now.
Yeah, probably. But this is fun. So, you know.
All right. So, and what for me
next? So I have two weeks to do it.
Hmm. Hmm.
That's a good question, Mike.
I don't, I don't know. I might
have to think about that a little bit.
Maybe we'll send out a tweet
about that later this week once we've decided.
Well, Mike, thank you
for a very interesting language
report. And, you know, it's great
to be doing the show live with you again. We'll be here doing
the show live like we do almost
every week. Next week
you can join too. Head on over to jupiterbroadcasting.com
slash calendar.
That will list the
live times of this show and all the
other shows that we do live.
If you want more Coder Radio, well, head
on over to coder.show. That has
the whole back catalog. And if
that's not enough, jupiterbroadcasting.com
has all the other fine
shows, including, you know,
we've got some new stuff going on over in our
Extras feed. If you haven't heard, if you
haven't checked it out, but maybe you've already caught
up on all the JB content for the week and need
a little bit more, extras.show.
Go check out
the latest Brunch with Brent.
I think you'll find it's very enjoyable.
Mike, if they want
more of you, well, you're over
on Twitter. What's your handle?
That's at Domenico on Twitter.
I'm there too, at
Westpane. And you can find the whole
network sending out notifications about all the
latest and greatest shows at
Jupiter Signal. Thank
you all so much for joining us.
We'll see you right back here
next week.
you

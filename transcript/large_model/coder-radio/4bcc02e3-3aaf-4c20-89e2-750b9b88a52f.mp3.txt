This is Koda Radio, episode 364, for July 1st, 2019.
Hello, and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business of software development and related technologies.
My name is Wes, and I'm very pleased to be joined by that Floridian gentleman who we won't call crazy, Mr. Michael Dominic. Hi, Mike.
Hello, Wes, and the reports are true. I am Florida Man.
Well, we wouldn't have you any other way. I mean, I kind of like that we're on opposite sides of the country in that way. We're bringing different perspectives, and that's what makes it fun.
National representation.
We got a lot in this show today, so we might as well just come in hot. There's no better way. Let's start with some news that we should get out of the way so we can get into the meatier stories we really want to talk about.
And that's all the business around Johnny Ives' exit from Apple. And just like any update that happens around Johnny Ives, there's been a lot of news.
Oh, sure there has. So Sir Johnny Ives, as he's known by his friends.
Oh, yes, of course.
Is leaving Apple to start a new design firm called from love, which amazing name bonus points. There has been a I mean it started with a big Wall Street Journal story of Johnny Ives being disincentivized or disinterested, I think is the correct term someone will correct us in the work at Apple due to kind of a.
I'm trying to put this in a non combative way, Wes. Pain in the ass accounting being counter mindset. Is that fair?
Sure. And I mean, he's functioning at a very high level as a high level designer responsible for a lot of stuff. I can see how, you know, if you're overly constrained and Apple at this point is a pretty large organization.
At some point, you just want, you know, you want more agility, you want to focus on your creative work, and maybe the bureaucracy is constraining.
Well, sure. And like, I can tell you, accountants just create busy work, right? Everything is paperwork, everything is right. Maybe we don't get into my pep.
And I mean, there's, there's often reason for that. But that doesn't make it fun. And in many cases, there's, you know, excesses there that just inefficiencies built into the system.
The reasonable opinions of West do not necessarily reflect the opinions of Mike, or the quarter radio program. No, I think your opinions more reflect accurately the actual programming.
It's, I don't know, like, I have to be honest with you, this announcement makes all of the crappy decisions made by Apple make a lot more sense to me because yeah, the accounts are in control.
So yes, we released a shitty keyboard. But no, we can't have a new keyboard because, well, we've already paid for the tooling on the factory and God forbid we, you know, not show year over year growth.
Now, West, tell me why I'm wrong.
You know, I'm really not sure you are our whole I mean, we have a larger problem in our society, I would say with focus on short term gains quarterly capitalism.
Yeah, exactly. It's I mean, it's really cork from DS nine says it best, you know, it's it is all it's all about the short term quarterly gains.
And you just don't care about sustainability or long term growth. And you would hope Apple has has been a company that's been, you know, better about that than many others and not necessarily only ruled by stock price fluctuations.
But maybe it sounds like it's getting worse. I try to avoid controversial statements. I'm not sure that's true, but lay it on us, Mike.
So like, I actually believe that accountants, finance and operations people should never be out be allowed to become CEOs.
They just lack a vision and a quest for excellence, right? Like I would rather a drunk former poet or a mad scientist who is going to create the Green Goblin than someone who knows how to
actually like balance an account and notes the difference between checks and balances. And by the way, it means different things in a different context.
Of course it does. Accounting sucks. Right? Like, I personally would eliminate the IRS and I would also eliminate all CPAs. But that's just me.
Well, I like your point earlier about, you know, you're right. Like you need, you need accounting, you need the realities, you need information about how your finances stand, but you need someone in this.
That was not my point.
Right, right. You need someone in charge, you know, a CEO, whatever, that gets the higher goal, that understands that. I think that's where you see a lot of larger companies start to stagnate, right?
You lose people with the vision, you lose the agility of a smaller organization, and you're too focused on compliance and stock price.
I guess what I'm suggesting is that once a company reaches the point where an operations guy or an accountant could actually be the CEO, it means the company is too big and needs to be broken up.
And you need someone who has a vision and aggression and will indeed accidentally or intentionally cheat on accounting rules because he either doesn't know or doesn't care.
Whoopsie.
No, but it just is the point, right? You know, Tim Cook, great guy, to me, kind of a Mary Sue, could never have created the IMAC, could never have saved Apple. If Tim Cook ran Apple, he would have looked at the numbers and said, I'm going to sell to Dell during the 90s.
That's what I'm talking about.
Yeah, you're right. You need that sort of relentless pursuit of vision that you just don't get.
Well, you need someone crazy. Like Steve Jobs, his biggest strength was that he was actually an egocentric megalomaniac.
I am a little curious what you think about this exit that Johnny Ives gets to do and how that might compare with, you know, someone like you or me and how we would exit.
So I did an exit like this once. This is basically someone slacked or, in my time, hip-chatted someone in a rage because, like, Johnny Ives should have been the CEO or should have left when Steve Jobs died, right?
So, by the way, it's not just me saying this. They literally pay him more than any executive. They gave him a fake promotion just to keep him there so it wouldn't hurt the share price having Steve Jobs die and him leave at the same time.
It just is the case that working with an accountant or an operations guy is a nightmare.
I got to tell you something. Every time I have to send an invoice to an accounting person, I cry because they care about nonsense, right? They would rather see their servers crash than not have a PO, you know, exactly detailed on each line item.
It's such a waste of time. I realize that's not the answer you wanted.
I mean, not really, but I'll take it.
All right, let me rephrase. I'll rephrase. I think accountants and finance people ought to serve the creative people, right? It shouldn't be the other way.
As an engineer or as a designer, you should not have to write your documents to satisfy the accountant. The accountant should figure out what's right, say, this is what I think I should pay you and pay you.
It should not be your responsibility to effectively do their job.
Yeah, no, you're right. I mean, their role is to keep things running, right? And there are essential services to perform, but that's just there as, you know, something you have to get done. It's not the spirit or the heart of the work, which is, as you say, what the, you know, what the creative people, the designers, the engineers, the people making the primary product of whatever organizations involved.
But it's deeper than that, right? Apple's opening a credit card. So they are effectively going to become a financial services company. And this has happened before. Remember General Motors, a little car company. I don't know if you've heard of them.
I have.
Their biggest business was giving auto loans and personal loans, right? So we should move on from this. But yeah, Mike hates accountants and finance people. That's the lesson today.
Well, let's move on to something that maybe you don't hate. It's time, that's right, for our check in on your weekly programming challenge. This time, we're gabbing about Go.
Yeah, I hate Go too, so this is going to go downhill. So no, I'm kidding. So Go, you know what, my first comment in the doc is Go is C++ plus three pluses, three pluses more power. There's a lot to like here, Wes. One, there's no accountants. Two, there is Go routines, which are, I want to be careful how I say this, but I also need to say in 30 seconds.
So they are effectively on a conceptual level threads. But they're not like LLVM threads that we would normally think about, right? They're managed completely by the Go runtime.
Yes, right. So the difference here is that you're not using the underlying kernel primitives on whatever operating system you're doing. These are so called green threads, user land threads managed entirely within Go. And so that usually means cooperative multitasking.
When I read that, and I started working with them, I kind of raised an eyebrow like, well, wait, is that is that going to be slower? In fact, it's faster. Because the Go routines give you the ability to completely control the threads. For instance, I know people are going to say this is like a nerdy trivial thing to care about, but mutexes.
The fact that I can lock a variable or really any data type, like, I mean, there's a whole thing we're gonna get into here about what is a variable in Go, but lock it to one Go routine, and then unlock it when it's done, prevents a lot of threading, or what we would normally in other languages call concurrency threading issues, right?
For instance, let's take a simple example, we have some variable called, you know, glass, we want to mutate some value of that, right, whether it be size or temperature. Well, we might have two threads using quotes here, that are trying to operate on it and might mutate it in a way we don't expect.
And each thread can actually verify the value. Using the mutex functionality in Go, we can say, this is locked until, you know, Go Routine A is done. Then when Go Routine A is done, Go Routine B can then operate on it.
Yeah, I'm curious what you think, you know, as someone who's used certainly plenty of.NET stuff, as well as, you know, Ruby, which I would say has a much worse concurrency story. What do you think of this sort of concurrency first design of Go?
Well, concurrency in Ruby is just not good, right? I mean...
No, no, it's not. Really, it's awful.
Yeah, so, I mean, your question jumps to kind of my end thing here, although we have a few things I'd like to go through. Go is solving problems that I just don't have, right?
Like, the root problem that Go seems to solve is, I need a better C++ in terms of concurrency and large distributed systems.
Which is just not the arena I'm working in. But I could see how, again, like, if you think about languages and platforms, you know, let's take Rails, which I think we're going to talk about a little later.
Rails is not optimizing for performance. It's not optimizing for really anything but developer time, right? It's to minimize the amount of dev time you have to buy.
Yeah, everything, you know, convention over configuration, all the defaults that exist. Yeah, it's just easy to get going to make it easy for humans and, well, just, you know, buy more servers if you need to.
Right, just throw money at RAM. Where Go is kind of the opposite. Like, the equivalent Go application is going to take you a bit longer to write, but the performance is going to be much better.
And if you happen to be Google or someone at scale, it makes a lot of sense. And I'm not even being, like, critical here.
I actually think Go has its place, much like I think Rust has its place, although I wouldn't use Go the way I'm using Rust.
Yeah, maybe you could compare and contrast real briefly there.
Yeah, like, Rust, I feel like, is more, okay, you're going to write this one microservice component in Rust. It's going to process a lot of data very quickly.
You know, I'm doing a lot with OBJs and STLs right now. I've been working, I mean, we've talked about this a few times, right?
Oh, yes, right. Your 3D render files, etc.
Yeah, we're doing a lot of processing and analytics on them, and the reality is just, like, running a small server or, although I have been playing with Azure Functions, too, in AWS LAMP instances,
in Rust, it's just a lot more performant than doing that in the Rails app, even versus doing it in the Rails app and using FFI for Rust or for C++, I guess, would be an option.
Right, trying to offload your hot paths out to something faster.
Right, it's just better to throw it on a serverless instance, frankly. I could see Go. See, Go, to me, is a little different than that, where I see Rust as kind of a utility that you have in your tool belt.
Go feels like I'm building a giant system, it needs to be performant, and I'm building the whole damn thing in Go.
Sure, right? I mean, Kubernetes is a great example of a giant Go project.
Exactly. I'm pretty sure Docker's written in Go.
Yeah, there's tons of stuff, like the Snap daemon, lots of stuff that just runs as a lean little executable that needs to provide some network services.
You know, Go's put in some good time to get a low overhead garbage collector, and that's where I was kind of curious, you mentioned, well, it might take you longer to write your project in Go.
How much, coming from Ruby, which is maybe the exact opposite, how much impedance was there compared to stuff like Objective-C or C-Sharp or Java?
And I also wonder if you worry about large code bases. Some people are concerned about the current lack of generics and some of the other difficulties in lacking some of the higher abstractions that Go lacks with the purpose of keeping it simple.
Yeah, I mean, the comparison to Objective-C, I think, is a little unfair because Objective-C would be a front-end language. I'm thinking of kind of back-end data processing things.
You know, I'm in a particular position that gives me a particular perspective, right? I'm selling development services.
So I just can't sell Go because I can't say that something that could take 250 hours in Rails, or Ruby, rather, is going to take 350 or 400 in Go.
Like that, there's no way for me to sell that in my current market.
Now, if I were developing internal products, I might say, well, the long-term server cost is cheaper, but from my now 12-plus years running a dev shop, I can tell you that when I look at a new language or new platform, it's how can I get those dev hours as low as possible?
Because, frankly, that's how you beat the other dev shops, right?
Right, that's what you're billing on to bring it back to accounting, and so that's what you need to minimize.
Right, you need to minimize that. So I'm going to be careful how I say this, but, eh, f*** it, I'll just say it bluntly.
Better doesn't matter. It's can I get past the purchasing agent, right? Like that's kind of the biggest thing.
Right, so it'd be great, it's okay, it'd be great to have a faster language, but you need it not to impose a bunch more burdens on you.
Right, so you need to be able to cheat in some places, right? You really do need object-oriented stuff to do a bunch of inheritance, although I have to agree that Go's use of interfaces and structs is a lot better conceptually than OO languages.
It's also a lot more scientific. The other problem Go has is that it's a harder language to hire for since we're comparing it to Ruby.
Although it does seem to be growing pretty rapidly, so I wonder if that'll change.
Yeah, but the average base pay is significantly higher right now, right? And that could change, right? Somebody's listening to this 10 years from now, that might be different.
You know, one of the things I think we fail to do, Wes, is take these coding challenges from particular points of view, not just the platonic, like, how good is this technology, but also how practical is this for us?
Right, because always you're in a context, and languages need to be fit with those. You have a tool that matches that particular task.
Right, and I'm basically in a very, you know, LSC kind of, if I can't hit a certain bid, I can't win the job context.
So something like, like even Rust, I have to tell you, the only reason I'm able to sell Rust is because I don't say I'm selling Rust. I sell Ruby or.NET, and then we run Rust serverless services, which is really hard to say, to process large amounts of data, right?
You could not be competitive selling Go or, frankly, Rust for your generic, I need a web application that serves data to my business, right?
Right, as long as Rails is fast enough, that's always going to be easier and quicker to make.
But replace Rails with, you know, Java Play,.NET Core, right? There's a million things that are fast enough.
Right, right. Django, some Node.js app, whatever.
Absolutely, yeah.
Okay, interesting.
But I do like Go. I mean, I don't want to be too negative. I just, I'm finding a hard, and this is the problem I had, like, who is this for?
Which I put in the doc because maybe if you are working in a very tech-driven enterprise and you are being paid a salary, this makes sense.
Yeah, right. So, like, from the context of someone who works at an enterprise dev shop, you're on a team of ten people or something, you're working on some microservice, and it's written in Go.
Right, where you're not having to compete with a more, you know, for the lack of a second argument, batteries-included solution.
Right, yeah.
But I do like it. I mean, I feel like I came off negative here. I mean, it does feel like a C++ as though it were thought of in the 2000s.
What did you think of the error handling? You know, they make it pretty explicit rather than the sort of try-catch stuff that's in vogue these days.
Yeah, I thought it was a little annoying, to be honest with you. Again, it's one of those things that I feel like adds to the cost.
You weren't pleased that you had to sort of consider the errors at every little interaction?
No, so this is – I mean, I can't wait until next week and you look at Objective-C, because one of the beauties of Objective-C is you can just ignore errors if you are confident that they won't exist in reality.
Oh, my. Well, Objective-C is almost the opposite of this, where it's a language optimized for, like, I need to hit a low bit.
Oh, yeah, sure. Okay, that kind of makes sense.
And Rust, I got to tell you, I have some of the same trouble in Rust that I did looking ago, and I use Rust in production. It's like, I do charge a premium anytime I think I have to do Rust Dev, only because I do have to catch all those errors and I can't just, like, pretend they don't exist, right?
It's kind of the opposite. I'm wondering maybe if you would compare to, say, Elixir, right, which is how we started off this challenge, which kind of takes the opposite, let it crash approach, while still having a very similar focus on concurrency to go.
And I wonder, would there be less, could you do something in Elixir that you couldn't go that would be similar to Ruby?
I think from a guy who owns a dev shop perspective, I would be much more comfortable selling Elixir, not because I think it's more stable, and don't get me wrong, Elixir is very stable, but because the estimate that I would come up with would be in the realm of acceptability to the client, right?
Where if from my two weeks, week and a half, whatever, looking at Go, everything costs a thousand hours or more. It just does. I can't see a way to actually function.
Now maybe I have wildly misunderstood Go, or I have focused too much on the concurrency limitations, and I'm going to take that back because people are going to write in,
Yeah, what do you mean here, Mike? I mean the discipline that gives you good concurrency and gives you a lot of power, but also requires you to actually do a lot of work, right?
Sure, you still have to think about it. Which right, circling back to, I think you put my point more elegantly than I did context, right? The context that I live in, I just can't sell a web service for 2000 hours.
Right, your problem is not optimizing performance, you just need to optimize ability to rapidly prototype and ship some products to customers.
Well, I have vicious toad-like competitors here, and if you look up where I live, you know what I'm talking about.
Oh.
Who will underbid me just to get the continuing work.
Right, even if they're taking a loss on it, they'll just want to keep the contract going.
Oh, you and I should talk offline. It just is the case that my main problem is people don't want to pay more than 300 hours for anything.
Yeah, that'll happen. Okay, one last point I want to hit on before we should move on, and I should give you your next language.
So one of the things I'm always pleased at, and I think this is a use case maybe you are not in at the moment, but is one that I see Go used a lot in, and that's as like command line application.
Because you can take Go and using the Go compiler, you just get these nice little mostly statically linked executables out of it.
So I can go to a GitHub releases page, download a zip file, and just copy it under my home derbin, and I'm away. And that's another thing that Rust has, but languages like Python and Ruby can't really compete with, right?
You can do stuff. If you're shipping a Docker container, it's fine or whatever.
But for little command line applications, and I shouldn't say little, right?
I mean, tons of people use Docker or Snap or LXD or Cube CTL.
Oh yeah, sure, sure.
These are interfaces, so they're kind of important, and I think Go and Rust really excel there, especially being able to ship stuff.
Yeah, again, I am not trying to say Go is bad. I feel like I've come off as too negative.
You know what, it's just, Wes, can I play the old man card?
I think you're going to anyway, so please do.
Thank you.
All my command line scripts are already written in Ruby, but they're not the same type of command line script you're talking about, right?
So I certainly use Go every day.
In fact, before I knew what Go was in 2010, I was using it every day because I'm using Docker.
Of course.
And I'm using a bunch of Docker command line tools I've pulled off of GitHub, which are all, just like Wes is saying here, Go scripts.
Yeah, I think that's great.
I mean, listen, writing small terminal programs in a language that is as performant, please don't email, I don't want to see your benchmarks, but relatively as performant as C++, but much easier to work on.
You know what, I am doing a C++ job right now, Wes, and let me tell you something, Go is infinitely easier to work on.
There's no doubt.
There's just absolutely no doubt.
Right, but you could still just ship something for many use cases, maybe not all, sure, but many use cases you could compete with.
Well, yeah, so my issues with Go, my negativity on Go is mostly around the tooling.
We need the DHH of Go to say it just is the case that you have to be able to get a web service done in 150 to 200 hours, right?
Right, some frameworks that make it easier.
I'm curious, did you have problems getting stuff set up in terms of IDEs, et cetera?
I know they've struggled with some of their module system and getting and installing dependencies, whereas Rust, say, has the excellent Cargo.
I will say that Cargo is wonderful, and yeah, Go needs something like Cargo.
I know.
Oh, you're teasing, because, all right, we're going to do a segue here. Are you ready?
So, before I broke my Darter Pro.
Oh my, Mike, you just, okay, we're not going to get into that. I'm sorry for anything you own.
Getting Go set up on Pop!OS, which, for those who don't know, is just basically a skin of Ubuntu, right?
Is that fair skin? I don't want to be unfair to the Pop!OS people.
I mean, I would say it's a separate distribution with Ubuntu as one of their upstreams.
All right, sure, it's like a Linux Mint, right? It's based on Ubuntu. Fair enough.
It was relatively painless. It's exactly what I would do for any other toolchain on Linux.
On a other operating system, it was very hard to get the Go toolchain set up.
And full of weird errors that I ended up just fixing by doing the rest of it on Mac.
That other operating system, it's not a door. It's not a cellar.
It's Windows!
Yeah, let's talk about that, because this week, I was a little bit busy.
We had a Linux Academy Company Summit down in Texas, so, you know, a little preoccupied.
But I couldn't help noticing you were sending some provocative tweets out, Mr. Nominick,
talking about moving things to Windows.
And in particular, it kind of sounds like you're doubling down on the Windows subsystem for Linux.
All right, well, okay.
So, it is true that for a job I am doing, I did pick up a Dell XPS 15.
Oh, those are nice. Running Windows 10.
Actually, they attract dust and fingerprints like they're going out of style.
Oh, really? Okay. I mean, talk about that if you want.
All touchscreens are bad. That's where I would leave it.
You know, you don't have to touch them. You can just ignore that part.
I didn't. It just attracts dust in the air.
I'll send you a picture on our Slack. It's crazy. I've been wiping it off once a day.
And it's because it's plastic and whatever the material they use.
It is running Windows 10. And I am using, we have the link in the show notes,
Penguin, who we talked about in the show a few weeks ago,
which is a Debian-based interface, shall we say, to the Windows subsystem for Linux.
Yeah, I mean, it's a distribution built, designed for, you might say,
the Windows subsystem for Linux.
I would like to say that Windows 10 is not the best distribution of Linux I've ever used.
I would really like to say that.
No. Really?
It just is. And in fact, I am not even...
Are you using that sexy new terminal?
I am not, because I'm not on the insider ring.
I refuse to download the terminal until the actual real Linux kernel goes mainstream.
But when it does, I don't understand why people who have to deploy to Linux
wouldn't just use Windows 10.
You get the best IDE in the world, which I've been saying this for years,
so no one can say I'm a shill, is Visual Studio,
and you can run games and crap natively.
Yeah, but don't you... Okay, so another picture you sent out was
everyone's favorite Windows updates.
So aren't there some downsides?
If you listen to Chris, it's better to just run Windows
in a PCI pass-through or some virtualization.
Why should I pivot to using Windows as the full-time OS?
Well, first of all, I am not a Windows evangelist at all,
so it is not my goal to convince you to use Windows.
So if you're asking me why you should use it, my answer is you shouldn't.
But you must have some reasons in your context to be using it.
The reasons in my context is I spend a lot of time at Visual Studio,
and the performance is just significantly better natively than on a VM.
And the problem you raised about Windows constantly wanting to update and restart is,
well, you don't turn it off and just let it restart every night.
It's not ideal, but, you know, I don't know, it works.
I can run all my Linux tooling and my VS environment,
and both of them run at near-native performance.
That's nice.
Penguin, I've seen no significant difference between that and Pop OS, let's say.
Whereas when running Pop OS and I had Windows and a VM,
I had significant issues, let's say, with screen tearing and things like that.
Wow, I mean, that's an interesting report from the field, Mr. Dominic.
I'm glad, I mean, I guess at the end of the day,
should we just be happy that Linux runs really darn well on Windows?
And that just means that you can have the best of both worlds?
Or should I be a little more worried that you've destroyed your Pop systems
and are now dancing with the devil?
Well, why are you worried? Why are you worried?
Let me ask you this. What is Linux?
Is Linux Gnome? Is it KDE?
I mean, you're right.
Really what I'm talking about is Linux on the desktop.
If Windows 10 has a real Linux kernel, which it will in a few months, right,
it's not running just a very strange, distant cousin.
It's like a family reunion of Linux.
Your code is running natively. It's actually running on a Linux kernel.
You cannot say it's a translation layer.
Yeah, I mean, I guess you're right.
And to some extent, it doesn't really matter which one is really running on the host CPU
and which one is cheating a little bit because it just doesn't matter.
Well, it's not cheating, though. It's not cheating.
So with the WSL2, it is a native Linux kernel.
So the WSL1 is cheating. It's doing a translation layer.
The WSL2, which is in Super Insider Alpha Preview or whatever,
which is, granted, I am not running because this is a production machine.
When that comes to production,
Windows will legitimately be an operating system that is running a full Linux kernel,
just like Ubuntu, just like Mint, just like Fedora.
What's the difference, other than personal preferences?
I mean, there's a little bit of difference, right,
in that you're booting into Windows rather than the Linux kernel.
You're booting into both. It boots both kernels.
Yeah, but one of them is, like, isn't –
Linux is technically in a Hyper-V session, just like a minimal one.
I do take your point.
Like, it doesn't really matter if you're going to run both operating systems,
which, as you say, like, if you deliver software from Windows,
you kind of have to, right?
So, I guess, if you're already in that position, it just doesn't matter.
Like, you should just – whichever experience gives you the best of both worlds
so that you can use both systems well, that's what you should do.
Did you see the controversy that literally happened
before we started recording today?
I think I might have missed it.
Regarding Microsoft wanting Windows to join the Linux distro mailing list.
Oh, yeah, you know, I think I did see a few stories floating around about that.
You did see it, right?
Because this is their argument.
And I have to say, I read their argument,
and if I can run Visual Studio natively,
if I can deploy it to my Linux IoT devices,
my Linux services – rather, servers –
or online services, I guess,
while coding to those type of things using a Linux –
native Linux kernel and toolchain, great.
If I don't have to VM Windows, great.
I mean, honestly, I think the missed story here
that all the tech pundits haven't gotten is,
why the hell didn't Mac do this?
They're already running a Unix kernel.
They're running the Darwin BSD kernel.
Why have the – or, I'm sorry, the mock kernel in a Darwin environment?
Yeah, yeah, it's complicated.
But they've got, like, a POSIX environment.
But, like, seriously, Mac could have easily ripped out the BSD side of that,
put in a Linux kernel, and said,
we are the ultimate dev station.
And you know what?
Because – can I fry some bacon?
Oh, lay it on us, Mr. Dominic.
All right, so this bacon's out of London for Canonical.
Have you noticed that Canonical's not pushing the desktop anymore?
They're pushing servers, and they're a partner with Microsoft?
Have you also noticed that a Microsoft developer came out in public and said,
yes, Azure is a majority Linux at this pace?
I did see that.
So maybe Microsoft is setting Windows 10 up
as the best Linux development environment you could possibly have?
I mean, it does make sense.
They are – you know, Azure is a key component of their long-term business model,
because of course it is.
It's the cloud.
And, well, if you're running on Azure, you're probably running a Linux system,
and you need a good way to target that.
And to Microsoft's credit, as you say, right, I mean, they know dev tooling.
They are very good at that.
So they can provide some of these first-class integrations,
not only between Windows and Azure,
but between Windows, Linux, and Azure all in one complicated little three-way.
Right.
And no one's going to, like, attack GNOME or KDE.
No one's going to stop you from running desktop Linux.
I mean, it –
I'm on KDE Plasma as we're doing the show right now.
Right.
And then I'm on what I call Windows 10 Plasma.
My future prediction – and then we should get to the end of the show –
Windows 10 and Linux are going to be the only two viable operating systems
for real developers.
Designers will stick to Mac because of weird things like, you know,
400 nano, whatever, in the Mac display.
But it is going to become effectively the case that as a server developer,
a back-end developer, Windows 10 becomes, if not as viable,
more viable than any desktop Linux distro.
It's strange days, I will admit, but I think you're right.
And I've been actually playing with this, too.
I've set up an insider preview Windows environment.
Traitor.
See, burn him.
He's the traitor.
I was never on your side.
I think realistically, thinking pragmatically,
the more people that use Linux, the better.
Desktop Linux is, at least for the immediate future,
going to be just a small little niche,
and we should instead celebrate the amazing success of Linux on the server
and just how, you know, I mean, it's a legitimately great way to run that stuff.
So if Microsoft's on board with that, too, great.
And the more people that can easily be exposed to Linux,
the better because maybe someday they also say,
oh, do I want to run this on the desktop?
They'll try it out.
They'll play with it.
Maybe they'll buy a Raspberry Pi and run it on there.
It really doesn't matter.
The future is already guaranteed.
Again, I mean, we should wrap this up.
But again, I just want to reiterate the point that like maybe I'm wrong,
but in my mind, and I think this is what Linus believes
because I saw an interview with him years ago,
Linux has nothing to do with Ubuntu, Gnome, or Fedora.
Linux is a kernel.
So if you are running the Linux kernel, you are running Linux, period, right?
Whether it's a headless Raspberry Pi that's making coffee for you
or it's indeed a Windows Dev instance that you're running all Linux tools
and using the app to get to install,
using the Debian interface with a native Linux kernel,
you are running Linux, right?
Gnome, KDE, I don't know.
They kind of had their time.
Had their time?
Wow, Mr. Dominic.
I mean, that time might still be now.
But you're right.
We should move on.
There's plenty of time for Flame Wars later in the show.
Let's wrap things up a little bit with two points
on some languages we frequently discuss.
Yes, that's, of course, Ruby and Python.
So first up, many of you probably saw the big news out of Stripe,
and that's the open sourcing of Sorbet,
a fast, powerful type checker for Ruby.
They write,
We designed Sorbet to be used at Stripe,
where the vast majority of our code is written in Ruby.
We spent the last year and a half
developing and adopting Sorbet internally,
and we're finally confident that Sorbet
is not just an experimental internal project.
We're ready to share Sorbet with the entire Ruby community.
In fact, we've already had 30 companies beta test Sorbet
and provide feedback.
So right now, what you get,
it's the core static type checker,
tooling to create new Sorbet projects,
and, interestingly,
tooling to gradually adopt Sorbet in existing projects.
And, Mike, that's kind of what I'd like to talk about with you today.
You know, when we were talking about Go earlier,
there's additional constraints, right?
And you were talking about how Ruby is a great fit
for being able to just rapidly produce stuff.
But everyone knows Ruby can get, let's just say, a little sloppy.
Something like Sorbet might be able to help clean that up,
and if you do have a great success,
you do have a long-running project,
maybe Sorbet could help you maintain it in the long term.
Yeah, that's interesting.
I mean, I did look at Sorbet.
It's one of these things that I feel like would be great
when you're starting a project,
but going back and then implementing it
and trying to have to go back and check all your types
is going to be time-consuming and painful.
Having said that, honestly,
if you're doing a large-scale Ruby on Rails
or Ruby project in general,
and you need to, you know,
get a little more type safety, right?
Make your code a little more safe.
I would check out Sorbet.
I mean, Stripe's been using it. I have played with it.
If I was starting a new project, I probably would use it.
And, you know, I'm always starting new projects.
So, yeah, I would definitely include this.
Just to have...
You know, it's almost like having
just a little more compiler checking
is really what it is, right?
Because Ruby's not a strong-type language.
No, and it's an incredibly dynamic language, right?
I mean, tons of stuff happens and is available at runtime.
So this is just a way that you can have the compiler,
you know, where it makes sense,
where you don't need as much flexibility.
You can sort of start to lock down, you know,
maybe internal core data types
and objects and structures that you're using
and have some extra guarantees
that you're not going to run into random errors around nil
or any other little type mismatch.
What's interesting, I think, is that it's,
you know, this is one space, like,
you know, obviously TypeScript is a big success.
Facebook's had Hack for PHP for a long time now.
And Python even has type annotations
as part of the language now,
not to mention some of the other available systems.
So it's interesting to see Ruby catching up.
Yeah, I think it's a...
I think it's a useful tool
that's going to be more and more useful
as some of these legacy Ruby applications
get, you know, just, you know how it is.
They get exponentially bigger over time, right?
Yeah, and many people, you know, you want to...
They say, like, oh, well, we switched to Go
partially because these types.
So you can still make Ruby work.
It might be, you know, everyone knows the pain of a rewrite.
So if you can instead suffer a little less pain
and still get partial benefits,
well, that might be a huge win.
One problem Ruby and Python share,
and we touched on this earlier,
it's application distribution.
And if you're shipping a snap
or you're shipping a Docker image, it doesn't really matter
because you basically write a script
that imperatively,
and that's kind of part of the problem here,
builds your system for you, right?
You say, like, oh, yeah, okay, here's my...
Maybe you're using Bundle and you got, like, you know,
the gems that you wanted to install for you
or you're doing pip and setting up a virtual env in Python.
Either way, when you're setting these things up,
you've got to go get and install this stuff.
And that works okay.
If you're just running stuff for yourself,
really, it's not that big of a deal.
And if you're just running scripts that you make for yourself
on your own system or systems you deploy to, fine.
It's still not great.
It's not always totally deterministic
or you have to go through some extra hoops
to make it that way, but it works.
But it's particularly troublesome
when you've hacked together a nice little script
or you've tried to write a nice command line
that you want to share with someone
and you're like, how do I distribute this application?
Yeah, sure.
That's where a new Python project called PyOxidizer
comes into play.
I think this is interesting because there are already
some solutions to this in Python.
In particular, Twitter has a project called Pex,
which is a Python executable.
There's another one called Shiv out there and Platter.
There's a number of these that sort of help to try
to re-bundle some of your virtual environment.
Right now, though, most of those end up relying on
having a Python interpreter on the system already.
And to most cases, that's true, right?
That's one of the things that makes Python a great choice
for writing some of these applications
because you can usually rely on a Linux
or even a Mac system to have Python.
PyOxidizer is different because it's everything.
So it's using Rust.
I figured we just had to include it in the show
for that reason alone, right?
I appreciate it a lot, actually.
And it actually produces a single executable
that includes a virtual end that gets mapped into memory
so it can actually load faster than a traditional one
that has to read in from the disk,
and a Python interpreter.
So it's just all-in-one use of the interpreter,
loads it up with access to the virtual end files.
You know, that sounds very good to me a lot.
I mean, I, for years, struggled with how do you package things on Linux,
and I ended up being a snappy.
Is that the wrong word?
Yeah, you know, snap, snap packages,
snapty, snapcraft.
No, no, I call them snappies.
No, it's not cute enough. Snappies.
I call the other ones flatties.
Snappies and flatties. I like it, Mr. Dominic.
That's just the part of the show where Wes is like,
he's just messing with me now, isn't he?
You are an ultimate troll.
Yeah, you know, I have to be honest with you.
I hate Python.
It ruined my Rubyism.
You mean because it tempted you?
Because it's just better than Ruby in almost every way.
We're getting a lot of feedback on the show.
Yeah, I mean, you're coming in hot.
I'm coming in hot.
I mean, they're similar.
I admit similar opinions.
They're mostly close enough.
This could be a big advantage.
Whoa, whoa, whoa.
What do you mean close enough?
You're so diplomatic, Wes.
You know, I listen to you on all your other shows,
but you're Mr.
Tell me what you really think of Ruby and no holds barred.
I mean, I don't like it as much as Python,
but there's many things about it I do like sort of aesthetically.
I like the use of nil.
I like some of like using question marks and other things.
It's pretty flexible.
I would say I generally prefer Python's explicitness,
explicit nature to Ruby's sort of magic.
Now, you're going to say, and you're right,
that a lot of that came out of the Rails community,
but it's just still kind of part of that,
and it just feels a little looser.
I've not tried Sorbet.
That might help.
Python's not great, you know, with some of the extension methods
with double underscore and that sort of thing.
I really like languages that have interfaces
and other sorts of utilities like that,
and I think those are missing from these languages.
But otherwise, while I prefer Python generally
and have more experience in that realm,
I guess what I mean is you can switch between them
relatively easy.
Both of them have libraries for basically anything
you want to do,
and the design doesn't have to change that much between them.
You were actually much nicer than I thought you'd be.
Okay, I mean, I would say that Ruby never could get out
of the shadow of Rails, right?
Where Python has become, and this is not me just trolling
for, you know, to be a dick.
Python is dominant in data science.
Python is dominant in ML now.
Yes, I know ML.net exists.
Please don't email me again, Microsoft people.
And you can totally write all that stuff in F sharp and C sharp,
but really, you're running into Python.
Where Ruby is like,
yeah, we kind of can write a Rails app.
Like, Ruby, in a weird way, Ruby got,
I don't want to say destroyed,
but kind of co-opted by the Rails community.
Am I making sense at all, or does that sound completely insane?
No, I think you're right.
I mean, part of the success of Ruby
was having that killer application that was Rails.
But you're right, it just, you know,
like many problems we see economically,
it was sort of a single thing it did really well.
And so if you want to run it for that,
Python has all kinds of applications and utility.
And I guess, I mean, we should end here,
but I guess to put a finer point on it,
the development of the Ruby language
has effectively been co-opted by what is best for Rails.
Which has, you know, limited it, right?
Python has many other domains, and they are,
you know, we can argue about technical limitations,
but they are effectively equivalent languages.
Python kept a broad, this is a language,
not a web framework.
Right, and I suppose another way
to talk about what you're saying is,
like in the design discussions of Python,
these other communities, right?
Like the big data machine learning communities,
the shell scripting communities,
they're all present.
And in the Ruby universe, it's mostly just the Rails web dev.
It's just Rails, right.
I mean, people will say they do Sinatra or Patrino,
or they do, like I have Rails scripts,
but I mean, effectively, everything is geared towards Rails.
But yay, Python.
Yay, Objective-C.
Maybe our audience has opinions
about some of the neat stuff we've talked about.
Maybe you're thinking about adopting Sorbet
in your project.
Or you're thankful to finally have
a great way to ship Python.
Go try out PyOxidizer,
and then let us know what you think.
coder.show slash contact.
You can also head over to coder.show
to find our whole backlog
and an easy way to subscribe.
We've got an RSS feed.
Super simple.
It's the best way to make sure you get
every single Coder Radio episode.
If you want to catch us live,
yeah, we do this show live every Monday,
12 p.m. Pacific.
If you don't know what that is in your time zone of choice,
well, head on over to jupiterbroadcasting.com slash calendar,
where our magic Google bots
will automatically convert it
to your time zone.
jupiterbroadcasting.com also has
all the other fine
Jupyter Broadcasting productions.
If you want to get caught up on the
latest Linux and open source news,
well, Linux Action News.
Or if you're new to this whole Linux world,
go check out Choose Linux,
which is a show that captures
the experience of discovering Linux.
If you just can't wait and none of that
is enough content for you, well, don't worry.
Mike and I are both on Twitter.
Mike especially.
He's at Dimenuco.
And I'm at Westpane.
The whole network's there too, of course,
at Jupyter Signal.
Thank you so much for joining us today.
Please do try and join us live if you can.
We'd love to have you.
Until then, see you next week.
jupiterbroadcasting.com

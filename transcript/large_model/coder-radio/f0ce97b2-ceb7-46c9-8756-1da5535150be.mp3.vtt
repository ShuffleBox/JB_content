WEBVTT

00:00.000 --> 00:07.000
This is Kota Radio, episode 368 for July 29th, 2019.

00:31.000 --> 00:43.000
Hello and welcome to Kota Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business, software development and related technologies.

00:43.000 --> 00:49.000
My name is Wes and I'm very pleased to be joined by Mr. Michael Dominic. Welcome back to the show, Mike.

00:49.000 --> 00:51.000
Thank you. How are you, Wes?

00:51.000 --> 00:55.000
Oh, I am doing fantastic. I'm excited about the episode we've got today.

00:55.000 --> 01:04.000
Not only are you finally going to reveal what you think of Clojure, you know I'm dying to know, but we've got a whole bunch of other great things to talk about.

01:04.000 --> 01:11.000
So we might as well start off with one of my favorite things. That's some feedback from you, our dear audience.

01:11.000 --> 01:16.000
This comes from the subreddit, kotoradio.reddit.com, from the user Selsek.

01:16.000 --> 01:18.000
It starts off like this.

01:18.000 --> 01:30.000
Thanks, guys. Thanks for everything you do. I'm a new listener and a complete new programmer, but I've learned quite a few things from listening and love the show, even if I don't understand most of it yet.

01:30.000 --> 01:33.000
Well, thank you for the kind words.

01:33.000 --> 01:36.000
The more I get into CS, the more I wish I understood it better.

01:36.000 --> 01:41.000
I'm currently working on a cybersecurity degree with a minor in computer science.

01:41.000 --> 01:51.000
And I've got a question I can never get an adequate answer to on Google or from professors and thought maybe you guys could answer it on the show.

01:51.000 --> 02:00.000
There are so many languages out there, and I just don't understand when or why you would want to use one language over another.

02:00.000 --> 02:11.000
For example, I always thought you had to use Java for Android and Swift or Objective-C for iOS, but I recently learned you could also use things like F sharp or C sharp.

02:11.000 --> 02:17.000
It's so confusing for anyone to know when to use what, and I just don't know where to turn next.

02:17.000 --> 02:21.000
What should I learn? Do you guys have any advice?

02:21.000 --> 02:24.000
First of all, thank you for the kind words. It's always appreciated.

02:24.000 --> 02:34.000
As we stumble into the language flame war here, kind of do whatever you want, right? I mean, as long as you're picking Objective-C, you're obviously making the right choice.

02:34.000 --> 02:37.000
So let your heart guide you to Objective-C.

02:37.000 --> 02:43.000
Oh, ouch, Mike. That's only just like a little bit biased, I think, but I understand your position.

02:43.000 --> 02:46.000
That seems biased, really?

02:46.000 --> 02:51.000
I really liked one of the commenters on the question from Tyler A. Young.

02:51.000 --> 02:54.000
He pointed out a good few axes to consider when you're thinking about stuff.

02:54.000 --> 02:57.000
So one might be developer productivity.

02:57.000 --> 03:00.000
Lots of people like higher level languages like Python or Ruby.

03:00.000 --> 03:03.000
They're expressive. They're nice to work with.

03:03.000 --> 03:11.000
On the other hand, your application domain might really need strong performance guarantees if you're making something like a video game, say.

03:11.000 --> 03:20.000
And other ones, you know, if you're just making a web app that's already bound by something like database or disk performance, then you might have more options in terms of language choice.

03:20.000 --> 03:24.000
You might be trying to target something like the embedded space or mobile.

03:24.000 --> 03:28.000
In all of those, there's usually languages that are commonly used.

03:28.000 --> 03:31.000
Now, you can use almost any language for almost anything, right?

03:31.000 --> 03:35.000
So you can use F sharp to write Android apps, say.

03:35.000 --> 03:40.000
Usually you find that out as you get better with languages and you learn more.

03:40.000 --> 03:47.000
So I don't think there's anything wrong with just sort of sticking to learning the basics for whatever projects you're trying to work on.

03:47.000 --> 03:52.000
Because once you've learned a handful of languages, it just gets easier to start learning other languages.

03:52.000 --> 04:02.000
And you'll naturally find as you try using different languages for different tasks where they fit nicely for you, because that can be a very personal choice sometimes.

04:02.000 --> 04:10.000
Yeah, I mean, honestly, trolling aside, it definitely is about, you know, what can you get stuff done and but also what will you enjoy, right?

04:10.000 --> 04:15.000
Foreshadowing, I think we're going to have something about that later in this episode.

04:15.000 --> 04:18.000
Oh, yes, we will.

04:18.000 --> 04:25.000
One other note I really liked about Tyler's feedback here, Tyler's answer to the feedback, that's ecosystem.

04:25.000 --> 04:28.000
Sometimes ecosystem can be more important than the language.

04:28.000 --> 04:37.000
If you just really need a rich selection of well-supported, robust libraries, then, you know, something like Java or Python, that can make sense.

04:37.000 --> 04:39.000
It depends on what you're trying to target.

04:39.000 --> 04:45.000
But I think that's something that doesn't always get considered when you're considering things like aesthetics and how it feels to use a language.

04:45.000 --> 04:49.000
It also matters, you know, if you have the right database driver easily at hand.

04:49.000 --> 04:57.000
Now, I don't know how useful that is, but I'd say as you're learning and studying this stuff anyway, yeah, just stick with what you're doing.

04:57.000 --> 05:01.000
You'll hear us talk about esoteric languages and they're worth playing with.

05:01.000 --> 05:05.000
But don't feel like you need to do that at any pace more than you're curious about them.

05:05.000 --> 05:13.000
You know, there's plenty to learn and continuing down the route of learning Java or Python or other popular languages, you're still going to learn a lot.

05:13.000 --> 05:16.000
So, Wes, what is this crazy thing you sent me?

05:16.000 --> 05:26.000
Yeah, OK, so there's been some news out there in the computer science circles, and that's because what's called a decades old computer science conjecture.

05:26.000 --> 05:28.000
It's been solved in two pages.

05:28.000 --> 05:31.000
Now, that might be a silly headline.

05:31.000 --> 05:33.000
What's going on? Why do people actually care?

05:33.000 --> 05:41.000
Well, it's called the sensitivity conjecture, and it's kind of just an embarrassing outline problem for computer scientists.

05:41.000 --> 05:48.000
It's basically stood as one of the most frustrating and embarrassing problems in all of combinatorics in theoretical computer science.

05:48.000 --> 05:52.000
At least according to Scott Aaronson of the University of Texas.

05:52.000 --> 05:53.000
You might be familiar with his blogs.

05:53.000 --> 05:54.000
It's great.

05:54.000 --> 05:59.000
Talks a lot about various theoretical computer science as well as quantum computer related stuff.

05:59.000 --> 06:01.000
I follow it very avidly.

06:01.000 --> 06:04.000
He has a really good explanation of what's going on here.

06:04.000 --> 06:12.000
But honestly, the best one I was able to find is over at, believe it or not, the Explain Like I'm Five subreddit.

06:12.000 --> 06:15.000
What is the sensitivity conjecture like really all about?

06:15.000 --> 06:25.000
Well, it has to do with Boolean circuits and how much the output of that circuit varies is sensitive to the input to the circuit.

06:25.000 --> 06:38.000
So you might imagine this big, you know, Boolean function with lots of ANDs and NOTs and NORs and NANDs and ZORs and whatever gates you have all strung up and you've got some number of input bits and then some output bits.

06:38.000 --> 06:48.000
Sensitivity is basically a measure of how complicated the system is and, you know, what different ways of varying the inputs will affect the output.

06:48.000 --> 06:54.000
And the analogy the user Portarossa made was think of it like a BuzzFeed quiz.

06:54.000 --> 06:55.000
Oh, no.

06:55.000 --> 06:58.000
Yes, that's right. So maybe you've done one of these, Mike.

06:58.000 --> 07:07.000
You answer a bunch of multiple choice input questions about seemingly random topics like what's your favorite breakfast cereal and what's your favorite classic movie?

07:07.000 --> 07:13.000
And then eventually at the end, you get a response back, which is something like which Hogwarts house you belong to.

07:13.000 --> 07:16.000
Mike, something tells me you're a Slytherin.

07:16.000 --> 07:19.000
You know, that's what my wife says, too. I don't I can't imagine why.

07:19.000 --> 07:29.000
OK, so we've all taken those quizzes and like you're not happy with the outcome. So you kind of wonder, you know, like how many answers would you have to change to get a change in the output?

07:29.000 --> 07:40.000
Some of them don't make a difference at all. Right. So it doesn't matter if you prefer Coco Pops or Rice Krispies if the sorting hat algorithm only uses that to determine between Gryffindors and Slytherins or Hufflepuff and Ravenclaw.

07:40.000 --> 07:44.000
Right. So there could be choices that based on other choices don't matter at all.

07:44.000 --> 07:52.000
On the other hand, some of them matter a lot and it might be enough to just change one answer and get a totally opposite house.

07:52.000 --> 07:57.000
So I can tell you no self-respecting Slytherin is eating Coco Pops. Just throwing it out there.

07:57.000 --> 08:11.000
Right. Yeah. See, it just makes sense. So what the conjecture is about is if the rules for sensitivity, you know, this sort of system measuring the variability of the outputs on the inputs.

08:11.000 --> 08:22.000
If that follows the same sort of rules as other measures of complexity for other types of circuits, or if it's some sort of weird outlier and, you know, it's kind of just been sitting there.

08:22.000 --> 08:33.000
Theoreticians have posited that, okay, well, we probably assume that it is, you know, it follows the same. It's probably not a weird outlier. And that's what this proof is finally confirming.

08:33.000 --> 08:34.000
Okay.

08:34.000 --> 08:44.000
So the other part about this, it's interesting from a technical perspective. And if you have a little bit of familiarity with linear algebra, there's some great breakdowns out there which we'll have linked in the show notes.

08:44.000 --> 08:52.000
So you can go check those out and try to work your way through it. And what's notable is that this is what's called a proof from the book.

08:52.000 --> 09:04.000
Famous and wonderful mathematician, Paul Erdos, famously spoke of this book, Maintained by God, in which every perfect, most beautiful proof of all the theorems lived, right?

09:04.000 --> 09:11.000
And so anytime it's a great compliment, anytime someone solves something in an amazing and elegant way, it's what's known as a proof from the book.

09:11.000 --> 09:25.000
And that's what's astounded people here because it's an open problem. It's interesting theoretically. And for some reason, it was not only was it like took ages and hundreds and hundreds of hours of researchers trying to, you know, fight this problem over the years.

09:25.000 --> 09:26.000
Right.

09:26.000 --> 09:32.000
But then out comes this beautiful, remarkably simple, seemingly obvious two page proof.

09:32.000 --> 09:42.000
Yeah, there's something kind of really weirdly poetic about having such an old problem, have such a, I mean, relatively simple solution, right?

09:42.000 --> 09:47.000
Two pages is, I mean, that's most things aren't that short.

09:47.000 --> 10:02.000
I like to point that Scott Aaronson made, which was, you know, a lot of research, especially these days, you know, you put in a lot of work, you know, the researchers spend four or five months researching something and then write a paper sort of summarizing what they've found.

10:02.000 --> 10:15.000
And, you know, it takes a lot to sort of understand and be familiar with it. So the ratio of like, you know, what you need to understand to like find the answer and what you need to understand to understand the answer once it's been formulated is small.

10:15.000 --> 10:21.000
But here, like, the math is really simple and people are just shocked that it took so long to figure out.

10:21.000 --> 10:26.000
It's good that it's solved. And if you have any questions, email Wes at Jupiter Broadcasting.

10:26.000 --> 10:37.000
That's right. You know, I just like to, we're mostly a pragmatic show, as we mentioned in the introduction, but I still think it's nice to maintain a link with theory every now and again.

10:37.000 --> 10:41.000
Oh, no, I think it's great. Yeah, I think we could do a little more theory, actually.

10:41.000 --> 10:43.000
Oh, perhaps in a future episode.

10:43.000 --> 10:47.000
Now, what's the proof written in Objective C? I'm kidding. I'm kidding. Just keep moving.

10:47.000 --> 10:52.000
No, although maybe it will be soon if I get what you're thinking, Mike.

10:52.000 --> 10:58.000
So apparently there's some issues regarding trade conflict and GitHub.

10:58.000 --> 11:00.000
Yes, that's right.

11:00.000 --> 11:14.000
There's the debate over free speech taking place after Microsoft owned GitHub, remember, restricted the account of a developer based in Crimea, who used the service to host a website and some gaming software.

11:14.000 --> 11:25.000
So this is one case. Anatoly Kashkin, a 21 year old Russian citizen who lives in Crimea, basically woke up and found that his GitHub hosted site no longer worked.

11:25.000 --> 11:36.000
And some other restrictions about private repositories and basically found himself with, due to trade war imposed sanctions, unable to use GitHub.

11:36.000 --> 11:43.000
There's also been other hubbubs around some similar actions taking place to open source developers living in Iran.

11:43.000 --> 11:57.000
Kind of seems like a stark reminder that while GitHub is, you know, loves open source, Microsoft loves open source, it's a great place to develop and work on open source. It's a US entity, you know, it's not immune.

11:57.000 --> 12:03.000
We think of the internet as this borderless place, but that's just no longer the case, at least for things involving big business.

12:03.000 --> 12:18.000
So now, what is the potential impact on the wider open source community? Is it just that you can't work with people from, I guess, rival countries on GitHub now?

12:18.000 --> 12:29.000
Or is it like, what happens to that code, right? Is that code now contraband, so to speak, because of the trade war? Or is it you just can't, they can't have GitHub accounts now?

12:29.000 --> 12:40.000
And I'm assuming if there was an Iranian version of GitHub, that would work the same way for us. But there's, you know, not, at least not one that's big, like GitHub.

12:40.000 --> 12:48.000
So you get what I'm getting at? I was like, what if let's just make something up, right? What if like, Apache? Or I'll make it even better.

12:48.000 --> 12:59.000
What if, you know, the trade war was with Great Britain? And so can you no longer like download Ubuntu? Is that what that means? Because canonical is a British entity.

12:59.000 --> 13:04.000
So here's the here's what one of the developers got in an email, you know, or explaining what happened.

13:04.000 --> 13:18.000
Due to US trade control law restrictions, your GitHub account has been restricted. For individual accounts, you may have limited access to free GitHub public repository services for personal communications only.

13:18.000 --> 13:36.000
So yeah, it does seem like at least for a large part, it's it's just cutting off contributions and ways for these developers to actually maintain projects or possibly interact in a large way with existing open source projects that happen to be hosted on GitHub, let alone host their own projects.

13:36.000 --> 13:49.000
Wow. I mean, that that sounds actually very chilling to me. Like, just a reminder that literally, this global community of software developers, dare I put on my RMS hat and say hackers?

13:49.000 --> 13:54.000
Yes, the old style definition of hacker, yes. In the Unix sense.

13:54.000 --> 13:57.000
You know what, we will not be singing the free software song today, Wes.

13:57.000 --> 13:59.000
Oh, please. Come on, Mike.

13:59.000 --> 14:11.000
And if you know what the free software song is, great. If you don't, you really need to YouTube that one. I guess. I guess not, though, if you're an Iraner. Yeah, that sucks.

14:11.000 --> 14:17.000
That's really crappy. I mean, so can we get rid of closure with this sanction? Oh, geez.

14:17.000 --> 14:32.000
Ouch, ouch, Mike. Not appreciated. Yeah, I mean, so it doesn't seem like it's terribly the end of the world. We'll see what happens. Maybe some of the trade restrictions are not permanent. But maybe many people have jumped in and tried to suggest like, oh, well, you could use competing services, right?

14:32.000 --> 14:45.000
Like there's GitLab and Bitbucket. But at least for the competing services, most of those companies still have to abide by, you know, they're either on stock exchanges or otherwise tangled up in ways that they also have to do what the US says.

14:45.000 --> 14:55.000
Yeah, so there is just like, another thing here of like, my understanding is these people actually lost access to the repos, right? They can't do anything with them right now.

14:55.000 --> 14:59.000
Yes, exactly. And there was not a warning either. It was just GitHub flipping a switch.

14:59.000 --> 15:18.000
Once again, GitHub's great. I use GitHub. I love it. Git is meant to be decentralized, right? So if you're using GitHub, like old school SVN, you're just doing it wrong, right? It's really GitHub should just be a product management tool, which I love it for. I'm a big fan of the Kanban board thing.

15:18.000 --> 15:30.000
It's not that new, I just started using it. But like, and a backup for your code, right? An offsite backup, it really shouldn't be, you know, the one source of truth for your project. And I know it basically is for a lot of people.

15:30.000 --> 15:31.000
Yes, it is.

15:31.000 --> 15:44.000
And I can't say that I've never done that. But it just a reminder, Linus Torvalds, who yes, Linus made Git if you didn't know that, made it decentralized for many, many good reasons.

15:44.000 --> 15:46.000
So happy hacking.

15:46.000 --> 16:09.000
All right, well, let's move on from that complicated issue. And talk back a little bit more about open source software, the technical side of things. Now, this is a crazy story you sent to me, Mike, and that's a Rust based TLS library, outperformed open SSL in quote, almost every category. What's going on here?

16:09.000 --> 16:26.000
So we know that I love Rust. And I do pay attention to the Rust news when I can. Basically, there's a Rust implementation of a TLS library that pretty significantly outperforms open SSL. Now, that's kind of the headline here.

16:26.000 --> 16:44.000
There is a little bit of back and forth because, you know, there's some shared history and some shared code. And it's anytime you're talking benchmarks, you're going to get the well, but actually guy who's like, in these cases, or, you know, yes, of course, really, you shouldn't.

16:44.000 --> 16:47.000
This isn't like dunking on open SSL.

16:47.000 --> 17:05.000
It is just very cool, like, to see Rust being used in yet another way. And honestly, Rust is very performant. I would love to do more with it. I think the Rust community as it's growing, is going to start to replace a lot of these older utilities.

17:05.000 --> 17:21.000
And not just open SSL. Again, this isn't the story is about open SSL, but I'm not trying to like tack open SSL. No, no, I'll give you my exact use case of how I'm using Rust. I had to do some crazy STL file processing things. And I could have done that in C++.

17:21.000 --> 17:43.000
But you know what, the security and safety were really the safety guarantees of Rust, coupled with the performance made that a no brainer. So now I'm going back as I need to update some of my old C++. I'm using the wrong word libraries, maybe they are libraries, but like, there are things I bring into Rails projects for performance sensitive tasks, right?

17:43.000 --> 17:51.000
Stuff that you've offloaded out of the Rails thing, but you know, have some other code, we're living outside, do it faster, and then just return the results.

17:51.000 --> 18:14.000
Even if you just run it in a different process, right? And then just return it back. It's, it really has been more efficient from a developer perspective, protected me from a lot of stupid memory mistakes, because, you know, I used to write Objective C with, you know, manual memory management every day. But now I don't write because time moves on and C++ was never my first language anyway.

18:14.000 --> 18:30.000
So yeah, there's definitely a tendency to make mistakes there, where in Rust, those mistakes are simply not allowed. And I'm getting just tremendous performance. So I'm gaining safety, gaining developer productivity, once you kind of learn some of the idiosyncrasies of Rust.

18:30.000 --> 18:52.000
And I'm, I'm not giving up performance. I think that's great. I just like to highlight these Rust stories, because I honestly think that it is one of the, I mean, the Rust people won't shut up about it. But it is one of the lesser known, and I would say underrated languages of, you know, I think the next few years.

18:52.000 --> 19:10.000
Yeah, what excites me is, you know, it brings this these targets that can do stuff like write an operating system or target embedded boards. But with all the nice features that you get from you expect from modern languages that have build tools and easy way to pull down and manage dependencies with, you know, with cargo and rust, for example.

19:10.000 --> 19:28.000
So that's exciting. And it's exciting to see it succeed in this area. Again, not to knock open SSL, but as we all know, it's a, it's an old, complicated, large project started before, you know, we really understood all we do now about modern security practices in software.

19:28.000 --> 19:45.000
Not only can rust help address some of that, like some of the stuff here is nice to not only the security stuff, but like, it's faster in some ways. And the big one for me I saw was uses approximately half as much RAM. That's a handy optimization if you've got a lot of SSL connections.

19:45.000 --> 19:59.000
Of course, we'll have links to everything the author has some great blog posts that actually dive into all the different measures that they did to try to do these benchmarks because obviously benchmarking is complicated. That's not the takeaway here.

19:59.000 --> 20:07.000
But if you're curious about what makes this all work, you want to dig into some of the code. That's all linked coder dot show slash 368.

20:07.000 --> 20:16.000
All right, Mike, we've put it off far too long. It's time once again for our seven languages check in.

20:16.000 --> 20:22.000
Yeah, so closure. All right. I'm going to do a little preamble to the Constitution here.

20:22.000 --> 20:24.000
Oh, I'm excited already.

20:24.000 --> 20:34.000
This is the first language I have looked at in a long time, where I went in, got frustrated and stayed frustrated with it.

20:34.000 --> 20:45.000
Now, I actually was able to get it set up and do a little bit around it. But the more I read about it, the more I understood why I didn't like it. So maybe we should just take a step back.

20:45.000 --> 20:50.000
So closure is West's one ring of Sauron of programming languages.

20:50.000 --> 20:52.000
That seems right. Yeah, that seems right.

20:52.000 --> 21:04.000
It is, you know, closure is to West as objective C is to Mike, right? So just, it's also a, would you call it a child of Lisp?

21:04.000 --> 21:09.000
Yeah, I mean, it is, it is a Lisp. Rich Hickey, the author, did a bunch of common Lisp before.

21:09.000 --> 21:16.000
So it shares some common Lisp heritages, although it is not the same as common Lisp by any means. But yes, it is definitely a Lisp.

21:16.000 --> 21:23.000
Right. So if you are like me, and you never liked Lisp, then you are not going to like closure.

21:23.000 --> 21:26.000
And this is coming from the small talk guy. Come on.

21:26.000 --> 21:29.000
Oh, this is nothing like small talk. Oh, come on. Really?

21:29.000 --> 21:37.000
I just meant you're generally very open about languages, you know, except when they're criticizing objective C.

21:37.000 --> 21:42.000
Well, I, you know, you had to bring up small talk, huh? Okay. So fair enough.

21:42.000 --> 21:49.000
So it actually like, I don't have a reason that like, you shouldn't be using closure. I actually think it's very good.

21:49.000 --> 21:57.000
I just don't like it. But let's, let's give the fair case. And then I'll explain why I don't like it after maybe that's, that's better.

21:57.000 --> 22:05.000
I actually found getting started was relatively quick, which I, I had this expectation was going in that this was going to be like a beast to get set up.

22:05.000 --> 22:07.000
It was not.

22:07.000 --> 22:17.000
Oh, good. I'm glad to hear that. Did you install line again, the main build tool? Or did you go with the default CLI tools that were recently introduced?

22:17.000 --> 22:27.000
I went with the default CLI tools with one big asterisk, there is a VS code extension for it. That brings it all kind of more to the forefront and accessible.

22:27.000 --> 22:29.000
Oh, yeah. Kelva?

22:29.000 --> 22:38.000
If you're familiar with any of the other VS code, like build tools, it looks very much the same, you know, with the obvious accommodations to closure.

22:38.000 --> 22:43.000
So it was nice. I was in an environment that I'm used to working in. Great.

22:43.000 --> 22:51.000
I, I really wanted to like it, right? Because I think it has a lot going for it. First off, the JVM.

22:51.000 --> 23:04.000
So I've done a ton of Java, I've done a bit of Kotlin. And there's like JVMs are running around everywhere, right? Big enterprises, little, there are hell you can run the JVM on some of these IoT boards.

23:04.000 --> 23:07.000
I'm not really sure. Maybe you shouldn't, but you can.

23:07.000 --> 23:14.000
But you can't. Yeah. I mean, the JVM is almost everywhere and is run in production by many, many large organizations.

23:14.000 --> 23:25.000
Right. And closure is giving you, you know, by being so purely functional, it's giving you again, kind of that safety that I was going on with, with Rust, comparing it to an F sharp.

23:25.000 --> 23:31.000
Closure is much pure functional language, in my opinion, than an F sharp.

23:31.000 --> 23:34.000
I, I think that's actually a pretty, pretty safe assertion there.

23:34.000 --> 23:35.000
Interesting.

23:35.000 --> 23:40.000
See, this is the problem, right? I like everything I did. I looked at other people's benchmarks.

23:40.000 --> 23:45.000
I wrote a few kind of dumb, you know, write a blackjack card counter and things like that.

23:45.000 --> 23:46.000
Yeah, right.

23:46.000 --> 23:50.000
I wanted to like it. I could not get over the syntax was my real issue.

23:50.000 --> 23:52.000
Really? The syntax?

23:52.000 --> 24:07.000
The syntax. I could just, I kept having to stop and I don't even know how to say like, stop and think about what I was doing because I kept typing things in more of a, I want to say like, like C family style language, right? Like, yeah.

24:07.000 --> 24:10.000
Yes. Yeah. Algol derived.

24:10.000 --> 24:12.000
Right. And I was just kept being wrong.

24:12.000 --> 24:21.000
It really has everything I should like, right? Functions are first class objects, although I'm not sure that you would really call them objects.

24:21.000 --> 24:24.000
Looping, it's meant for looping, right?

24:24.000 --> 24:39.000
My weird dunking on Lisp before, Lisp has been around for a long time and does a lot of great work and Clojure is, it's true. It's a much nicer, more modern Lispian. I'm not even sure how you'd say that. Like Lisp derivative.

24:39.000 --> 24:41.000
Yeah, I just say, you can just call it a Lisp.

24:41.000 --> 24:54.000
Okay. You just call it a Lisp. Okay. I wanted to like it, Wes. I really did. I feel terrible. Like the ability, so my number one positive feature, you could just like import stuff from Java.

24:54.000 --> 24:59.000
Oh yeah. You get access to the whole Java ecosystem. Anything that runs on the JVM.

24:59.000 --> 25:03.000
Yeah. So like grab some great old jars and have a party.

25:03.000 --> 25:04.000
Yeah.

25:04.000 --> 25:23.000
In theory, and this is actually a question, so I'm not sure. Let's say you have like a big enterprise Java app, right? And you want to write this new, very complex data processing module. Could you just like write that in Clojure and just pull in what you need from, you know, whatever your existing, your existing Java modules?

25:23.000 --> 25:37.000
Yeah. And I would say actually that's a fairly common sort of thing. You know, if you have a bunch of libraries, maybe existing or external that are written in Java, either because legacy or you like them that way, or for performance reasons, possibly.

25:37.000 --> 25:48.000
And then you can use Clojure as a higher level sort of thing on top to connect that all together in a nice way, as it does, as you say, you know, has nice facilities for working with data, managing it in a high level way.

25:48.000 --> 25:53.000
And because we're talking about the JVM here, it is literally everywhere, as you stated before.

25:53.000 --> 26:05.000
And you can do the reverse too. So because Clojure is distributed as just as a jar, right, it's just a bunch of compiled JVM bytecode, you can sort of sneak it into Java projects to just sort of add it as a dependency.

26:05.000 --> 26:20.000
That can be one neat thing you can do is in a Java application, if you wanted to have a little more, you know, debuggability or like live ways to introspect at runtime, one thing you can do is add Clojure and just have it open up a network REPL doesn't have to do anything else.

26:20.000 --> 26:25.000
But then you can connect to the network REPL and then go interrogate all the structures living on the JVM at runtime.

26:25.000 --> 26:27.000
Oh, wow. Okay.

26:27.000 --> 26:35.000
And of course, there are other tools, right? One of the nice things about the JVM is there's a rich suite of observability tools already. But that's one way you can play with it.

26:35.000 --> 26:39.000
I mean, the whole macro thing, which I had a hard time wrapping my head around.

26:39.000 --> 26:45.000
You can kind of think of them as compiler extensions that you can write in line with your code.

26:45.000 --> 26:46.000
Interesting. Okay.

26:46.000 --> 27:01.000
Because when you when the compiler sees a macro, it takes the so that the thing about Lisp right is the homo iconicity that you the language you use to describe it is the same data structures you use with the language.

27:01.000 --> 27:11.000
And that's it takes a while to get used to that. It's kind of a kind of a head trip because Clojure is not written. So the compiler for Clojure never sees text.

27:11.000 --> 27:20.000
There's a separate component called the reader. And the reader reads the actual, you know, the text file, but it immediately converts it to actual data structures.

27:20.000 --> 27:32.000
And that's what the Lisp or the Clojure compiler actually uses. So when you write a macro, the compiler stops its compilation, and it just reads whatever is in the macro, you know, whatever you're using the macro on.

27:32.000 --> 27:48.000
And so you get a data structure that is describing, you know, could be like a function body definition, say, and then you can use all the tools you have in Clojure for working with lists and sets and vectors and maps to modify that return a new data structure.

27:48.000 --> 27:52.000
And then that's what the compiler compiles. Oh, crap. That's actually really powerful.

27:52.000 --> 28:10.000
Yes, it is amazing for doing like meta programming work, adding abilities to add abstraction. So tons of the language itself. It's just written as macros, for instance, the or function, it's not really a function, it's a macro, because it needs that ability.

28:10.000 --> 28:17.000
Because of the control flow, you know, it may or may not evaluate everything, you can do that with the added power of a macro.

28:17.000 --> 28:30.000
Right. I mean, another thing that just stuck out to me was I really like the way it handles asynchronous programming, which you can tell, like, this is something that would make a lot of sense in a data intensive asynchronous environment.

28:30.000 --> 28:41.000
I thought the so there was one concept was that I'm, I think I understand it, but I might be wrong. The atoms and how they relate to agents.

28:41.000 --> 28:59.000
So agents are a little more confusing, and are not really, I mean, they are used and can be useful, and sometimes the right abstraction, but atoms are used ubiquitously in Clojure, because they just ended up being a really nice way to do state and they're kind of the default way to handle state in Clojure.

28:59.000 --> 29:06.000
And the key to understanding atoms is to think of them as compare and swap. That's the semantics of the atom.

29:06.000 --> 29:16.000
So really, it's all about an atom is basically a, a reference to an immutable value. So everything in Clojure is immutable, basically.

29:16.000 --> 29:24.000
You have all this data, it's an immutable value, it's not, don't think of it as immutable object. But you do sometimes need to make changes, right? You do need change in your program.

29:24.000 --> 29:25.000
You need some state. Yeah.

29:25.000 --> 29:38.000
And that's where the atom comes in. So you say, like, all right, I'm setting my state in the atom. And then you can later go back and say, all right, I have this reference my atom. And then I can point that atom from one immutable value to the next one.

29:38.000 --> 29:49.000
But it's got nice concurrency things in there. So you write a function that receives the current atom state and returns the new atom state. And then Clojure behind the scenes handles all the compare and swap stuff.

29:49.000 --> 30:01.000
So like, if there's a race where one person had, you know, got the lock and was trying to write, like, you don't have to think about any of that. It just does it for you. So you do have to write it being aware, right? Like there may be retries happening under the hood.

30:01.000 --> 30:13.000
But as long as you stick to a few simple rules, they are fantastic. And because they're used everywhere, they're well optimized. So most of the time, you don't have to worry about using them. They're not a lot of overhead.

30:13.000 --> 30:28.000
So on a high level, why am I wrong? What am I missing in the glory of Clojure? Like, it's by no means bad, in my opinion, I'm just, it didn't enchant me the way it did you. So I'm clearly I'm missing something, right?

30:28.000 --> 30:48.000
I guess the things I thought you would like were the simplicity of it, the lack of getting in your way, you know, you're a capable developer who moves fast and works on his own set of projects. And I think that's one area where, where Clojure can shine just because it's, it can give you a lot of leverage, right?

30:48.000 --> 30:59.000
So instead of having if you did have a Java project, or you needed to produce an X, you know, object that would run on the JVM, what would you choose? Would you not choose Clojure?

30:59.000 --> 31:02.000
I would probably choose Kotlin.

31:02.000 --> 31:24.000
Yeah, that's fair. No, Kotlin is a great choice as we you know, as we talked about when we when we talked about Kotlin. Because it depends on if you want to shift to a different paradigm. It may be tricky, because I think if you don't have a strong, as you say, you know, if you if you hate Lisp already, there is a little barrier to overcome.

31:24.000 --> 31:36.000
It's funny. So at first, you know, take some time to learn to read because it's a weird ordering, right? Like the function name comes first. And while I think that ends up being pretty clear, once you get used to it, it's a big change.

31:36.000 --> 31:49.000
Yeah, I think I you know, I think it's difficult to understate how much just the novelty of the syntax threw me off, especially because I've spent, you know, the last three weeks working almost exclusively in Ruby.

31:49.000 --> 31:51.000
Right? Yes, it's quite different.

31:51.000 --> 32:03.000
And then at night trying to like, do some closure. And it's pretty frustrating when you like, especially as you say, the kid is an experienced programmer, you have the idea, basically, most of the time of like, what you're actually trying to do.

32:03.000 --> 32:13.000
And then you have to, you know, flap around and try to make the language actually cooperate with you. And so that that can take a while before, you know, before you that impedance mismatch sort of calms itself.

32:13.000 --> 32:25.000
And I find the opposite now. It's kind of funny. There was a while where I was first learning Clojure. And I'd also been doing a lot of Scala at the same time. But I'd started Scala first, actually, and then kind of switched to Clojure and then had to come back to Scala for a project.

32:25.000 --> 32:27.000
And you found Scala foreign to you?

32:27.000 --> 32:40.000
I really did. And I actually struggle. I struggled with Python. I struggle with the C like languages now because I got so used to the way Clojure does it. And what's neat is that homo iconicity stuff comes back because

32:40.000 --> 32:54.000
big words, big words. There are no weird magic stuff. So like, when you're looking at a Python, like a Python source file, right? Like, what is the def when you're defining a function? What is that? I mean, is there even a name for it? No, it's just like a part of the syntax.

32:54.000 --> 33:13.000
Clojure has reified everything. So you're just writing a data structure. And all everything is remarkably consistent. Because how do you define a function? Well, you just make a list with def and as the first part of it. So other languages just sort of seem like they have a lot of unnecessary ceremony.

33:13.000 --> 33:17.000
And a whole bunch of, you know, restrictions for no reason.

33:17.000 --> 33:43.000
Yeah, I think that's actually fair. I think that's a great point to bring up. Because, you know, with a general show like this, there's so many different types of programming paradigms, right? And I think, honestly, I think we should cover more lisp-esque stuff as much as that hurts me to say, only because it's a whole, it really is a whole different, I don't know, like tradition, right?

33:43.000 --> 33:56.000
Almost like we were talking to the Harry Potter houses, right? It's like a whole different, it's Hogwarts compared to that weird Russian school from the books and movies. If you don't know what I'm talking about, there are other magic schools, and they're very different.

33:56.000 --> 34:24.000
Derm strength, something like that. So a couple questions for you. Did you, were you using par infer? So like, there's a couple different ways to edit lisp. And one of them, par edit has been around for a long time, and it's very respected. Because you sort of do it syntactically, like you don't worry about the syntax, you do it semantically, and you worry about the statement. So instead of writing text, you think way more about just like manipulating data structures, like, oh, pop this off the end of that list and add it to the head of this thing.

34:24.000 --> 34:53.960
I was I was not that sounds a lot better. So that's right. And then there's also par infer, which is a great project from Sean LeBron, that kind of makes Clojure, like writing Python, where the spaces, they don't really matter. Clojure doesn't care about whitespace at all. And in fact, in Clojure commas are whitespace, which is one thing I love. And it's like, been so hard when you go back to languages that are really picky about commas being in the right place. So it just doesn't matter, why should it? So par infer lets you like, as you so let's say you tab something to the to the right.

34:54.240 --> 35:05.920
That will then auto update all the right number of parentheses that you have to balance for you, because it's able to infer what kind of thing you're trying to write. And it helps you keep your code looking very nicely styled and typeset for you.

35:06.480 --> 35:16.320
So is this is this kind of a standard tool chain that this be slash Clojure developers are using? Is like, is there no chip like IntelliJ for Clojure?

35:16.320 --> 35:28.040
No, actually, so there absolutely is. And I'd be curious to see if you like it. It's called cursive. And it's based on and based on IntelliJ, a large part of it's actually written in Kotlin, and then some Clojure in there as well.

35:28.840 --> 35:43.640
And so that's another example where Kotlin was used, because, like it needed really fast stuff implemented to match up with the Java stuff. Kotlin was perfect for that. It was originally in Clojure. But there were some reasons why not to have an enclosure. So it's Clojure is not always the right fit.

35:43.640 --> 35:55.240
But you will find, you know, there's good professional level tooling. As we talked about last week, SpaceMax can also be a great tool. There's, there's really first class support there. So what was your workbook like?

35:55.240 --> 36:14.680
Yeah, I was building on the command line. I was using the, it was Clava. Oh, Calva, sorry, is the plugin I was using. I mean, it did some of this balancing, you know, kind of like the ID features I expected. But not, I'm looking at Parn for right now, not to that level, not even close.

36:14.680 --> 36:41.560
The other thing too, about Clojure development that I'm not, I'm curious to know if you picked up on, it's kind of different than most other ways, unless you're coming from a LISP background, because every single top level form in a Clojure file can be evaluated independently. So it's not like a complicated static type language that has to take a whole bunch of stuff and, you know, runs over the whole file or maybe a whole set of nested files and then eventually, you know, consumes all of it and then produces an output.

36:41.560 --> 37:10.720
Most Clojure developers send forms, which is just the name for like a set of parentheses sort of thing, to the compiler, interactively, and you build up a program. So you can start with maybe a blank sheet, and then you start defining stuff. And then you just usually there's like a hotkey. So like Ctrl C is a common one, that then just sends that code over to a running REPL. And it gets evaluated in a running JVM that you keep for most of your development session. And then as you want to like redefine a function, you just send it over there again. And then you just send it over there again.

37:10.720 --> 37:16.400
And then you add stuff, and then work interactively. It's kind of like constantly unit testing, as you go.

37:17.080 --> 37:21.640
I completely missed that. I heard what you said, I just completely I didn't even notice that ability.

37:22.120 --> 37:38.440
Yeah, so that's one thing that people love about Clojure, because you can, you know, you don't have to do this write, compile, test sort of cycle, you can make that a lot faster. And as you're well aware, as many people are, fast feedback and debugging is critical.

37:38.440 --> 37:58.520
Oh, yeah, yeah. It would be interesting. Yeah. You know what, I'm you know what I might want to do in a couple months, I should play around with the more take another, maybe even pick up a list book and cry the entire way through. And see if I got a little more familiar with just the entire list way of doing things, would I find it less jarring?

37:58.520 --> 38:21.240
Right. And I think that is a hard, that's a, this was a hard challenge. And I'll be the first to say that, because it is so different there. It's a different paradigm, it's more functional, and the whole background and heritage of the language and culture is different. So it was a tall ask to see that, you know, how much could you really get familiar with in like a week's amount of playing with the language, right? I just want to know, did you try Clojure script at all?

38:21.240 --> 38:44.440
I did not. Well, I take it back, I did, I did something stupid and trivial, but I ended up being. So from a practical perspective, I was actually, I still am very interested in like, just just the scenario that I laid out before using Clojure to modify existing old Java applications. I shouldn't say old, I'll say legacy, right. And that's less on the front end side.

38:44.920 --> 38:46.520
Hmm. Yeah, that makes sense.

38:46.520 --> 39:06.440
But I know, I know, Clojure script is also near and dear to your heart. It is just because you get to leverage the same thing. And, you know, take a fight some of the JavaScript woes that we all know and love. So let's let's summarize here, Wes. So far, you have done TypeScript, Kotlin, and Objective-C.

39:06.680 --> 39:07.640
Yes, I have.

39:07.640 --> 39:27.000
I have done Elixir, ReasonML, Go, and Clojure. I have to pick a language for you. And if you want, you can pick one for me, or you can wait till next week. So what kind of language would you like? Do you want something like common that maybe you haven't done? Do you want something out there? Like, what are you thinking?

39:27.000 --> 39:44.040
Not, not too out there. I would kind of like it to be something I might actually use or want to use or could use, you know, that had a reasonable enough world that it might still be not the default choice, but I could make use of in some capacity.

39:44.520 --> 39:47.000
All right, then I'm going to pick F sharp for you.

39:47.000 --> 39:57.640
Oh, all right. This is this is interesting, because I mean, that's your new darling, and you're trusting me with her.

39:57.640 --> 40:20.200
Actually, though, as you've shown me Elixir, I've been loving F sharp quite a lot less. But so there's a point to that. And I'm curious if you come out with the same impression that I do, because you're coming, I think, from a much, much, much more functional background than I am. That F sharp is a really, really good introduction to functional programming for folks who want to get into it.

40:20.200 --> 40:48.040
But maybe, you know, compare it to bulk closure, right elixir, recent ML, and any of them, dare we say Haskell. And it really just feels like it's, you know, the low, low fat, no carbs, functional programming languages. That's not a bad thing, right? Like the interop with.net, the interop with C sharp. Super important. There's tons of.net code out there. But I'm just curious how you feel about it.

40:48.040 --> 41:01.480
No, I'm curious. And I'm curious about that aspect, too. It's been a while since I've used the.net platform. But I've followed it's, you know, open sourcing and all the developments coming out of it for a while now. So I'm excited to give it more of a check in.

41:01.640 --> 41:04.160
It runs great on Linux and is very fast.

41:04.200 --> 41:10.840
See, that's perfect. I'm excited already. Is there anything I should I mean, should I just aim for the standard docs and go from there?

41:10.840 --> 41:33.720
Yeah, and for the standard docs, I mean, the tool chain on Linux, you're probably just fine with VS code and the command line tools. I wouldn't even bother like, you know, I love JetBrains, I wouldn't even bother installing their ID. It's, frankly, VS code is so, so good. The F sharp plugin there that you won't need it. You won't need it. And I think it's called the rider, if I'm not mistaken, right?

41:33.720 --> 41:49.040
Okay, well, that's great. That's way up my alley. And I'm excited to get started. And maybe next episode, you can tell us a little bit more about why you're loving elixir so much. But we don't have time for that today. We've got to get out of here.

41:49.280 --> 41:49.840
We do.

41:49.840 --> 42:19.560
Yeah, that's it for this episode of coder radio. But if you'd like a whole bunch more, and I assume you do coder.show is the place to go coder.show slash RSS is our RSS feed or slash subscribe. If you want to find all the other ways you can find the latest show content. Also, head on over to Jupiter broadcasting.com. Because not only do we have all the other great Jupiter broadcasting productions, like the newly rebooted shoes, Linux, but we also have a bunch of other things that we're going to cover in the next episode.

42:19.840 --> 42:41.400
With l drew and Joe, which I'm very much enjoying. But we also have a calendar on Jupiter broadcasting.com. That'll tell you when we're doing this show live to usually noon Pacific, but check the calendar to be sure. If all of that is not enough. Well, Mike's on Twitter, and he's a lot of fun. What's your handle by

42:41.400 --> 42:51.480
at Dumanuco. I'm at Westpane and you can follow the network at Jupiter signal. Thank you all for joining us. We'll see you right back here next week.


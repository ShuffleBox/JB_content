This is Koda Radio, episode 355 for April 29th, 2019.
Hello, and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business, software development, and related technologies.
My name is Wes, and I'm joined once again by Mr. Michael Dominic. Welcome to the show.
Well, a wubba dub dub and a hippity hop. Happy Koda Radio to you, Mr. Payne.
Oh, I'm always happy to be there. And you know, I'm glad I'm here today because we got a lot to talk about.
This is a thick, juicy beyond burger of a show.
And you know, a lot of the stuff that we find actually, well, sure, sometimes we find it, you know, whatever Mike drags into the show.
Oh, but many of those things, well, actually, they come from you, our wonderful audience.
If you go to our website, Koda.show, Koda.show slash contact, there's a contact form.
You just write it in. You can be anonymous if you want. You can tell us your name. Let us know what you think.
It just helps us make a better show. And sometimes it gives us great stuff to talk about.
So I was thinking today, let's start off with some feedback. All right, so this one's, this one's for me.
Tom wrote in to talk about in a recent episode, we were talking about Chrome OS and Windows. Actually, it was 353 a week with WSL.
When Mike, you were telling me all about your recent adventures over in the subsystem.
And we were kind of pondering things about like, what does this mean for desktop Linux? And what about Chrome OS?
And Tom wrote in, Wes, it hurt me when you said that there is little difference between Windows and Chrome OS.
He breaks it down for us. Chrome OS is open source versus closed Windows. Free versus paid.
An open standards based platform, meaning the web here, versus proprietary.
No bloatware versus tons of bloat. And no ads versus some small ads in Windows.
Small.
Small, yeah. That's up to the observer perhaps.
Yeah.
And your DPI.
Spam is in the eye of the beholder. But keep going.
And finally, Chrome OS is Linux. So although Google's version comes with telemetry, just like Windows, Tom notes,
people are free to avoid that by building their own. So we have things like Cloud Ready, which is excellent, in my opinion.
And you know what? I think I think Tom's pretty much spot on here.
There are ways in which I think about them in the same context, just in that they come from this big company and have been bundled and stuff.
And, you know, you might not necessarily be able to build the exact version that gets configured and shipped on your machine.
But there are still a lot of differences as platforms, especially when you compare it to the closed world of Windows.
And while they both might let you run Linux apps, they're obviously doing it in a very different way.
Sure. I mean, Wes, this was directed at you, so...
Chime in. Come on. The water's fine.
Can I say a pox on both your houses?
I think you just did.
Yeah. I more agree with you, Wes, than I do the writer. But yeah, you both suck.
Just go buy like a XPS or like a Galago or something. I don't know if you want to run Linux, run Linux.
I've never, you can ask Chris, in years of this show, I've always been kind of like skeptical of Chrome OS,
especially when they added the sort of ability to run and... Was it Android apps or Linux apps first? I can't remember.
Android, then like regular...
It was Android, then like devs, right?
I believe so, yeah.
But it's basically dev packages, right?
I mean, they are just running Linux applications. You know, I haven't actually played around with how the packaging works.
So full disclosure here, I'm very ignorant of Chrome OS. I had a sales guy who I bought a Chromebook when they first came out.
Like, we're talking six years ago, seven years ago. Crap, we're talking like eight years ago.
And he had it for two months, and then I just like bought him a Surface because it just wasn't good enough, right?
Yeah, it just wasn't meeting your needs. Overly restricted, maybe?
Yeah, like he needed... I hate to use the 90s term, but he needed multimedia functionality that at the time,
remember, we're going back like seven to eight years here, wasn't exactly possible.
I will give Chrome OS one thing in the demos I've seen, it is a lot better than it used to be, right?
Just as web apps are better than they used to be.
But I don't know what to say, Wes. I mean, at your shop over there, are they running a lot of Chrome OS?
No, not that I'm aware of. It seems like its main inroads have just been in education, schools, maybe some sort of enterprise-like casual handout use.
Yeah, at the Mad Botter, we're Linux and Mac, and we obviously have Windows partitions for testing, compatibility.
We do sell some software on Windows, but I am not a Chrome customer. I am not a Chrome OS user.
It's hard for me to kind of weigh in intelligently.
If you had a Chromebook that was suitably powerful and had a nice Google-maintained system, nice and clean, you just showed up and it works,
you open the laptop, you know that they're handling most of the stuff, and you can install all your favorite desktop, you know,
electron Linux applications, and you can have a real development environment. Would you use it?
I mean, if that's the case, sure. But isn't that just like Pop OS? Isn't that just another version of Ubuntu now?
I guess I'm missing something.
I think the worry is not the personal aspect, I think, is the nature of this.
Because, yes, personally, just running Linux, I love that. That's a great comment that you made.
No, I'm not trying to be a troll.
No, no, no, I like it. I just mean it may be that the end users, that's not â€“ yes, it is an option,
but they're going to get the choice of a Windows and Chromebook or maybe a Mac in their day-to-day lives.
Sure.
I think that's where a lot of the hope around Chrome OS is coming from is like,
hey, look, it is Linux, and it's becoming kind of like more real Linux, even if it's not perfect.
So, I mean, to answer your question in a, I guess, like a fuller way,
I have never been shy about spending money on computers.
Listen to the back catalog, right, folks?
So I would never buy a Chromebook because I just wouldn't, right?
Like, I don't know, I really will buy whatever the sexy new XPS or System76 Linux laptop is.
Or if I need a Mac, I will buy a brand new Mac Mini.
All right, let me break it down.
Other than education, I don't understand the Chromebook as a product.
Given that if I have people who aren't doing dev or engineering, Windows-based laptops are so cheap.
In fact, if I buy a Windows laptop and I throw a XFCE, by the way,
please listen to Choose Linux on Jupyter Broadcasting.
No one forced me to do this, by the way, this is voluntary.
It turns out that XFCE, which for those who don't know is a Linux desktop environment,
uses basically no memory and is super fast on shitty hardware you can buy in Best Buy.
So like for me, for my purposes as a guy who runs a dev shop,
if I have a sales guy or a customer service rep,
and if he or she doesn't want to run Windows because he wants to be part of the...
And I've had this happen, Wes, where they don't want to be the odd man out.
Does that kind of make sense?
Yeah, I mean, there's just social pressures there.
We are a Mac and Linux shop, right?
And each of us have a Mac and Linux machine, but for one hardcore Mac guy.
But like, I don't know, I would just like buy him a HP or a Dell at Best Buy
and like slap Ubuntu XFCE edition on that.
And like, I guess, educate me,
where would Chrome OS come into this conversation that I'm not understanding?
I mean, I think it would mostly probably be for larger organizations
where you had a lot of overhead, you know,
where you did need some of those enterprise controls
to manage rollouts and submissions.
And so that's what I see a lot of this debate.
Like personally, in my own life, I'm actually thinking about buying one just to play with it
because the tech is interesting behind it, but I don't really need it.
And I don't see myself using it just because I am comfortable
with the administrative overhead of regular operating systems.
But if you're the IT guy and you don't need like 50 different people all trying to do their own
and attempting to manage security updates
on the various developer laptops that they have,
maybe that gets you a little scared if you're from a sysadmin background.
That, I think, is a lot of the Google play here.
Is this like an enterprise play, basically?
I mean, there's definitely that angle, yeah.
And that's the same in the schools because you can, you know, you get it out,
they'll get you set up, and then the IT staff can administer it
and make sure that they're wiped.
And there's the security aspect of, you know, it's more sandboxed
and it's hard to install the things you want maybe,
but as a result, people just aren't going to break them.
Fair enough.
Well, we spent 10 minutes on Chrome OS just now,
which I think is 11 minutes more than we should.
Way more, yeah.
For the record, Mike remains questionable about Chrome OS.
I liked your comment, though.
You brought up your willingness, let's say willingness, to buy new hardware.
That is, I think, one of the reasons that we should move on to this next feedback topic.
Let me brace for impact then.
Yeah, hardware, it comes up sometimes.
Andy writes in to us, in a recent episode,
you guys were talking about some people on Reddit, I'll put that in scare quotes,
really hate when there are discussions about hardware.
And that it's probably just, you know, one person with two accounts.
Now, I'm not that person, but I also dislike you guys talking about hardware.
In fact, about a year or two ago, it seemed like half of every second episode
or about 25% of the show was about hardware.
I very nearly removed the show from my podcast app.
But, well, I didn't have anything better to replace it.
What I like about this is he next writes,
the hosts of the show are interesting to listen to.
Unfortunately, that only goes so far when the content itself doesn't interest me.
To be clear, I don't expect you to change anything as I'm just one person.
If you have more listeners that enjoy what you're talking about,
well, then it doesn't make sense to stop.
I'm just letting you know, here's one in that other column.
Thank you for the generally entertaining show.
Yeah, so this is a point, Wes, where you can do arbitration,
and Chris can't defend himself,
but I think I'm going to defend myself and Chris a little bit here.
So this show is old, Wes, right?
Like, you know, you're new to it.
Yeah, this is episode 355.
And as podcasts go, you know, and I've been the host of the show for a long time,
I would argue, before I hit his actual points,
that one of the main Achilles' heel of Coderradio is that it's Coderradio,
not Linux coding radio or like iOS development radio.
So it's so broad that you always end up covering a lot of things.
Like we just did last episode, we talked about what?
Erlang, Clojure, I think I threw an F sharp reference somewhere, right?
You sure did.
And before that we talked about Rust,
and before that I think I talked about Swift maybe a few weeks ago.
So the hardware stuff has been a back and forth.
What I will say is I think there's a balance.
For instance, this eGPU, you know, I'm using an eGPU for a job right now.
I have had a lot of people reach out to me on Twitter or via email
asking details about the eGPU.
I definitely get the, you know, which Linux distro are you running
or are you running Mac or Linux this week?
I get it.
It kind of doesn't matter for the context of the show.
But it's definitely a hard balance, right?
Like the analogy I like to make is if this was carpentry radio,
you know, you'd like a carpenter, right?
It would be totally appropriate to talk about, well,
do you like Black & Decker or do you like Craftsman tools?
And why?
It's my opinion that that's an appropriate conversation to have.
Yeah, right.
I mean, they're parts of your trade.
It's not the direct work and it's not a show about making hammers.
But, well, you're using a hammer.
So I would argue a different point.
So, okay, whether I'm running an XPS 13 or a Dordor Pro, I get it.
It's just like a vendor difference.
But how about if I switch from, let's say, OpenStack to Kubernetes?
Well, that's worth talking about, right?
Yeah, I would say so.
And that would be the title of the show.
So at that point, I'm going to just leave that analogy with you and say,
Wes, you are the only innocent man here.
You're the only non-convicted hardware addict here.
Judge me and Chris for the last six years.
Go ahead.
Judge, jury, executioner.
All right.
Well, in my previous existence as a Just Coder Radio fan.
Well, and you did host another show, though, right?
Yeah, yeah, absolutely.
But just thinking about it from that perspective, I think it was just,
you know, it happened to be, too, the nature of the host.
So not only is it something that you need to use for your job
and spend time thinking about because you're a craftsman
and you want to work with good tools,
and those tools do affect your ability to get work done.
So you talk about it.
Secondly, you're just flat out cursed.
So you just break everything that comes into contact with you.
So that also has led to just being hardware talking about like a little bit more.
I buy laptops seemingly once a decade.
So, you know, that shifts things,
although maybe that might change in the future now that you're influencing me.
Well, a little defense here.
I also, because of the type of work I do, particularly in the aerospace industry,
I get hardware where I do the work on the hardware
and then have to ship it back.
Right, so there's just a lot of transient hardware flowing through your life.
Yeah, there's a lot of churn, right.
I would also say it was a topic that I enjoyed listening to you and Chris talk about
because you came at it from different perspectives,
but it was an area that you could really meet in the middle.
From his perspectives using hardware for one purpose
and watching the industry for a long time
and yours from another angle.
So it was a fun way to interconnect and sort of talk about this stuff
in a little, not just from a consumer angle.
I guess that's the point that I liked
because we're just talking about things that we're using from day to day life.
Okay, that's fine. That's less relevant.
But if it's tooling that you use to get your job done,
to do development, to do programming or anything in that area,
I think it just makes sense.
Yeah, I would add, I mean, we went into a cursory explanation about three weeks ago
that at some point we have to talk again about eGPUs
because all of mine and Chris' agonizing over my potential ideal workstation,
I might not give this eGPU back, Wes.
I might just say I spilled a martini on it.
Everybody would believe that, right?
Yeah, absolutely.
Honestly, I am shocked at how good Thunderbolt supported.
I know I'm taking a tangent, but indulge me, it's Cesar.
I am shocked, or two weeks from it,
how good eGPU support is on a modern Linux kernel.
This is awesome.
I am not a big gamer.
I've gone into the telegram, into the IRC a few times to ask for a gamer.
I'll play a casual 2D game, right?
But for ML programming, for just compiling big pieces of lots of code,
oh my God, if you are a developer who just spent $2,000 and up on a laptop
and you're annoyed you don't have a dedicated graphics card,
honestly, and I'll drop it here, consider an eGPU.
Because when you're at your office, you're at your home office,
in my case I work from home, you plug it in via Thunderbolt, it's great.
But if you need to be on the road, you just run on the Intel,
the graphics processor, and you have your battery life
to do your PowerPoint or whatever you're doing.
In my case, it's whatever the healthy LibreOffice version of PowerPoint is.
But presentations?
Impress?
Whatever.
It's the built-in one to pop OS.
It's great.
And I do think it's important, right?
Particularly because we have a bent towards independent software developers.
If you're a one-man band, you don't want to have to spend,
and frankly, we've had a history of covering Mac development and iOS development,
you don't want to spend $7,000 on a Mac Pro,
which is what I'm guessing they're going to cost in June.
We'll find out in a few months.
And then another $2,500 on the MacBook Pro to carry.
Wouldn't it be nice if you could just buy the MacBook Pro,
or if you're not a Mac guy, buy the XPS or the Darter or whatever,
but get the best of both worlds?
Is that insane, Wes?
No, honestly, it sounds kind of like the perfect unicorn situation.
Because I have this OWC eGPU enclosure here.
I can pop out the Radeon Sapphire card I have in
if a better one comes out in a year,
and all I have to pay for is the card.
The enclosure still works.
You just swap them out, and suddenly it's like buying a nicer computer
with a better graphics card.
It's the whole new world, right?
I have to say, I was telling my wife,
and to say that her eyes glazed over is a wild understatement,
because apparently she found this boring.
But I don't need to spend money on computers now.
I have good enough computers,
but maybe I could buy a nicer monitor, right?
And then in a year I'd buy a nicer card to go into the eGPU container.
I forgot the word, the eGPU dock.
No.
Case.
The hell they call them, Wes.
I was just going to let you try to figure it out,
because I was enjoying it.
I can't remember, but let's just call it the eGPU container.
Enclosure.
Enclosure, thank you.
And wow, I have a new computer.
But when I'm on the road and I'm giving a presentation,
I still have my beautiful eight hours of battery life.
Right.
I don't know.
And we'll drop the hardware thing from here,
but yeah, we're going to cover eGPU stuff,
because I think it's a game changer,
especially for independent guys like me.
And Wes, I think it's a game changer for you,
because you're amazing,
and we need you rendered in the highest detail possible.
Yeah, absolutely.
I mean, you've been making all those face swaps
between me and Jar Jar,
and that just takes a lot of time to compute.
I made the face swap between Chris and Darth Maul,
although nothing happened.
It was kind of weird.
Eerily the same.
Anyway, you're right.
It's time to move on from that.
Thank you for writing in, Andy.
I appreciate that your feedback was nuanced.
Well, we always appreciate the feedback, right?
Keep writing in.
Yeah, absolutely do.
And I like that you took it into account
that people like different things,
and that's just how it is.
We think a lot about it too.
So for something completely different,
Mike, you've been trying to get us to include this in the show
for like a hot minute,
and I was like, what is this?
I'm not really caught up.
Now's the time.
I'm really confused.
As someone who ends up running things like Qt, the framework,
I'm running the Plasma desktop.
So it's in my every day.
I've never really understood the dual licensing
and how the licensing requirements work.
So, Wes, you have the benefit of, again,
all these topics you are not involved in directly.
I am unburdened and innocent.
There is an application known as Gryphon,
which I'm sure you know,
a little company called the Mad Botter.
I love it.
It is a radar display system for fighter and now bomber jets, FYI.
There was a version of it written in Qt,
and then a wonderful young man named Mike called the Qt company in Boston
and said, hey, we'd like a license.
What can we do here?
We think we're okay with the GPL, but, you know, I'd like to talk,
and if we're not, let's, you know, before I sold anything,
I'm going to be super clear.
So would my lawyer, before we sold anything.
And the cute people, the gentleman I spoke to was basically like,
no, you need a proprietary license, and it's a lot of money.
So we RMFR'd the entire project, and then we sponsored.
Wait, the entire project?
The entire source code base, yeah.
Wow.
Yeah, we sponsored Avalonia,
which is the cross-platform.NET open source toolkit,
and rewrote the entire thing in.NET with Windows support first,
and then eventually we added Linux support in about a month.
So this was a major derailment for not only the project, but the company.
This was a tens of thousand dollar loss for me personally, for my RAM.
Turns out, and so funny, a listener of the show sent this video to me,
and in fact, he makes IoT boards, and we're going to be evaluating them soon.
There's been so much confusion for the cute company about the licensing
that they've made a very helpful, very detailed video on it.
I've watched the whole thing three times.
It's their attorney.
It's a video made by attorneys.
And this is like a 57-minute video, so that's a lot.
Yeah, this is going into theoretical cases and legalities
of using the GPL and the LGPL and proprietary software.
I don't want to get in a fight about proprietary software.
Just right now, the way my business is, I just have to.
Everything's proprietary.
Proprietary software is not ethical.
One day you'll have that last cheeseburger.
Right, but yeah, you're making software,
and I'm sure if your customers were like, let's make it open source.
Okay, cool.
Then I would go with it.
And I will say we contribute back as much as our customers allow us to,
which I know is like a lame defense,
but unfortunately that's the way contracts are in.
I don't want to get into it too much.
Yeah, you're running a business.
You've got bills to pay.
We'll move on.
We're a consulting.
We're a dev shop.
We are at the mercy of our customers.
Yeah.
Well, it turns out that our exact use case was completely okay under the GPL.
Oh, really?
Regardless of what the person you talked to at the organization told you.
As long as they could upgrade the version of Q
and put another Q binary in the place of the Q we were giving them,
then we're fine.
Really?
So this is kind of a, because we got a lot of feedback on this, Wes.
We got a lot of feedback on this Q stuff.
If you are considering Q for a project, check out this video.
I have to say it hasn't changed my position
only because in the intervening time I now have a major project written on.NET.
I've joined the.NET Foundation.
We've open sourced.NET code.
You found a new home.
I sort of got married, right?
We're doing a lot of.NET work.
I can't deny that I would have preferred to have originally shipped this in Q,
but when the rep tells you that you'll be in violation of the license,
you don't do it, right?
That's just, that's life.
Right.
That's just a bad idea.
We see this all the time, any kind of lack of clarity in licensing,
it's not a good risk that you can take.
You're just asking for a lawsuit down the road.
Right.
And for a little company like the Mad Botter, we would be destroyed by that.
It would be bang.
It would kill us.
Reflecting back on it now that you're here and on the other side of this little debacle,
did you like the?
Licensing aside, what was the difference like?
You had to switch all kinds of stuff.
You know what?
I liked Q.
As an experienced Objective-C developer, which I have to mention in every show,
C++ is very comfortable for me to work in, but I have to be honest with you.
I'm going to answer a different question.
I should have listened to the JB community.
Yeah, that's just always true.
They were, and you can scroll up in Telegram, they were hollering at me that,
you are not violating the license.
Go ahead and ship.
Don't worry about it.
And you know what, they were absolutely correct.
Now, they did not offer to pay your legal bills if they were wrong, but it's good advice.
The GPL is, I got to tell you, the GPL is a tough document to really understand, right?
Especially the V3 version with the TiVo.
Yeah, anti-TiVoization stuff.
What is TiVoization, right?
If I showed them a demo on a computer that I own, is that like TiVoization?
It's all crazy.
I would say that, it's funny, the things I like about Q are not the things the salesman wants to sell you on.
So, yeah, just maybe expand a little bit on that last point.
So, the things you like versus what they're actually trying to make money on?
Sure.
So, a lot of effort has gone into not have you write into C++ for Q.
And I'm not talking about QML, which is for those who don't know QML.
QML is like their markup language.
It can do some logic, but think of it like...
It's like presentation versus code, kind of, right?
Yeah, think about Android XML.
You can do some stuff, but not...
You're not going to write your whole app in QML if your app is as complicated as the radar display, for sure.
Right, yeah, absolutely.
But there's a Python extension to Q that we actually covered on the show.
There's JavaScript extensions.
So, adding more bindings, adding more ways to use Q without having to use C++.
I think there's a Java one, but I'm not entirely...
I think that might be a community project, not an officially blessed one.
But I liked it because it was C++, right?
And that, you know, for my business as a dev shop, just saying,
okay, we all have to work in C++ would really simplify everything that I'm doing.
Yeah, and I imagine that that's not an uncommon choice
in some of the areas that you're playing with in aerospace or aeronautics.
Finally, yeah. I mean, we kind of gloss over this, but we build web systems all the time.
But our niche is really aerospace.
I'm still surprised we don't talk about Ada more often.
We could.
That's for another show.
I don't know how to do that in a 45-minute format.
Oh, man, we should, actually.
Ada was one of the first languages I studied in my own computer science education.
I tell you what, then.
My birthday's in June. We can have a Mike's Birthday episode,
and you and I can go 13 rounds on Ada.
Yeah, I'm looking forward to it.
All right.
But obviously, so like, okay, so since Wes brought it up,
in the aerospace industry, there's a few standards, right?
There is old stuff. I call it Ada.
There's like down to the hardware C, C++, which is where I kind of need to be.
There's.NET. There's like a lot of.NET.
Oh, really?
Yeah, there's a lot of.NET.
There's some Java on the back-of-office stuff, but very rare.
To be honest, you're looking at C++ and.NET and some Ada,
but that's like, Ada's its own thing.
Maybe a better way to say it is you have embedded,
you have application, and then you have back-of-office.
Yes, that makes sense.
The beautiful thing about Q was it could have been the embedded, the application,
and the Rails could have still been the back-of-office, right?
So you could have just knocked out those other two parts.
You've already thrown everything else out,
which from a hiring and management perspective
would have made my life tremendously easier.
So now, because of the licensing, I'll call it confusion,
what's happened is embedded is Rust in one case,
but also.NET,
because it turns out Microsoft will throw money at any problem you put in front of them.
Wait, really? I didn't know you could do embedded with.NET.
You can do near-native performance C-sharp and F-sharp.
And is that still with garbage collection in that,
or is it a more minimal runtime?
That's a simple question.
Yes, you do have garbage collection,
but not the normal garbage collection you have on...
Different algorithms, a different garbage collector targeted for that.
You also don't have the entire.NET ecosystem to work with.
There's a NuGet, right?
You can't pull in a NuGet package and be like,
oh, great, it's very constrained.
But if you use a constrained subset of the language and dependencies then?
And frankly, I've been unfair.
When I said C-sharp, yes, it's possible,
but I really mean F-sharp.
We do F-sharp.
I love that.
Performance-wise, you're already paying a penalty for having the CLR,
which for those who don't know is the Common Language Runtime,
which if you're a Java developer, you have the JVM between Java.
Google it if you don't know.
And we do some.NET applications.
A lot of, like, Gryphon itself is a.NET application.
And we do some line-of-business apps,
which could easily be written in.NET instead of Rails, right?
But it didn't.
Like, that's where we are now.
So the only differences between what I've just described
and what we're doing is our back-of-office is Rails
for reasons that we have our own stuff that works in Rails,
and it's great.
I don't understand, and maybe this is where Wes can help a little bit,
why there's so much complication around the licensing of Q.
I mean, even ignoring all the stuff I said about the CLR for.NET,
ignore the technical details, which is weird for a show called Code Radio.
The fact that you can't call a Qt rep
and get a straight answer on something feels like a problem.
Like, I don't know, I'm from New Jersey, right?
If I ask you a question and you don't answer my questioning,
like, I think it's because you want the right to sue me later.
Right, yeah, that makes sense.
So Wes, I don't know, I just threw a lot of data out.
What do you think?
I can certainly understand why it would be attractive at C++,
and even outside of that, there's plenty of bindings for things.
I can see why the base fee might be a lot,
because obviously it's all also GPL,
so they have to have some sort of revenue stream.
And that is why your point makes so much more sense,
because why their whole thing should be to make it super simple,
so that if you want to pay the money
or even think that you might want to pay the money to negotiate with them,
that should be clear and easy to do,
because otherwise you're just going to be confused.
If you can't get a clear answer
when you have a complicated dual licensing sort of thing,
and you see it all the time on Hacker News or anything else
for some new open core sort of system
or all these various in-betweens on different open source styles
of business running,
and someone asks some questions about like,
is this covered by the licensing?
And someone immediately pops in the comments and goes,
oh, here, DM me. Let's talk about this offline.
We'll get you all the information you need.
Now, do we know how those conversations go all the time?
Absolutely not.
But you got to hope and assume that the majority of them
are better than what you described.
Yeah, and you know, in defense of Q,
like the gentleman who I was talking to
has reached out to me several times.
They are not happy that we went to.NET,
and to say they're not happy is a giant understatement.
They feel that basically, you know,
the rep didn't understand our technical case,
and it turns out we could have done it the whole time,
blah, blah, blah, right?
Yeah.
It's, you know, I am not the biggest,
and we should move on,
but I'm not the biggest GPL hippie on the network, right?
Like I'm, you know, originally I was the iOS and Mac guy here.
If you think that having GPL software in industry is good,
you can't have this constant threat of legal action,
because, you know, a lot of the big applications
that you think about are written
by small subcontracting companies like mine.
And I'm not trying to like make this Mike's bitching hour,
but like it just is the case that, you know,
I have employees, right?
Like I can't use technology
that I think that I will be sued for.
Does that?
Oh, yeah, that's just absolutely.
It's not just you.
It's not you as an individual person.
You have a whole organization.
Right.
Like my employees have kids.
Like there's a whole, like, you know,
so I'm in this weird place where, again,
I think.NET is great.
I'm a member of the.NET Foundation.
I support financially.NET projects.
I would have preferred to use Qt,
but because of the legal risk, I didn't.
And, you know, I'm not, quote,
a member of the open source community.
I don't think I am.
That's Chris's thing and maybe your thing.
But I think you all should think about that before you,
I don't know, like we have the RMS stingers, right?
We have the RMS sound bites.
And it's like, well, the answer to that
is I'm just not going to use it.
Right.
If it's so difficult or off-putting, then.
Or scary.
If you can't give me a straight answer,
are you going to sue me or are you not?
Yeah.
I like that because it is like people do think it's great.
Right.
I mean, Qt is popular for partly, I think,
because, you know, it's easy to get started.
All the advantages that come from open source.
But you're right.
Many businesses find the GPL to be toxic.
And I think just some of this uncertainty
is often the reason why,
even if you get past the philosophy,
even if you're like, yeah, you're right.
I do want to give back.
Well, you were trying.
Well, we would contribute back.
Like, the sick part is we have contributed back to.NET projects.
We've contributed back to Rust projects.
Only because I could not justify the legal risk of using Qt
is why we didn't do it.
Hmm.
That makes a lot of sense.
That's an interesting case study.
And I think something we'll have to watch.
I'm kind of happy about it,
just because I think it did mean it gave you,
it forced you to do a little bit more Rust.
And that has led to a lot of great content for this show
and our next story today.
You know, Wes, I'd like to put a pin in this if I can.
Oh, please do.
Rust is moving fast.
So by the time this airs,
I'm sure there'll be five more versions.
But in Rust version 1.33.0, it adds pinning.
Wes, are you familiar with pinning?
I mean, I think in the general case, but not for Rust.
So tell me about this.
So I'm going to, again, this is a 45-minute radio show,
so you can pin a certain, let's say, object,
which do not throw things at me, Rust people.
You know, let's say data structure.
Yeah, that's a better term.
And so just to clarify,
this is a Rust-specific thing called pinning,
not related to dependencies
or, like, the other things I might think about.
You know, this is in the language,
but you have to be on Rust 1.33 or up, right?
So basically, you have a pin type and an unpin marker trait,
which there's a lot of words there.
So basically, the object, actually, they use object.
I'm surprised they use object and not data structure.
That's very interesting to me in the documentation.
Basically, making something a pin
means it will not move in physical memory.
So let's get our oscilloscopes
and let's get down into our RAM, boys and girls.
Literally, the object that you have created as a pin
is not going to move on the physical RAM.
That's in a simplified version of what's happening here.
Yes, I know there's different cases for swap.
Please don't email in, but yeah.
Right, right.
Yeah, the different levels of memory
and the abstractions that you're specifically writing towards.
So why did this stand out to you?
I mean, I can see how it might be useful,
but even as this blog post said,
you know, they say,
this feature will largely be used by library authors.
And that makes me wonder, what are you doing with it?
Nothing yet.
But, and bringing it back to.NET.
So.NET introduced async await,
which is an easy way to do concurrency
where the code looks procedural,
but actually like spins up a million threads
and does whatever the hell it needs to do.
You might use this for long running operations,
for network calls,
or if you've ever worked with BLE,
you probably use it a lot because Bluetooth low energy
is surprisingly not reliable.
No, not at all.
Not at all.
And we've seen that pattern, right?
.NET developed it, or fleshed out at least that implementation.
Yeah, Microsoft came up with it.
But we've seen it move.
Yeah, like you can do it in JavaScript,
you can do it in Python.
Java has it now, actually.
Yeah.
For some weird version of it.
So this is the first step, or maybe not the first,
but this is a step towards async await and Rust,
which you may think, okay, why do we want that?
And then Rust, that's usually used as a lower level language.
But think about it.
Do you want to write all these cases,
or do you want to have something, you know,
that in six months when you come back to read the code,
it's a lot simpler to understand?
Yeah, it's a nice option, right?
Maybe in some hot inner loop somewhere,
you can't use it, or you need to roll your own locking
and threading and all that.
But if you don't have to, right,
because basically this stuff all generates
these complicated state machines and callbacks
I don't want to write that.
Well, right, it's going to be like.NET
where there's a bunch of crazy cases where async await
makes no sense and you have to write everything yourself
just like you used to.
But for, you know, 90% of the cases, this is the answer.
And it seems like it could be especially useful in Rust as,
you know, it's already lower level,
so if this can make something just a little bit easier,
as you said, to come back to understand and to work on again,
I'm all for it.
Yeah, I think it's a great addition.
I'm very curious to see how Rust is going to implement async await,
and I think, you know, we're just going to have to wait for that.
But I have lots of questions about how that's going to work,
particularly in an embedded context.
Yes, you might have a lot of concerns about how that works.
Yeah, and maybe it just won't, right?
But, you know, we'll see.
Interesting.
That's certainly an evolving story.
And, you know, as you said, Rust is moving fast.
That might be a feature.
That might just be the next thing that I really have to just bite the bullet
and dig more into Rust.
That's right.
So I hear you're writing this new hot language from Microsoft twice.
What's going on here?
Yeah, Rust.
That's so old and busted, Mike.
I'm writing BOSQ.
I don't know if we decided how to pronounce it.
B-O-S-Q-U-E.
And it was just announced this previous week.
It derives from a combination of TypeScript-inspired syntax and types,
plus some ML, meaning the ML family of languages, not machine learning,
and Node and JavaScript-inspired semantics.
And the words of my cousin Teal, your words mean nothing to me.
Basically, it seems like, and we should be clear off the top, as they say,
as the project lead himself says, this is a research project.
It's not meant to be your new production language.
It's just something Microsoft's playing with as ways to start exploring
how to make programming better.
And that actually seems to be one of their big pushes here,
because they're almost preaching it as a new way to approach programming.
So there's a paper that's out by Mark Maron,
and he calls it out right at the top, regularized programming.
And the comparison is to the old style of what was called
structured programming, right?
You know, I don't love the way it looks,
but I think there are a lot of interesting ideas here.
And I think in the spirit of a lot of people that I find inspiring,
I think that regardless of the specifics of this implementation,
which we can talk more about because there are some interesting concepts in here,
I think the main goal of trying to reduce complexity
and making and designing languages with that as one of the primary
motivating factors is very much something I like.
I have been reading, I've read through the GitHub,
I've read both the articles we have in the show notes.
What is new about this language?
I mean, it's taking the ideas and the concepts in terms of, you know,
methodological concepts of strong typing and those of functional programming
and just basically merging them together.
Like, what am I missing, right?
Yeah, you're right.
I think it can be said that much of the stuff that's in here,
I don't know about what other languages are doing,
like one of the features is this typed string sort of thing,
where just like a way to declare types of strings
and lift some of the identification into the type system.
Strings are terrible, yes.
Right, and we often end up just programming with a whole bunch of strings
we pass around.
But you are right, that much of this stuff,
and I guess they almost say it themselves, that is flowing out of research,
out of other things that have already been implemented
or are seen in other languages and communities.
Like, you know, there are no explicit looping constructs in Bosque.
I like that, I think that's good,
but there are plenty of other languages that lack that.
Okay, but like there's also like, I don't know,
you can like do a map over things, right?
Like, isn't that just going to become the poor man's loop,
or am I just being overly cynical here?
Well, sure, but when you, and in the simple cases, it already is.
But even when you just have math, right,
you've already de-complected something,
because in the simple case, sure, a loop is basically just the same thing,
you're iterating over each item and then doing something,
but it can get more complicated,
because you have an arbitrary scope inside there
that you can just keep your own state, you can mess with stuff.
It is not fundamentally tied to a mapping over one thing.
And so I think that's the level that they're trying to get at here,
is to say like, yes, you understand this,
yes, these are equivalent in terms of theory,
but this is a more ergonomic and safer way to model this program or this problem.
And we think these should be the default tools available to you,
not these older imperative style.
Right, I agree with that.
But like, Microsoft already has F Sharp.
And TypeScript.
I have lots of problems with TypeScript.
You know I don't like TypeScript, right,
but you should just learn ECMAScript and be done with it.
But like, one of my hobby horses is that people writing these crazy algorithms in C Sharp
and doing these like low-level projects
where they need data integrity and all this kind of fun stuff
ought to really be using F Sharp.
And they're not.
So, I mean, anything that's invented is great.
I don't want to like take away from that.
But F Sharp solves many of these problems.
Maybe not in the same way, like the whole scoping thing, fair enough.
But I don't know.
If I were the Microsoft language team, I might,
like, you know this, Wes, it's my hobby horse, right,
.NET developers who aren't data scientists,
because data scientists love F Sharp,
need to pay more attention to F Sharp.
It's just, it's a really good language.
And it solves many of the problems that BOSK,
is that what we decided, BOSK or BOSK?
We're just going to use both, and we'll see what happens.
Like, claims to solve, and I'm not like,
this is definitely an achievement.
But, I mean, F Sharp.org guys, it's great, trust me.
Like, it's, it'll change your life.
No, I mean, you are right.
And I've seen some commentary kind of wondering,
like, is this just some sort of power grab?
These ideas don't look new, just like you were saying, right?
And so it depends on how much you read.
Are these claims?
This exists in another Microsoft language.
It's called F Sharp.
Like, sorry to interrupt,
but that's my entire criticism of this, right?
Like, we should make F Sharp better,
because it's already awesome.
You know, I think that is reasonable.
Thank you.
I will say, I do believe that there's value
in further exploring this stuff.
Oh, yeah, no, no.
I'm not saying we shouldn't have new languages.
I'm just saying like,
maybe that energy is being spent here,
but not necessarily like you're saying.
Like, we could be evangelizing more for F Sharp
and talking about F Sharp with some of the time
that we're using right now, even here.
Right.
So let me make an argument by parallel, right?
When Canonical did a bunch of crack
and decided to make Unity.
I remember the days.
That was a bad idea that did not work out.
I mean, I think some people,
Unity 7 lovers would perhaps disagree,
but you're right.
I mean, they're no longer doing it.
Right.
But you could re-implement the Unity style in Gnome
very easily via extensions.
And I'm sorry, non-Linux users,
but go down this road with me.
There is a limited amount
of deep engineering expertise to be used.
Like, these are literally concepts that like,
when I talk to C Sharp developers
who are like doing large data things
or like mathematical processing,
they're like, oh,.NET sucks.
I'm like, actually, no.
It's C Sharp.
It just isn't meant for this, right?
C Sharp is an object-oriented language
that is meant to build you
a pretty battleship-grade web application.
And these days, you know, a server app,
if you want to do ASP core.
Or even back in the day, ASP.NET.
Right.
But it's not necessarily there to do your, like,
high-level data processing pipelines.
Mm-hmm.
Right.
There is a solution.
And the beautiful thing about.NET
and the CLR is you can mix F Sharp and C Sharp.
You can have an entire module in F Sharp
that just, like, does all of that.
So, like, if Bosque, I'm calling it Bosque,
I just made a decision, is better, fabulous, right?
Like, I am not, I am all, you know what?
I'm using Rust.
It's hard to be more hipster than Rust.
But it's weird to me that the same company,
like, you know what?
JetBrains has Kotlin.
They're not, like, competing with themselves, right?
Mm, yeah.
So, like, where does F Sharp and Bosque begin?
Like, from what I've read on the GitHub page
and the commits, Bosque is maybe a more pure implementation,
where F Sharp is kind of in this weird space
of having to be married to, like,
we have to be compatible with the CLR and C Sharp
and blah, blah, blah.
Yeah, so I think there is that.
Like, it is, you know, they've built it on top.
I think it's implemented mostly in TypeScript right now.
So it's built on a different runtime,
which is kind of interesting.
Also, I would assume that Bosque in particular
probably doesn't run hardly anywhere in the future.
Like, I don't know that it will go anywhere.
I bet we will see some ideas filter into F Sharp.
I mean, that's a damn shame, though.
Like, you know what?
If I'm a shill, I'm an F Sharp shill, right?
Like, I don't want Bosque to die.
I would love Bosque to become one of these languages
that compiles into WebAssembly.
Is that crazy?
No, no, I mean, I think actually,
I think that's on something that they're interested in.
So it is, I think it's just an interesting,
I mean, just that we hadn't talked about this at all
and that you had these thoughts
and we've had such disparate views here.
If this, even if this isn't the thing,
you know, isn't the next playground,
clearly people care about this stuff
and maybe that's enough, right?
Like, so Vocal Point,
and they've already had a lot of issues opened up
on the GitHub project kind of reflecting on that.
How are we going to do, right?
There was questions about
how might this language handle asynchronous programming?
So there's lots to be left there.
I don't know.
I think it is trying to still find the right fit of,
you know, how do we combine all of these new ideas
that different languages have
and what does it look like to have all of them in one place?
And can that be simple, functional, and pleasant to you?
No, I think it's great.
I mean, Wes, can I make a crazy prediction
that we'll cover in a year from now?
Yes, you can.
I think what's going to happen
is that functional programming
is actually going to become the default.
I sure hope you're right.
You know, I think last week,
we talked about Dr. Armstrong, right?
The creator of Erlang.
And he had a paper, what is it?
OO Sucks, right?
Is that right?
Yeah, there's one of his older blog articles.
I think he's right, actually.
The more complicated applications I've had to write,
the less and less I've wanted to architect things
in an object-oriented way.
I really do believe that if you're a young developer,
because we get this email all the time,
learn an OO language like Java or C Sharp
just to be marketable to...
You've got to be conversant with these
because they are the dominant rare time.
Well, there's hundreds of millions of lines of code in them, right?
You're going to touch them.
The future, you know what?
Ring the bell, Wes. Ring it.
Wes was right.
It's going to be functional.
Things like Clojure, things like Rust,
things like Haskell, F Sharp.
I have to throw my F Sharp in there
because I'm defending it to my bloody death.
That's the future.
I can't tell you.
I write tons of code for clients.
I write tons of code for myself.
Tons of open source.
And for me, personally, at this juncture in my life,
it's always the functional code that's most interesting
because it's the algorithmic code.
It's either doing the crazy 3D file processing
or it's doing the, you know,
like the new ML project coming on in a few weeks.
Like, I don't know.
OO is for Goobies.
Send your hitmail to wes at jupiterbroadcasting.com.
Well, and then even there, I think...
You're right.
I mean, it does pair well with there things like...
It just has existed there for a long time.
And there are good parts about a lot of the standards
that get associated with object-oriented programming.
I think, you know, the push towards polymorphism
has been really good.
And that generally has made programming better.
And we have better ways to do abstractions.
So I think we've learned, right?
We've taken stuff like type classes or traits
and been able to have that sort of stuff a la carte
without having these imposed hierarchies
and this rigid style.
I also think you're right that frequently you can find...
While it may be foreign and look just overly terse,
you can get a really good coupling of the problem domain
and then the code that's used to represent it
when you've abstracted it well
and you're using some of these functional paradigms
because more and more it does look like
just a data pipeline process.
And you can understand in decomposed steps
because composition is so important
in functional programming.
It's then easy to decompose
and understand what each step is doing.
Compare that with like a whole bunch of different objects
all pulling strings on each other.
It's just madness.
Well, no, I think you're completely right, though.
I mean, in terms of functional being better architected.
But I think we should move on
because I feel like we're getting...
You know what, Wes?
My beard...
Do we even want to say...
I don't want to say this on the air.
You know, I'm going to say it anyway.
I have gray in my beard now.
Ooh, you're so distinguished, Mr. Dunham.
No, you know what it is?
I'm a has-been, just like Objective-C,
which is still the one language to rule them all,
one language to bind them all, one language...
Never mind.
What about...
You know what I hate?
Other than Swift developers, of course.
What do you hate, Mike?
Do you know?
Thank you.
I hate when I accidentally commit my AWS secrets
into my damn GitLab account.
Yeah, don't we all?
It's a B.
Yeah, I saw this thing out from AWS Labs,
which is part of the AWS's open source work.
Yes, it exists, if you didn't know that.
Actually, they do a fair bit
that you just don't always hear about it.
I thought they hated Linux.
Wait a minute.
I thought they just forked everything
and just went on their own.
Yeah, unless you follow their developer blogs,
it can be sometimes hard to notice all the open source work.
But they employ so many people
and obviously are built on so much open source technology.
You kind of just have to end up giving back.
I've played with a couple other sort of solutions for this,
like what's it called?
I think Truffle Hound is one
that basically just looks for high entropy strings
in your repositories and alerts you to them.
Git Secrets is a little bit different
and it does have some sort of configuration
so that it, by default, understands AWS.
So if you're a big AWS user and you really...
One of the first things,
especially when you're setting up in an AWS environment,
you've got to like,
all right, I go figure out my different credentials
and I've got to get my system provisioned and set up
so it can talk to AWS
and then run against the staging environment.
But I need those credentials over here,
but I really then need the production credentials
when I switch to broad and how do I do that?
And it shouldn't be in the repo.
And especially maybe you're working with multiple teams
or some sort of contracting company you've hired.
Just a mistake.
And if you've ever had to go back
and clean up secrets out of a repository,
secrets are annoying.
I have not used Git Secrets,
but I just thought it was neat
that there was a semi-first-party solution
from Amazon for this.
I don't know how easy it would be to make this work
for secrets for other cloud providers or other projects.
Maybe go give it a try.
Or, dear audience member,
perhaps you have a preferred solution for this.
You've already got it integrated with your CI system
because you're just that cool.
Let us know, coder.show slash contact.
Now, Mike, I know you, being the generous soul that you are,
well, you've got something of a contest going on, don't you?
Yeah, so I would prefer that my son not die in floods
or, you know, like, you know, arid landscapes.
I'm going to second you on that one.
Thank you.
And this extends to everybody's children, right?
Sons, daughters, whatever.
So we at the Mad Botter are sponsoring a little competition.
Now, you have till the end of May.
If you are a high school or middle school student
or indeed you know one, please share the info.
Write up with a technical diagram and a project synopsis
your plan to combat global warming using Linux.
Now, the using Linux part is important.
Has to be using Linux and preferably open source software,
but the condition is using Linux.
We're going to pick one winner from the high school bracket
and the middle school bracket,
and each winner is going to get a Dart or Pro from System76.
This is on my dime.
You know, I think we're going to do these about once a quarter for kids.
We will be verifying that you are actually a high school student
or a middle school student, of course.
But, you know, if you're listening, think outside the box, right?
Because Wes and I talked a lot about, what did we talk about?
F sharp today and a few other languages.
Don't think that you have to be married to what we've talked about.
I'm sure Wes would agree that it's preferable for you to kind of
just let it go, right? Just think outside, you know.
Yeah, that's one of the advantages of things like this is, you know,
we're old and stuck in our ways.
We're old and stuck in our ways and, you know,
oftentimes can't see the best solution for something,
and it takes out of the box ideas,
things that might seem just unintuitive or wrong or broken
that end up really shedding light on something.
Right, and this is definitely my, you know, this is my own initiative.
This is a team B thing.
I did email and talked about it privately in Tampa a few weeks ago
and say, well, should I do this Linux Academy course?
Linux Academy, there's no preference, right?
If you're a member, if you're not, whatever you want to do.
If your thing is a completely, you know, hell,
if you can solve global warming with real basic, go on.
And I have a friend named Brian who you should talk to,
who we're not friends, but it'd be fun.
Too soon?
No, amazing. Amazing.
Well, Mike, this is real generous of you,
and I'm excited to see what comes out.
You know what I figured, Wes?
Instead of pouring gin into laptops,
I should just give them to kids who might save my life.
And that means more gin for you.
And more sales for System76, who, by the way,
keeps sending me nasty messages about you being prettier than me.
We'll have to have a conversation offline.
We sure will.
Well, if you want to go find out more, of course,
you can find that stuff in our show notes, coder.show slash 355.
Or, well, you can just follow Mike's wonderful company,
The Mad Botter Inc. on Twitter there at TheMadBotterInc.
Mike, you're on Twitter too? What's your handle?
At Dimenuco.
I'm there as well. I'm at Westpane.
You can also find, well, the whole darn network
and with, you know, links to all the other hoots that are on there too,
at Jupiter Signal or just head on over to JupiterBroadcasting.com.
That's going to be it for us today.
But if you want more, you'll find the whole catalog there
and you'll find the calendar where you can come join us here
for the live show every Monday.
Thank you so much for joining. We'll see you then.
I'll see you next time.
.

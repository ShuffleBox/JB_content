This is Coder Radio, episode 340 for January 14th, 2019.
Hello and welcome to Coder Radio,
Jupiter Broadcasting's weekly talk show that's all about the art and business of software development.
Now, Chris is off getting married and gallivanting all over the desert, but never fear.
I'm here, that's right, I'm Wes Payne, and I'm happy, oh so happy, to be joined with Mr. Michael Dominic.
That's right, he is the seer of sea, the sultan of software. Welcome to the show, Mike.
Hello, Wes, good to have you today.
You know, it is good. There's nothing like getting a week started off right.
I didn't do any exercise recently, but I hear maybe someone in your family did.
Yeah, in terms of exercise, my wife just ran a full marathon at Disney World.
In fact, I have to call her Captain Marvel now. It's a rule in the house.
You probably should have been doing that all along. That seems good for a long-term health relationship.
Yeah, she's a beast. She got a gold Mickey Mouse medal and everything.
Well, that seems like just about the opposite of what we're going to start off talking about today.
And we've got a little feedback to the show. You wrote this, so I'm just going to read it and then you can explain.
Mike and Chris are old and boring.
Yeah, so wow. Thank you, Reddit.
I have to say, since Chris isn't here, this makes it much better for me, Wes.
A lot of the vitriol was directed towards him.
Oh, not you. You're just going to scapegoat this. Well, he's not here to say anything. I haven't seen all of it.
So apparently, Chris and I's desire to have working audio.
Wes, I don't actually know how old you are. I think we're similar in age.
I think you're right.
But there was a time when I was a 2 to 7 a.m. coder.
I was the night's watch, basically. Call me Jon Snow.
Plenty of energy drinks. You're up. No one else is up. You've got headphones on. No lights in the room.
You were in good shape.
Yeah, most productive hours.
Now I'm in bed by 9.30, 10.
Oh.
But I'm up at 4.35.
And apparently this is a bad thing.
And Chris and I have both discovered the wonders of sleeping more, drinking less and working out more.
Oh, general healthfulness is what you're talking about here.
Now, having said that, today's beer is a Einger out of Germany, which is from Bonn, Germany, if I'm correct.
It's an Oktoberfest Marzan, which is kind of, if you don't know, like a light amber.
You know, it's not quite an amber ale, but it's just on the border.
But this is only my actually second beer of the day.
Well, look at you showing some Monday afternoon restraint I've got over here.
See, you went all fancy and exotic. I'm going local.
I've got the Georgetown Brewing Bodhisattva India Pale Ale.
You know, I've heard that's good, though. See, I can't get that down here.
No, it's hard to find if you're not right here.
But maybe if you can ever make your way up to the Pacific Northwest, we can buy you several pitchers full.
First of all, one, I can definitely handle several pitchers, but those days are gone.
You're right. I mean, you're being helpful.
So, I mean, do you find there's some I've always I love mornings. I really do.
I'm not great at going to bed. That's just things are too interesting, right?
There's another there's more code to write. There's more research to do.
But when I actually get on GitHub, there's another ticket on GitHub.
It's just hard, even though I mean, I love being in bed and asleep or, you know, and I read a nice book before bed.
How do you do you find that once you're on that schedule, you just are tired enough that it forces you to go to bed?
No, in fact, I suffer greatly. It's a it's very hard for me still to go to sleep.
But I've been reading a lot of like old like novels like John le Carre novels.
Oh, but I'm reading them at a pace of like one or two a day.
Yeah, OK, which is great. It is crazy. How do you find time for your work?
That's that's rude, but I'm just going to ask you. Well, no, I can read them fast at night.
That's the problem. Oh, OK. So you're going to burn. I try to go to bed at nine and I'm up till midnight.
But I read and these novels aren't long, right, especially the John le Carre's.
Kind of just little pieces, little pieces of fiction candy.
Yeah, candy. OK, so there's some feedback that you guys are old and boring.
And is that just based on on when you wake up? Because kind of sleeping is arbitrary, right?
As long as you get enough of it. And otherwise, if you're lucky enough, you get to wake up.
I think it's also based on some of our comments from last week on Chris was having some issues with his Linux setup.
Oh, yeah. And I was the audio. Yes. Pulse audio is a nightmare.
Oh, God. And I was on Mac that week as well. This week, I'm on pop.
But it's got a lot of negative feedback, Wes. And I know you were a Linux hippie.
I think you do drugs every morning. Yes, I do. You got off of a plush tux. Yes.
Right off that grub command line. Yes.
So we got a lot of most of the negative feedback was like, you guys suck.
But I got to say, I'm not sure it matters what OS is used to produce a show or to compile something.
No, I mean, there is some metal level where maybe maybe it does, but it's certainly not the most important.
And I think if you have a pragmatic look at it, which I guess that's right on the tease of the show.
Right. So we're supposed to maybe take that angle here.
Pragmatic. Then we got it. You know, if you have it's either no show or a show.
Right. So you got to start with let's have a show and then use whatever tools.
Ideally, free open source tools would be our preference.
But if they're not going to make the cut, what we have certain, you know, we have certain quality standards the show really wants to meet.
Right. I mean, the other side of this was and I'm wrapping like three different points of feedback.
Right. One line, a lot of younger devs, you know, we tend to skew young West on the code radio.
Didn't like my comments about documentation and kind of following a process in your software development.
Oh, you're talking you're coming out pro documentation here. Wow.
I'm pro docs and I'm pro testing. It was not a popular opinion.
I'm actually kind of surprised about that. I would think I don't know.
I feel like I see some of the older set sometimes not no testing, but maybe, you know, a little more.
They're wisen so they know what to test and whatnot.
And then a little more sort of blind adherence to things like TDD in the younger crowd.
So that that's kind of interesting.
See, what I got a lot was, well, why do I have to document my code? I'm going to lose my job in two years.
You know, and I don't again, I do not mean to denigrate any of our listeners.
Of course, I can tell you why you need to document your code.
If the system you're writing is important enough to the business paying you to write it,
whether you're an employee or a contractor, eventually someone's going to need to change something.
Right. And they need to know what the what the hell is going on.
That's a good idea.
But right. Yeah. I mean, especially if you have rather complicated code, lots of files.
I'm thinking way deep down in some horrible Java object hierarchy.
Well, the example the example from last week was Docker configurations.
Oh, OK. And any kind of thing that was outside of the Docker configuration
that needed a special command to be run on bash ought to be documented somewhere.
Right. I mean, if it's not if it's not automated, it better be documented at least.
It also I love you. It also seems like a part of it, too.
And maybe I think sometimes process can be overbearing.
And a lot of this goes back to how we educate.
And that varies widely in different companies, organizations, and there's different philosophies on that.
But, you know, people get discouraged, I think, by having too much process.
Right. Like, oh, the really rigorous TDD or like documenting every tiny minutia item.
And obviously more documentation, more testing is generally better.
But the point, right, is that you're trying to care about the software you write.
You're trying to have a holistic understanding and leave some intent for the people coming after you.
Because you sure you can dive into the code base and you can tweak things and mess with configurations
or improve error handling or debug erase condition.
But just having a little bit a couple of sentences about this is the goal this code is trying to achieve.
Sometimes that can really make it simpler when you come back five to five years down the road.
And you also want to be mindful not to screw the person coming after you, right?
Yeah. Right. I guess in some ways it's sort of the philosophy.
And maybe we see this first with tests.
I feel like docs gets more of a struggle or it's less talked about.
But that, you know, shipping the code isn't really shipping the deliverable.
It's the tests and the...
Exactly.
And the infrastructure around it.
I want to ask you, because, you know, Wes, I listen to you about twice a week.
Because you're so good I have to listen more than once a week.
Oh, you flatter me, sir.
What do you think? Are Chris and I just getting too old?
Is it time for us to go to Elmer's factory and become Woo?
Or...
Should we fight this battle or should we walk away?
I think you got to fight the battle.
We have a culture right now that skews really young, which isn't bad, right?
Youth brings a lot of energy, new ideas change.
Not always good, cough, NPM cough.
But, you know, lots of energy to try to fix things.
Hang on, did you just say NPM?
I maybe, yes.
So, not only is it not always good, it's mostly bad.
We can have that conversation if we want to have it.
NPM is the HIV of package managers.
I mean, you almost made me cough up some of my drink here.
That was pretty good.
So, I don't know, but I do think we need to have...
I mean, as you said, we're kind of the same age.
Chris is only a little bit older than we are.
It's frightening if you guys are already too old.
Because you obviously have a lot to do and it doesn't matter if you triage the tickets in the morning.
That's the thing, we're not that old.
In theory, you should have a couple more decades of productive life ahead of you.
No, but they would like to...
If you look at the Coderadio subreddit, we are ready for the kennel, or rather the glue factory.
Some of that might just be the things that you focus on.
There's a time in life where you're kind of heads down, pushing through racing,
or you're willing to put up with a little more.
When you first learn Linux, you're like, oh yeah, sure, I had to spend two hours kind of figuring that out
and getting the graphics drivers just right.
It's working and it's great.
And then there's a time where you've done that like six times.
No one's complaining that like...
I'm on Pop-O-Wiz right now and I'm using a Galago Pro.
System 76, here's a shout out.
Connected to my Dell...
It's an old...
What do they call those?
I don't know the model.
Describe it.
Describe it.
It's a flat panel on that screen.
It's not 4K.
It's like 256...
Yeah, okay.
Is that 2K?
It's like 1440 by 1440.
And I've been using this monitor for like five years.
It's kind of a sweet spot resolution, honestly.
It's beautiful.
And I have Athelio coming.
Athelio, I'm sorry.
I'm excited to hear you talk about that.
But it's...
I don't know.
Every time I have to do like a week or two of Mac work,
I get my balls handed to me in the subreddit.
I don't even understand.
Yeah, I mean...
The same thing for Chris.
If he edits something on Final Cut because he has a problem,
it just seems like...
I don't know.
Like it's cheating on your wife.
It's Tux, my wife, because...
Tux could maybe get in shape and grow some hair.
I don't know.
I'm just saying.
Yeah, I generally tend to have a problem with some of the vitriolic,
at least the intentions of it.
I think it's fine to generally want...
You know, want us, want creators in this community
to use open source tooling.
But I think what other people need to remember
is that obviously you and Chris think about that, right?
I mean, you just paid money for a Linux-specific...
I mean, it'll run whatever, obviously,
but a Linux-targeted desktop that's beautiful, but...
And to be fair, I've bought a Raytel, an Aurex Pro,
a Dell XPS, a Galago,
and the Thelio I didn't pay for, spoiler alert,
the customer actually bought that for me.
Oh, yeah, okay.
Sure, that's fine.
But I bought a Dell Inspiron...
Not Inspiron, whatever their big desktop is,
it's running flight simulation software
that we wrote at the Mad Botter on Linux.
See, that's awesome.
And it's just not...
It's just like, to say that the little bit of OS X
or iOS work we do makes us traitors,
I think is nuts.
Right, and you're trying to run a business, right?
Yeah, exactly.
So you just got to...
People should know that you respect and try to use
free and open source software when you can,
and other times someone wants to pay you to make a proprietary app,
and, you know, you need dollars in your pocket either way.
But you know who is wonderful?
I'm going to guess our audience?
But specifically Mark.
Specifically Mark, yeah.
He had some really good feedback for the show, actually.
If people are interested in IoT, he wrote in,
there's a great option that might be relevant to the Coder audience.
We're talking about the Elixir programming language here
based on Erlang,
and more specifically a project called NERVS,
which enables you to create IoT devices
with features that include live device upgrades.
NERVS is interesting.
I've obviously heard of Elixir,
but I don't think I've not heard of NERVS.
What did you think of this feedback, Mr. Dominic?
I thought it was interesting.
I have to say since last week's show,
I haven't had an opportunity to actually try out NERVS.
But if there is a FOSS alternative to Azure Sphere OS,
I am going to jump on that.
I'm not going to say the reference I wanted to use,
because again, our LA overlords probably wouldn't love it.
Ask them to do it, frat boys.
I would definitely prefer that.
I have to say, can I reveal the kimono?
Yes, do it.
I mean, it's a weird phrase,
but I take your meaning and I want you to lay it all bare.
So Alice is not going to be running in her next version
on the Microsoft Bot Framework.
Oh, no.
That was a pretty significant little foundation.
Wow.
Yes.
You know what?
I can't say that I've seen the light,
but I can say that it's very dangerous
to be hooked into commercial companies as a small ISV,
which is what my business is.
It's interesting how that goes both ways, right?
Because often the argument is the other thing, right?
It's the argument of like, well, you don't need to specialize.
You don't need to be doing this.
Pay some other company to do it
so you can focus on whatever your core business model is.
Well, the problem is though,
you're limited in what you can build
by the boundaries of that framework
or that toolkit they give you.
And I think the Microsoft Bot Framework is great.
Don't get me wrong.
I encourage customers if they need a bot.
It's one of the cheapest and most effective ways to get a bot.
You can write it in JavaScript.
You can write it in C Sharp.
But I think the JavaScript SDK,
apologies to C Sharp people, is actually kind of better
because it doesn't have all the ASP web crap associated with it.
But God, if you're already writing a node,
which is just a nightmare in itself,
there are so many better open source options you could use.
In fact, I found a great one for Kotlin
that I'm evaluating and hoping to have on the show
in a couple of weeks.
And let me tell you, it's damn powerful,
having the JVM for bots.
I don't know if you know this, OpenNLP.
Wes, are you familiar with that at all?
Yeah.
Well, that's a Java Apache Foundation library, right?
It sure is, yeah.
Works seamlessly with the Kotlin runtime.
Nice.
So you just plug and play.
So were you worried at all about overhead
or anything like that running on the JVM?
Droplets are so cheap.
Yes, that's certainly true.
That's like my answer.
I don't even know what to say.
Droplets are just...
I'm not worried about it now.
By the way...
Oh, go on.
...run time, or it would be the.NET core runtime,
which are just as heavy.
Yeah.
Or similarly heavy, depending on the workload, right?
Yeah.
Either way, you're going to end up...
You're paying for it.
Yeah, exactly.
I mean, you want those niceties, right?
You don't want to have to go right C.
You want someone to handle a lot of those things for you.
Exactly.
And a lot of engineering hours have been poured into that.
And that's probably some of the same things
that this NURVS project is trying to take advantage of.
Yeah, I think so.
I'm going to check them out.
I think, Wes, you should check them out.
Maybe a Clojure wrapper?
Oh, yeah, that could be good.
And actually, Elixir has a lot of stuff
I really love from Clojure.
First-class, immutable, fast data structures.
And it's already got this.
You know, when you're doing bots or IoT or serverless
or any of those things,
you're already kind of running in a distributed world.
And honestly, right, like we talk about programmers
or development, but a lot of us end up being
distributed systems engineers in one way or another
just because, well, the database is over there
and my client's over here,
and maybe there's a GraphQL server in front of this.
And you end up with like a dozen different frameworks
and pieces together.
So it's nice that the whole Erlang platform, right,
they've got their own Beam VM, V-E-A-M,
and it's designed with that in mind.
They've been doing, you know, multiple concurrent actors
running phone switches for decades now.
So I don't know about NURVS.
They admit that it's young,
but claim it already powers rock-solid industrial products.
Sounds great.
Yeah, thanks, Mike.
That's great.
And if any of you have other projects,
maybe you're working on IoT or bot frameworks
and there's a framework free and open source
or otherwise that you're enjoying or despising,
you can tell us about it at coder.radio slash contact.
So, Wes, can I tell you why I'm sad this week?
I thought you already did.
But, okay, you're sad for other reasons.
Wes, I'm living in a world of depression.
All right, well, let me be your therapist today, Mr. Dominic.
Lay it on us.
Doctor? Doctor?
Oh, yes.
I thought that the iPad Pro 2018,
and I know this isn't your thing, so patience,
with this USB-C port would be an open interface
that I could just, you know, open a BSD socket
and work with, right?
Right, that you would just be able to connect to it
like a regular interface that you could go,
you could write an application that had a peripheral
that plugged into it or talked any of the various protocols
supported by that connector.
Hundreds of protocols, right?
In the Unix world, there are literally maybe even thousands.
So, what I found was there was something called the IO kit,
and we have a link in the show notes
the Apple developer form.
They just have a kit for everything, don't they?
They have a bathroom kit, I think.
Seriously, it's like, okay, what do you need?
Oh, that's the built-in bidet on the iOS platform.
You know, I would love a bidet.
We could talk about this.
I would love a bidet.
It is weirdly out of date, and a lot of it's deprecated now,
so I'm not sure what that means.
And it doesn't actually let you pick like a disk,
you know, like we would think of the Unix world,
like dev-slash-sda1 or dev-slash-whatever, right?
But it's not so specific like that.
It's not so specific, and it's unclear.
You can push it and twist it to read off of that USB port,
but Apple's own PR and own developer documentation
definitely gives the impression
that that's not how they want you to use it,
and the APIs you need to use to do that are deprecated.
So, one, I linked to the forms here.
I am not alone in wanting to simply be able to
brace yourself, Wes, access a connected disk on a drive.
So you're, yeah, I was going to ask you about that.
So your use case here is to be able to plug in
like an external hard drive?
Well, what I really, yeah, there's a couple things I would do.
I would plug in a hard drive.
I also would like to be able to plug in a, like,
Raspberry Pi board and actually like program the board from an iPad.
Oh, like, yeah, be able to flash it from...
Just like flash it from an iPad.
Basically do all the normal USB things.
Right.
I want the USB-C port to actually be a USB-C port, right?
It seems like at present that is not the case.
There's an Apple Developer Forum that's depressing.
I don't know what to say.
I mean, it comes down to these are the cases that are allowed.
You can try anything else you like,
but you have to get through App Review.
Well, of course you have to get through App Review, right?
Right, but it's kind of like if you try something new,
you need to develop...
You can't like call up and say,
hey, I have this idea for an app.
What do you think?
You have to develop the app first.
And then if they say no, guess what?
Nothing, right?
You're out of luck.
You have zero options.
Right.
So that's pretty disappointing.
And they mentioned specific cases that they support,
you know, music through Apple Music and photos through photos,
photos.app rather.
So it seems to be the case that while it is technically possible
to access the USB port on the iPad Pro 2018,
I can't say for sure because I did call App Review
and they kind of laughed at me.
Oh, really?
Yeah, I just couldn't get through.
They said we don't comment on unsubmitted apps.
And the young lady I spoke to said,
submit your app and I'll let you know.
That is just not a workflow.
I mean, okay, maybe for a big company,
but as an independent developer, how are you supposed to do that?
Well, it means I can't do the project.
You can't even explore working on what might be a pretty neat app.
So it's kind of like it seems like they don't envision the iPad Pro
as an actual full powered workstation computer.
They see it as something...
They call it a computer.
They see it as something else.
I'm hoping in the next version of the iOS SDK,
there are some Apple approved.
I can imagine it using Shortcuts, which is an Apple...
It's basically the crappiest implementation of Unix pipes
I've ever seen in my life.
That's what I was about to say.
You see, that's funny because I've heard a lot of,
from some people who will go unnamed,
a lot of positive things that, you know, like finally,
this has added a layer of like real utility to some of these apps.
It does, no, it's great.
But it's only great because the restrictions are too high, right?
Like if you just had a...
If it was just the case that you could share data between apps
in a normal kind of Unix-y, BSD-y way,
you wouldn't need Shortcuts, right?
Yeah, like I can see why they didn't go full file system metaphor,
but they didn't give you a lot between that, right?
Like I could, it could be whatever,
some more abstract object storage style system,
but I wouldn't be able to just like share these stuff between apps
and have them coexist like they're running on the same machine.
Yeah, that's not the case.
It is interesting.
I just got my, for Christmas, I got my father an iPad
and he'd used like Windows, I don't know, XP probably for his job
before he retired, just as like, you know,
had some software he had to use specific to his field.
And then otherwise it doesn't really use computers.
So I was thinking about this in the same way.
It's not a traditional computer, right?
A lot of their branding talks about how it's sort of redesigned.
It has, they've taken, I mean, almost in a BSD style approach,
like they've taken this very minimal core of stuff
that they want to implement and slowly extending it from there
rather than like a general purpose computer
that's been somewhat locked down.
Yeah.
And it seems like it could work for, like in one case,
I think my father's actually doing pretty well on it
for that same reason, right?
It's hard for him to damage anything.
It's hard to break stuff.
There's just not that much you can do to it
because your interactions are limited
and each one of them has really been thought through
in the context of all the other actions.
But I imagine, but for technical users,
it's just a lot of, it's more walled garden roadblocks.
Well, in a weird way, the iPad is actually the ideal
of the personal computer.
If you mean a personal computer to be a non-technical user
using it for, you know, personal use.
Right, just like social media, communication, standard stuff.
Yeah, I can see that.
It is disappointing.
Wes, take us out of this pit.
You have something good for us, I'm sure.
Oh, yes, I do.
Hard segue.
Hard segue.
Yeah, I mean, we don't need to be so sad about USB-C.
It is a shame, but at least the iPad has USB-C.
We're gonna just clip it right there and say,
maybe in the future, things will be opened up,
only time will tell,
and we'll check in with a very frustrated Shirley,
Mr. Michael Dominic, in the future.
So, when we were talking about Iokit just now,
I noticed I saw a lot of.h files,
some of their other reference documentation,
but it didn't seem particularly targeted
towards our friend Swift.
And I'm wondering how you...
I've heard...
I mean, I try to listen to Koda Radio every week.
I don't always make it,
but your thoughts on Swift seem to...
Honestly, I don't even know what the graph looks like.
It's too complicated for me to draw.
I want to know where you are.
I want to know where you're at right now.
So, the simple answer to your question is,
first of all,
if you actually dig into the documentation there,
when you see funk, that's Swift.
So, Swift can easily consume C++ Objective-C.
Excellent, okay.
See, I didn't know that.
Yeah, so the reason it's.h is, yeah.
I have complicated feelings towards Swift.
I thought you were not gonna drag me into this,
but that's fine.
So, Swift...
is a complicated language, actually.
I still kind of feel like it's a little bit of a mongrel,
in the dog sense,
in that it's too many things at once.
So, for instance,
it's got this idea of protocol-oriented programming, right?
Which basically means you should write your data structures
as structs instead of classes.
I wrote enums.
But...
which is great, because, listen,
there is a problem in Swift,
or maybe not a problem,
but an implementation detail of,
when you write a class in Swift,
you actually call the Objective-C runtime.
Oh, really?
And that has a lot of memory overhead, yes,
compared to a Swift struct.
So, if you write, for instance,
you have a user model,
and you want to write it as a struct,
that is a lot lighter than writing the same model as a class.
Now, there are some disadvantages of it,
the big one being, in practical terms,
that you cannot subclass a struct, right,
because there's no such thing.
Right, yeah, it's not...
that makes perfect sense.
So, it's interesting.
Like, a lot of the supposed speed gains by Swift
are by avoiding using OO.
Right, because, I mean, what you...
basically, they've stolen
some of the fancier functional programming-style things, right?
So, you can do all that stuff at compile time.
You have all these structs that implement various interfaces.
Exactly.
Exactly, structs that implement various...
what Swift calls protocols,
but are effectively fancy interfaces with some extra sugar.
Optionals, I think, in Swift are...
solving a problem I'm not sure that real people have.
So, let's talk about that more.
Optionals, are we talking about, like, the maybe monad?
Kind of.
It's slightly different.
So, for instance, if we had, like,
var Mike underscore name string,
colon string,
and we put a question mark on the inner string,
that's an optional.
Swift does... and this is...
I mean, monads do the same thing, they unwrap it,
but the way the Swift kind of runtime implements that
is...
it's very strange.
The idea being that you should never be able...
the compiler should catch you
from calling an optional that could be nil.
Right, so you've already accounted for it
at a higher level of abstraction,
and the compiler can read it.
Well, no, if you have an optional and it could be nil,
you have to do something with it.
Right.
Yeah, you have to handle the case of this might be nil.
Right.
But it really makes your code kind of crappy and messy.
You wind up in these weird pyramid structures like...
it...
nil or if unwrap, whatever, right?
There's a million ways to do it in Swift.
Where it's just like...
I would love to know,
and I'm sure there's no way to find this out,
how many people who are writing Objective-C
actually crash their applications
because they forgot to initialize a variable?
In like real-world cases,
I'm not talking about like during dev time.
Right, you're talking about like of problems out
in the production world.
In the production world.
Of errors that users care about and are having
was like nullability, was stuff like that.
Was that really a problem?
Was that the first thing on the list that needed to be solved?
And is it worth the overhead of reasoning about it so explicitly?
Because the level of complexity
that the optional system brings to Swift
is just much greater than handling values,
variable values in Objective-C.
Now, it's interesting,
because you come from more of a functional world, right?
You might tell me, well, this is just how life is.
Well, you know, actually, it's interesting.
I think that's one...
It's an ergonomics question in some ways, right?
You can have arguments about safety and other things,
but at the end of the day,
you're probably paying developers to make products
for users who are paying for it and they want...
I mean, speed has to be a factor
as much as correctness at times.
Obviously, you want correct code.
But as you say,
there might be some times where it does add a lot of overhead.
And there are other ways to deal with it,
stuff like nil-punning from the Lisp world, maybe.
Obviously, there's tons of languages...
What is that, if you can just jump in?
Well, treating, having null or nil,
but having a lot of your core built-in functions
have an understanding of that.
So instead of throwing a horrible exception,
it just returns the value that sort of makes sense for that.
So if you try to get the next part of an empty list,
you might get back nil, so you can sort of check for that.
And if you have nil also have a falseness to it,
then you can do sort of truthy evaluations that way too.
So there are some ways...
It's not as explicit, right?
You don't always...
You don't have the compiler to help you in that same way.
Another approach I can think of
is we were talking about Elixir and Erlang earlier.
And Erlang has an interesting sort of solution
where a lot of times you end up coding on the so-called happy path,
and not because you aren't thinking about failure,
but because you've planned at it in a higher level.
So you might have these...
They have these supervision trees where you have one process.
Let's say you need to go download like a list of 200 URLs
that your user has inputted to you.
So you spawn a process maybe for each of those
to go off and go fetch that URL,
then you aggregate it in some data structure somewhere.
Well, each of those might fail, right?
Like that might be a bad URL,
or that server's having a problem
and you need to retry it.
As you launch all these processes,
you can put those stuff in, right?
You can say like,
give it this number of allowed retries.
Here's your threshold you should do.
What happens when you fail?
Do you come back up to the caller above,
or do you launch a different error handling process?
So then your actual code down in the deep stuff
that's doing the HTTP request, say,
well, it doesn't have to care about that so much.
They have this philosophy of let it crash.
So you expect that that little process you spawned off,
it might crash, but the supervisor watching it
already knows how to handle that
and has a policy procedure in place.
See, that might be a better way.
I mean, the one thing I think
that the Swift optional kind of pattern gives you
is that you can use optionals in a way
to handle controller flow, right?
So the thing that huge Swift people will tell you is,
oh, the guard let statement.
It's all about the guard let statement, right?
Have you seen this before, Wes?
No, go into it a little more.
So guard let is basically a fancy way to say
if value is nil, let it be my values.
But it is kind of one of the quote-unquote advanced,
and I'm making snare quotes here, Swift tactics,
to basically handle the optional case
of something being nil.
And it is certainly useful.
I could see how that would be like a nice thing to have.
But as I'm looking at C Sharp and other languages,
particularly C Sharp's nullable implementation
that is very similar to Swift's.
I mean, it almost looks like directly inspired from Swift.
I think we're just adding a lot of noise to our code.
Right.
I mean, I suppose this comes down to another question
of like, where do you do your validation?
Is it throughout,
do you have sort of firmly validated borders at API calls
or other gateways between libraries?
And then do you just sort of assume things are working
with ways to report exceptions?
Or do you have something more like this,
where it's type checked and everything is through
and through validated,
and you have rigorous error testing at each and every level?
Right, because if you had already,
I'm looking at an example here, right,
where they have multiple guard lets,
they're grabbing name field dot text
and address field dot text.
So they have options here, right,
where so they have this guard let, they have a way to handle.
Well, what if this is nil?
Which is great.
You do want to handle that.
But maybe you also had a function somewhere else
that already validated this whole data,
turned it into a type that had everything there
that wasn't nilable,
and then you could pass it on to a simpler function.
Yeah, I agree with that.
I mean, I think it really comes down to,
is this a problem that really needed to be solved?
Yeah, okay.
How would you compare it to,
you were mentioning Kotlin earlier in the show.
I have just heard rave reviews for how Kotlin handles nil,
and so how would you compare those two?
I think Kotlin's nil handling is less heavy-handed.
I think it's a lot better.
Now, Kotlin does come with a requirement
to be compatible with Java and the JVM.
Yep, yeah, sure.
So it can't go quite as extreme as Swift?
Right, yeah, I mean, as a compiled language,
Swift can kind of reach farther,
has less overhead, doesn't have a giant VM with it.
Right.
I mean, my general argument against Swift
is that they've gone too far with this optional stuff, right?
So I wonder if there's an analysis,
like when you look at how people use Scala,
it's all over the place,
but you see some shops
where they were trying to get people from Java
to come over to Scala,
and they had people there who were maybe former Haskellers
or just really hardcore functional programmers.
I've seen a lot of people who,
they were interested in some of those techniques,
but it was just like, it was a little too much,
and it didn't focus on the top five problems
that they had with Java.
Like people, you know,
you want them not having to type types everywhere,
you want inference, you want those things,
but maybe you don't need to have learned, like,
a dozen things from category theory.
Yeah, see, you've hit the point exactly.
So in episode 104 of Coderadio,
I was pretty negative on Swift when it was announced.
It's legendary, I freaked out.
104, everybody, go give that a re-listen.
If you look at Swift and say,
does this solve the problems of Objective-C?
Well, first we'd have to agree on what the problems were.
In my argument, you know,
Swift solves the problem of Objective-C being kind of hard
because it's basically a superset,
I mean, not basically, it is a superset of C, right?
Like you have to know C to do Objective-C.
Right.
And you have to know pointers,
which I think Swift removes you having to know pointers.
Right, and that is something of a mismatch maybe.
It sort of depends, you know, right,
because the targeting, like,
what app you might be building could be different,
and sometimes you might be building a simple app
that does presentation pulling from some API.
Okay, you probably don't care about pointers in that case.
You're not doing anything fancy.
Exactly, but they also removed
one of the powers of the Objective-C runtime,
which is being a messaging model
where, you know, calling, like in Java,
calling something a nil object is a null runtime exception, right?
Yeah, famous NPE.
Right, you can actually send a message
to a nil object in Objective-C.
Oh, almost like a small talk heritage.
Well, it is a small talk heritage, exactly.
Swift gives that up almost completely
and says that if something is nil, something is wrong,
which I just don't think is the case.
If we're writing a complex application,
it's my opinion that a language
ought to be looser, not tighter,
where Swift wants to try to solve
every problem at compile time.
The challenge with that is the code is,
I mean, it can become really complicated.
You have to understand a lot of concepts,
like unwrapping the value of a variable.
You have to understand like when structs versus classes
are referenced by reference or referenced by value.
And there's all kinds of weird edge cases
that I think Swift actually adds
where Objective-C was an incredibly simple language.
I mean, it's C.
Right, once you got past the C part.
Once you got past the C part,
the objective part is super simple.
And I think Chris Latner, who developed Swift,
would say the problem with Objective-C was that it was C.
Right, like I just think that he just took
the completely wrong design path.
Right, like something closer to a C-sharp.
And the irony now is, of course, the C-sharp
is actually embracing the concepts of Swift.
So Swift, even for our listeners who are not Apple people,
Swift is going to influence your work either way.
Yeah, that was kind of going to be my next question here,
is there are obviously trade-offs,
but is Swift the future?
Even if you're not going to switch to Swift today,
does Swift have stuff that developers
should be paying attention to?
Well, there's definitely a class of people
inside of these big platform companies,
Microsoft and Apple particularly,
who feel that runtime null exceptions are a problem.
And the Swift style of handling quote-unquote
optionals against near quotes.
I mean, just the fact that Swift and C-sharp are embracing it.
C-sharp 8 is embracing it.
That's huge, right?
There's a lot of developers who work in those languages.
Yeah.
C-sharp more than Swift.
So it may just become that the best practice is null,
nil, or C-sharp calls it null, right?
Nill and null can mean different things.
This idea of nothing, of no value, yeah.
Right.
It is definitely...
Geez, I don't want to say something too crazy,
but I feel like this is the end of the small talk heritage
in a lot of ways.
Of the idea of message sending.
This is it.
This is full compiled.
Everything I compile time.
Oh, yeah.
No, I think you're spot on there.
We have lost...
And I think it's a shame that not more people have experienced
the dynamic nature of small talk.
I mean, you were in a whole system designed
and explorable and changeable by you.
And when you go really heavy, you know,
static types and all compiled beforehand,
there's obviously a lot of benefits, right?
From speed, from reasoning about the application,
to IDE benefits.
But you do lose that dynamic nature.
Yeah, you definitely do.
So it's hard to go, you know, you can't necessarily easily...
Some things you can.
But, you know, go pull up a REPL inside your application
and investigate it or go inside and explore values at runtime.
Well, and there's just a lot of extra like crud code
you have to write just to like handle all the compiler's demands
where you might know that something will never,
ever, ever, ever, ever be null or new.
But the compiler forces you to name it an optional, right?
Yep.
I think one thing we're hitting on is,
obviously, one goal of programmers is to be able to understand
the applications they develop.
And oftentimes we're in zones where we don't...
You can't have the whole pipeline in your head, right?
It's just too big.
And so I think that's where a lot of the value and motivation
for some of these more heavy-handed
static typing applications come from.
Personally, though, I mean,
I think kind of what you're maybe getting at
is simplicity is also important.
And while we...
Right, like simplicity is maybe one of the key ways
that you can get to actually reasoning about your program.
And maybe the compiler helps you less.
But if the result of that is you have a simple three-line function
that you can just read and understand,
that might be worth it.
Yeah, I think the best programming language
gives you very little tools, and it's just very simple.
That's one of the things I love about Objective-C.
For everybody who's complaining, or everybody,
but for a large percentage of the community who's complaining,
Objective-C was actually an extremely simple language.
You sent messages to objects.
You had all the C, you know, if...
Everything at that level was a C, right?
All the control flow statements, if, while, whatever.
And you had a few add-ons to that.
But that was it.
Anything else you wanted to do,
you had to pull in a library and implement it that way.
Or implement it yourself.
Where I feel that particularly Swift is trying to say
everything's built in.
And where the Smith...
Oh, well, kind of. Is it functional?
Eh, kind of. Is it protocol-oriented?
Whatever that means, kind of, right?
Like, it's basically everything to everybody
while being nothing to no one.
And I guess that is a danger of broad languages sometimes,
is you don't have one set right way of doing things,
you don't have one target audience, you are general.
Okay, well, I'll be curious to see how this evolves.
You know, clearly there's a trend right now,
static typing, a lot of these tool sets and ideas
are kind of in vogue.
And I think in many ways, for the right reasons,
we did have an era, perhaps you might call it the tar pit,
of kind of overly complex, object-oriented programs
that had a lot of mutable state
and were pulling on each other's strings
and were pretty hard to reason about.
And a lot of the ideas in Swift, for example,
are some ways to try to deal with that.
So I'm glad we're at least doing it.
I don't know if, you know, we probably won't find one solution.
We'll see if Swift gets better
and what your take on it in the future is, Mr. Dominic.
I'm curious.
I just saw you over on that there Twitterverse
tweeting away about serverless.
And I was kind of curious.
There's kind of multiple ways you can use serverless.
One is sort of a notion of like a little CPU cluster,
a little cluster of compute that you have, say,
like a cron job, maybe, where you say,
hey, I want this to be run every so often or on a request.
Do this little thing. It's a little mini computer.
I just have one job to do,
and it'll go send this off to another API.
But then there's also, at least on a lot of the implementations
we're seeing today,
something that comes along with serverless
is this sort of meshed network
of different events that you can have, right?
So you have, you know, AWS gives you
a thousand and one different events that you can have
key to trigger a lambda.
And so whether or not you really care about the compute,
you might just care about having that event system.
I'm curious what you're using it for,
both business and pleasure.
Yeah, so it's a lot of data processing,
but you're not wrong that it's the event queue.
When something happens, you know, run this,
you know, very tight F sharp or node function.
Are you running F sharp lambdas over there?
Yeah, yeah.
Oh, man. And you weren't even going to mention that.
Okay, so I was at a dance social,
and I met this guy named F sharp.
So F sharp's not bad, right?
F sharp is fast.
No, I think it's undervalued, honestly.
Yeah, I think it's weirdly underappreciated
because it runs actually really, really well on Linux.
And it's kind of the bastard child
of the.NET community in a lot of ways.
It's like if you told me you wanted me to write
a serverless function for you,
and you gave me a choice between node and F sharp,
I would probably be tempted to go F sharp.
Yeah, I mean, I can see why, right?
You get like a real runtime with real concurrency.
You get...
It's a much purer language than JavaScript.
Yeah, you know, JavaScript, they keep adding a ton of stuff,
and at least they're trying to steal some good ideas,
but it is just never, ever going to be a pretty language.
Yeah, I mean, for the next version of Alice,
we are writing some of the...
So the architecture is a little unusual, I guess.
There's a lot of serverless components
that process various data issues
that have caused us problems in the past,
and many of them, if not all of them,
are going to be in F sharp.
So far, the three that exist are in F sharp.
So do you also then get some of the benefits
from that shared runtime, like good AWS API implementations
for that platform?
We don't give a crap, right?
So we throw it up on Lambda or Azure functions,
and they just handle it,
which is kind of the beauty of the whole serverless thing, right?
Yeah, you don't have to care.
You get everything built in for you.
You don't care at all.
And particularly for F sharp being more of a functional language,
a functional style...
I mean, Wes, if your experience is different,
a functional style on serverless, I have found,
has been kind of the best way to go, right?
You know, data comes in to the function,
data goes out.
Yeah, it's very data-oriented,
and you end up, a lot of times,
you're building pipelines, right?
I mean, they're broken apart,
but you're just grabbing some data,
you're transforming it or analyzing it
or sending it to a database.
You're doing something with it and passing it along.
Yeah, it's...
It's a lot of languages.
But if you are...
curious,
go to fsharp.org,
and I would say that,
of the.NET languages,
and I've been a pretty pro C sharp guy,
I think F sharp is probably
the best language Microsoft has ever produced.
And now, they have...
I mean, it's a completely false language.
Yeah, right? I mean, now that we have.NET Core,
it's... Go run it.
There's actually an F sharp foundation by itself.
Oh, really?
Yeah, because a lot of folks are using it
on Linux and BSD for, like,
genetic processing and data science.
F sharp has kind of gone its own way
from the whole.NET community. It's weird.
F sharp is... Yeah.
That is... That is very interesting.
Yeah, I mean...
You're probably right about that.
We should see more of it.
The.NET runtime is nice,
and F sharp has a lot of those principles.
You keep seeing C sharp pull ideas out of F sharp
and implement it over there,
so they must be doing something right.
Oh, C sharp will just take anything.
Oh, sorry.
But they do... I mean, they generally do it in a nice way,
like their async await implementation,
I think, was ahead of the pack and is pretty nice.
I think it is, yeah.
I mean, I think...
In fact, I think the async await API
is one of the things where other languages
have tried to implement it,
notably Java.
Python, too.
Oh, C sharp one.
Who did it?
I mean, Python is not quite the same,
but explored similar ideas
in the asynchronous world.
So, okay.
Maybe one of the themes here is simplicity.
How do you find that...
I feel like I've heard a lot of mixed reports
with serverless, both good and bad.
If you reach a certain scale,
then you just have to be distributed, right?
You don't have to break things apart.
You just can't have monoliths.
And so serverless is ready to meet that need.
But as maybe a smaller operation sometimes,
how...
When does it or does it not sort of...
You know, if you already have droplets,
you're already running stuff,
when do you write a cron job that just runs there
and you update a text file versus go deal
with the more complicated and higher abstractions
of something like serverless?
Serverless is when I want to use a...
I mean, and it will be different
for a bigger shop, right?
So listeners don't freak out.
For a small shop, cost of overhead is kind of
your raison d'etre, right?
Your driving principle.
So when I have something that might peg
the CPU on my droplet,
let's say my $10 a month droplet,
the cost of just running it
on an Azure function or a
Lambda instance on AWS
tends to be less
than having to go up a droplet permanently,
because that's kind of a permanent function on...
I use DO as my host.
Those are the kind of things that I...
So for instance, we used to have an old version
of Alice that processed via OCR
PDFs.
That always
pegged the CPU. Oh yeah, right, sure.
You're doing a bunch of graphics work.
Yep, we threw that into an Azure function
droplet running an F sharp library
with some custom
code, obviously, to function
and then to process the
PDF and then send back whatever relevant
data back to the DO droplet.
It's that kind of thing that we're using.
Yeah, okay. So that makes a lot of sense.
So it's not kind of what I was thinking is you can
end up with these...
What used to be a bunch of code
in one library
for whatever language you're running
that split up into six different things that are each
with cues in between them, which are great, right?
Cues can be wonderful for decoupling,
but you also then have...
You come to the operational side and now you have like six different
cues that the back pressure you have to monitor
on and understand where things can
fail in each of the phases between the
pipelines.
But I guess if you're
using it as more of a standalone thing, something a little bit
simpler that just sort of runs and churns with a little bit of
data and puts it somewhere else and you don't have to think about it,
then it makes sense.
I've been looking...
It's a big cost saving too, right? It's a performance
and cost saving. Right, so even
if there was a little bit of operational overhead
or just having to adopt this new system,
integrating whatever monitoring you already had
with the rest of the AWS stack,
the fact that it's
pretty darn cheap if you're not doing crazy things
with it, that's a big seller.
Exactly. Well, and it's cheap if you're only doing
stuff every once in a while.
Right, it doesn't have to handle every request,
but if it does enough of those background
jobs to just keep the data fresh.
That's exactly it.
Interesting.
I've been looking at...
So it's by the
consultancy Cognitech that makes
Clojure actually.
They have a new project. They've got this
fancy functional sort of database called
Datomic, and they recently
launched it as a
AWS marketplace application, so you can
go spin it up. It costs like a production,
like the base version is probably like a dollar
a day.
It is proprietary, so that's not
great, but they have an interesting new feature
called Ions,
which is trying to leverage some of
those, like the serverless idea.
So they, you know, you go by their system,
they'll spin up with all the necessary
stuff. They've got a DynamoDB,
they've got a Postgres instance, it's all managed, already spun
up. They have all the cloud formation written
for you, right? And that just happens.
And they've got like a super tiny
simple wrapper,
and the rest of it you do with the tools
you would already use, like the command line
tools for developing Clojure and Git.
And then you basically write,
you write pieces of code,
commit them and push them,
and then it does the rest. It will
spin up new lambdas for you, it actually has a little
proxy thing that runs that you configure,
it gets a call, and then
all your code actually runs
on the database that you're running already.
So it gets code locality with the
database, and you don't have
to manage or talk to any of the AWS
APIs. You just like add a new function, add
a little metadata that says like, oh this is going to be a new
Ion, push it up,
and then everything updates for you.
Now do I have to interface with this
enclosure? No, you don't.
A lot of the benefits are
better if you do, but
Titanic has APIs for all kinds of
stuff. I just thought it was an
interesting take of like, people clearly
like the on-demand, they like the
performance and scaling models of
serverless, and they like having access to all
of these, like the rich infrastructure of AWS
events, but maybe they don't
like, I mean I don't love cloud formation,
I don't love dealing with and deploying on AWS
that much either.
I'm not a huge fan of that whole model either.
So it's something to check out if people are
interested in it. The other nice part is
Titanic's got this idea of a
database as a value.
And so instead of having to worry
about, basically reads are essentially
free all the time, and you'll never get, like you
request data at a time, and it
never changes out from under you. You just get this
like, immutable value. If you want to go
check the database at a previous time, you just ask
for it at that time, or you can get the newest
value. So
it's not for, you know,
keeping all of your time series data,
but for meaningful IT, like business
application data, there's a lot
of benefits to it.
Very cool.
That is actually very cool.
Yeah, we'll have some links. This is episode
340, so coder.radio
slash
340. You can go find
all the links to everything we've talked about.
You can find the past episodes.
Mr. Domingo, where do you want to send
people this week? I would like to send
them to themadbotter.com.
Oh, yeah.
Stay looking out
for more updates. It sounds like Alice has
quite the future ahead of you.
How about ask
at West, at Noble Pain on Twitter, huh?
It's at West Pain, which is confusing.
Someone already, I've had that
one for like ever, and someone has the other
one. I'm thinking about messaging.
So yeah, I've been sending nudie pics to the
wrong Twitter. Oh, well, please do make sure
you forward those. And
for people who have other stuff, not nudie
pictures, you can find the whole network
at Jupiter Signal. Of course,
you can go to jupiterbroadcasting.com. If you want
to find out when we're live, well, there's a calendar
right there. Don't miss
this. It's a ton of fun. We've got an IRC room
you can hang out with. Go harass us. They're talking
about Fortran right now, so it's clearly
on topic and fascinating. Go
be a part of that. And of course,
thank you for, thank you for
joining us for Koto Radio. We're going to have
lots of more good stuff to talk about, so we'll
see you next week.

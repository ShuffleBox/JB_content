This is Coder Radio, episode 342 for January 28th, 2019.
Hello and welcome to Coder Radio, Jupiter Broadcasting's weekly take on the art and
business of software development. Once again, Chris is away, but don't worry, he'll be back
real soon. And in the meantime, I'm Wes, and I'm, of course, joined by our new resident
Rustation, Mr. Michael Dominic. Hello, Mike. Hello, Wes. Do you have any WD-40? I'm feeling rusty.
Oh, you sure are. Unfortunately, I'm fresh out. You're on your own this week, Mike.
But that's okay. That's a shame. It is a shame. But we've got lots of other great stuff to talk
about. We've had some good feedback from the audience. There's been some developments around
patents and our favorite little language to discuss on this show, Swift. Interesting,
interesting developments there. And it's time to check in with WebAssembly. A lot has happened
from the days of ASM.js. What's it like in 2019? Where are we going? And why are we interested?
But before we get all into that, how are you doing this week, Mike?
I'm good. How are you, Noah? That's not your name. I miss Noah, though.
I know. I miss Noah, too. It's true. But that's okay. I'm doing great. We have a lot of fun stuff
to talk about. You brought some new topics on me this morning. And actually, it's been something
I want to talk about anyway. But before we get into any of that nonsense, let's talk a little
bit about some other network news. That's the launch of Choose Linux. That's right.
If you want to be cool like me and run elementary OS, well, then Choose Linux is a show for you.
It is a beginner-oriented show for people. Maybe you're Linux curious. You've looked over at Linux
and maybe Linux looks back at you, but you're not sure. Do you want to go say hi? That kind of thing.
This is the show for you. It's no prior knowledge necessary. It's Joe and the wonderful Jason,
who's new to the network, telling us all about Jason's adventures in, shall we say, Linux education?
Yeah, Linux, the open source world. He'd been writing a lot about other topics for a long time
and then sort of made the switch to Linux, I don't know, six months or so ago. So a competent
storyteller, kind of presenting an interesting story that, you know, we've all been there and
when you're an experienced user, it can be hard to really reflect. So that's why I love that it's got
Jason and Joe. Joe's got the curmudgeonly aspects, the, you know, doesn't quite take all the fun out
of it, but is there to provide some balanced perspective. And of course, Jason's just got
a great energy. So you can find that Choose Linux dot show. They've already got one great episode
up. It's coming out every other week. The easiest thing you can do, of course, is just go to Choose
Linux dot show and subscribe. That's right. Speaking of that, you can, of course, go to
coder dot show and find all the episodes of this show and get your subscription. And even more
importantly, you can find the ways to get in touch with the people making this here show Jupiter
Broadcasting and provide feedback. We love feedback and sounds like we got some good feedback or at
least some interesting feedback last week, Mike. Yeah, when you mentioned Rust, people just kind
of come out of the woodwork. It's interesting. We had a lot of feedback regarding Rust, but also
Jenkins. What was your general take on it? I mean, we had a lot of feedback on the Jenkins stuff.
Yes, we did. You know, I think it was kind of all over the map, which I think is good. It sounds
like we hit a nerve. A lot of people are using Jenkins and either love it or hate it. And that
kind of seems appropriate. And I hope we didn't come off as trying to I didn't I didn't want to
disparage Jenkins. It's a valuable tool. I've certainly used it and been grateful that it
exists. And it's a testament to the open source community. I think more I just want to have a
discussion around. Should Jenkins be where this stops? Can we do better in the world of continuous
integrations and all the various roles that Jenkins has? And how do we take the story of
Jenkins and reflect on what else we should do? Yeah, I mean, I think there is one comment in
particular from Browseria. I hope I'm saying that correctly. You made an honest try. That's
all that counts. I mean, you know, it was really a good, good faith. And he has a kind of a five
five points. But I think the the two that I found most interesting were it's on the subreddit.
Number three, it's simpler. You know how to run Docker containers, you know how to point to your
Git repo source control. If your Jenkins file is right, that's pretty much all you need to do.
And number five, which I think I particularly kind of discounted was that it's a visual
visualization tool as well. Right. I was in particular talking about how you can do many
of these things with bash scripts or, you know, various GitLab pipelines integrations.
But I could definitely see in an enterprise setting where you have a maybe non technical
manager, having the visualization is going to be pretty powerful. Yeah, right. It can be can be
useful to have a nice big board that shows you where your test broken and where it's failing
along that pipeline of complicated steps that you know that way you can find the right engineer to
yell at and make go fix that problem. Well, maybe you don't want that. Maybe you don't. Yeah, you
got to think about that. Yeah, there is actually some really good feedback. And there are a lot of
cost and benefit analysis. And there are times where maybe a small limited make file makes sense.
And there are other times where well crafted Jenkins file. Really, if you can if you get
someone on the team that can that can craft that file and is willing to be the subject matter expert,
you know, a browser is totally right that like no one else is once it's set up,
you're not going to really have to touch it. You just make new commits, new Docker files get
generated, all the automation happens. So a lot of times it's somewhat of a one time pain,
neglecting the other side of the whole maintenance story. Right, right. But anyway, that was our last
episode. Those 241. So if you want to go find out more about 340 141. Sorry, thank you. Gosh,
what am I doing? It's like almost two years of code. So much coder. I'm sure we would love more
feedback about Jenkins, though. It's an interesting conversation. I'm sure we'll see more updates from
the team behind Jenkins. It also seems like it seems like they kind of get it. You know,
a lot of stuff has been happening over there. There is modernization. So it's on the move.
Yeah. So speaking of things on the move, rust, man, can we just take a second and talk about
the rust feedback? Oh, yeah, let's just take a moment for rust. So just like the Jenkins feedback,
there was too much to really sum it up into one paceman. But first off, I want to thank all the
people who sent me blog posts, videos, a link to the rust book, extremely helpful that has kind of
gotten me started a couple of open source products I didn't know about that I'm going to be
investigating, hopefully featuring on here in the next month or two. I was just about to ask if we
were going to hear about those. All right. Little teaser. It has been great. I'm happy to say I have
successfully written a rust function. I'm going to continue to use that word. Okay. Well, you said
written. Does that mean you compiled it too? Written, compiled and called it from Ruby.
Oh, even executed. That's the whole darn thing. Wow. Executed. It's kind of and it does something
with everybody's favorite Star Wars hero. And yeah, Alan wouldn't let me put it on the server.
Something about Linux Academy has an anti Jar Jar policy. Oh, see, that just seems like
discrimination flat out. I mean, come on. Jar Jar is great. But seriously, I did in fact write a
random Jar Jar generator because that's what I do when I try something new. And I have to say,
it took me maybe being conservative 35 to 40 minutes. And most of that was like setting up
my environment, because that's all you know, how that is. West is always just like just a pain.
You're in a new you're in a new ecosystem, right? You have new norms and rules and
customizations to do and get everything integrated with whatever editor you're using.
Yeah, I ended up just using VS code, but I'm told that's maybe not the best choice for this. So I'm
eager to hear more about that. And just getting it to compile correctly to be called by Ruby. But
once I did, it was like the C style FFI from Ruby to call. That's exactly what I'm doing. Yep.
Fascinating. Oh, that's cool, though. I mean, I would probably it seems more fun to pair Ruby
and Russ than Ruby and C. Yeah, I'm finding it to be I like Ruby a lot, as we will talk about
probably in almost every episode. But Ruby, we mentioned it last week. If there's a tortoise and
a hare, maybe it's not the hare. Yeah, I think I think that's a that's pretty well diplomatically
said there. Yeah. So yeah, it's great. I mean, I don't have a whole lot on Russ today. But I'm,
you know, I'm like a little I'm a newbie at Russ, right? So I'm learning it. But as I particularly
play around with open source projects, I'm hoping to kind of bring them into the show feature them.
And I know we, Wes, we have a very, very large and extremely passionate Russ following. Yeah.
So that seems like one of the things that stands out for me, I've only dabbled about as much as
you have here. And I didn't even get into the FFI stuff. And while there might be, you know,
there might be some learning curve, there's obviously a new way to, you know, a new memory
model to kind of work with and how you handle that and all the different idioms of that community.
But it seems like what makes people keep coming back is the community around it. So I'm going to
be fascinated to watch as you interact more and more with the community and the community
more and more with the passionate people behind Russ. Indeed. Speaking of passionate patents,
I mean, oh, people. Oh, jeez. Oh, what a game. So I hear you're doing some Swift to us.
Isn't that true? Or OK. Well, I did actually I did install it because I wanted to try this whole
Swift on the server. I knew it was actually it wasn't bad. I didn't do a whole bunch,
basically my equivalent of your Hello World Jar Jar sort of thing. But it wasn't it wasn't bad.
And that's why I was kind of concerned or at least interested and needed to go follow up more
because I'm new to the Swift world is all I've been. It sounds like Apple's been filing some
patents related to Swift. Oh, they have. But really quick, what what server framework were
you using? I'm just curious. I was just doing getting some basic stuff going. So which one
did I use? Vapor? Yes, Vapor. Vapor is one of the one of the better ones. But yes. So maybe
don't try to sue Apple. You did agree to that, you left. I wasn't I mean, yeah, I guess I wasn't I
wasn't planning to, at least not till next year. I mean, that's kind of a, you know, a summer thing.
Yeah. So Apple is patenting lots of stuff in Swift. Wow. Basically,
I don't even know where to start with this, right? They're patenting optional chaining, which
again, neither West nor I are attorneys. But doesn't that look like a thing that existed in
like Lisp in the 80s? Or am I just? Yeah. And I mean, the ML community has has explored that for
a long time. Really any really in research languages since the 90s? Yeah, I'm sure. Or
probably even earlier knowing how the history of computer science goes. Yeah, right. There's two
patents in question. And people just sort of noticed, you know, people reviewing all the
patents flowing through the system. And realizing not only one is this applying to Swift, but then
too, you have the usual issues of, well, how valid are software patents in general, and then the
specifics of like, what are you claiming here? Because the method, you know, like the actual
implementation, the user facing stuff doesn't seem new at all. There's some arguments about,
okay, well, there's, you know, there's multiple ways to implement optional chaining in terms of
like how you build the programming language underneath. So there's some arguments about
maybe some of the stuff they're patenting applies to the particular way they chose to implement it
in Swift. Still, still, you end up back at the whole like, software patents just seem like such
a steaming pile of garbage sometimes. Well, I yeah, I'm no fan of software patents. But I
kind of didn't think you see again, which we one day we have to have an attorney on.
I didn't think you could patent something that already existed prior to you using it. Oh,
the other patent, basically, I linked it, I'll link it in the show notes, is basically
apt. Like it's basically a package manager. Right. And I mean, I think that hits on some
of the problems with software patents is to have to have effective patents that that don't infringe
on previous existing ideas or really do promote novelty and you know, the generation of new useful
ideas, which is nominally the goal of the whole idea. You actually have to have good enforcement
that can do meaningful review and determine like, is this adding something? It also sort of
violates a lot of the trust, you know, there is now more and more open access journals,
there's more and more sort of research style development, especially in a world where you're
doing a lot of server side stuff. You just don't there's a more open sharing because you need
other stuff, right? Like, look at the machine learning community where a lot of algorithms
get shared somewhat in the open because, well, that is part of the magic. The other magic is
these giant data sets, the companies aren't sharing. And so having patents just sort of
feels like you get the information out there, but it's also not in the free spirit of research.
Well, what's really interesting to me is I remember back in the day when Apple was like,
all open standards, yay, we are built on BSD, which was always kind of...
Right, they had that whole open source program where they, you know, dump code over the wall.
And now, and Microsoft was like, we're going to sue you for using the fat file system.
And now it's almost exactly the opposite, which I, it's bizarre to me.
But how do you, I mean, so how do you reconcile that with at least the development of Swift,
which we saw open sourced somewhat early, right? We got a whole bunch of like previous
Git commits from when it was still closed. And then it is being developed fairly out in open,
or at least that's what it seems like.
Well, I think Chris Latner, the creator of Swift, who obviously used to work at Apple and
Wes has that in the show notes for us. I think he makes a good point that in all likelihood,
he comments on a hacker news. This is just a way for Apple to screw patent trolls.
Because when you're a big company like that, you get sued all the time because people know
you'll settle instead of fight it. So what happens is if you sue them, it's,
and this is the standard Apache thing, right? If you get sued for patent infringement, well,
anything you own that somebody is using that's Apache licensed,
that license is immediately revoked. So then they are infringing your patents if you have patents.
So I'm hoping that this is like a defensive action and they're not going to just turn around and say,
gee, you know what, vendor so-and-so who is building something or like, there's a lot of
projects to bring like Swift onto Google's Fuchsia or onto Android and other platforms.
I'm hoping they don't start going after those people. I'm hoping this is just purely a shady
patent lawyer who also invests in apps that are written or compiled into Swift,
sues Apple. Apple could say, well, great, you own now, it was a million dollars.
Yeah. Right. And that's a good point. That is a big component, the patent grant,
the patent controls to try to prevent lawsuits that is part of the Apache license.
I think it just kind of shows some of the difference between different ways that open
source communities are structured because you have some that are sort of more organic,
maybe like Python. And then you have stuff like Swiftware. Yes, it is open source, but it is,
there's one giant copyright owner and contributor standing there as an elephant in the room. And
sometimes there can be a little friction between normal sort of open source concerns and the
concerns of a giant company that does have a lot of liability out there, especially when
people like Oracle exist. Can I put on my Chris Fisher tinfoil hat for a moment, though?
Oh, please do. So I do not believe in software patents, but let's just say we have a friend
named Jimbo that does. And he invents some crazy new whatever, right, way to program.
Apple then infringes his patent, and he also happens to be like a Swift consultant of some kind.
He sues them for patent infringement. Couldn't they just turn around and say, okay, well,
every time you've used Swift, you have infringed our patent, too. So sorry, not sorry.
You mean with or without the current licensing?
So I mean with the current licensing, assuming these patents aren't struck down, right?
Couldn't this also be used as a way for Apple to basically be able to use or under the threat of
filing a patent infringement lawsuit for the use of Swift, any smaller firm or any small research
labs patents, if that research lab or firm also uses Swift? When I say, of course, it doesn't
grant them the legal right. But the reality of a small research lab, you know, going up against
Apple is not right. That is a huge problem with the whole structure of this is that not all,
you know, not all legal bills are created equal or people have the equal ability to use Swift.
People have the equal ability to pay those. Actually, I was going to ask you a similar
question, which is exactly how confident does this make you feel using Swift? Obviously,
sometimes you don't have a choice or it's the right thing to use, regardless of all these
concerns. But just from the high level perspective, it does. I mean, it might be a little bit of a
question mark. I mean, it doesn't affect me because I don't file software patents.
But if I did, yeah, then definitely. And one thing to keep in mind, too,
the way the license and again, not an attorney, but my understanding of the license is that it
doesn't it doesn't just work against software patents. So if you patent some hardware design
and you also use Swift in theory, now, I doubt Apple would ever do this, but in theory,
they could have a lot of leverage over you. Right. I mean, they could publicly declare
at any point that future contributions are no longer under that license. They could change
a whole bunch of options and pursue other patent claims. And as you say, they just have more
lawyers than just about anyone else. Right. You have enough. They have enough cash on hand to
pay lawyers for several millennia. Yeah, that's that's very sad.
Yeah, it sure is. Oh, Swift. See, so that's one of the things like Swift is an interesting
language and there is a lot of support or at least interest in trying to port it to other
platforms. It has a good has a good runtime story. It has it has nice ergonomics. It has a
big company backing behind it. So, you know, it'll be supported and actually developed at
least for a little while. So it's a shame that it could be so complicated sometimes.
It also seems like one of those languages that maybe someday you might see running on Web
Assembly. Oh, yeah. So what is what are your general thoughts on Web Assembly before we dive
into this? Yeah, I mean, maybe we should maybe we should break down a little bit of, you know,
what's going on with Web Assembly? Why are we talking about it at all? You started off saying,
like, we should we should chat about Web Assembly. I know you saw some tweets, but
before that, let's just break it down. And really, I mean, it's it's an assembly,
a set of assembly instructions targeted at the Web. Right. You'd see this embedded in
web browsers and you'd have a way to use it as a compilation target, as a different sort of
architecture with some sandboxing and restraints built into the platform so that, you know,
obviously, if it's running on an end user's machine, you have to have some security concerns.
Just a few. Do you feel or are you using Web Assembly at all?
I've played with it, you know, just like your little bit of hello worlds and trying to get
something built. But right. But no, it's not immediately useful to me. I'm reasonably happy
with JavaScript as a compilation target. But I can see why. So what strikes me as a similarity
is we were talking about earlier in the show, Rust as an augmentation to Ruby. And Ruby can be
nice. There's a lot of development ergonomics. The whole language is focused on, you know,
making developers happy and it can be very pleasant to use. There's a lot of libraries.
But sometimes you need a little bit of a speed boost. You need more efficiency. And that's where
implementing something in a language like Rust or something a little more a little lower level
can be nice. And I see that as a way some way that Web Assembly will be used as to augment things.
You might still end up writing a large JavaScript application, but for parts that are just
twiddling bits, not necessarily handling complicated, you know, complicated information
processing, but parts that are mechanical, parts that are just, you know, calculating vector
instructions, trying to render graphics, whatever, something you need speed, really fast and
efficient, then you can use whatever compilation trigger, then you can use whatever language you
want. And then if you have Web Assembly as an output, ship it to the browser.
So another use I have seen for and I agree with everything you just said, by the way, I think,
in fact, the performance stuff, I think is going to be the most common. Are you familiar at all?
And I'm dating myself now and it's an objective see thing. So I'm sure you don't have never
touched it. I'm sure if you saw it, you'd run. It's a project called cappuccino. And I'm going to
show it to you. And I'm currently trying to load the projects.org website. It seems like they may
have gone to that GitHub repository in the sky. Oh, that's what it was. Yeah, it's a shame. What
it was, was an Objective C web development framework that let you use Xcode interface
builder to like lay out your layouts and everything and code an Objective C. The idea being you could
top quality, quote unquote, quality layout tools instead of having to write nasty HTML and CSS.
Actually, there's a modern project just like it. We had them on the show Platform Uno,
which is the same thing as XAML, XAML and C sharp. And what they're doing is they compile
into Web Assembly. And there's another one that I actually sponsor that I keep forgetting that I
sponsor Avalonia. I know they are basically doing the same thing and planning to go further into Web
Assembly. Same idea. You can use XAML and C sharp and F sharp. And you would be, again, if you're a
.NET developer, you'd be coding in the tools that you have come to know and loathe. But when you
compile, you're going to compile into Web Assembly. For those interested, a chat with Uno, go to
Radio 317. I have no idea how you did that so fast. I'm impressed, Wes. Maybe Chris could just stay
wherever he is. Let's just leave him. Oh, you flatter me, sir.
Is that crazy? I mean, not the Chris thing, but is it crazy for people to want this?
Because I have to be honest, there was a day when like cappuccino, the Objective-C
interface builder product, looked really attractive to me.
No, and I think it makes sense in the same context that you've seen JavaScript
really just kind of become, at least in some circles, just a compilation target in its own,
right? You're writing in TypeScript or at least using Babel in your pipeline. So it's not like
you're maybe you're looking at the generated JavaScript, but if you are, it's probably because
of some unfortunate reason or weird bug that somehow your source maps aren't covering.
Or you fundamentally don't understand TypeScript like I did in the beginning.
Yes, right. There are lots of reasons. One of the other interesting things is
JavaScript itself can compile into Web Assembly. So if you're just hot for the ECMA 2019,
that's coming out, right? You could use that as a way to bootstrap yourself up and try things out.
What it seems like is that for a lot of things like TypeScript, which is obviously a superset
of JavaScript or I use ClojureScript a fair amount and that's a sort of similar thing,
it ends up mapping really well. So in the back end of the compiler,
like a ClojureScript function fundamentally maps to a JavaScript function because they're both kind
of higher level languages, right? There's a GC involved. They have similar notions of sort of
dynamic types and the basic sort of data structures involved. That is not true for Rust. And so while
you can use JavaScript as an arbitrary turn complete bottom implementation to target,
it just doesn't have kind of the right primitives to write really good code that maps more to lower
level ideas and algorithms. Yeah, it seems interesting. And just kind of going off the chat,
Circus Freak, you guys have amazing names in the chat, by the way.
Oh yeah, I love it.
It depends, right? So the question is, isn't the performance of Web Assembly the same as
JavaScript? That is one of those questions that is super simple to say. And the answer would take
another hundred episodes. Basically, it depends on the browser vendor. And I'll give you a great
example. Google Chrome on most platforms that aren't, I forgot which one is slower, but there's
some issue. I think it's actually Mac OS, but don't quote me on that last part. Implement Web
Assembly in a way where it tends to be faster. In fact, sometimes it will like compile JavaScript
into Web Assembly. Safari is Safari. What can we say about Safari? Edge is dead, but do you know us
if Mozilla, if Firefox actually implements it yet? Yeah, I believe so. Yeah. Because they've been
involved because they were one of the big proponents of ASM.js before Web Assemble really,
really got going. It took over. Right. So this is a situation of it's going to depend on the browser
because the browser's engine is ultimately what runs the quote unquote assembly language,
the Web Assembly. Right. We saw that with JavaScript too for a long time. V8 was dominant,
and now Spider Monkey and others have caught up so that we have a generally fast JavaScript
environment. Right. And I think right now, even straight JavaScript on performance,
I'm pretty sure Chrome is kicking the shit out of everybody else if you actually care about
performance and you like giving Google all your information. It also seems like one of the big
bottlenecks that has been only relatively recently worked through is going through the translation
between JavaScript and Web Assembly. So you might be writing a game that just does everything in
Web Assembly, but I think a lot of people end up just needing to pass data structures back and
forth so that you can do some performance optimized thing in Web Assembly and then maybe do some
higher level DOM re-rendering in JavaScript that you already have a nice library for.
Yeah, I think that's going to be the case. I mean, I'm hoping for a future, and we'll get to the
con case pretty soon, but I'm hoping for a future where we can just compile libraries to Web Assembly
and pull them in via various package managers and be very happy. Something a bit maybe more
sophisticated or less of a hassle to use at scale than NPM. But I'm thinking more like a Cocoa Pods
or a Ruby Gem style situation, which I know NPM is very similar. But if these were compiled
quote unquote binary Web Assembly, I'm using air quotes binary Web Assembly targets,
that would be pretty good. And if you've ever developed iOS, what I'm basically saying is
static libraries, right? The equivalent of a.a file you might pull down from Cocoa Pods.
Would you compare that to like an ahead of time compiled jar that just has byte code?
That's exactly what it, yeah. A jar is actually probably a better analogy because it's definitely
not going to be like a static library, right? It's going to be, well, jars are static. But
you know what I mean? It's, yeah, Gradle. Give me Gradle. Give me Gradle or give me Death.
So, you know, our love of Web Assembly is not universal.
No, of course not. That's not, you know, nothing's ever so simple in our real world, Mike.
So DHH dividend, I can't say his full name. So the guy who created Rails says quote on Twitter,
treating the web as a compile target washes away much of what's so special about it. Reducing the
web to just another closed platform like Windows or iOS is to be blind to its truly unique shape
and promise. Let's cherish what made the web special, not pave over it. What's your reaction?
You know, I was thinking about this a lot yesterday, this morning. There is, and it kind of
comes up in multiple contexts. It kind of made me think of the debate when systemd was first sort
of being introduced. And if you are experienced with inkscripts, having them be bash meant you
could just open them up, right? You didn't have to go find the source somewhere. You didn't have to
go, especially if it's not on GitHub, you could just open them up. You could just open them up
right? You didn't have to go find the source somewhere. You didn't have to go, especially if
it's not on GitHub, it's probably in whatever version, the bizarre repo that Ubuntu has and
find the right version that actually shipped that you've installed through dpackage. Or it's a bash
script that you open up in VI, and you can edit and tweak and reboot and test immediately. And so
there is that like I was I was doing a little automation work trying to automate a site that
doesn't have an API, at least not yet. So I was kind of mechanized and automating some web forms.
There was a little bit of JavaScript to handle some fancy uploading stuff.
But it wasn't transpiled. It wasn't some fancy framework. It was just good old jQuery,
right? I've everyone basically everyone who's done web development over the past 10 years had
to use jQuery at some point. No, nothing wrong with the dollar sign. Not at all. And for the
right kind of stuff where you don't you're not writing, you know, an SPA, then jQuery can really
in this case, it was it was used simply. And I could have reverse engineered everything I
needed to know just from like looking at the web requests and you know, working backwards.
But I didn't have to, because I could just read the JavaScript. So I was able to just copy that,
you know, the copy the post that they were doing that way, without having to decode anything without
having to read, go look at all the how the form got encoded. That was really handy. And it was
a sort of like immediate ease of understanding and tweaking and playing with that you don't get
when you end up with a giant minimize JavaScript blog, or in the case of WebAssembly, a binary ASD.
Right. But but so the other the flip side of that, I don't know that WebAssembly,
what does it really change? I mean, maybe a binary is even a little bit more
hard to hard to introspect. But we're already a point where most websites that you get the
minimize JavaScript for even if you use some of the Yeah, right. You can use some clever tooling
to expand it and make it readable. But you don't get real variable names. So you're kind of you're
left trying to get Yeah, yeah. I mean, I, I sort of feel like like with anything else, you definitely
see how people could think this is kind of closing up the web, quote, unquote, as a platform. But
you know, I look at the advantages of WebAssembly, being able to code in whatever language,
you know, slash stack that I want to now granted, in my case, I would still just use JavaScript.
But I think you and I are in some way a bad case for this, because, you know,
I run into Windows guys all the time who, like, you know, I say give me great great old,
they say XAML or death. Right? They just want to lay everything out on XAML. That's what they want.
Right. That's what they know. That's not what they are familiar with. Yeah, of course.
And like, you show them CSS, and they cry. So well, that's that can happen to anyone.
Well, if you've ever looked at my CSS, it doesn't seem it seems like
there are two main advantages here, right? We've talked about the performance advantages,
and also the the freedom to choose your own stack. I kind of think it's the good outweighs the bad,
especially as you're saying, giving that all these big sites minimize the crap out of their
JavaScript anyway. And anything that's proprietary, a lot of people are obfuscating.
Right. Yes. And, but I mean, I can, I can certainly appreciate the sentiment because,
you know, we already have stuff like the various DRM solutions that get rolled up in in Chrome and
other browsers. It is we are we have already moved away from a web now, not necessarily everywhere.
And maybe maybe that's where some of the concern is that, you know, this will just increase with
WebAssembly. But we're already in a web where you can't really fully introspect everything that's
running in your browser. You don't really have entire control like you would like to think.
Yeah. And no one looks at even if you can look at the JavaScript, no one does.
No one does. Right. And everybody's pulling in the same, you know, react review or whatever,
anyway, when they're putting in JavaScript. So how many times are you implementing or building
upon Angular, for example? Yeah, exactly. And DHH has a follow on tweet. You know,
WebAssembly is exciting in a lot of ways. This isn't one of them. Hopefully we'll keep
HTML, CSS, JS readable. And he in that he's replying to someone who mentions that, you know,
we've seen Java applets, which I used to write. Don't judge me. ActiveX, Shockwave and Flash,
all of these fall down, which is true. Right. There have been many, many attempts to do this
kind of thing. I would argue, though, I forgot about Silverlight crap.
Everyone did. Yeah. Yeah. That's even Microsoft. So I don't think WebAssembly is going to go down
like that just because it's an open source kind of, you know, Linux. I know it's not Linux,
even like open source. I want to use the word standard. Right. Where Flash was proprietary,
Java applets were frankly, satanic. And Silverlight was just basically made for Netflix.
Right. I'm joking. You might be running a proprietary, something that has a proprietary
license and you don't get to see the source for, but you're running it on an open source system,
or at least an open source standard. Right, exactly. And also, you know,
who's backing WebAssembly now? Mozilla, Google, basically every other big company that I can
think of. You know, I'm not sure of any of the big browser vendors with the exception
of maybe Apple. I don't think Apple actually has any dog in this fight that isn't backing
WebAssembly and actively contributing to this standard. So it seems like the,
you know, the big platforms in the market have decided that it's the way to go.
Right. And at some point, I mean, it's so kind of maybe maybe if I'm taking you right,
it's going to happen. We just have to we now we kind of have to the debate has moved on from
should we do this or not? And it is happening. How do we how do we deal with it?
Yeah, I think the question becomes and now we're getting deep into like front end web development
hell. But at what point does, quote unquote, the interface or the API of WebAssembly, which I know
is a gross oversimplification, diverge or become a competitor to programming directly to the DOM?
Right now, there's no friction there that I'm aware of. I mean, it's just like,
you know, you it just compiled. I could see a world where particularly
big tech companies decide to put out like proprietary frameworks or
you know, you get into the IE six world of like, could Google, for instance, decide that they want
to have a special like API hook that you can call from an assembly that does something cool on Chrome
that you can't do in Firefox or I guess they care more about Safari.
Right. But couldn't they do that in JavaScript today?
They can do that right now. Exactly. It's a great example. I always find because I tend to use
Firefox and I use the Firefox developer edition for testing. Oh, yeah, right.
Firefox always implements things basically to the letter of the standard. Google's like,
meh, we're going to do it the way we think it should have been done. And Apple's just,
I don't know what the hell is going on over there.
Right. You know, that is a good point because you do think I'm thinking in particular of stuff like
the web audio standard, but you often see things in Chrome that like people end up even using
enough to make web apps. And then you just have these web apps that aren't really web
apps because they're Chrome apps for the nonstandard API.
Sort of like the one we use to make the show.
Sort of like the one we used to make. I wasn't going to mention that, but yes.
It's the only time I launched Chrome other than obviously browser testing.
Okay. So here's another. So you mentioned to me before we started the show that you're
running Linux today. This is a whole Linux powered code on radio. Pretty cool.
One of the things that might be more possible is shipping proprietary applications to the browser
with WebAssembly. Like I know the people behind AutoCAD have been experimenting with that.
And in 2018, we saw Unity release WebAssembly as a compilation target. So suddenly you might get
in browser games that are actually decent or some of your favorite tools running in the browser.
And while yes, that might be still proprietary, that's not great for the open web,
but as a Linux user, that might be the difference of me having to have a Windows VM or not.
Yeah. I mean, I think that's fine. I'm obviously not, you know, I'm not a total freedom penguin,
but I could also see the argument that that effectively becomes a form of,
I won't say DRM, but, you know, again, another form of kind of proprietary protection.
But again, wouldn't you rather be able to run things in the open platform of the browser
instead of having to install, like you said, a Windows 10 VM?
Yes. Yes, I would.
And for devs, I can't imagine like people want to write things to the Windows API anymore.
Even if it is UWP, which is actually a pretty nice API. I mean, I think that's why Platform Uno
and Avalonia are getting so popular because there's a whole pile of people with C-Sharp,.NET,
maybe UWP, WPF skills that want to come over into other platforms, right? So they want to ship an
app and run it on Windows, Mac, Linux. And in the case of Uno, and I think Avalonia is,
they're assumed, the web.
I'm kind of cool with that. Yeah, no, I see what you mean. That's, that is interesting.
I also noticed that there's like, there's been some efforts made to have WebAssembly as something
of a more general runtime, right? When you get in this world where suddenly a whole bunch of tools
can output to it. Well, yeah, it can ship in the browser, but kind of like with Node,
where V8 was ripped out of the browser and, you know, the whole thing was just,
it can ship in the browser, but kind of like with Node, where V8 was ripped out of the browser and,
you know, used to great effect on its own, whether you like Node or not. The same thing
could be happened with WASM, right? And so you can end up with like, oh, I compiled nginx to run
in WebAssembly on top of WebAssembly. And now instead of having to install it or compile it for
your architecture, well, here's a binary blob that you can run as long as you have something
that translates it to native instructions.
So, so Electron, right? So Microsoft bought GitHub who created and owns Electron.
You see a world where Microsoft changes Electron to not just be like an instance of Chrome,
but to be its own, just, you know, WASM, if I can try to use that runtime.
Oh, interesting. Some optimizations, but that are still linked enough so that maybe me,
that as the developer doesn't have to care too much, but get some nice benefits.
And the hope being that like, right. And that Slack doesn't like throw up on your computer
all the time.
So, oh, yes, it does. It does do that. It does seem like Electron got lots of stuff
right where you have this, the developer experience is clearly something people are
interested in, but just, you just see so many apps written for it, right?
But the experience for the end user leaves a lot to be desired. And I saw, I saw a couple
of things like some interesting and interesting Electron alternative based on Reason and OCaml
that offered a sort of development environment with some of the JavaScript style feedbacks
and a very similar API, but that could ultimately compile down to native code.
So it seems like a lot of people are interested in exploring that space.
It does. Now, let me ask you a question. On what operating system might you run a lot
of Electron apps?
Well, I think I would probably run those on Linux.
Would you make that choice?
Would you choose Linux? See, I'm trying to say, yeah.
You know, I think I would.
Well, if I wanted to choose Linux, where could I go?
Oh, you know, there's been a lot of good options to where you could go, but don't,
there's also a lot of bad options.
So don't go somewhere like DistroWatch.
No, that's not, that can't be right.
No, don't go there. You could go to jupiterbroadcasting.com, but that's not quite
specific enough. Really, you should go check out the brand new show, Choose Linux over
at chooselinux.show, chooselinux.show slash one.
If you just want to start out with the very first episode, it's brand new.
Expect a second episode coming out before too long.
It'll be every other week.
You can join Jason and Joe to find out Jason's new adventures in the world of Linux and Joe's
realistic take on it.
Sounds amazing.
Oh, it is.
Of course, head on over to coder.show if you want to get the whole backlog, all the episodes,
as many as you could want.
Really, there's no excuse.
All the updates from Mike, all the magic and mispronunciations from Chris, and occasionally
I pop in there.
Plus, there's a bunch of other great Jupiter Broadcasting shows over at jupiterbroadcasting.com.
You can find me over on Twitter.
I'm at Wes Payne.
And of course, Mike, you're there, too.
At Dimenuco on Twitter.
Beautiful.
Thank you all so much for joining us.
We've got we've got a live stream.
You can go to jupiterbroadcasting.com slash calendar to find out when we're going to do
that.
It's usually right about noon Pacific time on Monday.
You can try to catch us there.
We've got a great IRC room.
And don't forget coder.show slash contact to find all the ways to get in touch or head
on over to our subreddit.
Thanks for joining us and we'll see you next week.

WEBVTT

00:00.000 --> 00:08.080
Welcome to Coda Radio, Jupiter Broadcasting's weekly talk show exploring the art and business

00:08.080 --> 00:11.900
of software development and related technologies.

00:11.900 --> 00:18.560
My name is Wes and I am just so lucky to be joined with that sorcerer of software, the

00:18.560 --> 00:21.760
one, the only, Mr. Michael Dominic.

00:21.760 --> 00:23.760
You just sound so much better than Chris.

00:23.760 --> 00:25.400
Oh, that's right I do.

00:25.400 --> 00:26.860
I'm so flattered.

00:26.860 --> 00:28.560
You sound pretty good today too.

00:28.560 --> 00:30.560
Thanks, sir.

00:30.560 --> 00:32.280
What planet do you find yourself on?

00:32.280 --> 00:35.560
Oh, well, the swamps of Riverview, Florida as usual.

00:35.560 --> 00:36.560
Me and Jar Jar.

00:36.560 --> 00:38.960
Yeah, you guys are just best buds down there, it seems like.

00:38.960 --> 00:39.960
Just best buds.

00:39.960 --> 00:43.360
You let them play in your pool, you're hanging out, you're smoking cigars together.

00:43.360 --> 00:45.120
It's a wild scene.

00:45.120 --> 00:46.120
That's right.

00:46.120 --> 00:47.120
That's right.

00:47.120 --> 00:50.400
Well, thank you for having me here with you today, Mike.

00:50.400 --> 00:53.120
Chris is still away, but that can't stop us.

00:53.120 --> 00:54.960
There's code to talk about.

00:54.960 --> 00:56.960
Can't stop the code.

00:56.960 --> 00:58.360
Heck, no.

00:58.360 --> 01:00.240
Well, maybe you can though.

01:00.240 --> 01:03.280
We've got some feedback to start off the show.

01:03.280 --> 01:05.120
It starts off pretty strong.

01:05.120 --> 01:08.200
Yeah, they're coming in pretty hot here.

01:08.200 --> 01:12.880
So Joe writes in and I'm going to read it, but first I'd like to summarize it.

01:12.880 --> 01:16.520
Joe would like to know what the hell is wrong with me.

01:16.520 --> 01:20.680
I haven't really read this yet, but I want to know too.

01:20.680 --> 01:24.680
So Joe says blah, I'm not sure I get that part.

01:24.680 --> 01:25.980
Why.NET?

01:25.980 --> 01:26.980
It's a dead end.

01:26.980 --> 01:28.880
It doesn't have support on any other systems.

01:28.880 --> 01:35.080
Yes, technically it has had Xamarin, but let's be realistic.

01:35.080 --> 01:37.480
There's no good front end for Linux.

01:37.480 --> 01:39.560
Not true anymore, but we'll get to it.

01:39.560 --> 01:42.200
I have known about Qt for a long time.

01:42.200 --> 01:47.360
Back when he did more C++ programming, I looked at various ways to do cross-platform development.

01:47.360 --> 01:53.880
He avoids Qt, he says, because the license now in C++ is using WX widgets, which actually

01:53.880 --> 01:57.200
a few other people have recommended and I'll talk about it in a minute.

01:57.200 --> 02:02.840
Nowadays he's a Java programmer and yeah, I'm summarizing this a little long, but he

02:02.840 --> 02:08.400
says JavaScript looks like a spaghetti nightmare from the 70s.

02:08.400 --> 02:09.600
The man does not mince words.

02:09.600 --> 02:10.600
You have to respect him.

02:10.600 --> 02:11.600
I appreciate that.

02:11.600 --> 02:12.600
Yeah, props, Joe, props.

02:12.600 --> 02:13.600
And I mean, that's right.

02:13.600 --> 02:15.400
I mean, it does look like that.

02:15.400 --> 02:16.720
Yeah, it really does.

02:16.720 --> 02:18.200
So point by point, right?

02:18.200 --> 02:23.280
Oh, and he says go Pats for the football season, which really undercuts the rest of

02:23.280 --> 02:24.280
your email.

02:24.280 --> 02:27.640
Just don't mention that you're a Patriots fan.

02:27.640 --> 02:29.620
So simple answer, right?

02:29.620 --> 02:37.280
The product I am launching next week, yay, and Linux, but mostly Windows.

02:37.280 --> 02:39.520
So.NET's a pretty natural choice.

02:39.520 --> 02:43.000
The aerospace industry tends to love them some Microsoft.

02:43.000 --> 02:44.000
Right?

02:44.000 --> 02:45.000
Yeah.

02:45.000 --> 02:48.180
I mean, if you already have support for the runtime there, you should reintroduce your

02:48.180 --> 02:49.360
product real quick there.

02:49.360 --> 02:51.360
You cut out for a split second.

02:51.360 --> 02:54.200
So it's launching next week, so I can't say anything about it yet.

02:54.200 --> 02:55.200
Ah, yeah, okay.

02:55.200 --> 02:56.200
We just missed a tiny bit.

02:56.200 --> 02:59.680
But you said it mostly runs on, you're mostly targeting Windows?

02:59.680 --> 03:00.680
Yeah, yeah.

03:00.680 --> 03:04.280
I think like about like nine out of 10 installs are going to be Windows.

03:04.280 --> 03:05.280
Got it.

03:05.280 --> 03:07.360
Okay, interesting.

03:07.360 --> 03:11.240
In terms of Q, yeah, that was a, Wes, have you taken a look at Q in a while?

03:11.240 --> 03:15.120
No, you know, honestly, it's been a couple of years since I've really, you know, gotten

03:15.120 --> 03:17.920
down and ready and had a new project that I was playing with it.

03:17.920 --> 03:19.080
Yeah, yeah.

03:19.080 --> 03:23.520
I was looking at it recently, and I just got tripped up on the licensing.

03:23.520 --> 03:27.840
That seems especially complicated if you're not just playing solely in the open source

03:27.840 --> 03:28.840
world.

03:28.840 --> 03:29.840
Yeah, it is.

03:29.840 --> 03:36.560
Yeah, and we had an episode on the whole LGPL, and then it being by component was pretty

03:36.560 --> 03:37.560
confusing.

03:37.560 --> 03:42.040
So does that mean that you've kind of just, is that written off for you now?

03:42.040 --> 03:43.040
Not a path you're going to be?

03:43.040 --> 03:44.040
Yeah, it's written off for now.

03:44.040 --> 03:45.040
Got it, yeah.

03:45.040 --> 03:47.120
Just exploring other ways to accomplish the same thing.

03:47.120 --> 03:53.760
Yeah, the pricing to be compliant with the license was going to be just way too high.

03:53.760 --> 03:58.640
So yeah, you know, everybody loves Java, not trying to knock Java.

03:58.640 --> 04:01.200
I know Wes is a big Java fan, right?

04:01.200 --> 04:03.400
You know, I have nothing against Java.

04:03.400 --> 04:10.800
I don't want to build certain things with it, but as a building block to build big systems,

04:10.800 --> 04:11.800
it's come a long way.

04:11.800 --> 04:16.600
I like the newer Javas as well when you have, you know, a little more functional influence.

04:16.600 --> 04:18.320
That's a much more pleasant language.

04:18.320 --> 04:19.860
Yeah, yeah.

04:19.860 --> 04:23.240
So yeah, I appreciate the email, Joe, and a lot about Wes, unless you have anything

04:23.240 --> 04:24.280
else here on WX widgets.

04:24.280 --> 04:25.280
I did look at it.

04:25.280 --> 04:28.520
I don't, I have not used it yet, so I can't really speak to.

04:28.520 --> 04:32.720
No, I can't either, although I guess I've seen a lot of things written in it.

04:32.720 --> 04:35.440
I don't know if they were beautiful, but if you just want to go for a functional, seems

04:35.440 --> 04:37.120
like it's certainly up to the task.

04:37.120 --> 04:40.400
There you go.

04:40.400 --> 04:46.560
So next on the docket, a similar comment I got on YouTube and a Twitter question.

04:46.560 --> 04:48.240
Quite a lot was, why not Tornado FX?

04:48.240 --> 04:49.640
Are you familiar with this at all?

04:49.640 --> 04:51.880
Oh no, what's Tornado FX?

04:51.880 --> 04:55.440
This is actually keeping in line with Joe's Java mentioned.

04:55.440 --> 04:59.320
This is a version of Java FX that uses Kotlin.

04:59.320 --> 05:00.960
Oh, okay.

05:00.960 --> 05:03.040
Well that, that sounds pretty nice actually.

05:03.040 --> 05:09.160
It, yeah, it does look pretty, pretty sexy if I say so myself, but it's a little too

05:09.160 --> 05:12.680
new for me to want to ship in a production project.

05:12.680 --> 05:13.680
Right.

05:13.680 --> 05:19.680
I mean, Kotlin itself isn't really that old yet, and yeah, it seems like this product,

05:19.680 --> 05:21.280
it's moving pretty quickly.

05:21.280 --> 05:25.160
But oh yeah, as they say here, not yet compatible with Java 9 or 10 yet.

05:25.160 --> 05:27.760
So yeah, clearly there's some stabilizing to do.

05:27.760 --> 05:28.760
Yeah.

05:28.760 --> 05:32.480
There's some weirdness with Kotlin and different Java versions, as I've learned the hard way.

05:32.480 --> 05:33.480
Really?

05:33.480 --> 05:34.640
That's actually, I had not heard that complaint before.

05:34.640 --> 05:38.120
I've almost always heard pleasant things about Kotlin so far.

05:38.120 --> 05:39.120
Yeah.

05:39.120 --> 05:43.880
Well, I don't think it's currently true, but when Java 10 came out, it was actually not

05:43.880 --> 05:44.880
compatible with Kotlin.

05:44.880 --> 05:45.880
Oh yeah.

05:45.880 --> 05:46.880
Okay.

05:46.880 --> 05:49.800
I suppose there's always bound to be, bound to be a little leg when you have big changes

05:49.800 --> 05:50.800
underneath.

05:50.800 --> 05:51.800
Yeah, exactly.

05:51.800 --> 05:52.800
It can't be easy, Mike.

05:52.800 --> 05:53.800
This is software.

05:53.800 --> 05:54.800
What are you, what are you thinking over there?

05:54.800 --> 05:55.800
What?

05:55.800 --> 05:56.800
I'm sorry.

05:56.800 --> 05:58.840
I'm just, I'm just, you know, I'm just lost.

05:58.840 --> 06:00.400
Yeah, that's right.

06:00.400 --> 06:04.440
Well, so last I heard you had done something terrible to your phone.

06:04.440 --> 06:07.960
Is that, is it still in a state of disrepair?

06:07.960 --> 06:12.440
It is still in a state of disrepair because I refuse to pay the exorbitant 200 and something

06:12.440 --> 06:14.280
dollars Apple wants for screen replacement.

06:14.280 --> 06:15.280
Oh, ouch.

06:15.280 --> 06:20.760
Yeah, that's a, that'll burn a hole in your pocket real quick.

06:20.760 --> 06:26.920
So speaking of losing money, Fortnite, 15 million downloads by sidestepping the Google

06:26.920 --> 06:28.880
Play Store on Android.

06:28.880 --> 06:29.880
Wow.

06:29.880 --> 06:30.880
Woo wee.

06:30.880 --> 06:31.880
That is, I'm impressed.

06:31.880 --> 06:32.880
That's got it.

06:32.880 --> 06:33.880
I'm impressed.

06:33.880 --> 06:39.680
That's got to be significant, significant revenue loss there for Google.

06:39.680 --> 06:40.680
Right?

06:40.680 --> 06:44.000
I mean, yeah, they're pulling a pretty big cut from, you'd presume a lot of those would

06:44.000 --> 06:45.640
have come through them otherwise.

06:45.640 --> 06:46.640
Yeah.

06:46.640 --> 06:50.720
And with a 30% every in-app purchase.

06:50.720 --> 06:54.800
Do you, would this work, would this strategy work for a less popular application?

06:54.800 --> 06:57.760
I mean, obviously Fortnite has a ton of momentum in mind.

06:57.760 --> 06:58.760
People already know about it.

06:58.760 --> 07:01.780
They don't need discoverability really on the store and they just, you know, and they're

07:01.780 --> 07:03.680
already motivated to download it.

07:03.680 --> 07:04.680
Yeah.

07:04.680 --> 07:07.260
Would this work for something like, could you go around the Play Store and have any

07:07.260 --> 07:08.260
kind of this success?

07:08.260 --> 07:09.260
No, no.

07:09.260 --> 07:10.260
No.

07:10.260 --> 07:14.460
And actually we should mention that for a few days there, Fortnite actually was the

07:14.460 --> 07:20.400
victim of a man in the middle attack where, yeah, people were getting infected APKs and

07:20.400 --> 07:24.040
Google very publicly pointed it out in, right?

07:24.040 --> 07:27.560
But I guess this is what happens when you skip on all our niceties.

07:27.560 --> 07:30.360
Circumvent the app store.

07:30.360 --> 07:31.560
It's certainly interesting though.

07:31.560 --> 07:32.560
Yeah.

07:32.560 --> 07:37.760
That 30% cut feels, you know, very outmoded.

07:37.760 --> 07:40.440
It really kind of feels pretty steep.

07:40.440 --> 07:41.440
It really is.

07:41.440 --> 07:42.440
Yeah.

07:42.440 --> 07:45.840
And it's like, it adds to the weird walled garden effect and it doesn't, you know, that's

07:45.840 --> 07:50.400
useful what they do, but 30%, you know, like a standard, a more standard listing fee.

07:50.400 --> 07:54.960
Seems like it would just encourage more and better apps on the ecosystem anyway.

07:54.960 --> 07:59.640
One more financially sustainable for the developers, even if they are just doing advertising or

07:59.640 --> 08:00.640
support.

08:00.640 --> 08:01.640
Yeah, exactly.

08:01.640 --> 08:03.080
So tell me about Loom.

08:03.080 --> 08:04.080
This is your thing.

08:04.080 --> 08:05.080
Yeah.

08:05.080 --> 08:06.080
Oh yeah.

08:06.080 --> 08:07.080
So let's just move right along.

08:07.080 --> 08:10.520
Cause we've got a, you know, this show, it's gotta, it's gotta move.

08:10.520 --> 08:13.920
So Mike, we were just talking about JavaScript, right?

08:13.920 --> 08:19.840
And well, it's funny because a lot of people liked node because of the concurrency story,

08:19.840 --> 08:20.840
right?

08:20.840 --> 08:23.640
It could, it could do, you know, 10, 10 X connections.

08:23.640 --> 08:27.240
It could scale those connections and had that event loop built right in.

08:27.240 --> 08:32.560
But the downside is of course you've got asynchronous JavaScript, which can just be a big old mess

08:32.560 --> 08:33.560
of callbacks.

08:33.560 --> 08:34.560
Right?

08:34.560 --> 08:35.560
I don't know.

08:35.560 --> 08:36.560
What's your, where do you fall?

08:36.560 --> 08:39.040
What do you usually do when you need, you know, concurrent software?

08:39.040 --> 08:40.040
What's your tool set?

08:40.040 --> 08:42.720
Oh, it depends on the language.

08:42.720 --> 08:47.440
I mean, if I'm in.net or really anything else that supports a sync away, I tend to lean

08:47.440 --> 08:48.440
on that.

08:48.440 --> 08:52.160
Um, but yeah, in JavaScript I'm, I'm living in callback hell.

08:52.160 --> 08:53.160
Okay.

08:53.160 --> 08:54.160
That, that makes sense.

08:54.160 --> 08:57.880
Um, how do you like async await over in the.net world?

08:57.880 --> 08:59.560
I like it.

08:59.560 --> 09:08.520
It so it's a really, it's a really big, my opinion is a huge abstraction and well 99%

09:08.520 --> 09:09.880
of the time I think it's great.

09:09.880 --> 09:14.360
It saves me from, you know, just having really ugly looking code that's hard to maintain

09:14.360 --> 09:18.440
every once in a while you get like weird edge cases where you accidentally lock something

09:18.440 --> 09:21.800
up or things don't finish the way you think they're going to finish.

09:21.800 --> 09:22.800
Oh yeah.

09:22.800 --> 09:26.800
And then you have some bad concurrency states and everything goes to hell.

09:26.800 --> 09:27.800
Yeah.

09:27.800 --> 09:30.720
Cause what it's doing is every time you, you type the await keyword and it compiles, it's

09:30.720 --> 09:33.560
actually generating a bunch of code behind that.

09:33.560 --> 09:37.560
And it's, it's, so it's not like, it's not removing the need for crazy callbacks and

09:37.560 --> 09:38.560
concurrent.

09:38.560 --> 09:39.560
Right.

09:39.560 --> 09:42.160
It just, the compiler like makes you a state machine to do all of that for you.

09:42.160 --> 09:43.160
Exactly.

09:43.160 --> 09:44.160
Yeah, exactly.

09:44.160 --> 09:47.480
Well, we can dive into it later if we want, but Clojure's got this similar mechanism.

09:47.480 --> 09:50.840
There's is just shipped as a macro, the go macro, which will implement basically the

09:50.840 --> 09:51.840
same idea.

09:51.840 --> 09:55.520
Um, so that's, so that's one way of people that people deal with it, right?

09:55.520 --> 10:00.560
So we have, you've got like bear callbacks, um, promises are being seen a lot these days,

10:00.560 --> 10:02.400
which sort of revise it up one level.

10:02.400 --> 10:05.720
At least then you've got something you can, you know, hold in a variable you can interact

10:05.720 --> 10:06.720
with.

10:06.720 --> 10:10.100
Uh, it's a little more than just waiting, knowing it's sitting in the queue to be executed

10:10.100 --> 10:12.120
somewhere in the runtime.

10:12.120 --> 10:15.880
And then you've got compiler options where the compiler or a macro or something can help

10:15.880 --> 10:17.880
you manage some of the complexity.

10:17.880 --> 10:23.240
But we've got a link in the show notes for a great article that talks about what color

10:23.240 --> 10:28.880
is your function and that, that a synchronicity can leak throughout your code base and anytime

10:28.880 --> 10:31.880
you touch it, you sort of start to feel it.

10:31.880 --> 10:37.360
Project Loom is trying to solve some of that by going one level deeper and trying to fix

10:37.360 --> 10:38.480
it at the runtime.

10:38.480 --> 10:44.320
So one thing that, uh, you know, a number of languages that are thought of as good for

10:44.320 --> 10:50.760
concurrency like Go or Erlang, well, they've got some lightweight threads and that's something

10:50.760 --> 10:54.800
Java, there was, there was proposals way back in the day, but it really has never been there.

10:54.800 --> 11:01.360
And we just have to rely on either async callbacks in Java or regular old blocking calls.

11:01.360 --> 11:07.680
Obviously that has problems scaling, enter project loom and fibers, which are lightweight

11:07.680 --> 11:12.720
threads you can use as if they were just OS threads.

11:12.720 --> 11:18.640
The JVM will manage running those on actual physical cores on OS threads for you.

11:18.640 --> 11:19.640
Interesting.

11:19.640 --> 11:23.560
So have you, have you been able to use this yet?

11:23.560 --> 11:28.560
I've played with, uh, so it looks like the, there was previously a project called Quasar,

11:28.560 --> 11:33.920
which did this already, but basically looked at the generated byte code and did some, some

11:33.920 --> 11:37.960
introspecting and changing and modifying of it on the fly to achieve the same effect because

11:37.960 --> 11:40.940
it wasn't supported upstream in the JVM.

11:40.940 --> 11:44.620
That the person behind that project is now working for Oracle and working on project

11:44.620 --> 11:48.520
loom as well with some other researchers, of course.

11:48.520 --> 11:53.440
So I've used that earlier incarnation a little bit, not in production or anything too serious,

11:53.440 --> 11:54.440
but it was neat.

11:54.440 --> 11:58.480
And I have played with, uh, well, I've mostly played with Elixir, but I've used the beam

11:58.480 --> 12:01.400
VM, uh, which has similar lightweight threads.

12:01.400 --> 12:03.280
They call them processes over there.

12:03.280 --> 12:04.280
Interesting, interesting.

12:04.280 --> 12:10.860
And remind me, I don't want to let you off the hook cause you mentioned Elixir.

12:10.860 --> 12:16.560
So I have to hear the pitch for Elixir, but what I didn't understand from reading this

12:16.560 --> 12:24.320
was it looks like it's still calling OS, uh, threads on the, underneath it all, right?

12:24.320 --> 12:25.320
Yes, it does.

12:25.320 --> 12:26.320
Okay.

12:26.320 --> 12:31.000
Uh, but it can implement, it's basically taking the, um, like the parking that happens in

12:31.000 --> 12:32.000
that state machine.

12:32.000 --> 12:36.360
Um, we were talking about for like async await, uh, it's taking that and being able to do

12:36.360 --> 12:37.680
it at the runtime layer.

12:37.680 --> 12:42.160
So once you're running on these lightweight threads, it can figure out that you're blocked

12:42.160 --> 12:46.920
waiting for some IO and it'll just park that, it'll schedule it off a real OS thread.

12:46.920 --> 12:50.460
And then once that input's received, it can put it back on the thread and then mostly

12:50.460 --> 12:52.920
it's going to be built, I think just on top of the regular fork join.

12:52.920 --> 12:57.400
So they've just got the scheduling layer on top.

12:57.400 --> 12:58.400
Layer on top.

12:58.400 --> 12:59.400
Right.

12:59.400 --> 13:02.840
And theoretically being the JVM, you would avoid any weird issues with like different

13:02.840 --> 13:04.800
threadings on different OS's being.

13:04.800 --> 13:08.360
Yeah, you would hope that the VM would have that abstraction there for you.

13:08.360 --> 13:09.360
Right.

13:09.360 --> 13:12.320
Looks to scan at windows 10 because thanks guys.

13:12.320 --> 13:13.400
Yeah, exactly.

13:13.400 --> 13:17.160
So this was just appealing for me because it seems like a pretty clean, if you, if they

13:17.160 --> 13:21.600
get it right, it seems like a nice thing to be able to build upon because instead of having

13:21.600 --> 13:26.260
to, you know, have either just like you can do a thread, let's say you're making some

13:26.260 --> 13:28.240
long running HTTP request.

13:28.240 --> 13:31.840
If you put each of those on the thread, well that'll just only scale so far.

13:31.840 --> 13:36.880
And that's why a lot of people have been driven to asynchronous APIs in the first place.

13:36.880 --> 13:38.660
With this you get the best of both worlds.

13:38.660 --> 13:39.660
You can write your code.

13:39.660 --> 13:45.200
It looks like it's just regular blocking code and in some sense it is, it's just managed

13:45.200 --> 13:46.320
below that layer for you.

13:46.320 --> 13:51.560
So you can have a green thread per HTTP request and you don't have to care about it and it'll

13:51.560 --> 13:56.000
just handle all the scheduling so that they execute in the order they need to.

13:56.000 --> 13:57.720
Wow.

13:57.720 --> 14:00.800
We are living in a world of asynchronous abstraction glory.

14:00.800 --> 14:01.880
I know, right?

14:01.880 --> 14:06.360
So this is probably a long way off to actually see it in production and in production JVM

14:06.360 --> 14:07.800
on your servers.

14:07.800 --> 14:13.020
But I'm glad that it's happening because, you know, the JVM, it just remains so popular.

14:13.020 --> 14:14.020
So many places use it.

14:14.020 --> 14:15.440
It's, it is a powerhouse.

14:15.440 --> 14:19.240
It's got some of the best just in time compiling out there.

14:19.240 --> 14:21.080
So many man hours have been used for it.

14:21.080 --> 14:22.080
Not everyone loves it.

14:22.080 --> 14:24.840
It's kind of weird, especially when you're dealing with, I don't know, weird class path

14:24.840 --> 14:29.000
construction or the way it handles certificates, which are just absolutely deplore.

14:29.000 --> 14:30.000
Yeah.

14:30.000 --> 14:33.220
Either way, it's fast and it's been battle tested over a lot of years.

14:33.220 --> 14:38.480
So if we can get even better concurrency primitives on it, there's a huge amount of programmers

14:38.480 --> 14:39.480
that stand to benefit.

14:39.480 --> 14:40.480
Oh yeah.

14:40.480 --> 14:46.840
No, I could, yeah, for large scale JV Java based applications, that would be pretty significant.

14:46.840 --> 14:47.840
Absolutely.

14:47.840 --> 14:50.140
So you mentioned Elixir.

14:50.140 --> 14:56.280
So elevator pitch me, what are you doing in Elixir and why Elixir?

14:56.280 --> 14:58.320
I made a couple of toy projects.

14:58.320 --> 15:00.120
I haven't done anything too serious.

15:00.120 --> 15:04.080
I'd always just been curious about the beam VM.

15:04.080 --> 15:08.760
It has an interesting history coming out of the telecommunications industry and Ericsson

15:08.760 --> 15:09.760
in particular.

15:09.760 --> 15:15.260
And it's been widely respected in like VoIP circles for running a lot of those hardware

15:15.260 --> 15:20.600
appliances and software projects and being scalable and low latency.

15:20.600 --> 15:25.880
Elixir is, well, Erlang came out, the first version was actually just in prologue.

15:25.880 --> 15:31.080
So it has weird prologue like syntax, which is not everyone's piece of cake.

15:31.080 --> 15:32.800
I can understand that.

15:32.800 --> 15:39.720
Elixir is a new language that sits on top of the beam VM, inherits a lot from Erlang,

15:39.720 --> 15:44.560
is inspired by Erlang, but it comes with a friendlier, more, they call it Ruby inspired.

15:44.560 --> 15:48.440
It's not really like Ruby, but it's got the basic sort of syntax, you know, if you squint

15:48.440 --> 15:53.320
at the screen, it looks like Ruby and it's a lot more traditional.

15:53.320 --> 16:00.280
It's also just a little more, Erlang's great, but it came out of the late 80s, 90s, that

16:00.280 --> 16:01.920
era is when it first saw a lot of its growth.

16:01.920 --> 16:04.760
So it's just a bit dated.

16:04.760 --> 16:08.760
Elixir has a lot more niceties, more like a literal syntax for different sort of data

16:08.760 --> 16:12.480
structures, more just sugar, I would say.

16:12.480 --> 16:13.480
Okay.

16:13.480 --> 16:16.880
So it's in a lot of ways like a modernized.

16:16.880 --> 16:17.880
Yeah.

16:17.880 --> 16:18.880
Yep.

16:18.880 --> 16:19.880
I would say so.

16:19.880 --> 16:23.340
You know, there's anyone who loves both those languages would have a, that would be, should

16:23.340 --> 16:26.200
be shouting at us right now because there's a lot more intricacies for that and there's

16:26.200 --> 16:30.520
a large community with a lot of history that I can't capture in a 10 second spiel.

16:30.520 --> 16:34.980
But yes, they share a lot of that same background and they fit really well for those same things.

16:34.980 --> 16:40.240
So famously like Erlang runs the WhatsApp servers and it works really well for that

16:40.240 --> 16:43.800
because you can get lots of, lots of simultaneous connections.

16:43.800 --> 16:45.720
All of the just like, yeah, they have a weird stack.

16:45.720 --> 16:47.120
It's FreeBSD and Erlang.

16:47.120 --> 16:51.160
So both kind of secret weapons, I guess, and they have big honking.

16:51.160 --> 16:54.040
There's always those BSD guys at the show, right, at the trade show.

16:54.040 --> 16:55.040
There has to be.

16:55.040 --> 16:56.040
Yeah.

16:56.040 --> 16:57.040
And it's, you know, it's part of the community.

16:57.040 --> 17:00.720
And so they got these big honking BSD servers running Erlang and just getting millions of

17:00.720 --> 17:02.560
concurrent connections to them.

17:02.560 --> 17:06.380
And you know, they're not necessarily like, the beam is not as fast for computational

17:06.380 --> 17:08.200
things as the JVM is.

17:08.200 --> 17:12.640
But if you're just doing like message passaging, some web sockets, maybe is a use this sees

17:12.640 --> 17:16.720
a lot where you want low latency, fast response, and just to shove some signaling data through

17:16.720 --> 17:21.920
rather than like a big pipe of real data beams your guy.

17:21.920 --> 17:22.920
Very cool.

17:22.920 --> 17:23.920
Yeah.

17:23.920 --> 17:27.220
I was actually just at a dev meetup and there was like three guys just like hunched over

17:27.220 --> 17:28.220
their MacBooks.

17:28.220 --> 17:30.360
Yes, they were MacBooks.

17:30.360 --> 17:36.520
And just I walked up and said, hey, what are you guys working on?

17:36.520 --> 17:38.000
Oh, we're doing something in Elixir.

17:38.000 --> 17:39.000
I said, what?

17:39.000 --> 17:40.000
Why?

17:40.000 --> 17:44.600
You know, cause you go to these things, 90% of the people that are like making websites

17:44.600 --> 17:45.600
or iOS apps, right?

17:45.600 --> 17:46.600
Totally.

17:46.600 --> 17:47.600
Yeah.

17:47.600 --> 17:48.600
Yeah.

17:48.600 --> 17:49.600
None of it's like crazy.

17:49.600 --> 17:50.600
Just run of the mill software projects.

17:50.600 --> 17:51.600
Yeah.

17:51.600 --> 17:52.600
Run of the mill normal stuff.

17:52.600 --> 17:57.160
But yeah, I keep hearing about it and I keep trying to figure out what the actual use case

17:57.160 --> 17:59.880
I've heard the view over IP thing before.

17:59.880 --> 18:00.880
I didn't know about what's out there.

18:00.880 --> 18:01.880
That's pretty cool.

18:01.880 --> 18:02.880
Yeah.

18:02.880 --> 18:06.740
I think the other thing about Elixir, which maybe makes it a good story for people just

18:06.740 --> 18:09.480
getting into it is it does have a lot of those nice primitives.

18:09.480 --> 18:12.800
It's got a good functional programming story, mutabilities there.

18:12.800 --> 18:18.680
It also has great documentation and the creator of the language, I think his name's Jose Valim.

18:18.680 --> 18:19.680
He's just, he's awesome.

18:19.680 --> 18:23.920
He does, he goes to conferences, does all kinds of good spieling about it in the documentation.

18:23.920 --> 18:25.360
It's geared towards new users.

18:25.360 --> 18:26.520
It's easy to get started.

18:26.520 --> 18:28.080
It's probably already in, you know, it's in brew.

18:28.080 --> 18:29.580
It's in a lot of package managers.

18:29.580 --> 18:33.200
You get a nice little interactive rebel to play with it.

18:33.200 --> 18:34.520
It's just super fun to get started with.

18:34.520 --> 18:37.720
I haven't, yeah, I haven't used it for anything serious, but it was so easy to get started.

18:37.720 --> 18:39.040
I was like, there's really no excuse.

18:39.040 --> 18:40.440
I'll try to do a couple of things.

18:40.440 --> 18:44.880
And it is fun to be thinking in that concurrency style where you can just make a process for

18:44.880 --> 18:45.880
whatever.

18:45.880 --> 18:47.000
You have processes to store data.

18:47.000 --> 18:49.880
You have processes to make HTTP requests.

18:49.880 --> 18:52.360
You have processes to do basically anything you want.

18:52.360 --> 18:59.120
And that Erlang VM in its ADC glory handles all the scheduling.

18:59.120 --> 19:00.120
That's really awesome.

19:00.120 --> 19:01.120
Yeah.

19:01.120 --> 19:06.840
The other nice part too is you get access to OTP, which is the open telephony system

19:06.840 --> 19:11.860
or protocol project, whatever the P stands for.

19:11.860 --> 19:15.120
That is a lot of the stuff that gets bundled with Erlang.

19:15.120 --> 19:19.400
It's its own project, but has historically been developed with Erlang and it adds a lot

19:19.400 --> 19:23.600
of sort of the redundancy fault tolerance supervision structure that Erlang is known

19:23.600 --> 19:27.740
for because you know, when you're running a big telco switch, you can't really tolerate

19:27.740 --> 19:29.140
very much downtime.

19:29.140 --> 19:33.280
So it's good at things like hot reloading and it's really good at instead of having

19:33.280 --> 19:38.120
to deal with all the error pads, you just sort of set up a tree of supervised actors

19:38.120 --> 19:42.060
and you can configure things like a restart, how many retries should I do before I fail

19:42.060 --> 19:43.460
up to the next level?

19:43.460 --> 19:47.420
And how do I restart or, you know, do I have things I need to do before I run or after

19:47.420 --> 19:48.420
I run?

19:48.420 --> 19:50.240
And all of that's in that library for you.

19:50.240 --> 19:55.120
So you can, it really has like primitives to build a distributed system in a reliable

19:55.120 --> 20:01.800
way baked right into the runtime and the popular libraries.

20:01.800 --> 20:02.800
Very cool.

20:02.800 --> 20:06.080
So Closures is not your true, true love, is it?

20:06.080 --> 20:07.920
No, no, it wouldn't be.

20:07.920 --> 20:09.840
That's still Closure, of course.

20:09.840 --> 20:12.400
Ah, lay it on me, man.

20:12.400 --> 20:15.640
You know, I've just been really enjoying it.

20:15.640 --> 20:19.300
There's been some good developments going on since the last time we talked about it.

20:19.300 --> 20:23.680
In particular, the Closure community, I mean, lots of communities are good.

20:23.680 --> 20:27.340
It's a little bit, it's small enough that it can have a character of its own.

20:27.340 --> 20:30.800
Of course, there's still different pieces of it and all kinds of unique personalities

20:30.800 --> 20:36.920
that are involved, but it's a unique set of, Clojure's not often a first programmer's language.

20:36.920 --> 20:41.260
It's sort of a grumpy old programmer's language who got sick of fighting Java or JavaScript

20:41.260 --> 20:44.000
or whatever else and wanted something better.

20:44.000 --> 20:47.400
So it can be tough, a bit tough for people to pick up for the first language, but as

20:47.400 --> 20:52.200
a result, most of the people doing it are experienced senior programmers.

20:52.200 --> 20:55.560
So you get a lot of, there's a lot of maturity in the community, and while they have a lot

20:55.560 --> 20:59.580
of respect for academia, and one of the things they love to do as a community is pull great

20:59.580 --> 21:04.120
ideas from papers from the 70s and then implement them, but they do that with an air to being

21:04.120 --> 21:07.980
pragmatic because they all work at day jobs programming and just want to get stuff done

21:07.980 --> 21:10.380
and build reliable systems.

21:10.380 --> 21:12.680
So it's like.NET, but stable.

21:12.680 --> 21:13.680
I'm kidding.

21:13.680 --> 21:14.680
Yeah, totally.

21:14.680 --> 21:15.680
Totally.

21:15.680 --> 21:16.680
It even runs on.NET.

21:16.680 --> 21:19.920
There's a version that compiles to the CLR.

21:19.920 --> 21:25.920
It's not much used compared to the JVM or JS, but there is a project to get it to run

21:25.920 --> 21:31.360
well on mono and then you can hook it up to Unity, which is kind of neat.

21:31.360 --> 21:35.500
That would be the most hardcore game on Humble Bundle.

21:35.500 --> 21:36.500
You mentioned JS.

21:36.500 --> 21:40.840
Now is that JS via transpiling to JavaScript or is it WebAssembly?

21:40.840 --> 21:48.880
Yes, it is ClojureScript, which is a project written in Clojure that is a compiler that

21:48.880 --> 21:50.920
compiles a Clojure-like dialect.

21:50.920 --> 21:55.280
They're like 98% the same to JavaScript.

21:55.280 --> 21:58.000
It's Clojure inception there.

21:58.000 --> 22:04.120
ClojureScript is written in Clojure and what ClojureScript does is it compiles a dialect

22:04.120 --> 22:05.120
of Clojure?

22:05.120 --> 22:06.120
Yes.

22:06.120 --> 22:07.440
And then it compiles that to JavaScript.

22:07.440 --> 22:13.440
Let me spin my little thing here to see if I'm awake or not.

22:13.440 --> 22:19.840
So theoretically you're writing an application, again Clojure is one that I haven't done anything

22:19.840 --> 22:22.520
but I've been curious.

22:22.520 --> 22:23.520
You're writing an application.

22:23.520 --> 22:27.820
I'm assuming you're writing server software and you need some sort of front end because

22:27.820 --> 22:29.480
that's life.

22:29.480 --> 22:32.200
People want to look at your data that you've spent all this time making for them.

22:32.200 --> 22:33.200
Shocking.

22:33.200 --> 22:34.200
You can't just say the data's there, I promise.

22:34.200 --> 22:38.200
I've got a JSON blob for you if you want to go send a GET request over here.

22:38.200 --> 22:39.200
Does that work?

22:39.200 --> 22:44.600
If I really don't like you it's going to be XML.

22:44.600 --> 22:46.760
Is your full stack Clojure?

22:46.760 --> 22:49.320
Obviously you probably have CSS and all that.

22:49.320 --> 22:53.740
That is one of the compelling stories for ClojureScript is you can have full stack and

22:53.740 --> 22:59.600
you can share a lot of it because it's mostly just all the host primitives that are going

22:59.600 --> 23:01.520
to end up different.

23:01.520 --> 23:05.960
There's now compiler support so you can have a project that has three types of files, a

23:05.960 --> 23:14.240
.clj for pure Clojure, a.cljs for ClojureScript, and a.cljc which can be compiled as either.

23:14.240 --> 23:18.040
So you can have a bunch of definitions of things, you can have protocols implemented

23:18.040 --> 23:21.760
or any kind of abstraction that isn't going to see a direct implementation on top of the

23:21.760 --> 23:22.760
host.

23:22.760 --> 23:27.240
All of that can be shared in these.cljc files and then you can just implement the pull from

23:27.240 --> 23:33.320
that big standard library that you've made yourself there from both sides of it.

23:33.320 --> 23:35.520
So you can reuse your standard library?

23:35.520 --> 23:36.520
Yes.

23:36.520 --> 23:38.480
So your standard library, it's not just...

23:38.480 --> 23:39.480
Yeah, right.

23:39.480 --> 23:42.960
So you can make any sort of amount of code as long as, I mean, sometimes you need to

23:42.960 --> 23:44.840
have slight differences for the two platforms.

23:44.840 --> 23:49.320
But by and large, you can see projects where most of it is written in CLJC and then they've

23:49.320 --> 23:52.440
got a couple, you know, oh, here's a couple of things that we've got to do, the thread

23:52.440 --> 23:58.320
in on the server part, and here's the thing we've got to do, the UI part, or...

23:58.320 --> 23:59.720
So it's pretty flexible in that regard.

23:59.720 --> 24:03.600
And you can see a lot of, you know, they have the same data structures, and so there's several

24:03.600 --> 24:08.800
neat projects that have libraries for both the back end and the front end, and it does

24:08.800 --> 24:10.280
all the serialization and stuff for you.

24:10.280 --> 24:14.760
There's already several formats, one that's very fast, one that's very human readable,

24:14.760 --> 24:17.540
to handle Clojure data structures back and forth.

24:17.540 --> 24:18.540
So you can have...

24:18.540 --> 24:22.560
One of them, I think it's Sente, it's like a WebSocket abstraction, you can just have

24:22.560 --> 24:26.560
a WebSocket between your server and your client and just throw Clojure data structures across

24:26.560 --> 24:31.480
it and pick it up and you don't have to, there's no, you know, no mapping to different objects

24:31.480 --> 24:35.600
and different object systems between the languages, there's just a low impedance and it works

24:35.600 --> 24:37.680
really nicely.

24:37.680 --> 24:43.920
So is there like a popular development framework where obviously Python has like Django, Ruby

24:43.920 --> 24:44.920
has Rails?

24:44.920 --> 24:47.920
No, that's a good question.

24:47.920 --> 24:52.080
That's another thing Elixir has going forward is they've got Phoenix, which is a popular

24:52.080 --> 24:56.520
framework which is compared to Rails.

24:56.520 --> 25:02.440
Clojure not really, that is one aspect of its community that's a bit odd is it's almost

25:02.440 --> 25:07.560
like the Unix philosophy, there's a lot of composition, so they really tend to prefer

25:07.560 --> 25:11.600
libraries from frameworks, and I think again this stems out of the more mature community

25:11.600 --> 25:14.680
base because Rails is great, especially if you're starting a project, you don't really

25:14.680 --> 25:17.960
know where it's going to go, maybe you're not that, you haven't done doing it that long,

25:17.960 --> 25:21.080
Rails handles all the things that have to get handled but you don't necessarily care

25:21.080 --> 25:22.080
about right away.

25:22.080 --> 25:26.080
You know, I don't really care how the CSRF protection works, maybe later I need to customize

25:26.080 --> 25:30.720
it when I start doing that part of my project, but just throw it in there for me.

25:30.720 --> 25:35.280
Clojure's much more, they've got a lot of components that you can use to build a system

25:35.280 --> 25:37.440
of any kind that you want.

25:37.440 --> 25:40.680
Now there are some standard defaults out there and there's a couple sort of like project

25:40.680 --> 25:45.680
templates, you know, you can use to set it up and just sort of easily add like, oh here

25:45.680 --> 25:49.240
I'm going to do a full stack one, or this is just going to be a server, or this is a

25:49.240 --> 25:53.640
node project, and they'll just lay that all out for you, but you're still going to see

25:53.640 --> 25:54.640
all the pieces.

25:54.640 --> 25:59.200
Oh yeah, so ClojureScript also targets node, which is neat.

25:59.200 --> 26:01.960
Well, I mean everything targets node now, right?

26:01.960 --> 26:05.640
I can't get up and throw a rock without hitting a node developer these days.

26:05.640 --> 26:06.640
No you cannot.

26:06.640 --> 26:07.640
That is...

26:07.640 --> 26:12.120
So that's interesting though, so theoretically, I mean this is probably a terrible comparison,

26:12.120 --> 26:17.240
ClojureScript would be like TypeScript, you could theoretically use the node framework

26:17.240 --> 26:18.880
and just like the language of your choice?

26:18.880 --> 26:19.880
Yeah, yeah.

26:19.880 --> 26:20.880
Absolutely.

26:20.880 --> 26:24.560
So I've been working, I should actually pick it up again, I stopped working on it, but

26:24.560 --> 26:31.720
I was working on a Alexa app using the JS APIs, but using ClojureScript.

26:31.720 --> 26:34.920
Interesting, okay.

26:34.920 --> 26:38.080
Other than that, I'll later just probably go run on a Lambda running on node, and it'll

26:38.080 --> 26:39.080
just work.

26:39.080 --> 26:40.880
And there you go, and you're good.

26:40.880 --> 26:44.640
Yeah, and that's been interesting too, because I've done some Java, but I didn't have a huge

26:44.640 --> 26:48.840
Java background when I started learning Clojure, and I'd done more JavaScript.

26:48.840 --> 26:50.180
So there's a lot of libraries.

26:50.180 --> 26:54.360
One thing that is great and makes Clojure pretty easy is that there are direct Clojure

26:54.360 --> 26:58.800
libraries for things, but by and large, because the host interrupt is meant to be so good,

26:58.800 --> 27:02.560
and it is just really, it's really clear, you can just do all the host things from Clojure

27:02.560 --> 27:07.680
no problem, so you can use any either Java or JavaScript library, pull it right in and

27:07.680 --> 27:11.640
use it just like it was the host language, so you would just have this huge application

27:11.640 --> 27:15.720
base of software that's been already written for you, and you can just tie it together.

27:15.720 --> 27:17.640
So you could just pull in jars, basically.

27:17.640 --> 27:19.120
Yep, absolutely.

27:19.120 --> 27:22.360
And then you can, from the ClojureScript side, you can use NPM.

27:22.360 --> 27:24.480
Wow, okay.

27:24.480 --> 27:28.680
So that actually brings up another great question.

27:28.680 --> 27:32.800
So I'm looking at a, we've talked about it, I think, six months ago, last time you and

27:32.800 --> 27:33.800
I talked.

27:33.800 --> 27:34.800
Yeah, whenever that was.

27:34.800 --> 27:36.800
Yeah, it was like, it feels like a hundred years now.

27:36.800 --> 27:38.000
I think it might have been a hundred years.

27:38.000 --> 27:39.000
You're absolutely right.

27:39.000 --> 27:40.000
Last century.

27:40.000 --> 27:41.000
Nice to see you.

27:41.000 --> 27:44.560
Yeah, somehow the fashions come back around, so we still look great.

27:44.560 --> 27:46.080
I told you, we got to keep all our clothes.

27:46.080 --> 27:47.080
Now we sell them to hipsters.

27:47.080 --> 27:48.080
They're vintage.

27:48.080 --> 27:50.320
And these sweet mustaches we've grown.

27:50.320 --> 27:51.320
That's right.

27:51.320 --> 27:54.000
Top hats are back.

27:54.000 --> 27:59.660
How adept does one have to be at Java and kind of like the whole Java ecosystem to successfully

27:59.660 --> 28:00.660
start with Clojure?

28:00.660 --> 28:04.320
Is it a prerequisite or can you just kind of get on with it?

28:04.320 --> 28:07.560
I would say you don't really have to start with it.

28:07.560 --> 28:10.400
You're going to have to learn some things as you go along, like certainly you have to

28:10.400 --> 28:12.480
install a JVM onto your system.

28:12.480 --> 28:15.720
So that's probably the most unpleasant part.

28:15.720 --> 28:19.520
Actually recently in the past six months or so, the starting story for Clojure has gotten

28:19.520 --> 28:23.600
a lot better because before Clojure was just a jar, you know, like you just, it was a jar

28:23.600 --> 28:27.480
that you downloaded and that was the Clojure language and runtime and standard library

28:27.480 --> 28:29.160
all in that jar.

28:29.160 --> 28:34.260
So here's a command you can run where you run java-jar and you start up a REPL.

28:34.260 --> 28:39.660
So now they've done a much better job of, one, having that, they have a standalone program

28:39.660 --> 28:43.160
now that has an interface you can use and you just run it and it'll open up a REPL for

28:43.160 --> 28:44.160
you.

28:44.160 --> 28:48.160
It can also handle, instead of having to use Maven or some of the other Clojure-centric

28:48.160 --> 28:53.160
build tooling that's out there, which is all very good and very useful.

28:53.160 --> 28:55.520
This little tool can do that all for you as well.

28:55.520 --> 28:59.520
And it can pull from Git depth, so you can put in Maven coordinates or you can put in

28:59.520 --> 29:04.400
like a Git SHA or a Git tag and it'll pull all that down and handle all that for you.

29:04.400 --> 29:07.520
So that makes it really easy if you just want to like go grab a couple libraries, open a

29:07.520 --> 29:11.760
REPL and start hacking on it.

29:11.760 --> 29:19.680
That said, probably for the first, for a lot of the learning, you really don't need it

29:19.680 --> 29:20.680
that much.

29:20.680 --> 29:25.560
Especially when you do, you'll eventually pull in some Java libraries or maybe work

29:25.560 --> 29:29.160
with some of the Java base API for IO or other things.

29:29.160 --> 29:33.820
So you'll start learning some of the Java things, but if you have even a tiny understanding

29:33.820 --> 29:38.200
of object orientation, I had done way more Python than I had done Java before I started

29:38.200 --> 29:40.480
playing with Clojure and that was more than enough.

29:40.480 --> 29:43.200
It's like, okay, you get what's happening here, here's a method call.

29:43.200 --> 29:44.200
Here's why that works.

29:44.200 --> 29:46.560
Here's what the factory is.

29:46.560 --> 29:47.560
That's all you need.

29:47.560 --> 29:51.760
You don't need to get into any of the complicated, more obscure parts of Java unless you want

29:51.760 --> 29:52.760
to.

29:52.760 --> 29:53.760
Okay.

29:53.760 --> 29:57.280
So yeah, that makes a ton of sense.

29:57.280 --> 29:59.840
So you're still in love with it?

29:59.840 --> 30:03.720
Still everything, any gripes?

30:03.720 --> 30:08.080
Gripes, not a ton.

30:08.080 --> 30:11.960
They've been making progress in a lot of the areas people commonly gripe about.

30:11.960 --> 30:16.760
So one thing that's been hard over the years is error messages because it's a hosted language

30:16.760 --> 30:20.480
and it tries to not hide that it's a hosted language.

30:20.480 --> 30:24.600
So you end up oftentimes with like really long stack traces that go through your code

30:24.600 --> 30:28.760
and then into the Clojure library code and then into JVM code and just this big stack

30:28.760 --> 30:29.760
trace.

30:29.760 --> 30:32.440
And if you're not used to Java or stack traces, that could be hard to read.

30:32.440 --> 30:37.680
Now, I think if you're good at scientific debugging and you already are the sort of

30:37.680 --> 30:41.880
developer who, you know, there's one style where you kind of like have, it's like you're

30:41.880 --> 30:46.900
bowling with guards on the lanes where you're sort of bouncing off the compiler and bouncing

30:46.900 --> 30:48.480
off just running into things.

30:48.480 --> 30:52.220
But if you already have a really good understanding of what you're doing as you're writing your

30:52.220 --> 30:55.240
program and know just like, you know, you have small commits where you know what you

30:55.240 --> 30:57.080
changed and in what areas.

30:57.080 --> 30:59.800
I've never found it to be that big of a deal.

30:59.800 --> 31:04.480
That said, they are putting in a lot of work in that area and it's rapidly getting better.

31:04.480 --> 31:09.220
So I'm hoping to see that improve for people that it really upsets.

31:09.220 --> 31:13.480
So basically, I would completely fail immediately because, you know, my commits, I need at least

31:13.480 --> 31:15.480
10 files, a couple thousand lines.

31:15.480 --> 31:19.760
Well, I mean, as long as you're aware of what you're changing.

31:19.760 --> 31:21.800
Yeah, I'm joking.

31:21.800 --> 31:24.640
Oh man, you're triggering me here.

31:24.640 --> 31:28.120
There's been so many people I've worked with over the years that are just like, either

31:28.120 --> 31:31.920
they didn't get git or they just hated the idea of it because they refused to use it

31:31.920 --> 31:34.040
in any same way.

31:34.040 --> 31:36.400
Here's our Code Reader Tip of the Week.

31:36.400 --> 31:38.520
Don't ever type a git commit tachy.

31:38.520 --> 31:40.160
Just don't do it.

31:40.160 --> 31:41.160
It's bad.

31:41.160 --> 31:42.480
You're going to regret it.

31:42.480 --> 31:45.000
You're probably going to have a rough code review.

31:45.000 --> 31:48.960
Yeah, you have the staging area for a reason, like you should probably use it.

31:48.960 --> 31:56.760
You should like use it and it's unlikely you change six files and only did one thing.

31:56.760 --> 32:02.760
So I will say Clojure is worth learning if people are interested in a lot of the sort

32:02.760 --> 32:06.320
of non, if you take out the statically typed world of functional programming, if you're

32:06.320 --> 32:12.800
just interested in like a data-oriented functional thing, to compare it to like Go or C or some

32:12.800 --> 32:17.060
of the more low-level languages, there's some aspects of programming.

32:17.060 --> 32:21.220
Maybe you're implementing TCP or some other network protocol.

32:21.220 --> 32:22.220
It feels like a state machine.

32:22.220 --> 32:26.840
It feels like a little mechanical thing that you're cranking on the side or the CPU is

32:26.840 --> 32:30.280
cranking it and it goes and you're processing low-level bits.

32:30.280 --> 32:31.480
You're accessing memory.

32:31.480 --> 32:34.060
You're sending little bits of data here and there.

32:34.060 --> 32:37.640
And then there's like the bigger systems, not necessarily even bigger, but there's the

32:37.640 --> 32:41.940
higher level, the more like up towards the human scale of things that are information

32:41.940 --> 32:46.920
processing systems that are really dealing with data, rich data, complex data.

32:46.920 --> 32:50.480
That's the side of things that I'd say Clojure really excels at.

32:50.480 --> 32:52.720
You might still reach down to the host language.

32:52.720 --> 32:55.760
You know, there's a lot of libraries out there that have part of them implemented in Java

32:55.760 --> 32:58.720
for like the really hot, tight inner loops.

32:58.720 --> 33:01.640
And then you just use Clojure on top of that to sort of orchestrate it in a way where you

33:01.640 --> 33:06.480
don't have to have all the overhead of, you know, all the types of Java and all the boilerplate

33:06.480 --> 33:11.240
of Java and just the, you get a nice mutable standard library.

33:11.240 --> 33:12.240
That sounds really cool.

33:12.240 --> 33:16.320
And yeah, the ability to pull in any jar effectively seems awesome.

33:16.320 --> 33:17.320
Yeah.

33:17.320 --> 33:20.080
So you can just kind of leverage it and it's, you know, it's just going to always be more

33:20.080 --> 33:21.280
concise than Java.

33:21.280 --> 33:23.160
And so you have less code to look at.

33:23.160 --> 33:27.880
The other aspect I've really enjoyed and have been consistently surprised by is, so there's

33:27.880 --> 33:31.880
the biggest outlier for Clojure is that it's a dynamic language and it's not statically

33:31.880 --> 33:32.880
typed.

33:32.880 --> 33:33.880
Oh, I didn't know.

33:33.880 --> 33:34.880
I thought it was static.

33:34.880 --> 33:35.880
Okay.

33:35.880 --> 33:36.880
Yeah.

33:36.880 --> 33:39.400
And so that's, that's one thing that people are constantly kind of tripped up by because

33:39.400 --> 33:43.400
it's a weird part of the, if you imagine like a big grid, you know, there's sort of like

33:43.400 --> 33:49.140
dynamically typed and mutable languages like Python and Ruby.

33:49.140 --> 33:52.440
And then there's stuff that is, you know, Haskell on the other corner up here that is

33:52.440 --> 33:56.480
immutable and statically typed and Clojure is immutable and dynamically typed.

33:56.480 --> 34:00.520
And there's just not that many other languages that sit where it sits and it's its own unique

34:00.520 --> 34:01.520
experience.

34:01.520 --> 34:02.520
Yeah, that is interesting.

34:02.520 --> 34:05.520
That isn't so immutable and dynamically typed.

34:05.520 --> 34:09.160
I'm trying to think of what other languages like that.

34:09.160 --> 34:13.920
I think Elixir is pretty close to it in that respect.

34:13.920 --> 34:18.600
Maybe some other like weird Lisp or Lispy, I was thinking like, yeah, yeah, but there's

34:18.600 --> 34:19.600
not that many.

34:19.600 --> 34:24.880
And I think, well, like I have nothing against static typing or Haskell, which I find fascinating.

34:24.880 --> 34:28.440
If you can and want to use Haskell, like do it.

34:28.440 --> 34:32.800
But I think people take their experience of either like Java being too verbose, but like

34:32.800 --> 34:38.160
they'd still like the types there or Python and Ruby growing to be like a big noodly mess

34:38.160 --> 34:39.160
where you have no idea what's happening.

34:39.160 --> 34:42.560
And the Ruby is just sending messages all over the place and you have no idea and it's

34:42.560 --> 34:47.360
all happening at runtime and who the heck knows what's happening in this project anymore.

34:47.360 --> 34:48.360
Monkey patching.

34:48.360 --> 34:49.360
Yeah.

34:49.360 --> 34:50.360
Monkey patching everywhere.

34:50.360 --> 34:51.360
Yes, exactly.

34:51.360 --> 34:55.600
And it's not to say that Clojure is immune from those problems, but the combination of

34:55.600 --> 35:02.120
being really concise and the immutability means it's just not as big of a deal.

35:02.120 --> 35:05.520
You know, you can have something that would be like four or five files in Java, be probably

35:05.520 --> 35:09.640
just like one Clojure file of 100, 200, it depends on exactly what you're doing.

35:09.640 --> 35:11.220
But it's just so much more concise.

35:11.220 --> 35:13.660
You can look at the function and be like, oh, yeah, here we go.

35:13.660 --> 35:15.660
I can understand what's happening because there's less of it.

35:15.660 --> 35:18.040
It's not in three different classes.

35:18.040 --> 35:19.300
That's super cool.

35:19.300 --> 35:20.960
That is like, yeah.

35:20.960 --> 35:26.040
And the other thing, too, is it embraces both data and runtime in a way that I've not seen

35:26.040 --> 35:28.200
very many other languages.

35:28.200 --> 35:32.360
From the runtime aspect, it's almost as much as Smalltalk did, where Smalltalk has its

35:32.360 --> 35:37.120
own sort of crazy running environment.

35:37.120 --> 35:40.920
So it's not quite to that level, but you really feel you're connected to this program.

35:40.920 --> 35:45.880
So when you open up your editor, one people seem to really like is Cursive, which is built

35:45.880 --> 35:47.920
on top of IntelliJ, basically.

35:47.920 --> 35:51.800
So it's familiar to anyone using IntelliJ already, hooks up into Clojure.

35:51.800 --> 35:55.920
But you've got this running REPL connection all the time.

35:55.920 --> 35:59.360
And the way Clojure compiles is a single form at a time.

35:59.360 --> 36:03.240
So you can just evaluate any form in your editor at any time and just send it to your

36:03.240 --> 36:09.080
real system, sort of hack live against it until you've got it to a point that you like.

36:09.080 --> 36:10.080
That is really cool.

36:10.080 --> 36:16.340
Yeah, it's a sort of like jacked into the computer in a way that you don't often experience.

36:16.340 --> 36:18.880
You can see the matrix as long as it's in Clojure.

36:18.880 --> 36:22.040
Yeah, it's all S-expression, so you have to be down with that.

36:22.040 --> 36:29.080
But if you can see past that, it has ruined me a bit for other languages because it's

36:29.080 --> 36:30.080
a Lisp, right?

36:30.080 --> 36:32.240
And Lisps are strange.

36:32.240 --> 36:35.640
And their syntax is implemented in data structures.

36:35.640 --> 36:40.440
And when that really clicks and you start thinking like, you know, when I see like a

36:40.440 --> 36:45.520
let's say like a function definition in Python, you know, there's the name of the function

36:45.520 --> 36:50.120
and then opening parentheses and then a list of the arguments for the function.

36:50.120 --> 36:51.120
What is that?

36:51.120 --> 36:52.120
Well, it's nothing, right?

36:52.120 --> 36:53.120
It's just syntax.

36:53.120 --> 36:58.360
In Clojure, that would be an actual list that you hand to the compiler.

36:58.360 --> 37:01.720
That would be an actual list.

37:01.720 --> 37:06.360
So like the syntax for Clojure is Clojure data structures.

37:06.360 --> 37:13.600
Well, I think I just had a mind implosion moment.

37:13.600 --> 37:15.200
Yeah, it's crazy.

37:15.200 --> 37:19.560
So a Clojure function would not be what I think it would be, it wouldn't look like the

37:19.560 --> 37:20.560
way I think it looks, right?

37:20.560 --> 37:22.640
Yeah, it depends on what you mean.

37:22.640 --> 37:27.640
So it'll be, if you're like defining a function in Clojure, it's an opening parentheses and

37:27.640 --> 37:34.760
then the word defn, but in Clojure it's called a symbol, the symbol defn, D-E-F-N, and then

37:34.760 --> 37:39.160
a space and then the name of the function and then a space and then a vector, which

37:39.160 --> 37:44.880
is a square bracket and a list of the parameters that function accepts.

37:44.880 --> 37:50.400
But it's not just syntax because what the compiler sees is an actual list, a data structure

37:50.400 --> 37:54.680
that is a list, and then the first item of that list is a data structure that's a symbol,

37:54.680 --> 37:58.240
which is defn, and then it sees another symbol, which is the name of the function, and then

37:58.240 --> 38:02.200
it sees an actual vector with more symbols inside of it.

38:02.200 --> 38:03.200
Wow.

38:03.200 --> 38:04.200
Okay.

38:04.200 --> 38:05.200
Yeah.

38:05.200 --> 38:07.640
So the compilation's a bit different.

38:07.640 --> 38:14.120
So the first stage is reading, and reading takes the Clojure file and there's actually

38:14.120 --> 38:17.640
a, it's actually its own thing, it's called Eden Extensible Data Notation.

38:17.640 --> 38:22.560
It's like JSON, but more Lispy, S-expression based, and a little more extensible, which

38:22.560 --> 38:23.560
is nice.

38:23.560 --> 38:28.960
So it takes an Eden file, reads it so it gets a big, builds a big data structure, and then

38:28.960 --> 38:33.200
hands those data structures, one structure at a time, to the compiler, the compiler emits

38:33.200 --> 38:36.800
bytecode, ships it to the JVM, and it runs it.

38:36.800 --> 38:41.280
So basically everything all the way down is effectively Clojure data structures.

38:41.280 --> 38:42.960
Yes, exactly.

38:42.960 --> 38:47.360
And that's what makes the ability to write macros so useful, because you already have,

38:47.360 --> 38:52.360
like the whole Clojure standard library is just utility functions to work on the built-in

38:52.360 --> 38:53.360
data structures.

38:53.360 --> 38:56.840
It's all about data, so you've got all the kinds of things to handle, nested maps and

38:56.840 --> 39:01.380
complicated arrangements of vectors, and there's four comprehensions in there, and there's

39:01.380 --> 39:03.960
map and filter and reduce and all sorts of stuff.

39:03.960 --> 39:08.560
All of that can also be used in macros, because when you write a macro, the compiler sees

39:08.560 --> 39:12.800
it, takes whatever you've written inside the macro, doesn't evaluate it, and hands it as

39:12.800 --> 39:16.880
a data structure to the macro code that you write, and then you can use all of your normal

39:16.880 --> 39:21.880
tools to manipulate that, emit more code, and then the compiler compiles that instead.

39:21.880 --> 39:23.040
Okay.

39:23.040 --> 39:24.040
My mind is blown.

39:24.040 --> 39:28.360
Yeah, and that's why it's so powerful, and that's why, you know, for like C-Sharp they

39:28.360 --> 39:35.720
added async await to the compiler, and Clojure core async answers some of the same problems,

39:35.720 --> 39:37.240
and it's just a library.

39:37.240 --> 39:41.240
Now there are some limitations that make it in some cases worse to do that style, but

39:41.240 --> 39:45.120
it means the community didn't have to wait for the language designers to add that.

39:45.120 --> 39:46.120
They could do it at any time.

39:46.120 --> 39:48.320
Right, you just add your own macros and go from there.

39:48.320 --> 39:51.600
Yeah, you can grow the language, shape it as you need to, and of course you want to

39:51.600 --> 39:53.560
be, you know, you want to use that with care.

39:53.560 --> 39:57.120
It's a lot of power, but when it's appropriate, it's awesome.

39:57.120 --> 40:00.480
No, that sounds like it'd be very powerful.

40:00.480 --> 40:04.720
Yeah, once you wrap your head around that everything's a data structure, and if you're

40:04.720 --> 40:11.480
not used to, as I'm not used to, like Lispy-like languages, just for the audience, when we

40:11.480 --> 40:15.280
say Lispy-like, we mean, you know, descendant from literally Lisp.

40:15.280 --> 40:17.200
Yeah, exactly.

40:17.200 --> 40:21.200
Usually prefix notation, S-expressions, that sort of thing.

40:21.200 --> 40:26.520
Yeah, yeah, that's, I'm just looking at some of the stuff on Clojure.org here, I'm looking

40:26.520 --> 40:29.180
at some of the codes, and my head is spinning.

40:29.180 --> 40:33.680
It's like, it is very, very data centric.

40:33.680 --> 40:36.080
Yeah, yes, absolutely.

40:36.080 --> 40:40.040
Here I can send you a, I'll just post it and put it in the top of the doc, here's a recent

40:40.040 --> 40:44.840
data-driven routing library that exists out there, there we go, I'll make that a link

40:44.840 --> 40:45.840
for you.

40:45.840 --> 40:49.440
And so you can just scroll down and see some of the examples, and it is, you know, it is,

40:49.440 --> 40:51.960
it's all data structures all the way down.

40:51.960 --> 40:54.600
All right.

40:54.600 --> 40:56.000
Yeah.

40:56.000 --> 41:01.800
So, one thing that people come from, like, you know, Scala people, or people used to,

41:01.800 --> 41:06.640
even just Java's level of static typing, there's a little bit of uncertainty, so you do need

41:06.640 --> 41:11.040
a little more, and again, I think this goes back to the sort of senior programmer mentality.

41:11.040 --> 41:15.800
Certainly it's easy, maybe not easy, but it happens all the time, dynamic languages can

41:15.800 --> 41:18.680
be abused, you can make a little suit for yourself.

41:18.680 --> 41:23.560
It helps that Clojure is very function-oriented, and instead of classes, you have namespaces,

41:23.560 --> 41:27.380
and there's already sort of, it's almost like microservices in your code, you know, it encourages

41:27.380 --> 41:32.720
and stylistically is encouraged by the community to separate concerns and have very clear responsibilities

41:32.720 --> 41:35.660
and single, immutable, idempotent functions.

41:35.660 --> 41:38.220
So that helps a lot in that regard.

41:38.220 --> 41:41.400
And if you just are a more experienced programmer, have a little discipline, you know, you learn

41:41.400 --> 41:47.040
how to, you have doc strings, and you have good tests, and it all kind of just works.

41:47.040 --> 41:48.040
Works together.

41:48.040 --> 41:52.240
Yeah, I'm gonna have to take a look at this, just, you know, just for thinking in a different

41:52.240 --> 41:53.240
way, right?

41:53.240 --> 41:54.240
Yeah.

41:54.240 --> 41:57.080
Thinking about code as data structures and being more in the list.

41:57.080 --> 42:00.080
I spend most of my time working in C family languages.

42:00.080 --> 42:02.240
Yeah, you know, that's part of it, too.

42:02.240 --> 42:06.960
It's funny, I think that turns a lot of people off, and that's fair, ALGOL just won.

42:06.960 --> 42:11.160
That style of syntax seems to be mostly what we learn, and so that's what feels intuitive

42:11.160 --> 42:12.160
to us.

42:12.160 --> 42:16.880
So it's probably healthy, even if you never intend to build a real project with it, learning

42:16.880 --> 42:17.880
some kind of Lisp.

42:17.880 --> 42:22.440
Clojure is nice because it has so many libraries, it's easy to do a toy project that's actually

42:22.440 --> 42:26.440
useful as compared to maybe something like Racket, which is a little more academic.

42:26.440 --> 42:28.280
But go learn some weird stuff, right?

42:28.280 --> 42:34.400
It's nice to learn an ML family language, Prologues, interesting Erlang, Lisp, like there's

42:34.400 --> 42:35.760
all kinds of crazy languages.

42:35.760 --> 42:41.940
Forth is a cool, you know, concatenative stack-based languages are neat.

42:41.940 --> 42:42.940
People still learn Haskell?

42:42.940 --> 42:48.520
I remember that used to be like the hot non-C family, although this is definitely more foreign

42:48.520 --> 42:49.520
than Haskell.

42:49.520 --> 42:50.520
Yeah.

42:50.520 --> 42:52.040
I mean, yes and no.

42:52.040 --> 42:54.800
It's definitely more foreign on the surface, I would say.

42:54.800 --> 43:00.200
Haskell has a lot of deepness to it because it is like just a rich playground for implementing

43:00.200 --> 43:03.440
all sorts of ideas from type theory, which is cool, which is neat, like they do a lot

43:03.440 --> 43:06.760
of cool stuff.

43:06.760 --> 43:09.360
One thing I love about Clojure is it just tries to be simple.

43:09.360 --> 43:10.360
I'm like simple.

43:10.360 --> 43:15.080
There's one of the classic talks in the community is simple, not easy.

43:15.080 --> 43:19.880
And to prefer simplicity, ease is great, it's not that ease is bad, but simplicity is what

43:19.880 --> 43:23.920
helps scale and simplicity is what helps come back and review code and understand what's

43:23.920 --> 43:24.920
happening.

43:24.920 --> 43:30.440
So once you, there is a big gap of familiarity, but if you can get across that, like I don't

43:30.440 --> 43:33.720
know if you've followed any of the drama from like the Scala side of things, just all the

43:33.720 --> 43:38.040
incompatibilities between Scala versions and having to build multiple times and configure

43:38.040 --> 43:42.080
SPT to emit for different Scala versions and all of that, it just doesn't happen in

43:42.080 --> 43:43.080
Clojure.

43:43.080 --> 43:47.100
There's been like one or two breaking changes over the entirety of its 10-year record.

43:47.100 --> 43:48.100
That's pretty good.

43:48.100 --> 43:49.100
Yeah.

43:49.100 --> 43:50.100
I mean, that's, yeah, that's, yeah.

43:50.100 --> 43:55.240
It's also, so it can be a little unsettling for people too because you see a Clojure library

43:55.240 --> 43:58.240
and part of it is because of just the stability of the language and part of it is because

43:58.240 --> 44:02.840
a lot of the libraries end up just wrapping, like a popular HTTP library wraps the Apache

44:02.840 --> 44:05.160
HTTP library from Java.

44:05.160 --> 44:09.600
So you just get these libraries that don't ever really see a 1.0 release, but it's because

44:09.600 --> 44:14.400
they were already, there's such a thin little wrapper and layer to make it slightly more

44:14.400 --> 44:17.680
palpable to a Clojure programmer that you don't have to worry about it and it doesn't

44:17.680 --> 44:19.440
need that many changes.

44:19.440 --> 44:21.960
It just works.

44:21.960 --> 44:22.960
That is super cool.

44:22.960 --> 44:23.960
Yeah.

44:23.960 --> 44:24.960
But very different.

44:24.960 --> 44:25.960
So I was turned off at first.

44:25.960 --> 44:26.960
Yeah.

44:26.960 --> 44:27.960
I was like, what is happening?

44:27.960 --> 44:33.520
Well, it's a good exercise though, for frankly, myself and the listeners break out of your

44:33.520 --> 44:40.280
C-sharp Java, God forbid JavaScript bubble and give something like Clojure a shot, right?

44:40.280 --> 44:41.280
Yeah.

44:41.280 --> 44:42.280
Just to learn.

44:42.280 --> 44:43.320
Taste something strange.

44:43.320 --> 44:47.200
So where can folks find you and learn more about this crazy data structure love?

44:47.200 --> 44:48.200
Oh yeah.

44:48.200 --> 44:52.160
You can find me over at Westpane on Twitter or check out some of the other JB shows I

44:52.160 --> 44:53.840
sometimes appear on.

44:53.840 --> 44:54.960
Check out TechSnap this week.

44:54.960 --> 44:56.500
It's been tons of fun.

44:56.500 --> 44:59.260
We had special guest Martin Wimpress on.

44:59.260 --> 45:01.600
So we had, we just had a riotous time.

45:01.600 --> 45:03.120
One of the wimpy.

45:03.120 --> 45:04.120
Yeah, exactly.

45:04.120 --> 45:05.120
Exactly.

45:05.120 --> 45:06.400
Friend of the network.

45:06.400 --> 45:07.400
What about you, Mike?

45:07.400 --> 45:11.520
Where can they get more of you besides this here coder radio, a coder.show, right?

45:11.520 --> 45:13.540
HTTP colon slash slash coder.show.

45:13.540 --> 45:14.540
That's right.

45:14.540 --> 45:18.800
You can find me at Dumanuco on Twitter and yeah, check out the calendar for the recording

45:18.800 --> 45:19.800
schedule.

45:19.800 --> 45:20.800
It's going to be weird for a few weeks.

45:20.800 --> 45:21.800
Yeah.

45:21.800 --> 45:22.800
But don't worry.

45:22.800 --> 45:25.000
Nothing can stop Coder Radio.

45:25.000 --> 45:44.880
And that with Clojure.


This is Koda Radio, episode 366, recorded on July 8th, 2019.
Hello, and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business of software development and related technologies.
My name is Wes, and I'm glad to be joined the explorer on the functional final frontier, Mr. Michael Dominick. Hey, Mike.
Hello, Wes. We are all functioning on this very special episode of Koda Radio.
Yeah, that's right. So to be out in the open about it, this is a pre-recorded episode. We're both away, but we didn't want to leave you high and dry with no Koda Radio to listen to. Of course not.
So we thought now's a good time. Mike brought this topic up. It's obviously something near and dear to my heart.
We talk about functional programming all the darn time. Maybe we could actually take some time, talk basics and maybe a little bit about, you know, using it in the gosh darn real world.
What do you think, Mike? I love it. OK, well, before we dive into that rather heady topic, I thought, you know, this is Koda Radio.
We haven't talked about WebAssembly in what feels like months, and I noticed a little story. I'm curious to see what you think about it.
Some people over at Fluence have been working on a port of Redis to WebAssembly.
Yeah, so I guess it's true. Everything that we can put in WebAssembly, we're going to. Kidding aside, actually, this is pretty neat because now you can run Redis basically anywhere WebAssembly runs.
Which, depending on when you're listening to the show, might in fact be everywhere. I think this is cool.
I think more things like Redis, the foundational things that you use to build other solutions that can be ported to WebAssembly as an option, not maybe as a mandatory thing just yet.
I think that's going to frankly just open up a lot of opportunities for people. How about you?
Yeah, right. I mean, if you're already familiar with the Redis, you can use it and you're able to just sort of port some of that know-how and methodology and use it in the browser.
Or as a, you know, on some random thing that's had a WebAssembly environment ported to it. That is pretty handy.
And I think Redis is kind of a good mix. You know, it's not crazy complicated, single threaded, but also super useful. It's a nice abstraction. Many people use it.
And if you go take a look at the article, which I encourage you guys to do, it's a good breakdown of sort of like where this tech is at and some of the problems you might run into and why it's not, you know, it's not necessarily the perfect solution or something you might even want to use.
But it's a nice way to see how this stuff is all evolving because it takes a lot to get something actually running as a complicated existing application actually running in WebAssembly.
Do you use much Redis yourself, Mr. Dominic, since we're talking about the subject?
You can use it quite a bit in Rails and I have. I mean, ironically, I would probably not use it in WebAssembly, but yeah, I've used it along in conjunction with Rails projects.
Well, I imagine this trend will continue. We'll keep seeing more and more things ported to WebAssembly. Have you had a chance to play with it anymore?
You know, honestly, I have not. I take it back, actually. When I did the what is it? Oh, my God. I'm at the Realm ML language you had me do.
Oh, ReasonML, yeah.
ReasonML. That had a WebAssembly capability. And I did play with that some.
That's an interesting point too, right? We're seeing more as as newer languages develop. I imagine WebAssembly might just be a runtime they're already thinking about.
It's going to be the one true runtime, I bet.
I would like to play a little bit more on the back end with, you know, just running it sort of on the command line and away from a browser.
I've only ever played with it in a browser so far and not enough to do anything useful, I'm afraid. Definitely something we're going to continue to watch.
Now, Mike, you came to me with the topic for today's show and you had an interesting idea for the approach. And I'm kind of just curious, as we get started, where are you on your journey of exploring functional programming?
So I'm basically a convert. I've been exploring it for a while. I've been more and more bought into it. You know, in fact, I'm writing a post. I've been writing it for weeks. I haven't finished it.
Titled F sharp is your functional gateway drug. And I'll be damned if it isn't. It's been pretty it's been pretty interesting.
I think we're going to dive into this a lot. But the thing that really drew me to FP was solving, I'm going to use a technical term here, the gobbly gook spaghetti code problem that you tend to get with traditional patterns.
Absolutely.
gobbly gook, you can you can look that up or call someone from MIT that will explain it to you. And I have to say I am more and more and I mean, I've looked at this for a long time, but I am now basically trying to be functional first, which is which is a big change.
Ah, so looking at that as as the paradigm that you try to express a problem in, rather than defaulting to using an object oriented approach.
Exactly. So where I can find a functional pattern that works where I can do something with either no state or at least immutable state. That is what I'm doing first. No, that's not to say I'm not still using much. Oh, right. Of course I am. I read a lot of Ruby, a lot of rails. But I really am like I'm trying to not have like magical singleton classes that have a bunch of state and do a lot of stuff.
Right. That is a good that's a good clarification. And you know, that's another thing I think we should talk about is, it's all well and good, right? I've assigned you to use closure for a week or two. And you've been playing with f sharp. There's lots of almost mainstream functional languages these days, you know, especially if you include some of the modern features.net and Java have all that means you can do functional programming, you can apply functional programming techniques or design philosophies or patterns in a lot of the languages that you use.
I imagine this means you've you've kind of had to teach if you've converted, you've had to start teaching those around you too, right?
A little bit. Yeah, I mean, some of the languages make it easier than others to kind of bring people in. So C sharp in particular, particularly version six and seven, and I think the current one is eight, but I'm mostly using seven has adopted a lot of some of the patterns from f sharp. And it's, they're optional, right? You don't you don't have to do it. You certainly can.
Other languages I think are a little harder to be kind of functional with, particularly Ruby impossible. And there's definitely like trivial things are obviously easy because they're trivial. But of course, but like, you know, just act active record, right? When I say Ruby, I really mean rails active record and just the whole thing is designed to be Oh, Swift is actually really nice.
If you try to look at it from a protocol, slash functional programming orientation. I mean, I, you know, so far, I think C sharp has actually added of the languages I use routinely added the kind of the easiest transition. But then you know what happens you're using C sharp and you're just like, Oh, but I could be an F sharp right now. That might just be me.
No, of course, once you've sort of had it had a taste of it, you, you want more.
Right now now where do these languages stack up against? Obviously, the one true language closure? I mean, I don't know if you should call it that we shouldn't forget things like like Haskell and and Idris on this on the spectrum, right? So so baby, this is actually a good conversation. Functional is not really binary, right? There are functional programming languages. There are languages that use functional programming patterns. There are languages like C sharp that can use functional programming patterns, but aren't really functional.
What would you say is like the reference implementation?
You know, I don't know if I would say there is a reference implementation, but I think it is important to talk about terminology, of course. And there are multiple approaches, you know, a lot of them are, you know, a lot of functional programmers are people that identify that way do come from some of the, you know, the static type ecosystem. And there's a lot of great things over there. You were just talking about Swift, right?
Interestingly, though, I see a number of people talking about some, especially when you're trying to apply these techniques across languages, I think there are some simpler stuff you can use to start with. And, you know, by all means, explore all the routes available and find out what works for you and your problem domain and, and how you like to model problems.
But I think you can, you know, the big ones that come to my mind is stuff like using plain immutable data, you know, rather than like you said, a lot of stateful singleton objects, stuff like that, having data and in particular having immutable data data that doesn't change out from under you, especially if you're using any sort of concurrency in your application.
With the name like functional programming, it probably also makes sense to talk about functions. Now, I don't think you necessarily have to have like, first class functions, all you probably should and not having them is kind of crazy in 2019. Thankfully, we do have them in languages like Java now, right?
So that's, so that's nice. But you should also focus on item potent functions, right? Modeling things as quote unquote, pure functions, where they're like mathematical functions and the output to what extent possible. And this is where you can get on a conversation, right?
And like Haskell or Clojure, like how far do you want to push that? Where do you call it practical and accept, you know, little bits of state where you need them? Or, you know, how functional do you really try to make things, but to the largest extent possible, kind of push state to the edges, isolate IO, make it really clear when you're doing those sorts of things and let everything else in your application be pure functions.
Yeah, I mean, I think one of the keys, right, is that anytime there's state, or, you know, mutability, it's a good sign that you're in the functional world. If you're basically forced to be very intentional about those things, right, you can't have accidental state. And maybe West, just for a second, let's just dive into some of the problems you're going to avoid.
For instance, side effects, right? You mentioned concurrency, that's a huge deal. Just thinking about asynchronous programming and concurrent programming is actually, for me, and I'm wondering what you think about this, easier, if I think about it in a functional paradigm. And frankly, the less state I have, the less concurrency hurts.
Yes, exactly. Right. I mean, you can get into situations where if you've modeled it nicely, then because it's a pure function, you know, it doesn't affect anything outside of its scope. So you can just, if you need to have it, you know, give it more data and run it on more threads. Where does that come up for you? I mean, are these multi threaded web applications that you're running or separate rails processes?
So a lot of what I do is actually I spin up microservices for some of these monolithic rails apps that do like heavy data processing. Yeah. Okay, little helper services. And those I really do try to keep them in F sharp and basically truly functional. I have one alive right now in Rust that's doing some interesting STL stuff.
Granted, some of this is by virtue of it is a mic, it's literally running on not lambda, Azure functions. Ah, yeah, sure. Data in data out, right, there's no state get a CL file in, you get the, we do a bunch of stuff to it, the result out. That has one that helps me, if you know hosting rails apps, you do want to avoid your process getting too big and taking too much memory and having issues.
Oh, man, why is that such a problem? I just nearly every rails app that I've had to support over the years, at one point or another gets into that state. Yeah, yeah, there are some. Well, you know, it's like gnome, right? It's like the gnome desktop, if there were some decisions made long ago, that leave it open to this problem. Part of it is rails is doing a lot of magic for you. And that just takes memory.
You know, so this is an interesting example, maybe you can help me, I've been doing a little bit of Ruby, I've just, I've had some tools that I've been using that are Ruby libraries or work well in the Ruby ecosystem. And I'm familiar enough with it, you know, it's not my best language or anything, but I know how to get stuff done. So it's been an interesting experiment to just try to do so in a functional manner where possible. But I do like I do find myself running off and running into things that I think, you know, I wish this API was modeled differently. So one of those examples was, I
m using the mechanize gem. Okay, yeah, yeah. You know, which is an, it is a stateful thing, you get this like stateful web browsing agent that you can go, you know, crawl and interface and submit forms and walk around web pages. And honestly, it makes it really easy. Like there's, you know, if you just need to go automate something that doesn't have an API, it's a pretty helpful tool. There's similar libraries for other environments. But you get this like, crazy, weird object. And anytime you have to do deal with serialization, or
discover ability. Now, in static languages, it can be a lot better. You know, you at least get some nice IntelliSense sort of stuff to try to help you. And, you know, maybe if I had Ruby mine open, it would do that, too. It's just, all these different objects have different APIs. And most of what I wanted out of it was data, right? Like, I'm just trying to get like values out of these form fields. Why are you giving me this object? I just want, I just want a hash map.
I mean, what you've just hit is, is the fundamental criticism of Ruby. And usually people mean Rails. But are you doing, is this actually a Rails project? Or is this something separate?
There is some Rails, but most of these are a little smaller things on the side.
Yeah, I mean, Ruby, I like Ruby, I'm not gonna dunk on Ruby, I have large systems written.
And there's plenty of stuff, you know, like, like the blocks and map and like, there's all the primitives are there.
Well, it has, so this is a thing more, yeah, so newer versions of the language, it's actually a great contrast to C sharp. They do have it, right? Like, you can, you can do the map reduce thing, which I think, I think you're going to talk about in a little bit, it's like one of the core functional techniques, right? In Ruby, the problem is every gem, which, for those who don't know, gems are basically Ruby libraries that you pull in, is probably written to be stateful and oh, so it's gonna kick and scream every step of the way, just like what you're saying, when you're
in a database where you just want a hash, right? You would just like a hash, or what I would call it the hash dictionary, whatever, of that data.
Yeah, you know, a key value store with other simple plain data underneath it.
By the way, calling hashes dictionaries is an Objective C thing, just to run out of that there. As I'm sure you know, now.
Oh, you. I do. I have recently learned, you know, it's not a bad, it's not a bad term.
It's not a bad term. It's a fair term for it. But the problem is, yeah, you're right. I mean, personally, this is one of the more annoying things about the Ruby ecosystem to me is, oftentimes, instead of just being able to get a hash of whatever it is, like you're using this, this mechanized gem, you have to learn the API for that specific library, which it's, you know, there's a cognitive load there, a more functional first kind of environment. That wouldn't be the case, right?
Right. Yeah. And as you're surely discovering with Clojure, that very much has a data driven sort of thing, you know, where instead of faithfully calling methods on an object to configure some library, you pass it some nested data structure that acts as the configuration for it.
I'm curious, what type of small Ruby apps are you actually writing? Like, are they web or are they like command line?
A little bit of both.
Okay, well, mechanized is obviously web, but okay.
Yeah, a little bit, a little bit from column A.
And how are you finding it when you try to apply a functional technique? Is it, or do you have you just given up on that?
I mean, I don't know that it would work super well, if I had to interrupt with a lot of like, regular Ruby developers, they're probably like, why are you doing it this way? But I think for the most part, I mean, I just, you know, I try to, and I have some examples we could talk about, I just try to push my interactions with the, you know, object oriented or imperative stuff kind of to the edges. And I have a big bank of, you know, peer functions to call on and then probably some, you know, some main thing somewhere that's going to go do some IO or like call into the mechanized stuff to get the data out of it. And then from there, I can process the data in a secure way.
So I can just have a series of of maps and reduces and filters or, you know, whatever, maybe some loops just because it's easy in Ruby.
Yeah, well, and then Yeah, and you can also iterate over Ruby collections, right?
Yes. Yeah. And so Ruby has lots of nice little primitives. And I find there's a slightly, I don't know, neither, I don't really love either of it in Python or Ruby, you know, trying to, to fudge it in like this. But I find, I find myself frustrated less than Ruby, I think.
Even though there's this, you know, Rails led reputation for magic, like, every time in Python, when I try to like, like append to a list, or an array or whatever, and mutates it, I just I always get so confused. And in Ruby, I find myself I don't know, it just feels a little more intuitive for the way that I want to work. And it's a little more like working with like, proper immutable stuff.
I could see that.
So it's not it's not been too bad. I think mostly, it's just that like, the culture isn't there.
Oh, no, the Yeah, the culture. I mean, it's a, again, the biggest library is Rails.
So I thought maybe we could talk a little bit, I have a resource that I think it's a great talk that I recently found. It was from a Clojure conference, but I think it's totally applicable to people just trying to program or explore programming in more functional ways. And that is a talk called solving problems, the Clojure way by Rafal Dittwald. I have just three clips here, I thought we could go through. And the first one kind of talks a little bit about, you know, like, we do we do live in an object oriented
world, and we just kind of accept that.
And the OOP approach has worked quite well. I mean, the industry basically, like, if you think about it, the industry has been dominated by object oriented programming, to the point where, you know, JavaScript added this way of doing things. But it's not without its detractors. And it's not without its problems. I'm not going to go into in depth what you know, the problems with object
oriented programming are, other than to just say that, you know, functional programming does have a completely different set of answers to a similar problem. So when, you know, with object oriented programming, they said, let's organize state, use objects and think of programs as interacting agents.
Functional programming, instead, agrees state is confusing, but says, let's avoid it. Let's just say state is bad. And when I say state, I mean, any values that change in place. So if you have an array, and you want to increment it in an imperative programming language, you just increment that array.
And in functional programming, we'd say, you know what, no, that's bad. Because then when these arrays are being passed to some function, and that function changes it, and we didn't expect that, things go wrong. Like, basically, state is the root of all problems. So let's try to avoid it.
Now, compared to, you know, classical imperative programming, and functional programming languages also gave us a new tool. And that was the function. And that's to distinguish and we use the word function to really distinguish from the idea of a procedure.
And the main difference between a function and procedure is that a procedure, you know, you can declare, you have to give it a name. And you can still pass procedures around, maybe by name, you can pass the names of procedures around. But you can't pass a given function that you create dynamically as a value, whereas with functions, you can.
So procedures can't really be passed around by value. And you can't create them on the fly and pass them around, whereas with functions, you can. If you've worked with JavaScript, you know, anonymous functions, you know, they're everywhere. And so it's not that crazy of a concept.
But at the time, it was definitely something very different. And if you work in like a strict object oriented programming language, they don't really have, they don't have these functions that you can just pass around.
Sometimes they're also called lambdas, but they don't have them. Like Java only recently, you know, had made it possible to pass around functions on their own. And barely anyone uses that because, you know, why do you need functions? You just have methods on objects.
But in functional programming, we say, no, no, we don't need an object. You can just have a function. It can just sit on its own.
And the the model, the mental model of functional programming, isn't steps to achieve some solution, isn't interacting agents working with each other, it's really mostly thinking of a program as a pipeline of input to output.
We think of, okay, what is the data that our program is going to be receiving over time? And how do we transform that data into the outputs that we want?
I'm curious if you, if you agree, Mr. Tomlinik, because that is what I find more and more. When I can think of things as a transformation of a pipeline, it's just easy to think about now, not, not always, you know, not everything can be modeled that way.
But it kind of takes these techniques to an architectural level. Because when you look at a pipeline, you can introspect and you know, you can place logging or metrics easily between all the values and you can isolate individual pieces of the pipeline to only have to reason about a chunk of it.
Yeah, I haven't thought about that metaphor before, but I like it. Top of my head, I think it's pretty good. I tend to think of it as almost a flow. But I guess it's really kind of the same thing, right? Like a stream flow, literal streams. I worry about any of these analogies or abstractions, or kind of just like, you know, metaphor, metaphors is the right word, because don't they start to fall apart eventually?
Yeah, sure, right? I mean, most all abstractions are leaky, as they say. So there is limited value. And you should be aware. Yeah, of course, right? I mean, mostly, we're talking about higher level ways to think about the problem. And then you might end up having to do something right on the outside or sealed away in some implementation detail where, yeah, okay, like it gets, it gets a little grizzly under the hood. But you're saved from having to have to deal with that. And you're presented with a nice clean interface.
Clojure has a data structure or a nice little thing called transients. So most of the stuff you're working with is are immutable trees, basically. Transients let you turn those into mutable stuff. And in a closed context, make a bunch of changes to them in a faster way, right? Suddenly, you just got you've got the superpower, you can mutate things. And then at the end of that transaction, it's sealed all up, and you just present it with an immutable interface again. So, you know, it gives you a little escape hatch, where if you need to, you can just
get some extra speed inside some fast little function in a loop somewhere. But for everyone else, it just looks like a regular nice immutable value.
Yeah, I can't disagree with any of that.
Well, then here, let's see what you think of this.
Now, you might be thinking, well, we want to avoid state, but mutable state and side effects are inescapable. That's kind of almost the point of programming, we want our programs to do something, have some side effect, if all our program did was just make our laptop hotter, and then, and they
could, you know, contribute to the heat of death of the universe, it wouldn't really be useful. I mean, unless you're cold. But, you know, the purpose of programs is to do something, even if at the least, it's to print out a single number, if all we want to do is taking a bunch of inputs and print out a number, that's still some side effect, it's printing to the console.
But, you know, this, typically, you know, real programs have other side effects that we think about. And it's things like, you know, could be communicating to a database and changing things in a database, sending an email or triggering some other external API, making an HTTP request to another server, or writing to the file system, these are all kind of effects that a program, typically what we want a program to have on other parts of, you know, the world,
of your computer system.
So functional programming would say, okay, yes, we do want side effects. And so it's not saying let's get rid of all state, let's get rid of all kind of side effects. Functional program is saying, but let's just do our best to avoid it.
And how, how do we avoid it? So how do we avoid mutable states, so values that can change? How do we avoid actually mutating that state in our programs? And how do we avoid all these other kinds of side effects? We kind of have three, functional programming has like three techniques, three little tricks that you can use.
And those are minimizing, concentrating and deferring.
So minimizing is just trying to have less, less state, so less values that we're keeping around. Concentrating is saying, okay, well, if we have to have values, let's keep them all in one place rather than throughout the program. And deferring, well, we'll get to deferring in a moment.
Cause in a moment. And this minimize, concentrate, defer also applies to mutations. So with mutations, we're saying, okay, let's try to have as little parts of our code that actually change values in places.
So the places that change state. And if we do have to have mutations, let's keep them as much together rather than spread throughout the program. And similarly with side effects, let's try to decrease the amount of places that we do side effects.
Concentrate the places that we do side effects. And if possible, defer them either to kind of the last step in our program or to a completely separate system.
Right? If you think about like a database, you're not dealing with necessarily doing all this fancy work that the database needs to do in order to keep track of the state and do a query and whatever.
Presumably there's a whole bunch of state that is necessary from your point of view of using a database. It's just like, here's a command. You figure it out.
And databases are something we're all kind of familiar with, right? I mean, SQL is a sort of classic declarative API. Now it gets hairy, especially when you're trying to optimize, you know, complicated queries, I'll admit.
But at least on the surface, the idea is you just sort of say, like, hey, here's the shape of the thing I want. Go get it for me. And I don't I don't need to reason about how you're going to do that.
I'm wondering what you think, Mike, of the you know, some of his principles there, you know, minimize, concentrate, defer, how you use those techniques yourself.
Yeah, that's exactly what I think I think we both mean here, right? It's your functionally do one things, which one thing rather not things, plural one thing.
One thing because saying things completely cuts the knees out for me. My point there, right? With no side effects, you should minimize state. Obviously, yeah, you're you're going to hit cases where, you know, you just need to state it should be pushed off.
I like your I actually like your metaphor that since I was thinking about as was listening to that of pushing it off to the side state should only come when you actually need it.
Not everywhere. See, I think the key here is that it's viewing your entire architecture, just as data flows in to a function, it flows out, and then probably into another function.
I think I'm actually a little harder on you on one point, though, Wes, I do think functions have to be first class objects, for lack of a better word, for you to really be functional.
You're probably right there. And I'll say I certainly prefer it in a language. Now, one thing you listening out there may be thinking is some of the stuff kind of sounds like all the you know, the react hotness in the browser, and this sort of, you know, views on top of data and one way data flows reactivity, that sort of stuff.
Mike, as you explore closure, you might come across well, you know, that the closure script community, they love react. There's a popular sort of larger framework that is kind of similar to Redux, although older, called the reframe. Okay. And there's a great little example in this talk about a change reframe made that I think is a perfect example of these principles.
So I mentioned reframe, which is the kind of Redux equivalent. It's this library that helps manage state in a front end application. And there's also very interesting example in a change that happened in reframe.
So originally, in one of the first, you know, the first one or two years of reframes existence, you'd have some code like here is closure code. So you can be happy with a closure conference, you can see some closure code. And this is a code to register an event handler.
So something a state transition, something that like, you know, you click a button and you want to trigger something to happen, you'd, you'd register one of these things to handle that. And so this is a adding product to a cart.
And in this situation, when the user clicks that button and triggers this event, we want to do three things. We want to make an Ajax call to tell the server, oh, hey, this person added this product to their cart.
We might want to dispatch or trigger some other event to happen.
And we want to update our local global state object, which in this case is called DB, to indicate that that item has been added to cart.
So this seemed fine, but the reframe folks are, you know, pretty happy about functional programming. And they saw this and they thought, you know what, this, this isn't, this isn't functional enough.
This could be done better because here we have three side effects, three things that the this function is doing that is triggering side effects in the rest of our system.
Could we do better? And you might think, well, no, but you know what, the whole point of this is to have side effects. But check this out.
They eventually came up with something, a new idea. They said instead of actually calling other side effectful functions in your code, like making Ajax requests or triggering another event or updating the database.
Well, actually, in this case, updating the database, this doesn't cause a side effect. This just returns a new database.
So it's these two that are the problem, Ajax and dispatch. Let's instead write our functions so that they just return an object that says what I would like to be done.
So I would like if calling this event for an Ajax event to happen with the following information, I would like for this other event to be dispatched and I would like for the database to now look like this.
But it doesn't actually do it. This function itself doesn't do those things. It just says, here is what I want to be done. So it's just like declares.
These are the things I want to be done, whereas on the left hand side, it actually does them.
And then the reframe system, other parts of the system actually take this and do something with it.
This is another example of deferring. Instead of having a whole bunch of these events that actually have side effects and do things, we have these functions just declare what they want done.
And we have one part of the system. It's a complicated part of the system. It has to figure out how to do all these things, do all these side effects.
But at least it's all concentrated one place. And the rest of our application is pure and easy to understand and easy to test.
If I had to test this, I'd have to test, okay, is the Ajax event actually happening? So maybe I have to mock an Ajax thing or actually just do an integration test.
Whereas on this side, I just have to check if the thing that it's spitting out is the thing that I wanted.
I mean, this is usually kind of trivial, but you can imagine that there might be some complicated stuff that's going on in here.
And all you have to do is check, is it doing that complicated stuff?
And then let's hope that the person that implemented or if you implemented the thing that does the Ajax bit, it just has to figure out how to do that.
And so you can test those things completely separately. So, again, kind of another one of these example of doing things functionally.
And I just love that example because it makes me immediately think of what I was talking about with mechanize.
Like, all right, at some point, yes, there's no escaping, you know, maybe mocks, but certainly integration tests. Like if you're going to scrape a website,
there's a real website out there and you're going to have to, you know, it could change. There's no replacing actual tests for that thing.
But if I can move a lot of that stuff and just have a bunch in the middle that's using pure data that I'm manipulating,
I can stop having to deal with all this mocking stuff and I can just write easy tests.
Yeah, that's I mean, that's obviously one of the core advantages, right? I think, you know, particularly we mentioned Ruby before.
Mocking state or creating mock state is probably the better way to phrase that is a huge thing that Rails developers do that takes a lot of energy and time.
I'm not I'm not going to come out and like be against, you know, mocking frameworks.
But yeah, not not having to do that, right? Not having to create this entire infrastructure that is basically, you know, aping what real estate might look like.
It's a big deal.
Yeah, exactly. And, you know, it's easy to if you do want to say you're running some of these tests.
A topic for another show is generative testing. And if a lot of your inputs and outputs are data, well, it's really easy to do that, too,
because you can generate data in a way that might be a little easier than having to make objects and keep track of them and interact with them all over the place.
I'm curious if you you know, do you have any go to libraries? Do you have any have any tricks that you've had to do?
Something I've observed is it can sometimes be easier to teach people who are new to programming to start with some of the functional stuff because coming from an imperative language or approach, you kind of have to unlearn some things.
You have to unlearn some things. And it's not necessarily intuitive. I mean, one of the primary challenges using a lot of F sharp was that a good, very large percentage of the, you know, the dotnet libraries, the NuGet packages,
you're probably going to want to use are assuming that you're in a C sharp type of pattern environment.
Yeah. And so interestingly, you're kind of in a similar place. Clojure finds itself with with Java is, you know, having system language languages and paradigms to interact with, even though you, you know, live in your own world.
And I'm curious, do you kind of find yourself making functional wrappers or just going with bare interrupt?
You end up writing like thin functional layers. I mean, I can't now I cannot claim, you know, that I've never just in a rush having to ship just pulled something in. And, you know, that's one of that is one of the strengths and weaknesses of the particular case of F sharp is that you can always
drop back to the more OO way of life if you need to.
And I think that can be important, especially as you're, you know, you're learning and in real life scenarios, like, well, it can be super useful to have an isolated learning environment, right? Like go, go learn XML or scheme or something.
It's also, you know, nice to have escape patches and easy, easy ways to kind of fall back where you need to because sometimes you just need to finish the darn thing, even if you're really enjoying learning.
Sometimes that takes a while and you're a little slower. It all takes time. Ain't that the truth? Well, I'm gonna have a bunch of links in the show notes. So the architect of Clojure, Rich Hickey, he's a big Java developer, he's given some good talks at Java communities, and he's just a great speaker in general.
So I'm gonna have a link, multiple links to several of my favorite of his talks. In particular, I would really point everyone at the value of values. Because it doesn't have anything to do with Clojure really, for me making the shift and thinking from stateful object or even thinking of thinking of a dictionary as an object.
And instead, thinking of that as a value, you know, thinking of it more like a number or a string, and not as some mutable instance. That's huge. And it has major design decisions, but it takes a while to percolate and really enmesh with the way that you're thinking about programs.
Go watch the value of values. Do you have anything that's been helpful in your journey? Or you want to point people to Mr. Dominic?
I would really just suggest if you're working primarily in one of these more, you know, like a Java C sharp, and all of this sounds a little intimidating, one definitely take a look at the resources here in the notes.
But also, you don't have to start by just like taking the C sharp example, you don't have to start by, you know, creating a file in F sharp and trying to do an entire feature in it, right?
You can start looking at other doing some type of map reduce, or even just avoiding state and mutability as much as you can in C sharp using some of the lambda functions.
I think you'll find, I think you'll find it helps even if you're not, you know, even if Wes and I haven't convinced you that this is something you really ought to do, right?
I think there will be value there. You don't have to go all the way is what I'm saying.
Yeah, absolutely. Just adopting a few of the techniques, thinking about things, you know, modeling them as as more pure functions.
Honestly, even if you don't change anything, I think it's just useful to be aware of that because there's tons of places that little stateful habits and techniques creep in.
And if you're not careful, you'll totally miss them.
Well, you know, it's like doing a little objective C. It's just important as your development as a engineer.
Yeah, exactly. It broadened your horizons. Now, Mike, you've been hard at work doing that. So here's a reminder to everyone out there.
This was a prerecorded episode, but we will be live next week. Yes, that's right.
And Mike is going to be checking in on his journeys with Clojure. I'm looking forward to it.
And I'm sure we'll be talking a little bit more about functional programming.
Mr. Dominic, if they just can't wait, I'm sure you'll be heckling me or just yelling into the void on Twitter. What's your handle?
It's at Dimanuco.
I'm there too. I'm at Westpane. And you can find the whole network at Jupiter Broadcasting.
That's not enough. Well, head on over to Jupiter Broadcasting dot com, where you can find all the other fine Jupiter Broadcasting productions and find the calendar to find out when we're here live.
You know, we're doing more live shows these days. It's way more fun when you show up. So we'd love to see you.
That's it for this episode. See you next week.
Thank you.

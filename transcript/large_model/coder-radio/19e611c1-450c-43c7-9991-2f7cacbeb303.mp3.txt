This is Koda Radio, episode 353, for April 15th, 2019.
Hello, and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business of software development and related technologies.
My name is Wes, and I'm joined once again by our returning hero, the patron saint of Papa Wes, the one, the only, Mr. Michael Dominic.
Happy Monday, Wes, and special thanks to Chris for filling in for me last week.
You've had some other things to distract you. Most notably, you've been playing with an eGPU setup, and I've been following along on Twitter.
We'll have some links to the threads of you showing off some of the pictures.
Maybe you could tell us about what you've been doing, but before we do, maybe we need a little motivation, because not everyone's lucky enough to be in a position where having an eGPU enclosure or setup or anything like that makes sense, and people might not be familiar with just what the point is.
Yes, so there's a few things here, right? This is more of a testing it out for a customer situation.
So this is an eGPU that I have that I probably won't have for very long, but I did take advantage of the situation by testing it on actually all three operating systems, so Windows, Mac, and Linux.
Oh, running the full gamut. I like it.
Running the full gamut. Now, the question as to why you would want an eGPU, I think is pretty interesting, Wes. When you think eGPU, what pops into your head?
Mostly I think about gaming or maybe some sort of machine learning application.
So this use case is compiling some core ML stuff on the Mac. That is really interesting.
My experience with the eGPU has been radically different on all three operating systems, and I guess we should start with the one that I actually intend to use on Mac OS.
And maybe you could review a little bit, too, about just what tools are you using? What's your actual setup look like here?
Yeah, so it's the OWC enclosure. It's one of their standard ones, and we'll have a link in the show notes to it, but I think they only make two, so it's the Thunderbolt one, right?
The card is a AMD Sapphire RX 560. Yes, that's correct. I'm just looking at it right now. 560.
That card has the advantage of being relatively affordable and not being NVIDIA, meaning it's compatible on Mac OS without any Voodoo.
This configuration is also one of the configurations recommended by Apple. So this is a pretty vanilla configuration without going all Apple Store black magic.
Right, you're not doing crazy stuff, and you're not modifying Kexex or going on strange forums and downloading random firmware.
You do have to build the eGPU case, which my wife very kindly did for me.
Aww, so supportive. That's amazing.
Yes, but once we got the parts and put everything together, it's a pretty simple setup.
So you did just assembling the actual structure that holds the graphics?
Yeah, and then from there, once you have it assembled, it's basically a PCI slot. So it's pretty straightforward.
I have to say, I have very mixed feelings on eGPUs for this kind of use.
Because you get into this insane situation of your biggest concern becomes cables.
I don't know if you know this, Wes, and I imagine many of our listeners don't because I didn't.
So Thunderbolt is not Thunderbolt, and Thunderbolt 3 cables are not all made alike.
Oh, no. I mean, it could be pretty confusing between Thunderbolt and USB-C and all the different sorts of stuff that can actually be bundled on those different sorts of connections and connectors.
Yeah, so first off, USB-C cables are completely useless for this, but they are indistinguishable for Thunderbolt cables visually,
other than a little lightning bolt that most manufacturers put on the ends of the cables.
Right, we've got the same form factor from the outside, but negotiating and talking totally different protocols.
Right, then there's Thunderbolt 2 and Thunderbolt 3.
You want Thunderbolt 3, but even if you get Thunderbolt 3, there's such a thing as active and passive cables,
and you lose 50% of your bandwidth if you don't get an active cable.
I imagine the active cables are considerably more expensive?
Considerably, yeah. And the truth is most long cables you will buy are passive,
because there's this weird case where the passive cables can hit the 40 gigs per second if they're below, I think it's like half a meter.
So not only are you limited in capacity, but you also have to start thinking really about how constrained your setup is going to be.
Do you have enough room to still carry that bandwidth?
Right, so for me, my setup is two constraints. If you want a longer cable, you're automatically buying a Thunderbolt 3 active cable,
which is more expensive, and you have to be really, really careful that it's an active cable.
So that just is a bad feeling all around.
You can't just go casually in an evening, select some parts, get them there and all going. You need to put some thought into it.
Yeah, this isn't like an arbitrary Amazon.com trip and you're done.
Having said that, Amazon does of course sell all these parts.
So next you get into like, okay, what cable is right for me?
Well, if you're doing machine learning, I'm sorry, what card is right for me?
The answer is always NVIDIA, unless you're on Mac OS.
Is that just because there isn't good driver support for modern NVIDIA cards after Apple stopped really chipping them?
Yeah, I mean, there is some accidental driver support.
So like Mac, this is definitely going to be foreign to non-Mac people. Mac bakes in its graphics drivers.
So if the driver isn't there, it's just not going to work.
And there's a lot of, I mean, I would recommend you listen to, I think, ATP from a few months ago.
There was like wild speculation and lots of rumors as to why Apple no longer ships NVIDIA parts.
They used to, right? There used to be a choice between NVIDIA and AMD.
I don't know if it's worth getting into that, but the rumor is that there was a certain MacBook Pro that shipped an NVIDIA chip.
It was horribly deficient in terms of reliability.
And after that, there was no more NVIDIA chips.
But the CUDA platform is effectively the standard for machine learning right now.
So if you're doing this on Mac OS, you're automatically taking, I won't say taking a hit,
but you're trying to think, Wes, you're sub-optimal, right?
Right. I know AMD has been putting lots of work to get more compliance and be able to do more of that.
But you're already, as you're saying, you're already in a position where you're not using what you would ideally,
given an infinite choice, configure your setup to be.
Or if you were just like simply on Windows, right? It's not even an infinite choice.
It's two choices.
Yeah.
So, OK, you're on Mac, you're basically constrained to AMD and please don't write in people that yes,
you can get NVIDIA working if it is related in drivers to the old Mac Pros from 2011.
I know, but that itself is limiting you to like a subset of that line.
On Mac OS, it's actually a pretty simple process. You plug in the Thunderbolt cable.
Great. The drivers are built in. Things just automatically work.
That's awesome.
On Windows, Wes, are you familiar with this operating system, Windows 10?
Yes, I am, actually.
You've heard of it?
I don't currently have one installed or running, but I've certainly used it in other work capacities
and helped other people configure it.
Well, because it's Windows, you first, and it took me about an hour to figure this out,
need a driver for the Thunderbolt controller to get the Thunderbolt controller to...
Wait, what?
Yeah.
Like you have to go out and find this and install it yourself?
I had to download a special Intel driver.
Oh, man. It's 2019, right?
Yeah, Windows Update couldn't find it.
I mean, they've gotten a lot better, right?
I mean, we should be clear.
That's maybe why it's a little surprising is it's no longer the old Windows days of really crappy driver installations.
Most stuff, or a lot of stuff anyway, kind of just works, but clearly not everything.
You know what? They will never hit the glory that was Windows 3.
So you had to do that.
You had to go get the AMD driver.
If you're a Windows user, all of this sounds pretty kind of banal to you.
If you're not a Windows user and you're used to apps getting your way to glory, this is pretty annoying.
But it does basically work flawlessly with a few weird exceptions.
So after you've got the driver for the Thunderbolt installed, then it recognized that...
Yeah, and restart about 400 times.
And do you have to fiddle with this?
I mean, do you have to have it plugged in at the right time?
Do you plug it in before you boot or after you boot?
So all three operating systems do not like it if you unplug the eGPU.
Linux just crashes.
Come on, man. Where's my hotswap PCI?
No, no chance.
Windows basically, I won't say blue screen, but locked up.
Mac handled it about 50% of the times.
But you could definitely see there was some distress on the screen.
It would freeze up for a few minutes.
It was clearly trying to cope here.
Trying to cope and switch back to Intel, right?
And we should say the hardware on the Mac side is a Mac Mini.
And the hardware on the Windows and Linux side is a current System76 Starter Pro.
So this isn't low-end hardware we're using.
Right. You've got some decent machines here, perfectly capable of handling this.
See, the test was a little different because I did what I had to do on Mac OS and it worked and I was happy.
Windows, I naturally downloaded Steam because if you have Windows, isn't that the whole point of Windows?
I thought so, yeah. It's the gaming operating system, at least when the game that you want doesn't run on Linux.
That is where you could tell I tried one crappy cable and one good cable.
And that's kind of where you can start seeing the difference.
But Linux, I want to talk to you about a package that's very special to me.
MisaUtils.
All right, break that down.
For people who aren't Linux adventurers, what is this package and why do I need it?
Well, when Satan invented graphics drivers, he did not build them into Linux like he did into Mac OS.
So MisaUtils is basically, I mean, it's a fair to say it's like the catch-all AMD graphics driver.
I mean, I think it's wider than that. It's kind of just a lot of the open source graphics utilities, right?
I mean, it's got all kinds of stuff integrated there and it's ways that multiple different graphics drivers
or a layer that you can use to talk to different graphics chipsets.
So there is a proprietary driver you could use from AMD or I should say a special.
I think it actually may be partially open source.
You could do that, Wes. You could also host your system by running their batch script and then have it not boot.
Proprietary software is not...
In this case, it was morally bankrupt. I had to wipe and pave. So, yeah.
Wait, really? So you ran the batch script that they provided to try to get things set up and going?
It asked for permission to reboot and then never booted again.
Wow. Did you look at the script? I mean, like, what is it doing?
No, it's huge. I mean, it's a batch script with like 50 files.
Some of them were just like.debs, like running executables.
I don't think I would be off base in saying this batch script is the equivalent of running like an XE installer in Windows, right?
Like you run it, you give it admin permissions.
Right. And then it's going to do whatever it needs to in theory to set up.
And you hope you didn't just install a rootkit, right?
Yes.
So that destroyed my system.
So I decided, why don't I just try the open source drivers?
And they work excellently with the following exceptions.
There is a big, big performance difference between Linux and Mac OS here, which, if you think about it, kind of makes sense, right?
Because you're using generic open source drivers versus, you know, this is one of the Apple recommended cards.
Yeah, right, right.
They, in theory, have worked with their provider and got graphics drivers in there that are tuned,
and they don't have the same sorts of qualms or problems with shipping proprietary stuff.
I am going to use the colloquial term kernel panic here for just defining a system crash of any type,
just to make this quicker because we've been on this for too long, I think.
If any of the following happens under Linux, you are screwed.
Your system falls asleep.
Your external monitor dims.
By dims, I mean turns off for the power settings.
You accidentally or intentionally unplug the graphics driver.
You lose power to the eGPU enclosure.
All of these will cause what I'm going to colloquially call a kernel panic,
meaning you have to forcibly turn off the computer and you'll lose whatever data wasn't saved.
It does not handle, like, losing power, okay, right?
It seems reasonable enough, like, okay, I get that, yeah.
But going into suspension, causing...
That's just normal, you know? That just happens.
And then I found that out by accident because I had to, like, go downstairs from my home office
and get a glass of water and use the bathroom.
And I guess five minutes went by, right?
So...
And then probably, too, right?
Like, if you knew that, you could have put your system in a state that could recover,
but most likely you probably had some stuff open maybe not totally saved
or that you were in the middle of progress.
Do you just have to reboot the whole machine then?
You reboot the whole machine.
I mean, the workaround is pretty obvious.
You don't allow it to turn off external monitors or to hibernate.
That's not an ideal solution by any stretch.
What I would say is, you know, I'm going to do a whole write-up
and I think we're going to cover eGPUs in more detail with, like, specs and benchmarks in a few weeks.
Oh, yeah.
I am going to continue for the next couple weeks while I still have this hardware trying it out on Linux.
I'm not sure that I can really recommend this if you're, like, a desktop Linux user
because just there's so many ways where your system just locks up and you lose your unsaved work.
I just don't think the experience is good enough right now.
And I'm sad because this is the answer for you buy a laptop,
but you want to use it as a, like, workstation-class machine every once in a while
to do, like, TensorFlow or whatever.
Especially because under Linux, you don't have that weird NVIDIA bar, right?
You could use NVIDIA and CUDA.
Yeah, absolutely.
I mean, I'm hoping that, like, Ubuntu 19.04 and that generation of desktop OS fix this problem.
I'm running 18.10.
Yeah, it's an interesting question of, like, what's the right—
I imagine at some point with enough effort, there's, like, a tuning or a configuration you can get that'll work well,
as is usually the case for Linux.
The question is, how arcane is that and is it worth the cost?
Well, even under Mac and Windows, like, the eGPU support,
you are in the cutting edge of, like, guys in their basements writing on forums.
It still seems kind of crazy to me that we can do that.
You know, we can have a graphics card just totally separate, isolated outside the system,
and then plug it in and it shows up like it's on PCI.
That's crazy.
Well, I mean, just for the setup I have now, having a relatively affordable Mac Mini
and an affordable Linux laptop and just being able to share the graphics card between them at will is—
Boom. Yeah, that is huge.
That's huge, right?
And if I had, like, a Windows, you know, partition, it could also be shared there.
I mean, that's not nothing, right?
Because the graphics card is the thing that goes out of date on your computer the quickest.
You know, and realistically, if you are just willing to make on the Linux side—
Oh, I should add that that problem exists under Windows too.
Wait, really?
Yeah, if it goes into suspension, it may lock up.
It didn't do it every time where it does under Ubuntu.
And I should be fair, for the purposes of this, it's pop OS, not Ubuntu,
but I would highly doubt that Ubuntu doesn't behave the same way
because, you know, pop is basically Ubuntu right now.
Mac somehow handles it, and I have a sick feeling it's because Apple has some weird drivers they wrote.
Right, this is like their advantage on, like, they write their own drivers.
Yeah, yeah, I mean, there's a lot of advantages when you can control the whole thing
and you can think of the product as a whole, right?
Right, but having said all that, I mean, if you are willing to just never let your computer go to sleep
or, like, turn off a monitor, which there is such a thing as screen burn, so I don't know,
or, like, turn it off correctly, like, shut it down, it works.
Like, if you're not, like, one of these, I have to have, you know, X months of uptime guys,
this totally works, and I think in, like, six months this is going to be the way most people should do things.
I am not a huge gamer, so I imagine there is some big tax on gaming performance,
but if you just, like, occasionally need to, like, compile a core ML library or a TensorFlow library,
wow, this is a very cost-effective and convenient way to do that.
So take it for what it's worth.
I love it. That is a good summary, and I appreciate, you know, we've talked to some other people on the network
about playing with eGPUs. I know Chris has had his adventures as well, but as you said,
it really is sort of the forefront, so it's fun to have an experience report
from someone with totally different motivations.
Speaking of illicit motivations, can you tell me about stepping away from the Rails project, Wes?
I thought you were a core member at this point.
Oh, no, you know me and Ruby. Actually, who you're thinking of is Sean Griffin, Mike.
I always get you guys confused. I'm sorry.
I know. That'll happen. Yeah.
So it's been more than six years since his first commit to Ruby on Rails,
and I think this article came by way of the Coder Radio subreddit,
where we find many interesting topics and feedback items.
So you can go to coderradio.reddit.com, or even easier, just go to coder.show.com if you want to get in touch with us.
Back to Sean. Really, this stood out to me, one, just because, I mean, it's interesting to follow the stories of developers,
particularly who end up working on open source projects and have been paid by companies to do so.
What also, so we start with that, and then also sort of just the Rails topic that's perennial on this show.
But where he's going is interesting, too, and I think really speaks to you, Mike,
because you've been playing with both Ruby and, I mean, we all know this is coming, Rust.
So if you weren't familiar, he's actually been, he's been playing around in Rust for a while.
He created Diesel, which is a really interesting ORM for Rust.
Yes, that is exactly what Rust needs. Let us bring the inefficiencies of ORMs to Rust.
We will pollute them, oh, with my life.
Oh, Mike, yeah, there's no taking that off the record. I think that's indelibly printed on the airwaves.
I'm very curious if anyone's listening. First of all, I think this makes a ton of sense.
Rails, one of the reasons I recommend it is it's super mature.
But if you are a hardcore open source contributor, one of the reasons it might be, you know,
just a touch boring for you is it's super mature, right? Like, what angle?
I mean, everything you said was true, Wes.
Can't you, like, make a mistake every once in a while to make my life easier?
I'll try. I mean, don't worry, there'll be plenty of opportunities for that.
So let me put my tinfoil hat on. Like, Sean Griffin, great developer.
I don't know him at all personally, but I literally use this code, so yay.
I've noticed kind of a lot over the last year or two of, like, core Rails contributors going to things like Elixir.
And I don't want to get you excited, but, like, Haskell Enclosure.
And now Rust. Is there, like, some sort of, like, are you, like, John the Baptist for, you know, all these functional languages?
Or am I just seeing something that doesn't exist?
I think the biggest one is actually Elixir, right? Or I guess I should say Phoenix because that's the framework.
Well, I mean, maybe some of this could be explained, too.
I mean, you had a tweet out earlier this week talking about some of the fun you've been having with Rust.
And you're using it in combination with Ruby.
I think it just shows that there's areas that Ruby just doesn't always make sense for.
Yeah.
But it does have a particular style, a community style.
So I think when people leave it, there's going to be certain languages that appeal to them more.
And it's probably not going to be Java.
Java. What year is it?
Yeah, I know. But, I mean, it's just, you know, it's still the favorite out there.
I will say, like, I almost feel like, and I know we're going to get hate mail because this is definitely a technically incorrect statement.
I almost feel like Ruby is a complete language and Rails is a complete framework at this point.
Yes. Yeah. I mean, I think you're right about that.
There's not a lot missing.
There might be reasons that it's not a good fit for your particular project, but it's certainly possible to do just about anything.
Right. I mean, there are some interesting stuff regarding performance going around.
And if you're, like, a real language nerd, you could be more interested in that than I am.
But, like, the truth is Ruby is slow.
It's going to be slow compared to, I don't know, Rust.
But FFI, baby. FFI.
Just FFI your way to glory and you're good.
As a Clojure guy, do you think maybe Mr. Sean should be looking at Clojure?
It really depends on the problem space.
I feel like part of the attraction, and maybe I'm wrong about this, but part of the attraction for people exploring Rust,
particularly coming from something like Python or Ruby, is, you know, it's just at such a different language level, right?
Suddenly the garbage collector is gone.
You've got more explicit ways to manage memory and you have much tighter runtime performance, or at least you can.
You have a lot more control over that stuff.
But I think the difference, and obviously Sean's helping as he's now involved with a lot of crates.io stuff,
is that Rust has a really supportive community, right?
I don't know that if you started doing this in C or C++ would you have nearly the same amount of stuff.
And Rust feels like, and we've talked about this on the show in some recent episodes,
it's kind of at a weird little level, maybe slightly higher level than that,
where of course you can target a lot of that stuff that really needs tight, totally compiled embedded code,
but it also has a lot of modern features and flexibility.
So you can write stuff that handles data in a rich, abstracted way that you might be more familiar from Ruby.
I mean, it's going to be totally different, but it's not going to be the same as doing that in C.
There's so many things you just said that on the Rust subreddit would be bad.
So I definitely agree with you that the Rust community is hyper welcoming.
Like, you know, our friend L, right?
L from Linux Academy is kind of big on it's okay to be new.
I would almost encourage you developers to gently reach out to the Rust community
because one, they know their language is kind of weird.
And I can't speak for the entire Objective-C community because I haven't talked to Rick and Susan yet.
But as 33% of the current Objective-C community, I can tell you, we will yell at you.
Right?
You know, we're just going to yell at you if you start talking to us about like, you know, I might cry.
I don't want to get into that.
But Rust is like, yeah, we know this is weird. Don't worry.
Now, I'm a little confused as to why you would want an object relational mapper in Rust,
but I guess you could do web development.
Like, it's totally not the way I see Rust in my kind of tool chest.
But certainly, like, I think the audience of the show, I think people who would pay for Linux Academy,
if you are looking to get involved in like an open source community, but you don't want to get yelled at,
Rust is a nice place to go.
I mean, there are many commuters, so I don't mean to like paint.
Like, you know what, the Ruby community, I will give them this in the Rails community,
have always been hyper inclusive and hyper nice, most of the time.
But, you know, there are some communities that aren't like that, right?
And I think you and I have both seen just being around and on the Internet that like the Rust people are very,
what's the right word?
Not forgiving, but very, like if you mess something up and like if you send a pull request that's wrong,
instead of just saying, rejected, you suck, they will actually like help you fix it.
Yeah, it does seem like they're, because as you said, they know they're coming, you know, they've built something new here.
There's not, you know, Rust is combining lots of different stuff into something that feels like its own thing.
It feels like the whole community gets that you need to have some support here.
It's not like, OK, well, you know, I've already done Java, now I'm learning Kotlin.
You should be able to figure that out. They've got great documentation.
Rust, it's a little bit different of a model, which is probably why it's so interesting, too, right?
Because the more languages you learn, there's differences.
Sure, they're all turning complete. Sure, you can do all the same tasks, at least almost all the time.
But I really think, and this is a perfect segue to an article I really wanted to talk about today,
over on Thorsten Ball's blog, and the title is Learn More Programming Languages, Even If You Won't Use Them.
And I just really, this sentiment really resonates with me because, like, Rust is a good example.
You just learn, you just start thinking about stuff in different ways.
And we already know this from human language, right?
There's all kinds of research showing the languages we speak and learn shape the way not only that we communicate,
but the way that we think about things.
Yeah, that's very true. I mean, I can swear at people who don't like Objective C in three languages.
Yeah, right. And I feel like you start thinking about things differently.
One thing I notice a lot about people coming over maybe learning Clojure or other functional programming languages
is there's a big mental shift that you have to go through.
You don't have imperative techniques or iteration or for-loops or any of the tools that you may have grown up on
and are already familiar with.
That's right. There's no for-loop.
No for-loop. It's gone.
Suck it up.
Sure, there might be a for-macro, but that's different, all right?
At first, it might be painful.
You know, you're thinking, how do I wrap my head around this?
It's uncomfortable. Each thing is more work than it feels like it needs to be.
Why am I doing these arcane invocations of maps and filters and reduce?
But afterwards, even if that's not the right language, even if you learn Haskell and it just doesn't make sense
or your ops team really doesn't want to deploy it or whatever the reason that you don't think you'll actually ever really use it,
you've learned a new way to model problems.
And like, just look at Java, right, with all the stream stuff that got added.
Those tools, even if it's in slightly different ways, are still totally relevant
and might show you techniques that could be useful, even if it's not in that home language.
Yeah, I know that. I mean, there's like so much here, right?
I think it's also kind of what you're hitting on.
It's important to learn different types of languages, right?
Like if you're a C-Sharp dev, going and learning Java, while not a bad thing by any stretch,
is not the same as like, maybe you should like look at F-Sharp, right,
or one of the more functional type languages.
Or if you hate yourself closure.
I mean, oh, sorry.
You're absolutely right.
I mean, probably you should learn, I don't know, it depends on how broad you want to go.
But try to sample from everything, right?
Try a stack-based language.
Play with something like Forth.
Maybe go try something like Prologue.
Definitely take an ML language for a spin like Haskell or OCaml.
And try something like Elixir, right?
There's all sorts of different little paradigms.
And regardless of how popular they might be, if you're interested in how computers work,
if you want to be a better programmer, this is no guarantee, certainly not sufficient,
but I would say it might be necessary.
I would say it's absolutely necessary.
I don't think you need to, I wouldn't hedge that one, right?
Like, so there's also like differences in hardness, right?
Like for instance, Go and Rust are often compared.
I have played with both.
I think Rust is definitely a lot harder than Go.
But it's because it's so much more different than what you expect coming from the C family.
Of course, C, C++, C, I guess C sharp, but I have a lot of issues with that.
It's the differences teach you, right?
Like just like when Wes talks about Clojure,
I start levitating because I'm being elevated onto a higher plane.
When I mentioned Objective-C, I mean, you smell the sulfur, right?
It's like ancient conjuring.
Ooh, it's strong today.
Now, what about like if you're a Ruby developer learning Python?
See to me that, I don't know, I'll let you go first on that.
Yeah, no, I mean, I do think you're right.
There's less to be gained there, not nothing.
And you might discover that you prefer that tool, but you're right.
It is important to not just learn different languages,
but learn different programming languages,
different heritages of programming languages,
so that you get those different styles of thinking and modeling about problems.
And you might just discover that you're totally charmed with it.
Like when I discovered that I really liked Clojure,
sure, I'd done some like scheme in college and played with it every now and again
and would do Python and occasionally think back to like,
oh, this kind of feels a little bit kind of functional from school that I remember.
And then I just started playing with it one day
and it's changed the way I think about all kinds of different programming.
And same thing when you discover, you know, when maybe you're learning C
and you have never done anything at that level of the stack
and suddenly you're thinking about assembly
and you're really getting to know memory
and the model of the machine that C imposes on you.
All of that stuff is worth doing.
And I guess I just get a little worried sometimes,
especially for like the world seems to think of software development
as like enterprise feature-based software development.
And that's fine. That's really important.
That's a huge motivator.
It pays all kinds of people's salaries and makes lots of products that we all use.
But I think you can't wholly separate that from computer science
and computation and thinking about that.
And if you just blindly learn one language and apply it in the same way,
you're just a practitioner.
And I think really the value our field can bring is that we're actively,
it's a creative process.
It's not the same as just like blindly applying the standard configuration to a switch.
Nothing against network engineers, they're incredible
and they have lots of stuff that isn't like that too.
But you need, we need the human side of creativity.
And for that, you need a well-rounded and educated background.
Yeah. Also, you know, your language of choice might, I don't know,
get replaced by something terrible.
Just, you know, I don't know what I could do for you here.
No, no, no one knows Swift.
Yeah. Everybody should learn Haskell because then you truly attain a godlike status.
Right. And you get to claim that you learned Haskell, right?
You can just lower that over.
And then you can change your profile pic to the old Hercules 90s TV show.
And if you get that reference, congratulations.
You should have learned Objective-C. You're old enough.
Everyone's old enough for Objective-C, Mike.
Come on. I thought that was the new hotness.
You know, one day I'm going to write a framework in Objective-C just to spite you guys.
I'm going to call it brackets.
All the brackets.
Speaking of things that are going to annoy the audience.
How do you feel?
But, you know, what is Linux?
I loved your episode last week of Linux Unplugged,
where you guys were meditating on what exactly is Linux?
What's the future of desktop Linux?
I wish I had called in because I have the answer, Wes.
It's called Windows LDAs.
You can run Bash.
You can run Ruby.
You can run Haskell.
I think Windows 10 is one of the more interesting Linux distributions I've seen in a long time.
Are you just trying to troll me, Mr. Dominic?
No.
So I have been using the Penguin.
It's spelled – I actually meant to ask them why they spell it P-E-N
instead of, you know, the way I think it should be spelled.
So it is a commercial.
It's 10 bucks on the Microsoft Store.
Basically, version of the Windows Linux subsystem, right?
That's what it is.
Right.
So the mode of the NT kernel that can emulate a whole bunch of Linux system calls,
and then you can run all kinds of software that targets Linux natively on Windows.
That's right.
And I have to say, it works.
Now, for those who don't know, maybe we should take just like a little skip back.
So there are – the Windows Linux – Windows subsystem for Linux,
which the name is hard for me to say for some reason.
WSL.
Just go with that.
So WSL has multiple flavors, right?
There is the Ubuntu SUSE I think is there, and isn't Fedora in there now too?
Yeah, I believe so.
Yeah.
So basically, they've got this support in the NT kernel now,
and then with some open source tools that Microsoft has provided,
you can package up a whole bunch of userland tools
and then build it into an executable that can run in that mode.
And then you basically get like a bash prompt just running in your Windows command line.
Yeah.
So you can basically run almost any non-Gui Linux application, right?
So for instance, you could do all your scripting, your Rails development in WSL.
Penguin is a Debian-flavored, I guess, derivative,
although I don't like the way that sounds,
but it really is like a version of Debian that these folks offer for $9.99.
It is awesome.
I have had no problems with it.
And I'm going to challenge you, and then I'm going to hand it over to you, Wes.
What is a Linux desktop?
If I have the command line, if I can run Linux binaries,
assuming the right architecture, right, so x86,
why is that not like a viable thing for...
I'm particularly thinking of our younger listeners,
and in fact, I owe someone an apology.
About a year ago, we had a listener email into the show
who is a local university student here, I think at University of Tampa or USF,
it doesn't really matter,
telling Chris and I that we should consider the WSL,
because that's what they all use in school now.
Why? Because they have proprietary Windows applications
they have to use for some of their classes,
but their CompSci classes are taught on Bash, effectively, right, the command line.
I think that's the future.
I think when you and I are in the old folks' home with Chris playing name that hair,
all the kids are going to be running some weird NT Linux kernel mishmash.
Okay, that's interesting. I do like it.
I mean, it's great that you suddenly have this whole, you know,
open source ecosystem of tooling that everyone's familiar with,
and having set up some development environments,
looking at you Python on Windows,
it's not an experience I would want to repeat,
especially compared to just, you know, apt install Python
or whatever operating system you're using.
I don't know if I see it as like totally the future.
I can see it as long as Windows remains dominant.
I think what's going to happen long term in the desktop,
not that Windows is going anywhere,
are we moving away from the desktop?
I guess I can see more of a workstation use,
but for the hybrid world of I have Windows for X reason,
having WSL that exists seems awesome
because you might need it for hardware support,
you might need it because some proprietary application
that can only run on Windows and doesn't emulate well,
it gives you access to lots of stuff.
And I guess you're right, if it's not Chromebooks,
if it's not OS X or Mac OS, excuse me,
maybe WSL is the best we can hope for.
Is that the world that we want? Maybe not.
But is it better than just being stuck on Windows
with no subsystem at all?
Well, I think we can all agree to that.
I mean, don't you think there's value particularly
for the audience of this show to say,
every once in a while you do have to run the operating system
that your end users are running,
and maybe you don't want to partition your drives
because NVME drives are stupidly small most of the time
when you get them.
If you're running Linux anyway, honestly,
maybe I'm just too ignorant of the current Linux community,
even though I run it every day.
The GUI apps I use on Linux are all like electron apps
for the most part, right?
I mean, obviously Firefox isn't and blah, blah, blah.
Right, but that's just a browser.
It's either a browser or an electron app or a terminal.
That's basically true for myself as well.
Right, when I'm working in Linux,
I'm effectively working in Bash
or some other terminal-esque environment.
Maybe we would be wise to consider,
let's get all the app compatibility of Windows
and still be able to do our work in the environment.
Oh, and by the way,
maybe I'm over-identifying just a little bit
because I do have a Windows application
that I sell and support,
so it is a huge pain in the ass
when I have to go dig out a Windows laptop.
Yes, no, that's fair.
But I don't know, with the rise of Electron,
I believe, and I know this is hot take alert,
that on the command line,
Linux is a superior environment.
I wish Mac would get their shit together,
but they just won't.
I'm going to take a little platform diversion here,
but look at like Lutris,
and I know you know what it is,
but for the audience,
the cross-platform play Windows game on Linux app
that's now in the Pop OS store.
We're jumping through all kinds of hurdles
to make that stuff work.
Are you just proposing we should just switch it up
and go the opposite route?
I'm proposing it's a two-horse race,
that none of that stuff even exists on Mac OS.
Yeah, you're right.
You don't even have that option,
where on Linux, yes, you have to jump through the hoops,
and I don't know,
why not have the Windows action show
and just talk about different versions of the WSL all day?
Why not, you know,
why don't we all get the Windows logo tattooed on our butts?
I mean, I'm just saying.
I think Mr. Martin Winpress made an interesting point
in that episode of Linux Unplugged,
and he talked ostensibly
as identifying
essential modifiability
with the Linux desktop.
Okay.
That you could recompile everything that you want,
that you have full control,
that you have large, free software
that you can play with, that you can do with,
and especially in the Windows 10 world,
right?
Like, for all the good things that Microsoft has done,
for all the improvements that exist in Windows 10,
including the subsystem,
it's also very much become like an online,
you know, intensely data-fied,
sending all sorts of metrics,
and it's licensed, right?
So it's not your software.
You may be able to run all sorts of neat, free software on it,
but it philosophically
feels like a different way of doing computing.
Now, that might not matter when all you want to do
is just run Bash,
but knowing, you know, the philosophy of the people
behind Bash,
it does feel like a little bit of a mental
conflict at times.
And I actually don't believe what I've been arguing.
I'm just trying to set up the argument, right?
There's also, like, a lot of reasons you would want to use Windows.
One, it's very old, the NT kernel.
It's probably due for
some significant rework.
Two,
I don't like any operating system
that preinstalls Candy Crush.
Like,
I know it's trivial, but it's kind of like,
it feels
cheap in a way,
which I know I'm starting to sound like Marco
Warman, so I'll stop, but
yeah, no, I mean,
having said that, though, Wes,
there are a lot of college kids, and in fact,
I'd love for our younger listeners to reach out.
Like, is this just a weird thing
that University of Tampa, the kid
who pinged me, is doing?
Or is this, like, something that other
schools are actually actively
putting forward?
I mean, it does seem like it would make sense.
Schools are already, you know, many of them
have deals with Microsoft or
other vendors that ship Windows,
and in particular,
you know, university machines often
have to be multipurpose, right? They support all
kinds of different curriculums and classes and
applications that might be needed, whether that's
some fancy, you know, Mathematica
program for the math students or
Adobe Suite for the design
students. So in that sense, I think it is, I mean,
it is very pragmatic, and one
of the strengths of the free and
open source software world is that we can do
that, right? You can take all that stuff now,
you can run it on Linux, or even before
we had this subsystem, you know, if you
learn how to use GIMP on Linux, you can
use it almost just the same
on Windows.
Where I'm curious is, I'm curious to see where Chromebooks
play as they've added more and more
Linux support. Now, I think it'll be slightly different
in that it's not quite the same,
at least currently, level of, like,
workstation, right? You can have, like, a really beast
mode Windows machine that you could also
run the subsystem on, and Chromebooks don't really target that,
but they are heavily targeting
that same education sector.
And in both of those cases,
regardless of the, you know, the
heritage, it's kind of the same
thing. You have a proprietary-ish
operating system that you run
as a black box that you can't really change,
and then you're given this little
window into the world of
free open source and
quote-unquote, Linux.
Into the world of freedom.
It sounds like you're having a pretty
good time using it, though. I'm
curious if you think, have you
spent any time playing with alternatives
to Penguin, which used to be called
wLinux. Penguin,
I guess, is a combination
of penguin, which is the Japanese
word for penguin, and then they
added w back in there because, yay,
Windows.
So it's just pronounced Penguin.
Yeah, I mean, I checked out the Ubuntu one.
It's fine.
The Penguin one, I mean,
basically, it's a Debian base,
and they do a lot of the setup for you.
They make it much easier to deal with, like, your Windows
drives. By drives, I mean
directories and directory structure.
And, you know, for 10 bucks,
the conveniences make a lot of sense
if you are
stuck on Windows, right?
Yeah, and really, I think when it was
first announced, there was a lot of skepticism, at least from
the Linux side of things, because
this is all, you know, it's all free stuff. It's
based on free stuff, like, where is this value
ad coming from? But to your point,
I think that's true, and especially if you're
already in this super pragmatic zone
of using the subsystem because you're just trying to get
work done, then, yeah, maybe
$10 isn't so much to know that
you're supporting, you know,
a business and community around this stuff so that it
can continue to grow, get better,
and you can continue to take
advantage of it. That's right, and one day
we will have a pure Linux distro
from Microsoft. Well, okay,
since you've been having so much fun with this, I got a
pick for you, Mike, that
I'd be curious to see what you think about.
It's called HTTP
Prompt, an interactive
command line HTTP client.
It's in the Python repository,
so it's just a pip install away.
Maybe you've used
stuff like HTTP.
Have you heard of that one? I have not.
What does that do? Well, it's like
a glorified curl that has
fancy colored output and has an easier
syntax to get used to.
This is like that, but even
better. It's an interactive command line,
so it's like a REPL for doing
HTTP requests, which I find
super interesting and useful,
and man, they've done a really
good job of like tab completing
and fancy curses menus that pop
up. So not only you got lots of color and
stuff, but it's super easy to modify stuff.
It also has HTTP2 support.
You can look at all the headers. You can change them
and modify a request and then resend it and
then look at what the response details
are. Now, of course, you can do lots of this stuff
like web inspectors
or just on the command line with curl or
any other tool or in your favorite
programming language, but it's not
always that ergonomic, and it seems
like HTTP Prompt has
put in a lot of work to just make it
easy. Like it has tons of cookies
support. There's open API and swagger
integration, pipelines
like Unix style and output redirection.
Like it's just it seems like an incredible tool
if you do all kinds of HTTP stuff.
Maybe you're debugging a problem with a service
or you're just designing something new.
I only just found out about it this
morning, so I played with it a bit.
I'm excited. I think it's going to remain in my tool belt.
That actually sounds really, really
cool. I like that a lot. Well, good,
because now you've got some
homework. Oh, no.
Yeah, I know, right? But that's good.
I'll be curious to see what you think of it. See if it falls
into use and curious to see how you
continue to enjoy Penguin.
Oh, no, I wiped out windows after three days. Are you kidding me?
Oh, is that right? Oh, I didn't make
I didn't make that clear. Sorry. Yeah, no.
So maybe we should just jump backwards for
a second.
It makes it less painful to run windows,
but like I think Chris
even liked the tweet. I think he's in the chat room.
He can, if he's still listening, jump in and be like, yeah,
I forgot
and it's going to make me sound so stupid. So I
can't wait for the feedback. I forgot
that like, so, OK, on
a new Linux install, I can like just
get my stuff running and
like do what it is I need to do.
Right. Yes. Just get up
from nothing. Easy, fast, not
an insane number of reboots. Right.
Basically the same on Mac, right? I mean,
let's be fair.
Windows, like there are so much
resource contention when you first install
Windows that I could not figure
out why the damn machine kept crashing on me.
Wait, like actually crashing? Yeah, like
freezing up, locking up.
And then I tweeted it and one of our
listeners, Sean, wrote back.
He's like, is that a new
install of Windows? I said, yeah, I just
installed it. Yeah, you know,
you need to like let it update several times
and like go away for
a while. Sure enough, I gave it an hour
and yeah, that's
yeah. It's amazing
how bad that is. Like there's
lots of stuff, especially like the enterprise where it's great
to administer Windows and you can tell they've
thought about administering it. But
setting it up is just such a pain. Now,
of course, you can go and use all their tools to automate
and that. But even
then, the update process is just
incredibly painful almost
every single time I have to engage with it.
Yeah, it's like
I don't understand and I would love to hear like
to people who do what I do
like independent developers
who are Windows people.
What happens when you're me and you like destroy
a laptop and you need to immediately get up and running?
Are you just hosed for
a while? Like is that
because like just to set it like everything
takes forever to install. Visual Studio
is like this is 30
gigs and you know.
Yeah, and it's hard to automate and there's
different procedures and because it's all like an
yeah, it's all gooey. It's an EXI.
Maybe this one's an MSI and you have to go fetch
it for from another source. And sure, there's
like some tools that can help automate some of those stuff
right? Bundle installers or chocolatey
or whatever you're using, but
it's never going to cover all the tools
you need. Yeah, I don't even know what to say.
I mean, maybe we're just missing something because we're not
Windows people, but
I'd be curious to hear of
our Windows listeners out there.
Coder.show slash contact. Let us know
what you love about it, why it works for
you, or maybe you've just got some pro tips from
Mike on how to have a better experience
using Windows. Well, the way I did that
was I plugged in a pop OS
and I hit reform hatch drive. Hey,
it was a lot better.
I love it. That's probably
the way to go. Problem solved.
And if maybe
you're trying to learn like a little bit more about
Linux because you've been convinced by our discussion
today or you know, Linux is just great.
Possibly you're trying to learn some developer
stuff like catching up on your Python
for instance. Oh boy.
Good news for you. Linux Academy's
yearly deal is back.
Limited time only. linuxacademy.com
$2.99
for the whole year. That's a
whopping 33% off
when you break it down. Like the monthly
price. That makes a lot of sense. If you want
to learn, you want to well, you know, a catalog
of stuff that you can go check out and use.
Now's the time to do it. It's just going to cost you more
in the future. So why not save a few
and get started learning some stuff.
Well, that's going to do it for
today's show. But if you want more, well
Coder.show and
if you want more from Jupiter Broadcasting, well
Jupiterbroadcasting.com. We've got a
shiny new, let's say new-ish
website that you could go check out.
Lots of good stuff. In particular
maybe go check out the latest Linux
Action News where Chris and
Joe break down all the stuff that's happening.
I had not had time to really dig into all
of Google's announcements about
their cloud stuff. And I didn't really have to
because they just explained it for me. So that's super
handy if you're interested in what's happening with Linux
and open source. linuxactionnews.com
slash 101
is the latest episode.
If you just don't have time for that
or maybe you want to interact more directly,
we're also both on Twitter. I'm
at Wes Payne and Mike you're at
Dumanuco and check out themadbotter.com
if you need anyone converted from
Windows to Linux. Beautiful.
Thank you all for joining us.
We'll see you right back here next week.
Bye.

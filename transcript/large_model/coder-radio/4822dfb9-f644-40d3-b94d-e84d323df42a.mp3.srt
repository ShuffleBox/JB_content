1
00:00:00,000 --> 00:00:07,000
This is Coder Radio, episode 340 for January 14th, 2019.

2
00:00:31,000 --> 00:00:34,000
Hello and welcome to Coder Radio,

3
00:00:34,000 --> 00:00:41,000
Jupiter Broadcasting's weekly talk show that's all about the art and business of software development.

4
00:00:42,000 --> 00:00:47,000
Now, Chris is off getting married and gallivanting all over the desert, but never fear.

5
00:00:47,000 --> 00:00:54,000
I'm here, that's right, I'm Wes Payne, and I'm happy, oh so happy, to be joined with Mr. Michael Dominic.

6
00:00:54,000 --> 00:01:02,000
That's right, he is the seer of sea, the sultan of software. Welcome to the show, Mike.

7
00:01:03,000 --> 00:01:05,000
Hello, Wes, good to have you today.

8
00:01:05,000 --> 00:01:08,000
You know, it is good. There's nothing like getting a week started off right.

9
00:01:10,000 --> 00:01:16,000
I didn't do any exercise recently, but I hear maybe someone in your family did.

10
00:01:16,000 --> 00:01:23,000
Yeah, in terms of exercise, my wife just ran a full marathon at Disney World.

11
00:01:23,000 --> 00:01:28,000
In fact, I have to call her Captain Marvel now. It's a rule in the house.

12
00:01:28,000 --> 00:01:33,000
You probably should have been doing that all along. That seems good for a long-term health relationship.

13
00:01:33,000 --> 00:01:39,000
Yeah, she's a beast. She got a gold Mickey Mouse medal and everything.

14
00:01:39,000 --> 00:01:46,000
Well, that seems like just about the opposite of what we're going to start off talking about today.

15
00:01:46,000 --> 00:01:53,000
And we've got a little feedback to the show. You wrote this, so I'm just going to read it and then you can explain.

16
00:01:53,000 --> 00:01:57,000
Mike and Chris are old and boring.

17
00:01:57,000 --> 00:02:00,000
Yeah, so wow. Thank you, Reddit.

18
00:02:00,000 --> 00:02:05,000
I have to say, since Chris isn't here, this makes it much better for me, Wes.

19
00:02:05,000 --> 00:02:08,000
A lot of the vitriol was directed towards him.

20
00:02:08,000 --> 00:02:13,000
Oh, not you. You're just going to scapegoat this. Well, he's not here to say anything. I haven't seen all of it.

21
00:02:13,000 --> 00:02:18,000
So apparently, Chris and I's desire to have working audio.

22
00:02:18,000 --> 00:02:25,000
Wes, I don't actually know how old you are. I think we're similar in age.

23
00:02:25,000 --> 00:02:27,000
I think you're right.

24
00:02:27,000 --> 00:02:33,000
But there was a time when I was a 2 to 7 a.m. coder.

25
00:02:33,000 --> 00:02:36,000
I was the night's watch, basically. Call me Jon Snow.

26
00:02:36,000 --> 00:02:41,000
Plenty of energy drinks. You're up. No one else is up. You've got headphones on. No lights in the room.

27
00:02:41,000 --> 00:02:42,000
You were in good shape.

28
00:02:42,000 --> 00:02:44,000
Yeah, most productive hours.

29
00:02:44,000 --> 00:02:46,000
Now I'm in bed by 9.30, 10.

30
00:02:46,000 --> 00:02:48,000
Oh.

31
00:02:48,000 --> 00:02:52,000
But I'm up at 4.35.

32
00:02:52,000 --> 00:02:54,000
And apparently this is a bad thing.

33
00:02:54,000 --> 00:03:01,000
And Chris and I have both discovered the wonders of sleeping more, drinking less and working out more.

34
00:03:01,000 --> 00:03:04,000
Oh, general healthfulness is what you're talking about here.

35
00:03:04,000 --> 00:03:13,000
Now, having said that, today's beer is a Einger out of Germany, which is from Bonn, Germany, if I'm correct.

36
00:03:13,000 --> 00:03:17,000
It's an Oktoberfest Marzan, which is kind of, if you don't know, like a light amber.

37
00:03:17,000 --> 00:03:22,000
You know, it's not quite an amber ale, but it's just on the border.

38
00:03:22,000 --> 00:03:26,000
But this is only my actually second beer of the day.

39
00:03:26,000 --> 00:03:31,000
Well, look at you showing some Monday afternoon restraint I've got over here.

40
00:03:31,000 --> 00:03:34,000
See, you went all fancy and exotic. I'm going local.

41
00:03:34,000 --> 00:03:38,000
I've got the Georgetown Brewing Bodhisattva India Pale Ale.

42
00:03:38,000 --> 00:03:42,000
You know, I've heard that's good, though. See, I can't get that down here.

43
00:03:42,000 --> 00:03:44,000
No, it's hard to find if you're not right here.

44
00:03:44,000 --> 00:03:50,000
But maybe if you can ever make your way up to the Pacific Northwest, we can buy you several pitchers full.

45
00:03:50,000 --> 00:03:56,000
First of all, one, I can definitely handle several pitchers, but those days are gone.

46
00:03:56,000 --> 00:03:58,000
You're right. I mean, you're being helpful.

47
00:03:58,000 --> 00:04:02,000
So, I mean, do you find there's some I've always I love mornings. I really do.

48
00:04:02,000 --> 00:04:06,000
I'm not great at going to bed. That's just things are too interesting, right?

49
00:04:06,000 --> 00:04:10,000
There's another there's more code to write. There's more research to do.

50
00:04:10,000 --> 00:04:13,000
But when I actually get on GitHub, there's another ticket on GitHub.

51
00:04:13,000 --> 00:04:19,000
It's just hard, even though I mean, I love being in bed and asleep or, you know, and I read a nice book before bed.

52
00:04:19,000 --> 00:04:25,000
How do you do you find that once you're on that schedule, you just are tired enough that it forces you to go to bed?

53
00:04:25,000 --> 00:04:31,000
No, in fact, I suffer greatly. It's a it's very hard for me still to go to sleep.

54
00:04:31,000 --> 00:04:35,000
But I've been reading a lot of like old like novels like John le Carre novels.

55
00:04:35,000 --> 00:04:40,000
Oh, but I'm reading them at a pace of like one or two a day.

56
00:04:40,000 --> 00:04:45,000
Yeah, OK, which is great. It is crazy. How do you find time for your work?

57
00:04:45,000 --> 00:04:48,000
That's that's rude, but I'm just going to ask you. Well, no, I can read them fast at night.

58
00:04:48,000 --> 00:04:53,000
That's the problem. Oh, OK. So you're going to burn. I try to go to bed at nine and I'm up till midnight.

59
00:04:53,000 --> 00:04:57,000
But I read and these novels aren't long, right, especially the John le Carre's.

60
00:04:57,000 --> 00:05:00,000
Kind of just little pieces, little pieces of fiction candy.

61
00:05:00,000 --> 00:05:04,000
Yeah, candy. OK, so there's some feedback that you guys are old and boring.

62
00:05:04,000 --> 00:05:09,000
And is that just based on on when you wake up? Because kind of sleeping is arbitrary, right?

63
00:05:09,000 --> 00:05:13,000
As long as you get enough of it. And otherwise, if you're lucky enough, you get to wake up.

64
00:05:13,000 --> 00:05:22,000
I think it's also based on some of our comments from last week on Chris was having some issues with his Linux setup.

65
00:05:22,000 --> 00:05:26,000
Oh, yeah. And I was the audio. Yes. Pulse audio is a nightmare.

66
00:05:26,000 --> 00:05:31,000
Oh, God. And I was on Mac that week as well. This week, I'm on pop.

67
00:05:31,000 --> 00:05:38,000
But it's got a lot of negative feedback, Wes. And I know you were a Linux hippie.

68
00:05:38,000 --> 00:05:43,000
I think you do drugs every morning. Yes, I do. You got off of a plush tux. Yes.

69
00:05:43,000 --> 00:05:48,000
Right off that grub command line. Yes.

70
00:05:48,000 --> 00:05:53,000
So we got a lot of most of the negative feedback was like, you guys suck.

71
00:05:53,000 --> 00:06:03,000
But I got to say, I'm not sure it matters what OS is used to produce a show or to compile something.

72
00:06:03,000 --> 00:06:09,000
No, I mean, there is some metal level where maybe maybe it does, but it's certainly not the most important.

73
00:06:09,000 --> 00:06:13,000
And I think if you have a pragmatic look at it, which I guess that's right on the tease of the show.

74
00:06:13,000 --> 00:06:16,000
Right. So we're supposed to maybe take that angle here.

75
00:06:16,000 --> 00:06:21,000
Pragmatic. Then we got it. You know, if you have it's either no show or a show.

76
00:06:21,000 --> 00:06:25,000
Right. So you got to start with let's have a show and then use whatever tools.

77
00:06:25,000 --> 00:06:29,000
Ideally, free open source tools would be our preference.

78
00:06:29,000 --> 00:06:35,000
But if they're not going to make the cut, what we have certain, you know, we have certain quality standards the show really wants to meet.

79
00:06:35,000 --> 00:06:40,000
Right. I mean, the other side of this was and I'm wrapping like three different points of feedback.

80
00:06:40,000 --> 00:06:47,000
Right. One line, a lot of younger devs, you know, we tend to skew young West on the code radio.

81
00:06:47,000 --> 00:06:52,000
Didn't like my comments about documentation and kind of following a process in your software development.

82
00:06:52,000 --> 00:06:56,000
Oh, you're talking you're coming out pro documentation here. Wow.

83
00:06:56,000 --> 00:07:02,000
I'm pro docs and I'm pro testing. It was not a popular opinion.

84
00:07:02,000 --> 00:07:05,000
I'm actually kind of surprised about that. I would think I don't know.

85
00:07:05,000 --> 00:07:12,000
I feel like I see some of the older set sometimes not no testing, but maybe, you know, a little more.

86
00:07:12,000 --> 00:07:15,000
They're wisen so they know what to test and whatnot.

87
00:07:15,000 --> 00:07:20,000
And then a little more sort of blind adherence to things like TDD in the younger crowd.

88
00:07:20,000 --> 00:07:24,000
So that that's kind of interesting.

89
00:07:24,000 --> 00:07:30,000
See, what I got a lot was, well, why do I have to document my code? I'm going to lose my job in two years.

90
00:07:30,000 --> 00:07:40,000
You know, and I don't again, I do not mean to denigrate any of our listeners.

91
00:07:40,000 --> 00:07:43,000
Of course, I can tell you why you need to document your code.

92
00:07:43,000 --> 00:07:47,000
If the system you're writing is important enough to the business paying you to write it,

93
00:07:47,000 --> 00:07:52,000
whether you're an employee or a contractor, eventually someone's going to need to change something.

94
00:07:52,000 --> 00:07:56,000
Right. And they need to know what the what the hell is going on.

95
00:07:56,000 --> 00:08:00,000
That's a good idea.

96
00:08:00,000 --> 00:08:05,000
But right. Yeah. I mean, especially if you have rather complicated code, lots of files.

97
00:08:05,000 --> 00:08:09,000
I'm thinking way deep down in some horrible Java object hierarchy.

98
00:08:09,000 --> 00:08:13,000
Well, the example the example from last week was Docker configurations.

99
00:08:13,000 --> 00:08:17,000
Oh, OK. And any kind of thing that was outside of the Docker configuration

100
00:08:17,000 --> 00:08:23,000
that needed a special command to be run on bash ought to be documented somewhere.

101
00:08:23,000 --> 00:08:28,000
Right. I mean, if it's not if it's not automated, it better be documented at least.

102
00:08:28,000 --> 00:08:31,000
It also I love you. It also seems like a part of it, too.

103
00:08:31,000 --> 00:08:34,000
And maybe I think sometimes process can be overbearing.

104
00:08:34,000 --> 00:08:37,000
And a lot of this goes back to how we educate.

105
00:08:37,000 --> 00:08:42,000
And that varies widely in different companies, organizations, and there's different philosophies on that.

106
00:08:42,000 --> 00:08:46,000
But, you know, people get discouraged, I think, by having too much process.

107
00:08:46,000 --> 00:08:52,000
Right. Like, oh, the really rigorous TDD or like documenting every tiny minutia item.

108
00:08:52,000 --> 00:08:55,000
And obviously more documentation, more testing is generally better.

109
00:08:55,000 --> 00:08:59,000
But the point, right, is that you're trying to care about the software you write.

110
00:08:59,000 --> 00:09:03,000
You're trying to have a holistic understanding and leave some intent for the people coming after you.

111
00:09:03,000 --> 00:09:08,000
Because you sure you can dive into the code base and you can tweak things and mess with configurations

112
00:09:08,000 --> 00:09:11,000
or improve error handling or debug erase condition.

113
00:09:11,000 --> 00:09:16,000
But just having a little bit a couple of sentences about this is the goal this code is trying to achieve.

114
00:09:16,000 --> 00:09:20,000
Sometimes that can really make it simpler when you come back five to five years down the road.

115
00:09:20,000 --> 00:09:24,000
And you also want to be mindful not to screw the person coming after you, right?

116
00:09:24,000 --> 00:09:28,000
Yeah. Right. I guess in some ways it's sort of the philosophy.

117
00:09:28,000 --> 00:09:30,000
And maybe we see this first with tests.

118
00:09:30,000 --> 00:09:34,000
I feel like docs gets more of a struggle or it's less talked about.

119
00:09:34,000 --> 00:09:38,000
But that, you know, shipping the code isn't really shipping the deliverable.

120
00:09:38,000 --> 00:09:39,000
It's the tests and the...

121
00:09:39,000 --> 00:09:40,000
Exactly.

122
00:09:40,000 --> 00:09:42,000
And the infrastructure around it.

123
00:09:42,000 --> 00:09:47,000
I want to ask you, because, you know, Wes, I listen to you about twice a week.

124
00:09:47,000 --> 00:09:50,000
Because you're so good I have to listen more than once a week.

125
00:09:50,000 --> 00:09:52,000
Oh, you flatter me, sir.

126
00:09:52,000 --> 00:09:55,000
What do you think? Are Chris and I just getting too old?

127
00:09:55,000 --> 00:09:58,000
Is it time for us to go to Elmer's factory and become Woo?

128
00:09:58,000 --> 00:10:00,000
Or...

129
00:10:00,000 --> 00:10:04,000
Should we fight this battle or should we walk away?

130
00:10:04,000 --> 00:10:06,000
I think you got to fight the battle.

131
00:10:06,000 --> 00:10:10,000
We have a culture right now that skews really young, which isn't bad, right?

132
00:10:10,000 --> 00:10:13,000
Youth brings a lot of energy, new ideas change.

133
00:10:13,000 --> 00:10:17,000
Not always good, cough, NPM cough.

134
00:10:17,000 --> 00:10:20,000
But, you know, lots of energy to try to fix things.

135
00:10:20,000 --> 00:10:22,000
Hang on, did you just say NPM?

136
00:10:22,000 --> 00:10:23,000
I maybe, yes.

137
00:10:23,000 --> 00:10:29,000
So, not only is it not always good, it's mostly bad.

138
00:10:29,000 --> 00:10:32,000
We can have that conversation if we want to have it.

139
00:10:32,000 --> 00:10:38,000
NPM is the HIV of package managers.

140
00:10:38,000 --> 00:10:46,000
I mean, you almost made me cough up some of my drink here.

141
00:10:46,000 --> 00:10:48,000
That was pretty good.

142
00:10:48,000 --> 00:10:52,000
So, I don't know, but I do think we need to have...

143
00:10:52,000 --> 00:10:55,000
I mean, as you said, we're kind of the same age.

144
00:10:55,000 --> 00:10:57,000
Chris is only a little bit older than we are.

145
00:10:57,000 --> 00:11:01,000
It's frightening if you guys are already too old.

146
00:11:01,000 --> 00:11:05,000
Because you obviously have a lot to do and it doesn't matter if you triage the tickets in the morning.

147
00:11:05,000 --> 00:11:07,000
That's the thing, we're not that old.

148
00:11:07,000 --> 00:11:12,000
In theory, you should have a couple more decades of productive life ahead of you.

149
00:11:12,000 --> 00:11:13,000
No, but they would like to...

150
00:11:13,000 --> 00:11:20,000
If you look at the Coderadio subreddit, we are ready for the kennel, or rather the glue factory.

151
00:11:20,000 --> 00:11:23,000
Some of that might just be the things that you focus on.

152
00:11:23,000 --> 00:11:28,000
There's a time in life where you're kind of heads down, pushing through racing,

153
00:11:28,000 --> 00:11:30,000
or you're willing to put up with a little more.

154
00:11:30,000 --> 00:11:34,000
When you first learn Linux, you're like, oh yeah, sure, I had to spend two hours kind of figuring that out

155
00:11:34,000 --> 00:11:36,000
and getting the graphics drivers just right.

156
00:11:36,000 --> 00:11:37,000
It's working and it's great.

157
00:11:37,000 --> 00:11:39,000
And then there's a time where you've done that like six times.

158
00:11:39,000 --> 00:11:41,000
No one's complaining that like...

159
00:11:41,000 --> 00:11:44,000
I'm on Pop-O-Wiz right now and I'm using a Galago Pro.

160
00:11:44,000 --> 00:11:47,000
System 76, here's a shout out.

161
00:11:47,000 --> 00:11:50,000
Connected to my Dell...

162
00:11:50,000 --> 00:11:51,000
It's an old...

163
00:11:51,000 --> 00:11:53,000
What do they call those?

164
00:11:53,000 --> 00:11:54,000
I don't know the model.

165
00:11:54,000 --> 00:11:55,000
Describe it.

166
00:11:55,000 --> 00:11:56,000
Describe it.

167
00:11:56,000 --> 00:11:58,000
It's a flat panel on that screen.

168
00:11:58,000 --> 00:12:00,000
It's not 4K.

169
00:12:00,000 --> 00:12:02,000
It's like 256...

170
00:12:02,000 --> 00:12:03,000
Yeah, okay.

171
00:12:03,000 --> 00:12:04,000
Is that 2K?

172
00:12:04,000 --> 00:12:06,000
It's like 1440 by 1440.

173
00:12:06,000 --> 00:12:08,000
And I've been using this monitor for like five years.

174
00:12:08,000 --> 00:12:11,000
It's kind of a sweet spot resolution, honestly.

175
00:12:11,000 --> 00:12:12,000
It's beautiful.

176
00:12:12,000 --> 00:12:13,000
And I have Athelio coming.

177
00:12:13,000 --> 00:12:15,000
Athelio, I'm sorry.

178
00:12:15,000 --> 00:12:18,000
I'm excited to hear you talk about that.

179
00:12:18,000 --> 00:12:20,000
But it's...

180
00:12:20,000 --> 00:12:21,000
I don't know.

181
00:12:21,000 --> 00:12:24,000
Every time I have to do like a week or two of Mac work,

182
00:12:24,000 --> 00:12:26,000
I get my balls handed to me in the subreddit.

183
00:12:26,000 --> 00:12:29,000
I don't even understand.

184
00:12:29,000 --> 00:12:30,000
Yeah, I mean...

185
00:12:30,000 --> 00:12:31,000
The same thing for Chris.

186
00:12:31,000 --> 00:12:34,000
If he edits something on Final Cut because he has a problem,

187
00:12:34,000 --> 00:12:35,000
it just seems like...

188
00:12:35,000 --> 00:12:37,000
I don't know.

189
00:12:37,000 --> 00:12:38,000
Like it's cheating on your wife.

190
00:12:38,000 --> 00:12:41,000
It's Tux, my wife, because...

191
00:12:41,000 --> 00:12:44,000
Tux could maybe get in shape and grow some hair.

192
00:12:44,000 --> 00:12:45,000
I don't know.

193
00:12:45,000 --> 00:12:46,000
I'm just saying.

194
00:12:46,000 --> 00:12:49,000
Yeah, I generally tend to have a problem with some of the vitriolic,

195
00:12:49,000 --> 00:12:50,000
at least the intentions of it.

196
00:12:50,000 --> 00:12:53,000
I think it's fine to generally want...

197
00:12:53,000 --> 00:12:56,000
You know, want us, want creators in this community

198
00:12:56,000 --> 00:12:59,000
to use open source tooling.

199
00:12:59,000 --> 00:13:01,000
But I think what other people need to remember

200
00:13:01,000 --> 00:13:03,000
is that obviously you and Chris think about that, right?

201
00:13:03,000 --> 00:13:06,000
I mean, you just paid money for a Linux-specific...

202
00:13:06,000 --> 00:13:08,000
I mean, it'll run whatever, obviously,

203
00:13:08,000 --> 00:13:11,000
but a Linux-targeted desktop that's beautiful, but...

204
00:13:11,000 --> 00:13:14,000
And to be fair, I've bought a Raytel, an Aurex Pro,

205
00:13:14,000 --> 00:13:17,000
a Dell XPS, a Galago,

206
00:13:17,000 --> 00:13:20,000
and the Thelio I didn't pay for, spoiler alert,

207
00:13:20,000 --> 00:13:22,000
the customer actually bought that for me.

208
00:13:22,000 --> 00:13:23,000
Oh, yeah, okay.

209
00:13:23,000 --> 00:13:24,000
Sure, that's fine.

210
00:13:24,000 --> 00:13:27,000
But I bought a Dell Inspiron...

211
00:13:27,000 --> 00:13:30,000
Not Inspiron, whatever their big desktop is,

212
00:13:30,000 --> 00:13:34,000
it's running flight simulation software

213
00:13:34,000 --> 00:13:37,000
that we wrote at the Mad Botter on Linux.

214
00:13:37,000 --> 00:13:38,000
See, that's awesome.

215
00:13:38,000 --> 00:13:39,000
And it's just not...

216
00:13:39,000 --> 00:13:42,000
It's just like, to say that the little bit of OS X

217
00:13:42,000 --> 00:13:45,000
or iOS work we do makes us traitors,

218
00:13:45,000 --> 00:13:46,000
I think is nuts.

219
00:13:46,000 --> 00:13:49,000
Right, and you're trying to run a business, right?

220
00:13:49,000 --> 00:13:50,000
Yeah, exactly.

221
00:13:50,000 --> 00:13:51,000
So you just got to...

222
00:13:51,000 --> 00:13:54,000
People should know that you respect and try to use

223
00:13:54,000 --> 00:13:56,000
free and open source software when you can,

224
00:13:56,000 --> 00:13:59,000
and other times someone wants to pay you to make a proprietary app,

225
00:13:59,000 --> 00:14:02,000
and, you know, you need dollars in your pocket either way.

226
00:14:02,000 --> 00:14:05,000
But you know who is wonderful?

227
00:14:05,000 --> 00:14:08,000
I'm going to guess our audience?

228
00:14:08,000 --> 00:14:10,000
But specifically Mark.

229
00:14:10,000 --> 00:14:11,000
Specifically Mark, yeah.

230
00:14:11,000 --> 00:14:15,000
He had some really good feedback for the show, actually.

231
00:14:15,000 --> 00:14:18,000
If people are interested in IoT, he wrote in,

232
00:14:18,000 --> 00:14:22,000
there's a great option that might be relevant to the Coder audience.

233
00:14:22,000 --> 00:14:25,000
We're talking about the Elixir programming language here

234
00:14:25,000 --> 00:14:27,000
based on Erlang,

235
00:14:27,000 --> 00:14:30,000
and more specifically a project called NERVS,

236
00:14:30,000 --> 00:14:32,000
which enables you to create IoT devices

237
00:14:32,000 --> 00:14:37,000
with features that include live device upgrades.

238
00:14:37,000 --> 00:14:38,000
NERVS is interesting.

239
00:14:38,000 --> 00:14:40,000
I've obviously heard of Elixir,

240
00:14:40,000 --> 00:14:42,000
but I don't think I've not heard of NERVS.

241
00:14:42,000 --> 00:14:46,000
What did you think of this feedback, Mr. Dominic?

242
00:14:46,000 --> 00:14:47,000
I thought it was interesting.

243
00:14:47,000 --> 00:14:49,000
I have to say since last week's show,

244
00:14:49,000 --> 00:14:52,000
I haven't had an opportunity to actually try out NERVS.

245
00:14:52,000 --> 00:14:59,000
But if there is a FOSS alternative to Azure Sphere OS,

246
00:14:59,000 --> 00:15:02,000
I am going to jump on that.

247
00:15:02,000 --> 00:15:04,000
I'm not going to say the reference I wanted to use,

248
00:15:04,000 --> 00:15:07,000
because again, our LA overlords probably wouldn't love it.

249
00:15:07,000 --> 00:15:11,000
Ask them to do it, frat boys.

250
00:15:11,000 --> 00:15:13,000
I would definitely prefer that.

251
00:15:13,000 --> 00:15:17,000
I have to say, can I reveal the kimono?

252
00:15:17,000 --> 00:15:18,000
Yes, do it.

253
00:15:18,000 --> 00:15:20,000
I mean, it's a weird phrase,

254
00:15:20,000 --> 00:15:23,000
but I take your meaning and I want you to lay it all bare.

255
00:15:23,000 --> 00:15:26,000
So Alice is not going to be running in her next version

256
00:15:26,000 --> 00:15:28,000
on the Microsoft Bot Framework.

257
00:15:28,000 --> 00:15:29,000
Oh, no.

258
00:15:29,000 --> 00:15:31,000
That was a pretty significant little foundation.

259
00:15:31,000 --> 00:15:34,000
Wow.

260
00:15:34,000 --> 00:15:35,000
Yes.

261
00:15:35,000 --> 00:15:39,000
You know what?

262
00:15:39,000 --> 00:15:41,000
I can't say that I've seen the light,

263
00:15:41,000 --> 00:15:44,000
but I can say that it's very dangerous

264
00:15:44,000 --> 00:15:48,000
to be hooked into commercial companies as a small ISV,

265
00:15:48,000 --> 00:15:50,000
which is what my business is.

266
00:15:50,000 --> 00:15:52,000
It's interesting how that goes both ways, right?

267
00:15:52,000 --> 00:15:54,000
Because often the argument is the other thing, right?

268
00:15:54,000 --> 00:15:56,000
It's the argument of like, well, you don't need to specialize.

269
00:15:56,000 --> 00:15:57,000
You don't need to be doing this.

270
00:15:57,000 --> 00:15:58,000
Pay some other company to do it

271
00:15:58,000 --> 00:16:01,000
so you can focus on whatever your core business model is.

272
00:16:01,000 --> 00:16:03,000
Well, the problem is though,

273
00:16:03,000 --> 00:16:05,000
you're limited in what you can build

274
00:16:05,000 --> 00:16:07,000
by the boundaries of that framework

275
00:16:07,000 --> 00:16:10,000
or that toolkit they give you.

276
00:16:10,000 --> 00:16:12,000
And I think the Microsoft Bot Framework is great.

277
00:16:12,000 --> 00:16:13,000
Don't get me wrong.

278
00:16:13,000 --> 00:16:16,000
I encourage customers if they need a bot.

279
00:16:16,000 --> 00:16:19,000
It's one of the cheapest and most effective ways to get a bot.

280
00:16:19,000 --> 00:16:20,000
You can write it in JavaScript.

281
00:16:20,000 --> 00:16:21,000
You can write it in C Sharp.

282
00:16:21,000 --> 00:16:24,000
But I think the JavaScript SDK,

283
00:16:24,000 --> 00:16:27,000
apologies to C Sharp people, is actually kind of better

284
00:16:27,000 --> 00:16:34,000
because it doesn't have all the ASP web crap associated with it.

285
00:16:34,000 --> 00:16:36,000
But God, if you're already writing a node,

286
00:16:36,000 --> 00:16:40,000
which is just a nightmare in itself,

287
00:16:40,000 --> 00:16:43,000
there are so many better open source options you could use.

288
00:16:43,000 --> 00:16:45,000
In fact, I found a great one for Kotlin

289
00:16:45,000 --> 00:16:47,000
that I'm evaluating and hoping to have on the show

290
00:16:47,000 --> 00:16:49,000
in a couple of weeks.

291
00:16:49,000 --> 00:16:53,000
And let me tell you, it's damn powerful,

292
00:16:53,000 --> 00:16:55,000
having the JVM for bots.

293
00:16:55,000 --> 00:16:57,000
I don't know if you know this, OpenNLP.

294
00:16:57,000 --> 00:16:59,000
Wes, are you familiar with that at all?

295
00:16:59,000 --> 00:17:00,000
Yeah.

296
00:17:00,000 --> 00:17:03,000
Well, that's a Java Apache Foundation library, right?

297
00:17:03,000 --> 00:17:05,000
It sure is, yeah.

298
00:17:05,000 --> 00:17:07,000
Works seamlessly with the Kotlin runtime.

299
00:17:07,000 --> 00:17:08,000
Nice.

300
00:17:08,000 --> 00:17:09,000
So you just plug and play.

301
00:17:09,000 --> 00:17:14,000
So were you worried at all about overhead

302
00:17:14,000 --> 00:17:18,000
or anything like that running on the JVM?

303
00:17:18,000 --> 00:17:21,000
Droplets are so cheap.

304
00:17:21,000 --> 00:17:24,000
Yes, that's certainly true.

305
00:17:24,000 --> 00:17:25,000
That's like my answer.

306
00:17:25,000 --> 00:17:26,000
I don't even know what to say.

307
00:17:26,000 --> 00:17:28,000
Droplets are just...

308
00:17:28,000 --> 00:17:32,000
I'm not worried about it now.

309
00:17:32,000 --> 00:17:33,000
By the way...

310
00:17:33,000 --> 00:17:36,000
Oh, go on.

311
00:17:36,000 --> 00:17:38,000
...run time, or it would be the.NET core runtime,

312
00:17:38,000 --> 00:17:40,000
which are just as heavy.

313
00:17:40,000 --> 00:17:41,000
Yeah.

314
00:17:41,000 --> 00:17:45,000
Or similarly heavy, depending on the workload, right?

315
00:17:45,000 --> 00:17:46,000
Yeah.

316
00:17:46,000 --> 00:17:48,000
Either way, you're going to end up...

317
00:17:48,000 --> 00:17:49,000
You're paying for it.

318
00:17:49,000 --> 00:17:50,000
Yeah, exactly.

319
00:17:50,000 --> 00:17:51,000
I mean, you want those niceties, right?

320
00:17:51,000 --> 00:17:52,000
You don't want to have to go right C.

321
00:17:52,000 --> 00:17:54,000
You want someone to handle a lot of those things for you.

322
00:17:54,000 --> 00:17:55,000
Exactly.

323
00:17:55,000 --> 00:17:57,000
And a lot of engineering hours have been poured into that.

324
00:17:57,000 --> 00:17:59,000
And that's probably some of the same things

325
00:17:59,000 --> 00:18:02,000
that this NURVS project is trying to take advantage of.

326
00:18:02,000 --> 00:18:03,000
Yeah, I think so.

327
00:18:03,000 --> 00:18:04,000
I'm going to check them out.

328
00:18:04,000 --> 00:18:06,000
I think, Wes, you should check them out.

329
00:18:06,000 --> 00:18:08,000
Maybe a Clojure wrapper?

330
00:18:08,000 --> 00:18:09,000
Oh, yeah, that could be good.

331
00:18:09,000 --> 00:18:11,000
And actually, Elixir has a lot of stuff

332
00:18:11,000 --> 00:18:13,000
I really love from Clojure.

333
00:18:13,000 --> 00:18:17,000
First-class, immutable, fast data structures.

334
00:18:17,000 --> 00:18:18,000
And it's already got this.

335
00:18:18,000 --> 00:18:21,000
You know, when you're doing bots or IoT or serverless

336
00:18:21,000 --> 00:18:22,000
or any of those things,

337
00:18:22,000 --> 00:18:24,000
you're already kind of running in a distributed world.

338
00:18:24,000 --> 00:18:27,000
And honestly, right, like we talk about programmers

339
00:18:27,000 --> 00:18:29,000
or development, but a lot of us end up being

340
00:18:29,000 --> 00:18:32,000
distributed systems engineers in one way or another

341
00:18:32,000 --> 00:18:34,000
just because, well, the database is over there

342
00:18:34,000 --> 00:18:35,000
and my client's over here,

343
00:18:35,000 --> 00:18:37,000
and maybe there's a GraphQL server in front of this.

344
00:18:37,000 --> 00:18:40,000
And you end up with like a dozen different frameworks

345
00:18:40,000 --> 00:18:41,000
and pieces together.

346
00:18:41,000 --> 00:18:44,000
So it's nice that the whole Erlang platform, right,

347
00:18:44,000 --> 00:18:48,000
they've got their own Beam VM, V-E-A-M,

348
00:18:48,000 --> 00:18:49,000
and it's designed with that in mind.

349
00:18:49,000 --> 00:18:52,000
They've been doing, you know, multiple concurrent actors

350
00:18:52,000 --> 00:18:54,000
running phone switches for decades now.

351
00:18:54,000 --> 00:18:56,000
So I don't know about NURVS.

352
00:18:56,000 --> 00:18:57,000
They admit that it's young,

353
00:18:57,000 --> 00:19:01,000
but claim it already powers rock-solid industrial products.

354
00:19:04,000 --> 00:19:05,000
Sounds great.

355
00:19:05,000 --> 00:19:06,000
Yeah, thanks, Mike.

356
00:19:06,000 --> 00:19:07,000
That's great.

357
00:19:07,000 --> 00:19:09,000
And if any of you have other projects,

358
00:19:09,000 --> 00:19:11,000
maybe you're working on IoT or bot frameworks

359
00:19:11,000 --> 00:19:13,000
and there's a framework free and open source

360
00:19:13,000 --> 00:19:16,000
or otherwise that you're enjoying or despising,

361
00:19:16,000 --> 00:19:22,000
you can tell us about it at coder.radio slash contact.

362
00:19:25,000 --> 00:19:27,000
So, Wes, can I tell you why I'm sad this week?

363
00:19:27,000 --> 00:19:28,000
I thought you already did.

364
00:19:28,000 --> 00:19:30,000
But, okay, you're sad for other reasons.

365
00:19:30,000 --> 00:19:33,000
Wes, I'm living in a world of depression.

366
00:19:33,000 --> 00:19:36,000
All right, well, let me be your therapist today, Mr. Dominic.

367
00:19:36,000 --> 00:19:37,000
Lay it on us.

368
00:19:37,000 --> 00:19:38,000
Doctor? Doctor?

369
00:19:38,000 --> 00:19:41,000
Oh, yes.

370
00:19:41,000 --> 00:19:44,000
I thought that the iPad Pro 2018,

371
00:19:44,000 --> 00:19:48,000
and I know this isn't your thing, so patience,

372
00:19:48,000 --> 00:19:53,000
with this USB-C port would be an open interface

373
00:19:53,000 --> 00:19:55,000
that I could just, you know, open a BSD socket

374
00:19:55,000 --> 00:19:56,000
and work with, right?

375
00:19:56,000 --> 00:19:58,000
Right, that you would just be able to connect to it

376
00:19:58,000 --> 00:20:00,000
like a regular interface that you could go,

377
00:20:00,000 --> 00:20:02,000
you could write an application that had a peripheral

378
00:20:02,000 --> 00:20:06,000
that plugged into it or talked any of the various protocols

379
00:20:06,000 --> 00:20:08,000
supported by that connector.

380
00:20:08,000 --> 00:20:09,000
Hundreds of protocols, right?

381
00:20:09,000 --> 00:20:13,000
In the Unix world, there are literally maybe even thousands.

382
00:20:13,000 --> 00:20:18,000
So, what I found was there was something called the IO kit,

383
00:20:18,000 --> 00:20:19,000
and we have a link in the show notes

384
00:20:19,000 --> 00:20:20,000
the Apple developer form.

385
00:20:20,000 --> 00:20:23,000
They just have a kit for everything, don't they?

386
00:20:23,000 --> 00:20:25,000
They have a bathroom kit, I think.

387
00:20:25,000 --> 00:20:27,000
Seriously, it's like, okay, what do you need?

388
00:20:27,000 --> 00:20:30,000
Oh, that's the built-in bidet on the iOS platform.

389
00:20:30,000 --> 00:20:32,000
You know, I would love a bidet.

390
00:20:32,000 --> 00:20:33,000
We could talk about this.

391
00:20:33,000 --> 00:20:36,000
I would love a bidet.

392
00:20:36,000 --> 00:20:41,000
It is weirdly out of date, and a lot of it's deprecated now,

393
00:20:41,000 --> 00:20:43,000
so I'm not sure what that means.

394
00:20:43,000 --> 00:20:45,000
And it doesn't actually let you pick like a disk,

395
00:20:45,000 --> 00:20:47,000
you know, like we would think of the Unix world,

396
00:20:47,000 --> 00:20:54,000
like dev-slash-sda1 or dev-slash-whatever, right?

397
00:20:54,000 --> 00:20:56,000
But it's not so specific like that.

398
00:20:56,000 --> 00:21:00,000
It's not so specific, and it's unclear.

399
00:21:00,000 --> 00:21:05,000
You can push it and twist it to read off of that USB port,

400
00:21:05,000 --> 00:21:10,000
but Apple's own PR and own developer documentation

401
00:21:10,000 --> 00:21:11,000
definitely gives the impression

402
00:21:11,000 --> 00:21:14,000
that that's not how they want you to use it,

403
00:21:14,000 --> 00:21:18,000
and the APIs you need to use to do that are deprecated.

404
00:21:18,000 --> 00:21:21,000
So, one, I linked to the forms here.

405
00:21:21,000 --> 00:21:25,000
I am not alone in wanting to simply be able to

406
00:21:25,000 --> 00:21:31,000
brace yourself, Wes, access a connected disk on a drive.

407
00:21:31,000 --> 00:21:33,000
So you're, yeah, I was going to ask you about that.

408
00:21:33,000 --> 00:21:35,000
So your use case here is to be able to plug in

409
00:21:35,000 --> 00:21:38,000
like an external hard drive?

410
00:21:38,000 --> 00:21:40,000
Well, what I really, yeah, there's a couple things I would do.

411
00:21:40,000 --> 00:21:41,000
I would plug in a hard drive.

412
00:21:41,000 --> 00:21:43,000
I also would like to be able to plug in a, like,

413
00:21:43,000 --> 00:21:46,000
Raspberry Pi board and actually like program the board from an iPad.

414
00:21:46,000 --> 00:21:48,000
Oh, like, yeah, be able to flash it from...

415
00:21:48,000 --> 00:21:51,000
Just like flash it from an iPad.

416
00:21:51,000 --> 00:21:54,000
Basically do all the normal USB things.

417
00:21:54,000 --> 00:21:55,000
Right.

418
00:21:55,000 --> 00:22:00,000
I want the USB-C port to actually be a USB-C port, right?

419
00:22:00,000 --> 00:22:03,000
It seems like at present that is not the case.

420
00:22:03,000 --> 00:22:09,000
There's an Apple Developer Forum that's depressing.

421
00:22:09,000 --> 00:22:10,000
I don't know what to say.

422
00:22:10,000 --> 00:22:15,000
I mean, it comes down to these are the cases that are allowed.

423
00:22:15,000 --> 00:22:18,000
You can try anything else you like,

424
00:22:18,000 --> 00:22:21,000
but you have to get through App Review.

425
00:22:21,000 --> 00:22:24,000
Well, of course you have to get through App Review, right?

426
00:22:24,000 --> 00:22:29,000
Right, but it's kind of like if you try something new,

427
00:22:29,000 --> 00:22:30,000
you need to develop...

428
00:22:30,000 --> 00:22:31,000
You can't like call up and say,

429
00:22:31,000 --> 00:22:32,000
hey, I have this idea for an app.

430
00:22:32,000 --> 00:22:33,000
What do you think?

431
00:22:33,000 --> 00:22:36,000
You have to develop the app first.

432
00:22:36,000 --> 00:22:39,000
And then if they say no, guess what?

433
00:22:39,000 --> 00:22:40,000
Nothing, right?

434
00:22:40,000 --> 00:22:41,000
You're out of luck.

435
00:22:41,000 --> 00:22:43,000
You have zero options.

436
00:22:43,000 --> 00:22:44,000
Right.

437
00:22:44,000 --> 00:22:46,000
So that's pretty disappointing.

438
00:22:46,000 --> 00:22:49,000
And they mentioned specific cases that they support,

439
00:22:49,000 --> 00:22:53,000
you know, music through Apple Music and photos through photos,

440
00:22:53,000 --> 00:22:54,000
photos.app rather.

441
00:22:54,000 --> 00:23:00,000
So it seems to be the case that while it is technically possible

442
00:23:00,000 --> 00:23:06,000
to access the USB port on the iPad Pro 2018,

443
00:23:06,000 --> 00:23:09,000
I can't say for sure because I did call App Review

444
00:23:09,000 --> 00:23:11,000
and they kind of laughed at me.

445
00:23:11,000 --> 00:23:12,000
Oh, really?

446
00:23:12,000 --> 00:23:14,000
Yeah, I just couldn't get through.

447
00:23:14,000 --> 00:23:17,000
They said we don't comment on unsubmitted apps.

448
00:23:17,000 --> 00:23:19,000
And the young lady I spoke to said,

449
00:23:19,000 --> 00:23:21,000
submit your app and I'll let you know.

450
00:23:21,000 --> 00:23:23,000
That is just not a workflow.

451
00:23:23,000 --> 00:23:25,000
I mean, okay, maybe for a big company,

452
00:23:25,000 --> 00:23:28,000
but as an independent developer, how are you supposed to do that?

453
00:23:28,000 --> 00:23:30,000
Well, it means I can't do the project.

454
00:23:30,000 --> 00:23:34,000
You can't even explore working on what might be a pretty neat app.

455
00:23:34,000 --> 00:23:40,000
So it's kind of like it seems like they don't envision the iPad Pro

456
00:23:40,000 --> 00:23:44,000
as an actual full powered workstation computer.

457
00:23:44,000 --> 00:23:46,000
They see it as something...

458
00:23:46,000 --> 00:23:48,000
They call it a computer.

459
00:23:48,000 --> 00:23:50,000
They see it as something else.

460
00:23:50,000 --> 00:23:53,000
I'm hoping in the next version of the iOS SDK,

461
00:23:53,000 --> 00:23:55,000
there are some Apple approved.

462
00:23:55,000 --> 00:23:59,000
I can imagine it using Shortcuts, which is an Apple...

463
00:23:59,000 --> 00:24:03,000
It's basically the crappiest implementation of Unix pipes

464
00:24:03,000 --> 00:24:04,000
I've ever seen in my life.

465
00:24:04,000 --> 00:24:06,000
That's what I was about to say.

466
00:24:06,000 --> 00:24:08,000
You see, that's funny because I've heard a lot of,

467
00:24:08,000 --> 00:24:10,000
from some people who will go unnamed,

468
00:24:10,000 --> 00:24:12,000
a lot of positive things that, you know, like finally,

469
00:24:12,000 --> 00:24:15,000
this has added a layer of like real utility to some of these apps.

470
00:24:15,000 --> 00:24:17,000
It does, no, it's great.

471
00:24:17,000 --> 00:24:20,000
But it's only great because the restrictions are too high, right?

472
00:24:20,000 --> 00:24:22,000
Like if you just had a...

473
00:24:22,000 --> 00:24:25,000
If it was just the case that you could share data between apps

474
00:24:25,000 --> 00:24:29,000
in a normal kind of Unix-y, BSD-y way,

475
00:24:29,000 --> 00:24:32,000
you wouldn't need Shortcuts, right?

476
00:24:32,000 --> 00:24:36,000
Yeah, like I can see why they didn't go full file system metaphor,

477
00:24:36,000 --> 00:24:38,000
but they didn't give you a lot between that, right?

478
00:24:38,000 --> 00:24:40,000
Like I could, it could be whatever,

479
00:24:40,000 --> 00:24:43,000
some more abstract object storage style system,

480
00:24:43,000 --> 00:24:46,000
but I wouldn't be able to just like share these stuff between apps

481
00:24:46,000 --> 00:24:49,000
and have them coexist like they're running on the same machine.

482
00:24:49,000 --> 00:24:51,000
Yeah, that's not the case.

483
00:24:51,000 --> 00:24:52,000
It is interesting.

484
00:24:52,000 --> 00:24:55,000
I just got my, for Christmas, I got my father an iPad

485
00:24:55,000 --> 00:24:59,000
and he'd used like Windows, I don't know, XP probably for his job

486
00:24:59,000 --> 00:25:01,000
before he retired, just as like, you know,

487
00:25:01,000 --> 00:25:04,000
had some software he had to use specific to his field.

488
00:25:04,000 --> 00:25:06,000
And then otherwise it doesn't really use computers.

489
00:25:06,000 --> 00:25:08,000
So I was thinking about this in the same way.

490
00:25:08,000 --> 00:25:10,000
It's not a traditional computer, right?

491
00:25:10,000 --> 00:25:12,000
A lot of their branding talks about how it's sort of redesigned.

492
00:25:12,000 --> 00:25:17,000
It has, they've taken, I mean, almost in a BSD style approach,

493
00:25:17,000 --> 00:25:19,000
like they've taken this very minimal core of stuff

494
00:25:19,000 --> 00:25:22,000
that they want to implement and slowly extending it from there

495
00:25:22,000 --> 00:25:25,000
rather than like a general purpose computer

496
00:25:25,000 --> 00:25:27,000
that's been somewhat locked down.

497
00:25:29,000 --> 00:25:30,000
Yeah.

498
00:25:31,000 --> 00:25:34,000
And it seems like it could work for, like in one case,

499
00:25:34,000 --> 00:25:36,000
I think my father's actually doing pretty well on it

500
00:25:36,000 --> 00:25:37,000
for that same reason, right?

501
00:25:37,000 --> 00:25:38,000
It's hard for him to damage anything.

502
00:25:38,000 --> 00:25:39,000
It's hard to break stuff.

503
00:25:39,000 --> 00:25:41,000
There's just not that much you can do to it

504
00:25:41,000 --> 00:25:43,000
because your interactions are limited

505
00:25:43,000 --> 00:25:45,000
and each one of them has really been thought through

506
00:25:45,000 --> 00:25:47,000
in the context of all the other actions.

507
00:25:47,000 --> 00:25:50,000
But I imagine, but for technical users,

508
00:25:50,000 --> 00:25:53,000
it's just a lot of, it's more walled garden roadblocks.

509
00:25:54,000 --> 00:25:57,000
Well, in a weird way, the iPad is actually the ideal

510
00:25:57,000 --> 00:25:59,000
of the personal computer.

511
00:25:59,000 --> 00:26:02,000
If you mean a personal computer to be a non-technical user

512
00:26:02,000 --> 00:26:04,000
using it for, you know, personal use.

513
00:26:04,000 --> 00:26:08,000
Right, just like social media, communication, standard stuff.

514
00:26:08,000 --> 00:26:10,000
Yeah, I can see that.

515
00:26:10,000 --> 00:26:11,000
It is disappointing.

516
00:26:11,000 --> 00:26:13,000
Wes, take us out of this pit.

517
00:26:13,000 --> 00:26:15,000
You have something good for us, I'm sure.

518
00:26:16,000 --> 00:26:17,000
Oh, yes, I do.

519
00:26:17,000 --> 00:26:18,000
Hard segue.

520
00:26:18,000 --> 00:26:19,000
Hard segue.

521
00:26:19,000 --> 00:26:22,000
Yeah, I mean, we don't need to be so sad about USB-C.

522
00:26:22,000 --> 00:26:25,000
It is a shame, but at least the iPad has USB-C.

523
00:26:25,000 --> 00:26:27,000
We're gonna just clip it right there and say,

524
00:26:27,000 --> 00:26:30,000
maybe in the future, things will be opened up,

525
00:26:30,000 --> 00:26:31,000
only time will tell,

526
00:26:31,000 --> 00:26:33,000
and we'll check in with a very frustrated Shirley,

527
00:26:33,000 --> 00:26:36,000
Mr. Michael Dominic, in the future.

528
00:26:36,000 --> 00:26:39,000
So, when we were talking about Iokit just now,

529
00:26:39,000 --> 00:26:42,000
I noticed I saw a lot of.h files,

530
00:26:42,000 --> 00:26:45,000
some of their other reference documentation,

531
00:26:45,000 --> 00:26:48,000
but it didn't seem particularly targeted

532
00:26:48,000 --> 00:26:50,000
towards our friend Swift.

533
00:26:50,000 --> 00:26:52,000
And I'm wondering how you...

534
00:26:52,000 --> 00:26:53,000
I've heard...

535
00:26:53,000 --> 00:26:55,000
I mean, I try to listen to Koda Radio every week.

536
00:26:55,000 --> 00:26:56,000
I don't always make it,

537
00:26:56,000 --> 00:26:59,000
but your thoughts on Swift seem to...

538
00:26:59,000 --> 00:27:01,000
Honestly, I don't even know what the graph looks like.

539
00:27:01,000 --> 00:27:03,000
It's too complicated for me to draw.

540
00:27:03,000 --> 00:27:05,000
I want to know where you are.

541
00:27:05,000 --> 00:27:08,000
I want to know where you're at right now.

542
00:27:08,000 --> 00:27:10,000
So, the simple answer to your question is,

543
00:27:10,000 --> 00:27:11,000
first of all,

544
00:27:11,000 --> 00:27:13,000
if you actually dig into the documentation there,

545
00:27:13,000 --> 00:27:16,000
when you see funk, that's Swift.

546
00:27:16,000 --> 00:27:19,000
So, Swift can easily consume C++ Objective-C.

547
00:27:19,000 --> 00:27:20,000
Excellent, okay.

548
00:27:20,000 --> 00:27:22,000
See, I didn't know that.

549
00:27:22,000 --> 00:27:25,000
Yeah, so the reason it's.h is, yeah.

550
00:27:25,000 --> 00:27:27,000
I have complicated feelings towards Swift.

551
00:27:27,000 --> 00:27:29,000
I thought you were not gonna drag me into this,

552
00:27:29,000 --> 00:27:30,000
but that's fine.

553
00:27:30,000 --> 00:27:34,000
So, Swift...

554
00:27:34,000 --> 00:27:38,000
is a complicated language, actually.

555
00:27:38,000 --> 00:27:42,000
I still kind of feel like it's a little bit of a mongrel,

556
00:27:42,000 --> 00:27:43,000
in the dog sense,

557
00:27:43,000 --> 00:27:45,000
in that it's too many things at once.

558
00:27:45,000 --> 00:27:46,000
So, for instance,

559
00:27:46,000 --> 00:27:51,000
it's got this idea of protocol-oriented programming, right?

560
00:27:51,000 --> 00:27:54,000
Which basically means you should write your data structures

561
00:27:54,000 --> 00:27:57,000
as structs instead of classes.

562
00:27:57,000 --> 00:27:59,000
I wrote enums.

563
00:27:59,000 --> 00:28:02,000
But...

564
00:28:02,000 --> 00:28:05,000
which is great, because, listen,

565
00:28:05,000 --> 00:28:07,000
there is a problem in Swift,

566
00:28:07,000 --> 00:28:08,000
or maybe not a problem,

567
00:28:08,000 --> 00:28:10,000
but an implementation detail of,

568
00:28:10,000 --> 00:28:11,000
when you write a class in Swift,

569
00:28:11,000 --> 00:28:13,000
you actually call the Objective-C runtime.

570
00:28:13,000 --> 00:28:14,000
Oh, really?

571
00:28:14,000 --> 00:28:16,000
And that has a lot of memory overhead, yes,

572
00:28:16,000 --> 00:28:19,000
compared to a Swift struct.

573
00:28:19,000 --> 00:28:20,000
So, if you write, for instance,

574
00:28:20,000 --> 00:28:21,000
you have a user model,

575
00:28:21,000 --> 00:28:23,000
and you want to write it as a struct,

576
00:28:23,000 --> 00:28:27,000
that is a lot lighter than writing the same model as a class.

577
00:28:27,000 --> 00:28:29,000
Now, there are some disadvantages of it,

578
00:28:29,000 --> 00:28:32,000
the big one being, in practical terms,

579
00:28:32,000 --> 00:28:34,000
that you cannot subclass a struct, right,

580
00:28:34,000 --> 00:28:35,000
because there's no such thing.

581
00:28:35,000 --> 00:28:37,000
Right, yeah, it's not...

582
00:28:37,000 --> 00:28:39,000
that makes perfect sense.

583
00:28:39,000 --> 00:28:40,000
So, it's interesting.

584
00:28:40,000 --> 00:28:43,000
Like, a lot of the supposed speed gains by Swift

585
00:28:43,000 --> 00:28:46,000
are by avoiding using OO.

586
00:28:46,000 --> 00:28:48,000
Right, because, I mean, what you...

587
00:28:48,000 --> 00:28:49,000
basically, they've stolen

588
00:28:49,000 --> 00:28:52,000
some of the fancier functional programming-style things, right?

589
00:28:52,000 --> 00:28:54,000
So, you can do all that stuff at compile time.

590
00:28:54,000 --> 00:28:56,000
You have all these structs that implement various interfaces.

591
00:28:56,000 --> 00:28:58,000
Exactly.

592
00:28:58,000 --> 00:29:00,000
Exactly, structs that implement various...

593
00:29:00,000 --> 00:29:01,000
what Swift calls protocols,

594
00:29:01,000 --> 00:29:05,000
but are effectively fancy interfaces with some extra sugar.

595
00:29:05,000 --> 00:29:08,000
Optionals, I think, in Swift are...

596
00:29:10,000 --> 00:29:13,000
solving a problem I'm not sure that real people have.

597
00:29:13,000 --> 00:29:15,000
So, let's talk about that more.

598
00:29:15,000 --> 00:29:19,000
Optionals, are we talking about, like, the maybe monad?

599
00:29:20,000 --> 00:29:21,000
Kind of.

600
00:29:21,000 --> 00:29:23,000
It's slightly different.

601
00:29:23,000 --> 00:29:25,000
So, for instance, if we had, like,

602
00:29:25,000 --> 00:29:30,000
var Mike underscore name string,

603
00:29:30,000 --> 00:29:32,000
colon string,

604
00:29:32,000 --> 00:29:34,000
and we put a question mark on the inner string,

605
00:29:34,000 --> 00:29:36,000
that's an optional.

606
00:29:36,000 --> 00:29:38,000
Swift does... and this is...

607
00:29:38,000 --> 00:29:40,000
I mean, monads do the same thing, they unwrap it,

608
00:29:40,000 --> 00:29:45,000
but the way the Swift kind of runtime implements that

609
00:29:45,000 --> 00:29:48,000
is...

610
00:29:48,000 --> 00:29:51,000
it's very strange.

611
00:29:51,000 --> 00:29:53,000
The idea being that you should never be able...

612
00:29:53,000 --> 00:29:55,000
the compiler should catch you

613
00:29:55,000 --> 00:29:58,000
from calling an optional that could be nil.

614
00:29:58,000 --> 00:30:00,000
Right, so you've already accounted for it

615
00:30:00,000 --> 00:30:02,000
at a higher level of abstraction,

616
00:30:02,000 --> 00:30:03,000
and the compiler can read it.

617
00:30:03,000 --> 00:30:06,000
Well, no, if you have an optional and it could be nil,

618
00:30:06,000 --> 00:30:07,000
you have to do something with it.

619
00:30:07,000 --> 00:30:08,000
Right.

620
00:30:08,000 --> 00:30:10,000
Yeah, you have to handle the case of this might be nil.

621
00:30:10,000 --> 00:30:11,000
Right.

622
00:30:13,000 --> 00:30:16,000
But it really makes your code kind of crappy and messy.

623
00:30:17,000 --> 00:30:20,000
You wind up in these weird pyramid structures like...

624
00:30:20,000 --> 00:30:22,000
it...

625
00:30:22,000 --> 00:30:25,000
nil or if unwrap, whatever, right?

626
00:30:25,000 --> 00:30:27,000
There's a million ways to do it in Swift.

627
00:30:27,000 --> 00:30:29,000
Where it's just like...

628
00:30:30,000 --> 00:30:32,000
I would love to know,

629
00:30:32,000 --> 00:30:34,000
and I'm sure there's no way to find this out,

630
00:30:34,000 --> 00:30:37,000
how many people who are writing Objective-C

631
00:30:38,000 --> 00:30:40,000
actually crash their applications

632
00:30:40,000 --> 00:30:43,000
because they forgot to initialize a variable?

633
00:30:45,000 --> 00:30:46,000
In like real-world cases,

634
00:30:46,000 --> 00:30:48,000
I'm not talking about like during dev time.

635
00:30:48,000 --> 00:30:51,000
Right, you're talking about like of problems out

636
00:30:51,000 --> 00:30:52,000
in the production world.

637
00:30:52,000 --> 00:30:53,000
In the production world.

638
00:30:53,000 --> 00:30:56,000
Of errors that users care about and are having

639
00:30:56,000 --> 00:30:59,000
was like nullability, was stuff like that.

640
00:30:59,000 --> 00:31:00,000
Was that really a problem?

641
00:31:00,000 --> 00:31:02,000
Was that the first thing on the list that needed to be solved?

642
00:31:02,000 --> 00:31:06,000
And is it worth the overhead of reasoning about it so explicitly?

643
00:31:06,000 --> 00:31:08,000
Because the level of complexity

644
00:31:08,000 --> 00:31:11,000
that the optional system brings to Swift

645
00:31:12,000 --> 00:31:15,000
is just much greater than handling values,

646
00:31:15,000 --> 00:31:17,000
variable values in Objective-C.

647
00:31:17,000 --> 00:31:18,000
Now, it's interesting,

648
00:31:18,000 --> 00:31:20,000
because you come from more of a functional world, right?

649
00:31:20,000 --> 00:31:22,000
You might tell me, well, this is just how life is.

650
00:31:23,000 --> 00:31:24,000
Well, you know, actually, it's interesting.

651
00:31:24,000 --> 00:31:26,000
I think that's one...

652
00:31:27,000 --> 00:31:31,000
It's an ergonomics question in some ways, right?

653
00:31:31,000 --> 00:31:33,000
You can have arguments about safety and other things,

654
00:31:33,000 --> 00:31:34,000
but at the end of the day,

655
00:31:34,000 --> 00:31:36,000
you're probably paying developers to make products

656
00:31:36,000 --> 00:31:38,000
for users who are paying for it and they want...

657
00:31:38,000 --> 00:31:40,000
I mean, speed has to be a factor

658
00:31:40,000 --> 00:31:42,000
as much as correctness at times.

659
00:31:42,000 --> 00:31:44,000
Obviously, you want correct code.

660
00:31:44,000 --> 00:31:45,000
But as you say,

661
00:31:45,000 --> 00:31:50,000
there might be some times where it does add a lot of overhead.

662
00:31:50,000 --> 00:31:52,000
And there are other ways to deal with it,

663
00:31:52,000 --> 00:31:55,000
stuff like nil-punning from the Lisp world, maybe.

664
00:31:55,000 --> 00:31:57,000
Obviously, there's tons of languages...

665
00:31:57,000 --> 00:31:59,000
What is that, if you can just jump in?

666
00:31:59,000 --> 00:32:02,000
Well, treating, having null or nil,

667
00:32:03,000 --> 00:32:07,000
but having a lot of your core built-in functions

668
00:32:07,000 --> 00:32:09,000
have an understanding of that.

669
00:32:09,000 --> 00:32:11,000
So instead of throwing a horrible exception,

670
00:32:11,000 --> 00:32:13,000
it just returns the value that sort of makes sense for that.

671
00:32:13,000 --> 00:32:16,000
So if you try to get the next part of an empty list,

672
00:32:16,000 --> 00:32:19,000
you might get back nil, so you can sort of check for that.

673
00:32:19,000 --> 00:32:23,000
And if you have nil also have a falseness to it,

674
00:32:24,000 --> 00:32:28,000
then you can do sort of truthy evaluations that way too.

675
00:32:28,000 --> 00:32:29,000
So there are some ways...

676
00:32:29,000 --> 00:32:31,000
It's not as explicit, right?

677
00:32:31,000 --> 00:32:32,000
You don't always...

678
00:32:32,000 --> 00:32:34,000
You don't have the compiler to help you in that same way.

679
00:32:34,000 --> 00:32:35,000
Another approach I can think of

680
00:32:35,000 --> 00:32:38,000
is we were talking about Elixir and Erlang earlier.

681
00:32:39,000 --> 00:32:41,000
And Erlang has an interesting sort of solution

682
00:32:41,000 --> 00:32:45,000
where a lot of times you end up coding on the so-called happy path,

683
00:32:45,000 --> 00:32:47,000
and not because you aren't thinking about failure,

684
00:32:47,000 --> 00:32:50,000
but because you've planned at it in a higher level.

685
00:32:50,000 --> 00:32:51,000
So you might have these...

686
00:32:51,000 --> 00:32:54,000
They have these supervision trees where you have one process.

687
00:32:54,000 --> 00:32:58,000
Let's say you need to go download like a list of 200 URLs

688
00:32:58,000 --> 00:33:00,000
that your user has inputted to you.

689
00:33:00,000 --> 00:33:02,000
So you spawn a process maybe for each of those

690
00:33:02,000 --> 00:33:04,000
to go off and go fetch that URL,

691
00:33:04,000 --> 00:33:06,000
then you aggregate it in some data structure somewhere.

692
00:33:06,000 --> 00:33:08,000
Well, each of those might fail, right?

693
00:33:08,000 --> 00:33:09,000
Like that might be a bad URL,

694
00:33:09,000 --> 00:33:10,000
or that server's having a problem

695
00:33:10,000 --> 00:33:12,000
and you need to retry it.

696
00:33:12,000 --> 00:33:13,000
As you launch all these processes,

697
00:33:13,000 --> 00:33:15,000
you can put those stuff in, right?

698
00:33:15,000 --> 00:33:16,000
You can say like,

699
00:33:16,000 --> 00:33:18,000
give it this number of allowed retries.

700
00:33:18,000 --> 00:33:20,000
Here's your threshold you should do.

701
00:33:20,000 --> 00:33:21,000
What happens when you fail?

702
00:33:21,000 --> 00:33:22,000
Do you come back up to the caller above,

703
00:33:22,000 --> 00:33:25,000
or do you launch a different error handling process?

704
00:33:25,000 --> 00:33:28,000
So then your actual code down in the deep stuff

705
00:33:28,000 --> 00:33:30,000
that's doing the HTTP request, say,

706
00:33:30,000 --> 00:33:32,000
well, it doesn't have to care about that so much.

707
00:33:32,000 --> 00:33:35,000
They have this philosophy of let it crash.

708
00:33:35,000 --> 00:33:38,000
So you expect that that little process you spawned off,

709
00:33:38,000 --> 00:33:41,000
it might crash, but the supervisor watching it

710
00:33:41,000 --> 00:33:42,000
already knows how to handle that

711
00:33:42,000 --> 00:33:45,000
and has a policy procedure in place.

712
00:33:45,000 --> 00:33:47,000
See, that might be a better way.

713
00:33:47,000 --> 00:33:48,000
I mean, the one thing I think

714
00:33:48,000 --> 00:33:52,000
that the Swift optional kind of pattern gives you

715
00:33:52,000 --> 00:33:54,000
is that you can use optionals in a way

716
00:33:54,000 --> 00:33:58,000
to handle controller flow, right?

717
00:33:58,000 --> 00:34:03,000
So the thing that huge Swift people will tell you is,

718
00:34:03,000 --> 00:34:04,000
oh, the guard let statement.

719
00:34:04,000 --> 00:34:06,000
It's all about the guard let statement, right?

720
00:34:06,000 --> 00:34:07,000
Have you seen this before, Wes?

721
00:34:07,000 --> 00:34:09,000
No, go into it a little more.

722
00:34:09,000 --> 00:34:12,000
So guard let is basically a fancy way to say

723
00:34:12,000 --> 00:34:17,000
if value is nil, let it be my values.

724
00:34:17,000 --> 00:34:21,000
But it is kind of one of the quote-unquote advanced,

725
00:34:21,000 --> 00:34:24,000
and I'm making snare quotes here, Swift tactics,

726
00:34:24,000 --> 00:34:26,000
to basically handle the optional case

727
00:34:26,000 --> 00:34:29,000
of something being nil.

728
00:34:29,000 --> 00:34:31,000
And it is certainly useful.

729
00:34:31,000 --> 00:34:34,000
I could see how that would be like a nice thing to have.

730
00:34:34,000 --> 00:34:38,000
But as I'm looking at C Sharp and other languages,

731
00:34:38,000 --> 00:34:42,000
particularly C Sharp's nullable implementation

732
00:34:42,000 --> 00:34:45,000
that is very similar to Swift's.

733
00:34:45,000 --> 00:34:51,000
I mean, it almost looks like directly inspired from Swift.

734
00:34:51,000 --> 00:34:55,000
I think we're just adding a lot of noise to our code.

735
00:34:55,000 --> 00:34:56,000
Right.

736
00:34:56,000 --> 00:34:59,000
I mean, I suppose this comes down to another question

737
00:34:59,000 --> 00:35:01,000
of like, where do you do your validation?

738
00:35:01,000 --> 00:35:02,000
Is it throughout,

739
00:35:02,000 --> 00:35:05,000
do you have sort of firmly validated borders at API calls

740
00:35:05,000 --> 00:35:07,000
or other gateways between libraries?

741
00:35:07,000 --> 00:35:09,000
And then do you just sort of assume things are working

742
00:35:09,000 --> 00:35:11,000
with ways to report exceptions?

743
00:35:11,000 --> 00:35:13,000
Or do you have something more like this,

744
00:35:13,000 --> 00:35:15,000
where it's type checked and everything is through

745
00:35:15,000 --> 00:35:16,000
and through validated,

746
00:35:16,000 --> 00:35:22,000
and you have rigorous error testing at each and every level?

747
00:35:22,000 --> 00:35:23,000
Right, because if you had already,

748
00:35:23,000 --> 00:35:25,000
I'm looking at an example here, right,

749
00:35:25,000 --> 00:35:26,000
where they have multiple guard lets,

750
00:35:26,000 --> 00:35:28,000
they're grabbing name field dot text

751
00:35:28,000 --> 00:35:30,000
and address field dot text.

752
00:35:30,000 --> 00:35:31,000
So they have options here, right,

753
00:35:31,000 --> 00:35:33,000
where so they have this guard let, they have a way to handle.

754
00:35:33,000 --> 00:35:34,000
Well, what if this is nil?

755
00:35:34,000 --> 00:35:35,000
Which is great.

756
00:35:35,000 --> 00:35:36,000
You do want to handle that.

757
00:35:36,000 --> 00:35:39,000
But maybe you also had a function somewhere else

758
00:35:39,000 --> 00:35:40,000
that already validated this whole data,

759
00:35:40,000 --> 00:35:42,000
turned it into a type that had everything there

760
00:35:42,000 --> 00:35:43,000
that wasn't nilable,

761
00:35:43,000 --> 00:35:47,000
and then you could pass it on to a simpler function.

762
00:35:47,000 --> 00:35:48,000
Yeah, I agree with that.

763
00:35:48,000 --> 00:35:49,000
I mean, I think it really comes down to,

764
00:35:49,000 --> 00:35:54,000
is this a problem that really needed to be solved?

765
00:35:54,000 --> 00:35:55,000
Yeah, okay.

766
00:35:55,000 --> 00:35:56,000
How would you compare it to,

767
00:35:56,000 --> 00:35:59,000
you were mentioning Kotlin earlier in the show.

768
00:35:59,000 --> 00:36:02,000
I have just heard rave reviews for how Kotlin handles nil,

769
00:36:02,000 --> 00:36:04,000
and so how would you compare those two?

770
00:36:04,000 --> 00:36:07,000
I think Kotlin's nil handling is less heavy-handed.

771
00:36:07,000 --> 00:36:11,000
I think it's a lot better.

772
00:36:11,000 --> 00:36:13,000
Now, Kotlin does come with a requirement

773
00:36:13,000 --> 00:36:16,000
to be compatible with Java and the JVM.

774
00:36:16,000 --> 00:36:18,000
Yep, yeah, sure.

775
00:36:18,000 --> 00:36:22,000
So it can't go quite as extreme as Swift?

776
00:36:22,000 --> 00:36:24,000
Right, yeah, I mean, as a compiled language,

777
00:36:24,000 --> 00:36:26,000
Swift can kind of reach farther,

778
00:36:26,000 --> 00:36:29,000
has less overhead, doesn't have a giant VM with it.

779
00:36:29,000 --> 00:36:30,000
Right.

780
00:36:30,000 --> 00:36:32,000
I mean, my general argument against Swift

781
00:36:32,000 --> 00:36:35,000
is that they've gone too far with this optional stuff, right?

782
00:36:35,000 --> 00:36:38,000
So I wonder if there's an analysis,

783
00:36:38,000 --> 00:36:41,000
like when you look at how people use Scala,

784
00:36:41,000 --> 00:36:42,000
it's all over the place,

785
00:36:42,000 --> 00:36:43,000
but you see some shops

786
00:36:43,000 --> 00:36:45,000
where they were trying to get people from Java

787
00:36:45,000 --> 00:36:46,000
to come over to Scala,

788
00:36:46,000 --> 00:36:50,000
and they had people there who were maybe former Haskellers

789
00:36:50,000 --> 00:36:52,000
or just really hardcore functional programmers.

790
00:36:52,000 --> 00:36:53,000
I've seen a lot of people who,

791
00:36:53,000 --> 00:36:55,000
they were interested in some of those techniques,

792
00:36:55,000 --> 00:36:57,000
but it was just like, it was a little too much,

793
00:36:57,000 --> 00:37:00,000
and it didn't focus on the top five problems

794
00:37:00,000 --> 00:37:03,000
that they had with Java.

795
00:37:03,000 --> 00:37:04,000
Like people, you know,

796
00:37:04,000 --> 00:37:06,000
you want them not having to type types everywhere,

797
00:37:06,000 --> 00:37:08,000
you want inference, you want those things,

798
00:37:08,000 --> 00:37:10,000
but maybe you don't need to have learned, like,

799
00:37:10,000 --> 00:37:13,000
a dozen things from category theory.

800
00:37:13,000 --> 00:37:17,000
Yeah, see, you've hit the point exactly.

801
00:37:17,000 --> 00:37:19,000
So in episode 104 of Coderadio,

802
00:37:19,000 --> 00:37:22,000
I was pretty negative on Swift when it was announced.

803
00:37:22,000 --> 00:37:24,000
It's legendary, I freaked out.

804
00:37:24,000 --> 00:37:28,000
104, everybody, go give that a re-listen.

805
00:37:28,000 --> 00:37:30,000
If you look at Swift and say,

806
00:37:30,000 --> 00:37:33,000
does this solve the problems of Objective-C?

807
00:37:33,000 --> 00:37:35,000
Well, first we'd have to agree on what the problems were.

808
00:37:35,000 --> 00:37:37,000
In my argument, you know,

809
00:37:37,000 --> 00:37:40,000
Swift solves the problem of Objective-C being kind of hard

810
00:37:40,000 --> 00:37:42,000
because it's basically a superset,

811
00:37:42,000 --> 00:37:45,000
I mean, not basically, it is a superset of C, right?

812
00:37:45,000 --> 00:37:47,000
Like you have to know C to do Objective-C.

813
00:37:47,000 --> 00:37:49,000
Right.

814
00:37:49,000 --> 00:37:51,000
And you have to know pointers,

815
00:37:51,000 --> 00:37:53,000
which I think Swift removes you having to know pointers.

816
00:37:53,000 --> 00:37:55,000
Right, and that is something of a mismatch maybe.

817
00:37:55,000 --> 00:37:57,000
It sort of depends, you know, right,

818
00:37:57,000 --> 00:37:59,000
because the targeting, like,

819
00:37:59,000 --> 00:38:01,000
what app you might be building could be different,

820
00:38:01,000 --> 00:38:03,000
and sometimes you might be building a simple app

821
00:38:03,000 --> 00:38:05,000
that does presentation pulling from some API.

822
00:38:05,000 --> 00:38:08,000
Okay, you probably don't care about pointers in that case.

823
00:38:08,000 --> 00:38:11,000
You're not doing anything fancy.

824
00:38:11,000 --> 00:38:13,000
Exactly, but they also removed

825
00:38:13,000 --> 00:38:15,000
one of the powers of the Objective-C runtime,

826
00:38:15,000 --> 00:38:17,000
which is being a messaging model

827
00:38:17,000 --> 00:38:20,000
where, you know, calling, like in Java,

828
00:38:20,000 --> 00:38:24,000
calling something a nil object is a null runtime exception, right?

829
00:38:24,000 --> 00:38:27,000
Yeah, famous NPE.

830
00:38:27,000 --> 00:38:29,000
Right, you can actually send a message

831
00:38:29,000 --> 00:38:31,000
to a nil object in Objective-C.

832
00:38:31,000 --> 00:38:34,000
Oh, almost like a small talk heritage.

833
00:38:34,000 --> 00:38:37,000
Well, it is a small talk heritage, exactly.

834
00:38:37,000 --> 00:38:41,000
Swift gives that up almost completely

835
00:38:41,000 --> 00:38:47,000
and says that if something is nil, something is wrong,

836
00:38:47,000 --> 00:38:51,000
which I just don't think is the case.

837
00:38:51,000 --> 00:38:55,000
If we're writing a complex application,

838
00:38:55,000 --> 00:38:57,000
it's my opinion that a language

839
00:38:57,000 --> 00:38:59,000
ought to be looser, not tighter,

840
00:38:59,000 --> 00:39:01,000
where Swift wants to try to solve

841
00:39:01,000 --> 00:39:04,000
every problem at compile time.

842
00:39:04,000 --> 00:39:07,000
The challenge with that is the code is,

843
00:39:07,000 --> 00:39:10,000
I mean, it can become really complicated.

844
00:39:10,000 --> 00:39:12,000
You have to understand a lot of concepts,

845
00:39:12,000 --> 00:39:15,000
like unwrapping the value of a variable.

846
00:39:15,000 --> 00:39:18,000
You have to understand like when structs versus classes

847
00:39:18,000 --> 00:39:22,000
are referenced by reference or referenced by value.

848
00:39:22,000 --> 00:39:26,000
And there's all kinds of weird edge cases

849
00:39:26,000 --> 00:39:28,000
that I think Swift actually adds

850
00:39:28,000 --> 00:39:32,000
where Objective-C was an incredibly simple language.

851
00:39:32,000 --> 00:39:33,000
I mean, it's C.

852
00:39:33,000 --> 00:39:35,000
Right, once you got past the C part.

853
00:39:35,000 --> 00:39:36,000
Once you got past the C part,

854
00:39:36,000 --> 00:39:39,000
the objective part is super simple.

855
00:39:39,000 --> 00:39:43,000
And I think Chris Latner, who developed Swift,

856
00:39:43,000 --> 00:39:47,000
would say the problem with Objective-C was that it was C.

857
00:39:47,000 --> 00:39:50,000
Right, like I just think that he just took

858
00:39:50,000 --> 00:39:52,000
the completely wrong design path.

859
00:39:52,000 --> 00:39:54,000
Right, like something closer to a C-sharp.

860
00:39:54,000 --> 00:39:56,000
And the irony now is, of course, the C-sharp

861
00:39:56,000 --> 00:39:59,000
is actually embracing the concepts of Swift.

862
00:39:59,000 --> 00:40:02,000
So Swift, even for our listeners who are not Apple people,

863
00:40:02,000 --> 00:40:06,000
Swift is going to influence your work either way.

864
00:40:06,000 --> 00:40:08,000
Yeah, that was kind of going to be my next question here,

865
00:40:08,000 --> 00:40:10,000
is there are obviously trade-offs,

866
00:40:10,000 --> 00:40:12,000
but is Swift the future?

867
00:40:12,000 --> 00:40:15,000
Even if you're not going to switch to Swift today,

868
00:40:15,000 --> 00:40:17,000
does Swift have stuff that developers

869
00:40:17,000 --> 00:40:19,000
should be paying attention to?

870
00:40:19,000 --> 00:40:21,000
Well, there's definitely a class of people

871
00:40:21,000 --> 00:40:23,000
inside of these big platform companies,

872
00:40:23,000 --> 00:40:25,000
Microsoft and Apple particularly,

873
00:40:25,000 --> 00:40:30,000
who feel that runtime null exceptions are a problem.

874
00:40:30,000 --> 00:40:33,000
And the Swift style of handling quote-unquote

875
00:40:33,000 --> 00:40:36,000
optionals against near quotes.

876
00:40:36,000 --> 00:40:40,000
I mean, just the fact that Swift and C-sharp are embracing it.

877
00:40:40,000 --> 00:40:43,000
C-sharp 8 is embracing it.

878
00:40:43,000 --> 00:40:44,000
That's huge, right?

879
00:40:44,000 --> 00:40:46,000
There's a lot of developers who work in those languages.

880
00:40:46,000 --> 00:40:47,000
Yeah.

881
00:40:47,000 --> 00:40:49,000
C-sharp more than Swift.

882
00:40:49,000 --> 00:40:54,000
So it may just become that the best practice is null,

883
00:40:54,000 --> 00:40:58,000
nil, or C-sharp calls it null, right?

884
00:40:58,000 --> 00:41:00,000
Nill and null can mean different things.

885
00:41:00,000 --> 00:41:03,000
This idea of nothing, of no value, yeah.

886
00:41:03,000 --> 00:41:06,000
Right.

887
00:41:06,000 --> 00:41:10,000
It is definitely...

888
00:41:10,000 --> 00:41:12,000
Geez, I don't want to say something too crazy,

889
00:41:12,000 --> 00:41:15,000
but I feel like this is the end of the small talk heritage

890
00:41:15,000 --> 00:41:16,000
in a lot of ways.

891
00:41:16,000 --> 00:41:18,000
Of the idea of message sending.

892
00:41:18,000 --> 00:41:19,000
This is it.

893
00:41:19,000 --> 00:41:20,000
This is full compiled.

894
00:41:20,000 --> 00:41:22,000
Everything I compile time.

895
00:41:22,000 --> 00:41:23,000
Oh, yeah.

896
00:41:23,000 --> 00:41:24,000
No, I think you're spot on there.

897
00:41:24,000 --> 00:41:25,000
We have lost...

898
00:41:25,000 --> 00:41:27,000
And I think it's a shame that not more people have experienced

899
00:41:27,000 --> 00:41:30,000
the dynamic nature of small talk.

900
00:41:30,000 --> 00:41:33,000
I mean, you were in a whole system designed

901
00:41:33,000 --> 00:41:35,000
and explorable and changeable by you.

902
00:41:35,000 --> 00:41:38,000
And when you go really heavy, you know,

903
00:41:38,000 --> 00:41:40,000
static types and all compiled beforehand,

904
00:41:40,000 --> 00:41:41,000
there's obviously a lot of benefits, right?

905
00:41:41,000 --> 00:41:44,000
From speed, from reasoning about the application,

906
00:41:44,000 --> 00:41:45,000
to IDE benefits.

907
00:41:45,000 --> 00:41:49,000
But you do lose that dynamic nature.

908
00:41:49,000 --> 00:41:51,000
Yeah, you definitely do.

909
00:41:51,000 --> 00:41:55,000
So it's hard to go, you know, you can't necessarily easily...

910
00:41:55,000 --> 00:41:56,000
Some things you can.

911
00:41:56,000 --> 00:41:59,000
But, you know, go pull up a REPL inside your application

912
00:41:59,000 --> 00:42:03,000
and investigate it or go inside and explore values at runtime.

913
00:42:03,000 --> 00:42:06,000
Well, and there's just a lot of extra like crud code

914
00:42:06,000 --> 00:42:11,000
you have to write just to like handle all the compiler's demands

915
00:42:11,000 --> 00:42:14,000
where you might know that something will never,

916
00:42:14,000 --> 00:42:17,000
ever, ever, ever, ever be null or new.

917
00:42:17,000 --> 00:42:21,000
But the compiler forces you to name it an optional, right?

918
00:42:21,000 --> 00:42:22,000
Yep.

919
00:42:22,000 --> 00:42:25,000
I think one thing we're hitting on is,

920
00:42:25,000 --> 00:42:29,000
obviously, one goal of programmers is to be able to understand

921
00:42:29,000 --> 00:42:30,000
the applications they develop.

922
00:42:30,000 --> 00:42:33,000
And oftentimes we're in zones where we don't...

923
00:42:33,000 --> 00:42:35,000
You can't have the whole pipeline in your head, right?

924
00:42:35,000 --> 00:42:36,000
It's just too big.

925
00:42:36,000 --> 00:42:39,000
And so I think that's where a lot of the value and motivation

926
00:42:39,000 --> 00:42:41,000
for some of these more heavy-handed

927
00:42:41,000 --> 00:42:45,000
static typing applications come from.

928
00:42:45,000 --> 00:42:46,000
Personally, though, I mean,

929
00:42:46,000 --> 00:42:48,000
I think kind of what you're maybe getting at

930
00:42:48,000 --> 00:42:50,000
is simplicity is also important.

931
00:42:50,000 --> 00:42:51,000
And while we...

932
00:42:51,000 --> 00:42:53,000
Right, like simplicity is maybe one of the key ways

933
00:42:53,000 --> 00:42:56,000
that you can get to actually reasoning about your program.

934
00:42:56,000 --> 00:42:57,000
And maybe the compiler helps you less.

935
00:42:57,000 --> 00:43:01,000
But if the result of that is you have a simple three-line function

936
00:43:01,000 --> 00:43:04,000
that you can just read and understand,

937
00:43:04,000 --> 00:43:05,000
that might be worth it.

938
00:43:05,000 --> 00:43:08,000
Yeah, I think the best programming language

939
00:43:08,000 --> 00:43:11,000
gives you very little tools, and it's just very simple.

940
00:43:11,000 --> 00:43:13,000
That's one of the things I love about Objective-C.

941
00:43:13,000 --> 00:43:15,000
For everybody who's complaining, or everybody,

942
00:43:15,000 --> 00:43:19,000
but for a large percentage of the community who's complaining,

943
00:43:19,000 --> 00:43:24,000
Objective-C was actually an extremely simple language.

944
00:43:24,000 --> 00:43:27,000
You sent messages to objects.

945
00:43:27,000 --> 00:43:29,000
You had all the C, you know, if...

946
00:43:29,000 --> 00:43:32,000
Everything at that level was a C, right?

947
00:43:32,000 --> 00:43:37,000
All the control flow statements, if, while, whatever.

948
00:43:37,000 --> 00:43:39,000
And you had a few add-ons to that.

949
00:43:39,000 --> 00:43:41,000
But that was it.

950
00:43:41,000 --> 00:43:43,000
Anything else you wanted to do,

951
00:43:43,000 --> 00:43:46,000
you had to pull in a library and implement it that way.

952
00:43:46,000 --> 00:43:49,000
Or implement it yourself.

953
00:43:49,000 --> 00:43:54,000
Where I feel that particularly Swift is trying to say

954
00:43:54,000 --> 00:43:57,000
everything's built in.

955
00:43:57,000 --> 00:43:59,000
And where the Smith...

956
00:43:59,000 --> 00:44:01,000
Oh, well, kind of. Is it functional?

957
00:44:01,000 --> 00:44:03,000
Eh, kind of. Is it protocol-oriented?

958
00:44:03,000 --> 00:44:06,000
Whatever that means, kind of, right?

959
00:44:06,000 --> 00:44:10,000
Like, it's basically everything to everybody

960
00:44:10,000 --> 00:44:13,000
while being nothing to no one.

961
00:44:13,000 --> 00:44:18,000
And I guess that is a danger of broad languages sometimes,

962
00:44:18,000 --> 00:44:21,000
is you don't have one set right way of doing things,

963
00:44:21,000 --> 00:44:24,000
you don't have one target audience, you are general.

964
00:44:24,000 --> 00:44:27,000
Okay, well, I'll be curious to see how this evolves.

965
00:44:27,000 --> 00:44:29,000
You know, clearly there's a trend right now,

966
00:44:29,000 --> 00:44:32,000
static typing, a lot of these tool sets and ideas

967
00:44:32,000 --> 00:44:34,000
are kind of in vogue.

968
00:44:34,000 --> 00:44:36,000
And I think in many ways, for the right reasons,

969
00:44:36,000 --> 00:44:39,000
we did have an era, perhaps you might call it the tar pit,

970
00:44:39,000 --> 00:44:43,000
of kind of overly complex, object-oriented programs

971
00:44:43,000 --> 00:44:45,000
that had a lot of mutable state

972
00:44:45,000 --> 00:44:47,000
and were pulling on each other's strings

973
00:44:47,000 --> 00:44:49,000
and were pretty hard to reason about.

974
00:44:49,000 --> 00:44:51,000
And a lot of the ideas in Swift, for example,

975
00:44:51,000 --> 00:44:53,000
are some ways to try to deal with that.

976
00:44:53,000 --> 00:44:55,000
So I'm glad we're at least doing it.

977
00:44:55,000 --> 00:44:58,000
I don't know if, you know, we probably won't find one solution.

978
00:44:58,000 --> 00:45:00,000
We'll see if Swift gets better

979
00:45:00,000 --> 00:45:02,000
and what your take on it in the future is, Mr. Dominic.

980
00:45:02,000 --> 00:45:04,000
I'm curious.

981
00:45:04,000 --> 00:45:07,000
I just saw you over on that there Twitterverse

982
00:45:07,000 --> 00:45:10,000
tweeting away about serverless.

983
00:45:10,000 --> 00:45:12,000
And I was kind of curious.

984
00:45:12,000 --> 00:45:15,000
There's kind of multiple ways you can use serverless.

985
00:45:15,000 --> 00:45:19,000
One is sort of a notion of like a little CPU cluster,

986
00:45:19,000 --> 00:45:21,000
a little cluster of compute that you have, say,

987
00:45:21,000 --> 00:45:23,000
like a cron job, maybe, where you say,

988
00:45:23,000 --> 00:45:27,000
hey, I want this to be run every so often or on a request.

989
00:45:27,000 --> 00:45:29,000
Do this little thing. It's a little mini computer.

990
00:45:29,000 --> 00:45:31,000
I just have one job to do,

991
00:45:31,000 --> 00:45:33,000
and it'll go send this off to another API.

992
00:45:33,000 --> 00:45:35,000
But then there's also, at least on a lot of the implementations

993
00:45:35,000 --> 00:45:37,000
we're seeing today,

994
00:45:37,000 --> 00:45:39,000
something that comes along with serverless

995
00:45:39,000 --> 00:45:41,000
is this sort of meshed network

996
00:45:41,000 --> 00:45:44,000
of different events that you can have, right?

997
00:45:44,000 --> 00:45:46,000
So you have, you know, AWS gives you

998
00:45:46,000 --> 00:45:48,000
a thousand and one different events that you can have

999
00:45:48,000 --> 00:45:50,000
key to trigger a lambda.

1000
00:45:50,000 --> 00:45:52,000
And so whether or not you really care about the compute,

1001
00:45:52,000 --> 00:45:55,000
you might just care about having that event system.

1002
00:45:55,000 --> 00:45:57,000
I'm curious what you're using it for,

1003
00:45:57,000 --> 00:46:00,000
both business and pleasure.

1004
00:46:00,000 --> 00:46:02,000
Yeah, so it's a lot of data processing,

1005
00:46:02,000 --> 00:46:05,000
but you're not wrong that it's the event queue.

1006
00:46:05,000 --> 00:46:08,000
When something happens, you know, run this,

1007
00:46:08,000 --> 00:46:13,000
you know, very tight F sharp or node function.

1008
00:46:13,000 --> 00:46:16,000
Are you running F sharp lambdas over there?

1009
00:46:16,000 --> 00:46:18,000
Yeah, yeah.

1010
00:46:18,000 --> 00:46:21,000
Oh, man. And you weren't even going to mention that.

1011
00:46:21,000 --> 00:46:24,000
Okay, so I was at a dance social,

1012
00:46:24,000 --> 00:46:26,000
and I met this guy named F sharp.

1013
00:46:26,000 --> 00:46:28,000
So F sharp's not bad, right?

1014
00:46:28,000 --> 00:46:30,000
F sharp is fast.

1015
00:46:30,000 --> 00:46:32,000
No, I think it's undervalued, honestly.

1016
00:46:32,000 --> 00:46:34,000
Yeah, I think it's weirdly underappreciated

1017
00:46:34,000 --> 00:46:37,000
because it runs actually really, really well on Linux.

1018
00:46:37,000 --> 00:46:41,000
And it's kind of the bastard child

1019
00:46:41,000 --> 00:46:44,000
of the.NET community in a lot of ways.

1020
00:46:44,000 --> 00:46:47,000
It's like if you told me you wanted me to write

1021
00:46:47,000 --> 00:46:49,000
a serverless function for you,

1022
00:46:49,000 --> 00:46:52,000
and you gave me a choice between node and F sharp,

1023
00:46:52,000 --> 00:46:55,000
I would probably be tempted to go F sharp.

1024
00:46:55,000 --> 00:46:57,000
Yeah, I mean, I can see why, right?

1025
00:46:57,000 --> 00:47:00,000
You get like a real runtime with real concurrency.

1026
00:47:00,000 --> 00:47:02,000
You get...

1027
00:47:02,000 --> 00:47:04,000
It's a much purer language than JavaScript.

1028
00:47:04,000 --> 00:47:07,000
Yeah, you know, JavaScript, they keep adding a ton of stuff,

1029
00:47:07,000 --> 00:47:09,000
and at least they're trying to steal some good ideas,

1030
00:47:09,000 --> 00:47:13,000
but it is just never, ever going to be a pretty language.

1031
00:47:13,000 --> 00:47:15,000
Yeah, I mean, for the next version of Alice,

1032
00:47:15,000 --> 00:47:17,000
we are writing some of the...

1033
00:47:17,000 --> 00:47:20,000
So the architecture is a little unusual, I guess.

1034
00:47:20,000 --> 00:47:22,000
There's a lot of serverless components

1035
00:47:22,000 --> 00:47:25,000
that process various data issues

1036
00:47:25,000 --> 00:47:27,000
that have caused us problems in the past,

1037
00:47:27,000 --> 00:47:29,000
and many of them, if not all of them,

1038
00:47:29,000 --> 00:47:31,000
are going to be in F sharp.

1039
00:47:31,000 --> 00:47:33,000
So far, the three that exist are in F sharp.

1040
00:47:33,000 --> 00:47:36,000
So do you also then get some of the benefits

1041
00:47:36,000 --> 00:47:40,000
from that shared runtime, like good AWS API implementations

1042
00:47:40,000 --> 00:47:42,000
for that platform?

1043
00:47:42,000 --> 00:47:44,000
We don't give a crap, right?

1044
00:47:44,000 --> 00:47:46,000
So we throw it up on Lambda or Azure functions,

1045
00:47:46,000 --> 00:47:48,000
and they just handle it,

1046
00:47:48,000 --> 00:47:51,000
which is kind of the beauty of the whole serverless thing, right?

1047
00:47:51,000 --> 00:47:53,000
Yeah, you don't have to care.

1048
00:47:53,000 --> 00:47:55,000
You get everything built in for you.

1049
00:47:55,000 --> 00:47:57,000
You don't care at all.

1050
00:47:57,000 --> 00:48:00,000
And particularly for F sharp being more of a functional language,

1051
00:48:00,000 --> 00:48:02,000
a functional style...

1052
00:48:02,000 --> 00:48:04,000
I mean, Wes, if your experience is different,

1053
00:48:04,000 --> 00:48:07,000
a functional style on serverless, I have found,

1054
00:48:07,000 --> 00:48:10,000
has been kind of the best way to go, right?

1055
00:48:10,000 --> 00:48:12,000
You know, data comes in to the function,

1056
00:48:12,000 --> 00:48:14,000
data goes out.

1057
00:48:14,000 --> 00:48:16,000
Yeah, it's very data-oriented,

1058
00:48:16,000 --> 00:48:18,000
and you end up, a lot of times,

1059
00:48:18,000 --> 00:48:20,000
you're building pipelines, right?

1060
00:48:20,000 --> 00:48:22,000
I mean, they're broken apart,

1061
00:48:22,000 --> 00:48:24,000
but you're just grabbing some data,

1062
00:48:24,000 --> 00:48:26,000
you're transforming it or analyzing it

1063
00:48:26,000 --> 00:48:28,000
or sending it to a database.

1064
00:48:28,000 --> 00:48:30,000
You're doing something with it and passing it along.

1065
00:48:30,000 --> 00:48:32,000
Yeah, it's...

1066
00:48:32,000 --> 00:48:34,000
It's a lot of languages.

1067
00:48:34,000 --> 00:48:36,000
But if you are...

1068
00:48:36,000 --> 00:48:38,000
curious,

1069
00:48:38,000 --> 00:48:40,000
go to fsharp.org,

1070
00:48:40,000 --> 00:48:42,000
and I would say that,

1071
00:48:42,000 --> 00:48:44,000
of the.NET languages,

1072
00:48:44,000 --> 00:48:46,000
and I've been a pretty pro C sharp guy,

1073
00:48:46,000 --> 00:48:48,000
I think F sharp is probably

1074
00:48:48,000 --> 00:48:50,000
the best language Microsoft has ever produced.

1075
00:48:50,000 --> 00:48:52,000
And now, they have...

1076
00:48:52,000 --> 00:48:54,000
I mean, it's a completely false language.

1077
00:48:54,000 --> 00:48:56,000
Yeah, right? I mean, now that we have.NET Core,

1078
00:48:56,000 --> 00:48:58,000
it's... Go run it.

1079
00:48:58,000 --> 00:49:00,000
There's actually an F sharp foundation by itself.

1080
00:49:00,000 --> 00:49:02,000
Oh, really?

1081
00:49:02,000 --> 00:49:04,000
Yeah, because a lot of folks are using it

1082
00:49:04,000 --> 00:49:06,000
on Linux and BSD for, like,

1083
00:49:06,000 --> 00:49:08,000
genetic processing and data science.

1084
00:49:08,000 --> 00:49:10,000
F sharp has kind of gone its own way

1085
00:49:10,000 --> 00:49:12,000
from the whole.NET community. It's weird.

1086
00:49:12,000 --> 00:49:14,000
F sharp is... Yeah.

1087
00:49:14,000 --> 00:49:16,000
That is... That is very interesting.

1088
00:49:16,000 --> 00:49:18,000
Yeah, I mean...

1089
00:49:18,000 --> 00:49:20,000
You're probably right about that.

1090
00:49:20,000 --> 00:49:22,000
We should see more of it.

1091
00:49:22,000 --> 00:49:24,000
The.NET runtime is nice,

1092
00:49:24,000 --> 00:49:26,000
and F sharp has a lot of those principles.

1093
00:49:26,000 --> 00:49:28,000
You keep seeing C sharp pull ideas out of F sharp

1094
00:49:28,000 --> 00:49:30,000
and implement it over there,

1095
00:49:30,000 --> 00:49:32,000
so they must be doing something right.

1096
00:49:32,000 --> 00:49:34,000
Oh, C sharp will just take anything.

1097
00:49:34,000 --> 00:49:36,000
Oh, sorry.

1098
00:49:36,000 --> 00:49:38,000
But they do... I mean, they generally do it in a nice way,

1099
00:49:38,000 --> 00:49:40,000
like their async await implementation,

1100
00:49:40,000 --> 00:49:42,000
I think, was ahead of the pack and is pretty nice.

1101
00:49:44,000 --> 00:49:46,000
I think it is, yeah.

1102
00:49:46,000 --> 00:49:48,000
I mean, I think...

1103
00:49:48,000 --> 00:49:50,000
In fact, I think the async await API

1104
00:49:50,000 --> 00:49:52,000
is one of the things where other languages

1105
00:49:52,000 --> 00:49:54,000
have tried to implement it,

1106
00:49:54,000 --> 00:49:56,000
notably Java.

1107
00:49:56,000 --> 00:49:58,000
Python, too.

1108
00:49:58,000 --> 00:50:00,000
Oh, C sharp one.

1109
00:50:00,000 --> 00:50:02,000
Who did it?

1110
00:50:02,000 --> 00:50:04,000
I mean, Python is not quite the same,

1111
00:50:04,000 --> 00:50:06,000
but explored similar ideas

1112
00:50:06,000 --> 00:50:08,000
in the asynchronous world.

1113
00:50:10,000 --> 00:50:12,000
So, okay.

1114
00:50:12,000 --> 00:50:14,000
Maybe one of the themes here is simplicity.

1115
00:50:14,000 --> 00:50:16,000
How do you find that...

1116
00:50:16,000 --> 00:50:18,000
I feel like I've heard a lot of mixed reports

1117
00:50:18,000 --> 00:50:20,000
with serverless, both good and bad.

1118
00:50:20,000 --> 00:50:22,000
If you reach a certain scale,

1119
00:50:22,000 --> 00:50:24,000
then you just have to be distributed, right?

1120
00:50:24,000 --> 00:50:26,000
You don't have to break things apart.

1121
00:50:26,000 --> 00:50:28,000
You just can't have monoliths.

1122
00:50:28,000 --> 00:50:30,000
And so serverless is ready to meet that need.

1123
00:50:30,000 --> 00:50:32,000
But as maybe a smaller operation sometimes,

1124
00:50:32,000 --> 00:50:34,000
how...

1125
00:50:34,000 --> 00:50:36,000
When does it or does it not sort of...

1126
00:50:36,000 --> 00:50:38,000
You know, if you already have droplets,

1127
00:50:38,000 --> 00:50:40,000
you're already running stuff,

1128
00:50:40,000 --> 00:50:42,000
when do you write a cron job that just runs there

1129
00:50:42,000 --> 00:50:44,000
and you update a text file versus go deal

1130
00:50:44,000 --> 00:50:46,000
with the more complicated and higher abstractions

1131
00:50:46,000 --> 00:50:48,000
of something like serverless?

1132
00:50:48,000 --> 00:50:50,000
Serverless is when I want to use a...

1133
00:50:50,000 --> 00:50:52,000
I mean, and it will be different

1134
00:50:52,000 --> 00:50:54,000
for a bigger shop, right?

1135
00:50:54,000 --> 00:50:56,000
So listeners don't freak out.

1136
00:50:56,000 --> 00:50:58,000
For a small shop, cost of overhead is kind of

1137
00:50:58,000 --> 00:51:00,000
your raison d'etre, right?

1138
00:51:00,000 --> 00:51:02,000
Your driving principle.

1139
00:51:02,000 --> 00:51:04,000
So when I have something that might peg

1140
00:51:04,000 --> 00:51:06,000
the CPU on my droplet,

1141
00:51:06,000 --> 00:51:08,000
let's say my $10 a month droplet,

1142
00:51:08,000 --> 00:51:10,000
the cost of just running it

1143
00:51:10,000 --> 00:51:12,000
on an Azure function or a

1144
00:51:12,000 --> 00:51:14,000
Lambda instance on AWS

1145
00:51:14,000 --> 00:51:16,000
tends to be less

1146
00:51:16,000 --> 00:51:18,000
than having to go up a droplet permanently,

1147
00:51:18,000 --> 00:51:20,000
because that's kind of a permanent function on...

1148
00:51:20,000 --> 00:51:22,000
I use DO as my host.

1149
00:51:24,000 --> 00:51:26,000
Those are the kind of things that I...

1150
00:51:26,000 --> 00:51:28,000
So for instance, we used to have an old version

1151
00:51:28,000 --> 00:51:30,000
of Alice that processed via OCR

1152
00:51:30,000 --> 00:51:32,000
PDFs.

1153
00:51:32,000 --> 00:51:34,000
That always

1154
00:51:34,000 --> 00:51:36,000
pegged the CPU. Oh yeah, right, sure.

1155
00:51:36,000 --> 00:51:38,000
You're doing a bunch of graphics work.

1156
00:51:38,000 --> 00:51:40,000
Yep, we threw that into an Azure function

1157
00:51:40,000 --> 00:51:42,000
droplet running an F sharp library

1158
00:51:42,000 --> 00:51:44,000
with some custom

1159
00:51:44,000 --> 00:51:46,000
code, obviously, to function

1160
00:51:46,000 --> 00:51:48,000
and then to process the

1161
00:51:48,000 --> 00:51:50,000
PDF and then send back whatever relevant

1162
00:51:50,000 --> 00:51:52,000
data back to the DO droplet.

1163
00:51:54,000 --> 00:51:56,000
It's that kind of thing that we're using.

1164
00:51:56,000 --> 00:51:58,000
Yeah, okay. So that makes a lot of sense.

1165
00:51:58,000 --> 00:52:00,000
So it's not kind of what I was thinking is you can

1166
00:52:00,000 --> 00:52:02,000
end up with these...

1167
00:52:02,000 --> 00:52:04,000
What used to be a bunch of code

1168
00:52:04,000 --> 00:52:06,000
in one library

1169
00:52:06,000 --> 00:52:08,000
for whatever language you're running

1170
00:52:08,000 --> 00:52:10,000
that split up into six different things that are each

1171
00:52:10,000 --> 00:52:12,000
with cues in between them, which are great, right?

1172
00:52:12,000 --> 00:52:14,000
Cues can be wonderful for decoupling,

1173
00:52:14,000 --> 00:52:16,000
but you also then have...

1174
00:52:16,000 --> 00:52:18,000
You come to the operational side and now you have like six different

1175
00:52:18,000 --> 00:52:20,000
cues that the back pressure you have to monitor

1176
00:52:20,000 --> 00:52:22,000
on and understand where things can

1177
00:52:22,000 --> 00:52:24,000
fail in each of the phases between the

1178
00:52:24,000 --> 00:52:26,000
pipelines.

1179
00:52:26,000 --> 00:52:28,000
But I guess if you're

1180
00:52:28,000 --> 00:52:30,000
using it as more of a standalone thing, something a little bit

1181
00:52:30,000 --> 00:52:32,000
simpler that just sort of runs and churns with a little bit of

1182
00:52:32,000 --> 00:52:34,000
data and puts it somewhere else and you don't have to think about it,

1183
00:52:34,000 --> 00:52:36,000
then it makes sense.

1184
00:52:36,000 --> 00:52:38,000
I've been looking...

1185
00:52:38,000 --> 00:52:40,000
It's a big cost saving too, right? It's a performance

1186
00:52:40,000 --> 00:52:42,000
and cost saving. Right, so even

1187
00:52:42,000 --> 00:52:44,000
if there was a little bit of operational overhead

1188
00:52:44,000 --> 00:52:46,000
or just having to adopt this new system,

1189
00:52:46,000 --> 00:52:48,000
integrating whatever monitoring you already had

1190
00:52:48,000 --> 00:52:50,000
with the rest of the AWS stack,

1191
00:52:50,000 --> 00:52:52,000
the fact that it's

1192
00:52:52,000 --> 00:52:54,000
pretty darn cheap if you're not doing crazy things

1193
00:52:54,000 --> 00:52:56,000
with it, that's a big seller.

1194
00:52:56,000 --> 00:52:58,000
Exactly. Well, and it's cheap if you're only doing

1195
00:52:58,000 --> 00:53:00,000
stuff every once in a while.

1196
00:53:00,000 --> 00:53:02,000
Right, it doesn't have to handle every request,

1197
00:53:02,000 --> 00:53:04,000
but if it does enough of those background

1198
00:53:04,000 --> 00:53:06,000
jobs to just keep the data fresh.

1199
00:53:06,000 --> 00:53:08,000
That's exactly it.

1200
00:53:08,000 --> 00:53:10,000
Interesting.

1201
00:53:10,000 --> 00:53:12,000
I've been looking at...

1202
00:53:12,000 --> 00:53:14,000
So it's by the

1203
00:53:14,000 --> 00:53:16,000
consultancy Cognitech that makes

1204
00:53:16,000 --> 00:53:18,000
Clojure actually.

1205
00:53:18,000 --> 00:53:20,000
They have a new project. They've got this

1206
00:53:20,000 --> 00:53:22,000
fancy functional sort of database called

1207
00:53:22,000 --> 00:53:24,000
Datomic, and they recently

1208
00:53:24,000 --> 00:53:26,000
launched it as a

1209
00:53:26,000 --> 00:53:28,000
AWS marketplace application, so you can

1210
00:53:28,000 --> 00:53:30,000
go spin it up. It costs like a production,

1211
00:53:30,000 --> 00:53:32,000
like the base version is probably like a dollar

1212
00:53:32,000 --> 00:53:34,000
a day.

1213
00:53:34,000 --> 00:53:36,000
It is proprietary, so that's not

1214
00:53:36,000 --> 00:53:38,000
great, but they have an interesting new feature

1215
00:53:38,000 --> 00:53:40,000
called Ions,

1216
00:53:40,000 --> 00:53:42,000
which is trying to leverage some of

1217
00:53:42,000 --> 00:53:44,000
those, like the serverless idea.

1218
00:53:44,000 --> 00:53:46,000
So they, you know, you go by their system,

1219
00:53:46,000 --> 00:53:48,000
they'll spin up with all the necessary

1220
00:53:48,000 --> 00:53:50,000
stuff. They've got a DynamoDB,

1221
00:53:50,000 --> 00:53:52,000
they've got a Postgres instance, it's all managed, already spun

1222
00:53:52,000 --> 00:53:54,000
up. They have all the cloud formation written

1223
00:53:54,000 --> 00:53:56,000
for you, right? And that just happens.

1224
00:53:56,000 --> 00:53:58,000
And they've got like a super tiny

1225
00:53:58,000 --> 00:54:00,000
simple wrapper,

1226
00:54:00,000 --> 00:54:02,000
and the rest of it you do with the tools

1227
00:54:02,000 --> 00:54:04,000
you would already use, like the command line

1228
00:54:04,000 --> 00:54:06,000
tools for developing Clojure and Git.

1229
00:54:06,000 --> 00:54:08,000
And then you basically write,

1230
00:54:08,000 --> 00:54:10,000
you write pieces of code,

1231
00:54:10,000 --> 00:54:12,000
commit them and push them,

1232
00:54:12,000 --> 00:54:14,000
and then it does the rest. It will

1233
00:54:14,000 --> 00:54:16,000
spin up new lambdas for you, it actually has a little

1234
00:54:16,000 --> 00:54:18,000
proxy thing that runs that you configure,

1235
00:54:18,000 --> 00:54:20,000
it gets a call, and then

1236
00:54:20,000 --> 00:54:22,000
all your code actually runs

1237
00:54:22,000 --> 00:54:24,000
on the database that you're running already.

1238
00:54:24,000 --> 00:54:26,000
So it gets code locality with the

1239
00:54:26,000 --> 00:54:28,000
database, and you don't have

1240
00:54:28,000 --> 00:54:30,000
to manage or talk to any of the AWS

1241
00:54:30,000 --> 00:54:32,000
APIs. You just like add a new function, add

1242
00:54:32,000 --> 00:54:34,000
a little metadata that says like, oh this is going to be a new

1243
00:54:34,000 --> 00:54:36,000
Ion, push it up,

1244
00:54:36,000 --> 00:54:38,000
and then everything updates for you.

1245
00:54:38,000 --> 00:54:40,000
Now do I have to interface with this

1246
00:54:40,000 --> 00:54:42,000
enclosure? No, you don't.

1247
00:54:42,000 --> 00:54:44,000
A lot of the benefits are

1248
00:54:44,000 --> 00:54:46,000
better if you do, but

1249
00:54:46,000 --> 00:54:48,000
Titanic has APIs for all kinds of

1250
00:54:48,000 --> 00:54:50,000
stuff. I just thought it was an

1251
00:54:50,000 --> 00:54:52,000
interesting take of like, people clearly

1252
00:54:52,000 --> 00:54:54,000
like the on-demand, they like the

1253
00:54:54,000 --> 00:54:56,000
performance and scaling models of

1254
00:54:56,000 --> 00:54:58,000
serverless, and they like having access to all

1255
00:54:58,000 --> 00:55:00,000
of these, like the rich infrastructure of AWS

1256
00:55:00,000 --> 00:55:02,000
events, but maybe they don't

1257
00:55:02,000 --> 00:55:04,000
like, I mean I don't love cloud formation,

1258
00:55:04,000 --> 00:55:06,000
I don't love dealing with and deploying on AWS

1259
00:55:06,000 --> 00:55:08,000
that much either.

1260
00:55:08,000 --> 00:55:10,000
I'm not a huge fan of that whole model either.

1261
00:55:12,000 --> 00:55:14,000
So it's something to check out if people are

1262
00:55:14,000 --> 00:55:16,000
interested in it. The other nice part is

1263
00:55:16,000 --> 00:55:18,000
Titanic's got this idea of a

1264
00:55:18,000 --> 00:55:20,000
database as a value.

1265
00:55:20,000 --> 00:55:22,000
And so instead of having to worry

1266
00:55:22,000 --> 00:55:24,000
about, basically reads are essentially

1267
00:55:24,000 --> 00:55:26,000
free all the time, and you'll never get, like you

1268
00:55:26,000 --> 00:55:28,000
request data at a time, and it

1269
00:55:28,000 --> 00:55:30,000
never changes out from under you. You just get this

1270
00:55:30,000 --> 00:55:32,000
like, immutable value. If you want to go

1271
00:55:32,000 --> 00:55:34,000
check the database at a previous time, you just ask

1272
00:55:34,000 --> 00:55:36,000
for it at that time, or you can get the newest

1273
00:55:36,000 --> 00:55:38,000
value. So

1274
00:55:38,000 --> 00:55:40,000
it's not for, you know,

1275
00:55:40,000 --> 00:55:42,000
keeping all of your time series data,

1276
00:55:42,000 --> 00:55:44,000
but for meaningful IT, like business

1277
00:55:44,000 --> 00:55:46,000
application data, there's a lot

1278
00:55:46,000 --> 00:55:48,000
of benefits to it.

1279
00:55:48,000 --> 00:55:50,000
Very cool.

1280
00:55:50,000 --> 00:55:52,000
That is actually very cool.

1281
00:55:52,000 --> 00:55:54,000
Yeah, we'll have some links. This is episode

1282
00:55:54,000 --> 00:55:56,000
340, so coder.radio

1283
00:55:56,000 --> 00:55:58,000
slash

1284
00:55:58,000 --> 00:56:00,000
340. You can go find

1285
00:56:00,000 --> 00:56:02,000
all the links to everything we've talked about.

1286
00:56:02,000 --> 00:56:04,000
You can find the past episodes.

1287
00:56:04,000 --> 00:56:06,000
Mr. Domingo, where do you want to send

1288
00:56:06,000 --> 00:56:08,000
people this week? I would like to send

1289
00:56:08,000 --> 00:56:10,000
them to themadbotter.com.

1290
00:56:10,000 --> 00:56:12,000
Oh, yeah.

1291
00:56:12,000 --> 00:56:14,000
Stay looking out

1292
00:56:14,000 --> 00:56:16,000
for more updates. It sounds like Alice has

1293
00:56:16,000 --> 00:56:18,000
quite the future ahead of you.

1294
00:56:18,000 --> 00:56:20,000
How about ask

1295
00:56:20,000 --> 00:56:22,000
at West, at Noble Pain on Twitter, huh?

1296
00:56:22,000 --> 00:56:24,000
It's at West Pain, which is confusing.

1297
00:56:24,000 --> 00:56:26,000
Someone already, I've had that

1298
00:56:26,000 --> 00:56:28,000
one for like ever, and someone has the other

1299
00:56:28,000 --> 00:56:30,000
one. I'm thinking about messaging.

1300
00:56:30,000 --> 00:56:32,000
So yeah, I've been sending nudie pics to the

1301
00:56:32,000 --> 00:56:34,000
wrong Twitter. Oh, well, please do make sure

1302
00:56:34,000 --> 00:56:36,000
you forward those. And

1303
00:56:36,000 --> 00:56:38,000
for people who have other stuff, not nudie

1304
00:56:38,000 --> 00:56:40,000
pictures, you can find the whole network

1305
00:56:40,000 --> 00:56:42,000
at Jupiter Signal. Of course,

1306
00:56:42,000 --> 00:56:44,000
you can go to jupiterbroadcasting.com. If you want

1307
00:56:44,000 --> 00:56:46,000
to find out when we're live, well, there's a calendar

1308
00:56:46,000 --> 00:56:48,000
right there. Don't miss

1309
00:56:48,000 --> 00:56:50,000
this. It's a ton of fun. We've got an IRC room

1310
00:56:50,000 --> 00:56:52,000
you can hang out with. Go harass us. They're talking

1311
00:56:52,000 --> 00:56:54,000
about Fortran right now, so it's clearly

1312
00:56:54,000 --> 00:56:56,000
on topic and fascinating. Go

1313
00:56:56,000 --> 00:56:58,000
be a part of that. And of course,

1314
00:56:58,000 --> 00:57:00,000
thank you for, thank you for

1315
00:57:00,000 --> 00:57:02,000
joining us for Koto Radio. We're going to have

1316
00:57:02,000 --> 00:57:04,000
lots of more good stuff to talk about, so we'll

1317
00:57:04,000 --> 00:57:28,000
see you next week.


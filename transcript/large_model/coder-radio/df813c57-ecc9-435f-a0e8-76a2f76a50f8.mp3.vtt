WEBVTT

00:00.000 --> 00:08.920
This is Coder Radio, episode 342 for January 28th, 2019.

00:30.400 --> 00:37.520
Hello and welcome to Coder Radio, Jupiter Broadcasting's weekly take on the art and

00:37.520 --> 00:43.360
business of software development. Once again, Chris is away, but don't worry, he'll be back

00:43.360 --> 00:49.680
real soon. And in the meantime, I'm Wes, and I'm, of course, joined by our new resident

00:49.680 --> 00:56.880
Rustation, Mr. Michael Dominic. Hello, Mike. Hello, Wes. Do you have any WD-40? I'm feeling rusty.

00:56.880 --> 01:00.640
Oh, you sure are. Unfortunately, I'm fresh out. You're on your own this week, Mike.

01:03.440 --> 01:07.520
But that's okay. That's a shame. It is a shame. But we've got lots of other great stuff to talk

01:07.520 --> 01:12.560
about. We've had some good feedback from the audience. There's been some developments around

01:13.200 --> 01:18.800
patents and our favorite little language to discuss on this show, Swift. Interesting,

01:18.800 --> 01:24.160
interesting developments there. And it's time to check in with WebAssembly. A lot has happened

01:24.160 --> 01:30.320
from the days of ASM.js. What's it like in 2019? Where are we going? And why are we interested?

01:31.920 --> 01:36.320
But before we get all into that, how are you doing this week, Mike?

01:36.960 --> 01:42.800
I'm good. How are you, Noah? That's not your name. I miss Noah, though.

01:42.800 --> 01:48.160
I know. I miss Noah, too. It's true. But that's okay. I'm doing great. We have a lot of fun stuff

01:48.160 --> 01:52.560
to talk about. You brought some new topics on me this morning. And actually, it's been something

01:52.560 --> 01:57.760
I want to talk about anyway. But before we get into any of that nonsense, let's talk a little

01:57.760 --> 02:02.720
bit about some other network news. That's the launch of Choose Linux. That's right.

02:03.680 --> 02:08.640
If you want to be cool like me and run elementary OS, well, then Choose Linux is a show for you.

02:10.640 --> 02:16.240
It is a beginner-oriented show for people. Maybe you're Linux curious. You've looked over at Linux

02:16.240 --> 02:21.200
and maybe Linux looks back at you, but you're not sure. Do you want to go say hi? That kind of thing.

02:21.200 --> 02:28.640
This is the show for you. It's no prior knowledge necessary. It's Joe and the wonderful Jason,

02:28.640 --> 02:37.440
who's new to the network, telling us all about Jason's adventures in, shall we say, Linux education?

02:38.160 --> 02:43.600
Yeah, Linux, the open source world. He'd been writing a lot about other topics for a long time

02:43.600 --> 02:48.480
and then sort of made the switch to Linux, I don't know, six months or so ago. So a competent

02:48.480 --> 02:54.560
storyteller, kind of presenting an interesting story that, you know, we've all been there and

02:54.560 --> 02:58.400
when you're an experienced user, it can be hard to really reflect. So that's why I love that it's got

02:58.400 --> 03:05.120
Jason and Joe. Joe's got the curmudgeonly aspects, the, you know, doesn't quite take all the fun out

03:05.120 --> 03:10.880
of it, but is there to provide some balanced perspective. And of course, Jason's just got

03:10.880 --> 03:16.960
a great energy. So you can find that Choose Linux dot show. They've already got one great episode

03:16.960 --> 03:20.400
up. It's coming out every other week. The easiest thing you can do, of course, is just go to Choose

03:20.400 --> 03:26.800
Linux dot show and subscribe. That's right. Speaking of that, you can, of course, go to

03:26.800 --> 03:32.240
coder dot show and find all the episodes of this show and get your subscription. And even more

03:32.240 --> 03:36.480
importantly, you can find the ways to get in touch with the people making this here show Jupiter

03:36.480 --> 03:42.000
Broadcasting and provide feedback. We love feedback and sounds like we got some good feedback or at

03:42.000 --> 03:49.280
least some interesting feedback last week, Mike. Yeah, when you mentioned Rust, people just kind

03:49.280 --> 03:56.560
of come out of the woodwork. It's interesting. We had a lot of feedback regarding Rust, but also

03:56.560 --> 04:04.000
Jenkins. What was your general take on it? I mean, we had a lot of feedback on the Jenkins stuff.

04:05.120 --> 04:10.240
Yes, we did. You know, I think it was kind of all over the map, which I think is good. It sounds

04:10.240 --> 04:15.360
like we hit a nerve. A lot of people are using Jenkins and either love it or hate it. And that

04:15.360 --> 04:18.880
kind of seems appropriate. And I hope we didn't come off as trying to I didn't I didn't want to

04:18.880 --> 04:22.480
disparage Jenkins. It's a valuable tool. I've certainly used it and been grateful that it

04:22.480 --> 04:26.320
exists. And it's a testament to the open source community. I think more I just want to have a

04:26.320 --> 04:31.680
discussion around. Should Jenkins be where this stops? Can we do better in the world of continuous

04:31.680 --> 04:35.760
integrations and all the various roles that Jenkins has? And how do we take the story of

04:35.760 --> 04:42.960
Jenkins and reflect on what else we should do? Yeah, I mean, I think there is one comment in

04:42.960 --> 04:48.320
particular from Browseria. I hope I'm saying that correctly. You made an honest try. That's

04:48.320 --> 04:54.000
all that counts. I mean, you know, it was really a good, good faith. And he has a kind of a five

04:54.000 --> 05:00.240
five points. But I think the the two that I found most interesting were it's on the subreddit.

05:00.240 --> 05:04.320
Number three, it's simpler. You know how to run Docker containers, you know how to point to your

05:04.320 --> 05:09.040
Git repo source control. If your Jenkins file is right, that's pretty much all you need to do.

05:09.040 --> 05:14.720
And number five, which I think I particularly kind of discounted was that it's a visual

05:15.280 --> 05:20.960
visualization tool as well. Right. I was in particular talking about how you can do many

05:20.960 --> 05:27.440
of these things with bash scripts or, you know, various GitLab pipelines integrations.

05:27.440 --> 05:30.880
But I could definitely see in an enterprise setting where you have a maybe non technical

05:30.880 --> 05:35.680
manager, having the visualization is going to be pretty powerful. Yeah, right. It can be can be

05:35.680 --> 05:39.280
useful to have a nice big board that shows you where your test broken and where it's failing

05:39.280 --> 05:43.040
along that pipeline of complicated steps that you know that way you can find the right engineer to

05:43.040 --> 05:49.040
yell at and make go fix that problem. Well, maybe you don't want that. Maybe you don't. Yeah, you

05:49.040 --> 05:52.560
got to think about that. Yeah, there is actually some really good feedback. And there are a lot of

05:52.560 --> 05:56.880
cost and benefit analysis. And there are times where maybe a small limited make file makes sense.

05:56.880 --> 06:01.920
And there are other times where well crafted Jenkins file. Really, if you can if you get

06:01.920 --> 06:06.560
someone on the team that can that can craft that file and is willing to be the subject matter expert,

06:07.760 --> 06:10.560
you know, a browser is totally right that like no one else is once it's set up,

06:10.560 --> 06:13.600
you're not going to really have to touch it. You just make new commits, new Docker files get

06:13.600 --> 06:18.240
generated, all the automation happens. So a lot of times it's somewhat of a one time pain,

06:18.240 --> 06:24.880
neglecting the other side of the whole maintenance story. Right, right. But anyway, that was our last

06:24.880 --> 06:30.000
episode. Those 241. So if you want to go find out more about 340 141. Sorry, thank you. Gosh,

06:30.000 --> 06:36.480
what am I doing? It's like almost two years of code. So much coder. I'm sure we would love more

06:36.480 --> 06:40.400
feedback about Jenkins, though. It's an interesting conversation. I'm sure we'll see more updates from

06:40.400 --> 06:44.560
the team behind Jenkins. It also seems like it seems like they kind of get it. You know,

06:44.560 --> 06:48.400
a lot of stuff has been happening over there. There is modernization. So it's on the move.

06:48.400 --> 06:54.960
Yeah. So speaking of things on the move, rust, man, can we just take a second and talk about

06:54.960 --> 07:00.640
the rust feedback? Oh, yeah, let's just take a moment for rust. So just like the Jenkins feedback,

07:00.640 --> 07:05.760
there was too much to really sum it up into one paceman. But first off, I want to thank all the

07:05.760 --> 07:13.040
people who sent me blog posts, videos, a link to the rust book, extremely helpful that has kind of

07:13.040 --> 07:16.240
gotten me started a couple of open source products I didn't know about that I'm going to be

07:16.240 --> 07:20.960
investigating, hopefully featuring on here in the next month or two. I was just about to ask if we

07:20.960 --> 07:27.920
were going to hear about those. All right. Little teaser. It has been great. I'm happy to say I have

07:27.920 --> 07:32.560
successfully written a rust function. I'm going to continue to use that word. Okay. Well, you said

07:32.560 --> 07:38.320
written. Does that mean you compiled it too? Written, compiled and called it from Ruby.

07:38.320 --> 07:44.400
Oh, even executed. That's the whole darn thing. Wow. Executed. It's kind of and it does something

07:44.400 --> 07:50.880
with everybody's favorite Star Wars hero. And yeah, Alan wouldn't let me put it on the server.

07:52.080 --> 07:56.480
Something about Linux Academy has an anti Jar Jar policy. Oh, see, that just seems like

07:56.480 --> 08:02.880
discrimination flat out. I mean, come on. Jar Jar is great. But seriously, I did in fact write a

08:02.880 --> 08:10.160
random Jar Jar generator because that's what I do when I try something new. And I have to say,

08:10.160 --> 08:16.960
it took me maybe being conservative 35 to 40 minutes. And most of that was like setting up

08:16.960 --> 08:22.480
my environment, because that's all you know, how that is. West is always just like just a pain.

08:23.280 --> 08:26.880
You're in a new you're in a new ecosystem, right? You have new norms and rules and

08:26.880 --> 08:30.560
customizations to do and get everything integrated with whatever editor you're using.

08:31.440 --> 08:37.360
Yeah, I ended up just using VS code, but I'm told that's maybe not the best choice for this. So I'm

08:37.360 --> 08:42.240
eager to hear more about that. And just getting it to compile correctly to be called by Ruby. But

08:42.240 --> 08:50.160
once I did, it was like the C style FFI from Ruby to call. That's exactly what I'm doing. Yep.

08:50.160 --> 08:54.480
Fascinating. Oh, that's cool, though. I mean, I would probably it seems more fun to pair Ruby

08:54.480 --> 09:02.240
and Russ than Ruby and C. Yeah, I'm finding it to be I like Ruby a lot, as we will talk about

09:02.240 --> 09:07.680
probably in almost every episode. But Ruby, we mentioned it last week. If there's a tortoise and

09:07.680 --> 09:13.280
a hare, maybe it's not the hare. Yeah, I think I think that's a that's pretty well diplomatically

09:13.280 --> 09:17.680
said there. Yeah. So yeah, it's great. I mean, I don't have a whole lot on Russ today. But I'm,

09:17.680 --> 09:23.120
you know, I'm like a little I'm a newbie at Russ, right? So I'm learning it. But as I particularly

09:23.120 --> 09:27.040
play around with open source projects, I'm hoping to kind of bring them into the show feature them.

09:27.040 --> 09:33.840
And I know we, Wes, we have a very, very large and extremely passionate Russ following. Yeah.

09:33.840 --> 09:37.600
So that seems like one of the things that stands out for me, I've only dabbled about as much as

09:37.600 --> 09:41.440
you have here. And I didn't even get into the FFI stuff. And while there might be, you know,

09:41.440 --> 09:44.160
there might be some learning curve, there's obviously a new way to, you know, a new memory

09:44.160 --> 09:48.000
model to kind of work with and how you handle that and all the different idioms of that community.

09:48.000 --> 09:52.400
But it seems like what makes people keep coming back is the community around it. So I'm going to

09:52.400 --> 09:56.240
be fascinated to watch as you interact more and more with the community and the community

09:56.240 --> 10:00.720
more and more with the passionate people behind Russ. Indeed. Speaking of passionate patents,

10:00.720 --> 10:07.280
I mean, oh, people. Oh, jeez. Oh, what a game. So I hear you're doing some Swift to us.

10:07.280 --> 10:13.520
Isn't that true? Or OK. Well, I did actually I did install it because I wanted to try this whole

10:13.520 --> 10:18.080
Swift on the server. I knew it was actually it wasn't bad. I didn't do a whole bunch,

10:18.080 --> 10:23.600
basically my equivalent of your Hello World Jar Jar sort of thing. But it wasn't it wasn't bad.

10:23.600 --> 10:27.840
And that's why I was kind of concerned or at least interested and needed to go follow up more

10:27.840 --> 10:32.640
because I'm new to the Swift world is all I've been. It sounds like Apple's been filing some

10:32.640 --> 10:37.120
patents related to Swift. Oh, they have. But really quick, what what server framework were

10:37.120 --> 10:41.840
you using? I'm just curious. I was just doing getting some basic stuff going. So which one

10:41.840 --> 10:49.760
did I use? Vapor? Yes, Vapor. Vapor is one of the one of the better ones. But yes. So maybe

10:49.760 --> 10:54.960
don't try to sue Apple. You did agree to that, you left. I wasn't I mean, yeah, I guess I wasn't I

10:54.960 --> 11:00.880
wasn't planning to, at least not till next year. I mean, that's kind of a, you know, a summer thing.

11:00.880 --> 11:07.600
Yeah. So Apple is patenting lots of stuff in Swift. Wow. Basically,

11:09.200 --> 11:12.800
I don't even know where to start with this, right? They're patenting optional chaining, which

11:12.800 --> 11:18.960
again, neither West nor I are attorneys. But doesn't that look like a thing that existed in

11:18.960 --> 11:25.280
like Lisp in the 80s? Or am I just? Yeah. And I mean, the ML community has has explored that for

11:25.280 --> 11:30.320
a long time. Really any really in research languages since the 90s? Yeah, I'm sure. Or

11:30.320 --> 11:35.120
probably even earlier knowing how the history of computer science goes. Yeah, right. There's two

11:35.120 --> 11:39.120
patents in question. And people just sort of noticed, you know, people reviewing all the

11:39.120 --> 11:44.080
patents flowing through the system. And realizing not only one is this applying to Swift, but then

11:44.080 --> 11:48.800
too, you have the usual issues of, well, how valid are software patents in general, and then the

11:48.800 --> 11:53.280
specifics of like, what are you claiming here? Because the method, you know, like the actual

11:53.280 --> 11:57.520
implementation, the user facing stuff doesn't seem new at all. There's some arguments about,

11:57.520 --> 12:01.840
okay, well, there's, you know, there's multiple ways to implement optional chaining in terms of

12:01.840 --> 12:05.680
like how you build the programming language underneath. So there's some arguments about

12:05.680 --> 12:09.440
maybe some of the stuff they're patenting applies to the particular way they chose to implement it

12:09.440 --> 12:15.040
in Swift. Still, still, you end up back at the whole like, software patents just seem like such

12:15.040 --> 12:22.160
a steaming pile of garbage sometimes. Well, I yeah, I'm no fan of software patents. But I

12:23.920 --> 12:28.000
kind of didn't think you see again, which we one day we have to have an attorney on.

12:28.000 --> 12:36.000
I didn't think you could patent something that already existed prior to you using it. Oh,

12:36.000 --> 12:41.120
the other patent, basically, I linked it, I'll link it in the show notes, is basically

12:41.120 --> 12:47.600
apt. Like it's basically a package manager. Right. And I mean, I think that hits on some

12:47.600 --> 12:53.040
of the problems with software patents is to have to have effective patents that that don't infringe

12:53.040 --> 12:57.920
on previous existing ideas or really do promote novelty and you know, the generation of new useful

12:57.920 --> 13:03.520
ideas, which is nominally the goal of the whole idea. You actually have to have good enforcement

13:03.520 --> 13:08.720
that can do meaningful review and determine like, is this adding something? It also sort of

13:09.760 --> 13:13.760
violates a lot of the trust, you know, there is now more and more open access journals,

13:13.760 --> 13:17.040
there's more and more sort of research style development, especially in a world where you're

13:17.040 --> 13:23.120
doing a lot of server side stuff. You just don't there's a more open sharing because you need

13:23.120 --> 13:26.320
other stuff, right? Like, look at the machine learning community where a lot of algorithms

13:26.320 --> 13:30.400
get shared somewhat in the open because, well, that is part of the magic. The other magic is

13:30.400 --> 13:34.720
these giant data sets, the companies aren't sharing. And so having patents just sort of

13:34.720 --> 13:39.920
feels like you get the information out there, but it's also not in the free spirit of research.

13:40.880 --> 13:45.040
Well, what's really interesting to me is I remember back in the day when Apple was like,

13:45.040 --> 13:49.680
all open standards, yay, we are built on BSD, which was always kind of...

13:50.560 --> 13:53.920
Right, they had that whole open source program where they, you know, dump code over the wall.

13:54.560 --> 13:59.280
And now, and Microsoft was like, we're going to sue you for using the fat file system.

13:59.280 --> 14:05.680
And now it's almost exactly the opposite, which I, it's bizarre to me.

14:05.680 --> 14:09.200
But how do you, I mean, so how do you reconcile that with at least the development of Swift,

14:09.200 --> 14:13.520
which we saw open sourced somewhat early, right? We got a whole bunch of like previous

14:13.520 --> 14:18.000
Git commits from when it was still closed. And then it is being developed fairly out in open,

14:18.000 --> 14:19.280
or at least that's what it seems like.

14:19.840 --> 14:24.480
Well, I think Chris Latner, the creator of Swift, who obviously used to work at Apple and

14:24.480 --> 14:31.840
Wes has that in the show notes for us. I think he makes a good point that in all likelihood,

14:31.840 --> 14:36.880
he comments on a hacker news. This is just a way for Apple to screw patent trolls.

14:36.880 --> 14:40.800
Because when you're a big company like that, you get sued all the time because people know

14:40.800 --> 14:44.560
you'll settle instead of fight it. So what happens is if you sue them, it's,

14:44.560 --> 14:49.600
and this is the standard Apache thing, right? If you get sued for patent infringement, well,

14:49.600 --> 14:52.880
anything you own that somebody is using that's Apache licensed,

14:52.880 --> 14:58.800
that license is immediately revoked. So then they are infringing your patents if you have patents.

14:58.800 --> 15:03.280
So I'm hoping that this is like a defensive action and they're not going to just turn around and say,

15:04.320 --> 15:10.400
gee, you know what, vendor so-and-so who is building something or like, there's a lot of

15:10.400 --> 15:14.720
projects to bring like Swift onto Google's Fuchsia or onto Android and other platforms.

15:14.720 --> 15:19.840
I'm hoping they don't start going after those people. I'm hoping this is just purely a shady

15:19.840 --> 15:24.640
patent lawyer who also invests in apps that are written or compiled into Swift,

15:25.200 --> 15:27.840
sues Apple. Apple could say, well, great, you own now, it was a million dollars.

15:27.840 --> 15:33.120
Yeah. Right. And that's a good point. That is a big component, the patent grant,

15:33.120 --> 15:36.960
the patent controls to try to prevent lawsuits that is part of the Apache license.

15:38.640 --> 15:43.600
I think it just kind of shows some of the difference between different ways that open

15:43.600 --> 15:46.720
source communities are structured because you have some that are sort of more organic,

15:46.720 --> 15:51.520
maybe like Python. And then you have stuff like Swiftware. Yes, it is open source, but it is,

15:51.520 --> 15:57.920
there's one giant copyright owner and contributor standing there as an elephant in the room. And

15:57.920 --> 16:02.080
sometimes there can be a little friction between normal sort of open source concerns and the

16:02.080 --> 16:06.320
concerns of a giant company that does have a lot of liability out there, especially when

16:06.320 --> 16:12.400
people like Oracle exist. Can I put on my Chris Fisher tinfoil hat for a moment, though?

16:12.400 --> 16:19.520
Oh, please do. So I do not believe in software patents, but let's just say we have a friend

16:19.520 --> 16:26.480
named Jimbo that does. And he invents some crazy new whatever, right, way to program.

16:27.760 --> 16:32.960
Apple then infringes his patent, and he also happens to be like a Swift consultant of some kind.

16:32.960 --> 16:38.480
He sues them for patent infringement. Couldn't they just turn around and say, okay, well,

16:38.480 --> 16:43.760
every time you've used Swift, you have infringed our patent, too. So sorry, not sorry.

16:48.560 --> 16:51.520
You mean with or without the current licensing?

16:52.560 --> 16:56.560
So I mean with the current licensing, assuming these patents aren't struck down, right?

16:56.560 --> 17:02.800
Couldn't this also be used as a way for Apple to basically be able to use or under the threat of

17:02.800 --> 17:08.480
filing a patent infringement lawsuit for the use of Swift, any smaller firm or any small research

17:08.480 --> 17:15.840
labs patents, if that research lab or firm also uses Swift? When I say, of course, it doesn't

17:15.840 --> 17:20.400
grant them the legal right. But the reality of a small research lab, you know, going up against

17:20.400 --> 17:26.320
Apple is not right. That is a huge problem with the whole structure of this is that not all,

17:26.320 --> 17:31.600
you know, not all legal bills are created equal or people have the equal ability to use Swift.

17:31.600 --> 17:35.600
People have the equal ability to pay those. Actually, I was going to ask you a similar

17:35.600 --> 17:40.080
question, which is exactly how confident does this make you feel using Swift? Obviously,

17:40.080 --> 17:43.200
sometimes you don't have a choice or it's the right thing to use, regardless of all these

17:43.200 --> 17:49.120
concerns. But just from the high level perspective, it does. I mean, it might be a little bit of a

17:49.120 --> 17:54.640
question mark. I mean, it doesn't affect me because I don't file software patents.

17:55.200 --> 18:00.000
But if I did, yeah, then definitely. And one thing to keep in mind, too,

18:00.000 --> 18:04.240
the way the license and again, not an attorney, but my understanding of the license is that it

18:04.240 --> 18:09.200
doesn't it doesn't just work against software patents. So if you patent some hardware design

18:09.200 --> 18:14.320
and you also use Swift in theory, now, I doubt Apple would ever do this, but in theory,

18:16.080 --> 18:20.320
they could have a lot of leverage over you. Right. I mean, they could publicly declare

18:20.320 --> 18:24.400
at any point that future contributions are no longer under that license. They could change

18:24.400 --> 18:29.520
a whole bunch of options and pursue other patent claims. And as you say, they just have more

18:29.520 --> 18:33.280
lawyers than just about anyone else. Right. You have enough. They have enough cash on hand to

18:33.280 --> 18:40.080
pay lawyers for several millennia. Yeah, that's that's very sad.

18:40.080 --> 18:46.480
Yeah, it sure is. Oh, Swift. See, so that's one of the things like Swift is an interesting

18:46.480 --> 18:50.080
language and there is a lot of support or at least interest in trying to port it to other

18:50.080 --> 18:55.120
platforms. It has a good has a good runtime story. It has it has nice ergonomics. It has a

18:55.120 --> 18:59.120
big company backing behind it. So, you know, it'll be supported and actually developed at

18:59.120 --> 19:04.320
least for a little while. So it's a shame that it could be so complicated sometimes.

19:07.040 --> 19:12.960
It also seems like one of those languages that maybe someday you might see running on Web

19:12.960 --> 19:21.520
Assembly. Oh, yeah. So what is what are your general thoughts on Web Assembly before we dive

19:21.520 --> 19:27.040
into this? Yeah, I mean, maybe we should maybe we should break down a little bit of, you know,

19:27.040 --> 19:32.080
what's going on with Web Assembly? Why are we talking about it at all? You started off saying,

19:32.080 --> 19:34.720
like, we should we should chat about Web Assembly. I know you saw some tweets, but

19:35.520 --> 19:39.840
before that, let's just break it down. And really, I mean, it's it's an assembly,

19:39.840 --> 19:44.480
a set of assembly instructions targeted at the Web. Right. You'd see this embedded in

19:44.480 --> 19:50.400
web browsers and you'd have a way to use it as a compilation target, as a different sort of

19:50.400 --> 19:55.520
architecture with some sandboxing and restraints built into the platform so that, you know,

19:55.520 --> 19:59.280
obviously, if it's running on an end user's machine, you have to have some security concerns.

20:02.080 --> 20:09.120
Just a few. Do you feel or are you using Web Assembly at all?

20:10.080 --> 20:14.240
I've played with it, you know, just like your little bit of hello worlds and trying to get

20:14.240 --> 20:18.960
something built. But right. But no, it's not immediately useful to me. I'm reasonably happy

20:18.960 --> 20:25.920
with JavaScript as a compilation target. But I can see why. So what strikes me as a similarity

20:25.920 --> 20:31.280
is we were talking about earlier in the show, Rust as an augmentation to Ruby. And Ruby can be

20:31.280 --> 20:34.480
nice. There's a lot of development ergonomics. The whole language is focused on, you know,

20:34.480 --> 20:38.000
making developers happy and it can be very pleasant to use. There's a lot of libraries.

20:39.040 --> 20:43.440
But sometimes you need a little bit of a speed boost. You need more efficiency. And that's where

20:43.440 --> 20:48.000
implementing something in a language like Rust or something a little more a little lower level

20:48.000 --> 20:55.120
can be nice. And I see that as a way some way that Web Assembly will be used as to augment things.

20:55.120 --> 20:58.400
You might still end up writing a large JavaScript application, but for parts that are just

20:58.400 --> 21:03.360
twiddling bits, not necessarily handling complicated, you know, complicated information

21:03.360 --> 21:08.160
processing, but parts that are mechanical, parts that are just, you know, calculating vector

21:08.160 --> 21:12.880
instructions, trying to render graphics, whatever, something you need speed, really fast and

21:12.880 --> 21:18.720
efficient, then you can use whatever compilation trigger, then you can use whatever language you

21:18.720 --> 21:22.960
want. And then if you have Web Assembly as an output, ship it to the browser.

21:24.320 --> 21:28.720
So another use I have seen for and I agree with everything you just said, by the way, I think,

21:28.720 --> 21:33.440
in fact, the performance stuff, I think is going to be the most common. Are you familiar at all?

21:33.440 --> 21:37.280
And I'm dating myself now and it's an objective see thing. So I'm sure you don't have never

21:37.280 --> 21:42.320
touched it. I'm sure if you saw it, you'd run. It's a project called cappuccino. And I'm going to

21:42.320 --> 21:47.440
show it to you. And I'm currently trying to load the projects.org website. It seems like they may

21:47.440 --> 21:55.120
have gone to that GitHub repository in the sky. Oh, that's what it was. Yeah, it's a shame. What

21:55.120 --> 22:00.000
it was, was an Objective C web development framework that let you use Xcode interface

22:00.000 --> 22:05.520
builder to like lay out your layouts and everything and code an Objective C. The idea being you could

22:05.520 --> 22:12.160
top quality, quote unquote, quality layout tools instead of having to write nasty HTML and CSS.

22:12.160 --> 22:16.720
Actually, there's a modern project just like it. We had them on the show Platform Uno,

22:16.720 --> 22:22.000
which is the same thing as XAML, XAML and C sharp. And what they're doing is they compile

22:22.000 --> 22:25.280
into Web Assembly. And there's another one that I actually sponsor that I keep forgetting that I

22:25.280 --> 22:31.520
sponsor Avalonia. I know they are basically doing the same thing and planning to go further into Web

22:31.520 --> 22:38.800
Assembly. Same idea. You can use XAML and C sharp and F sharp. And you would be, again, if you're a

22:38.800 --> 22:45.040
.NET developer, you'd be coding in the tools that you have come to know and loathe. But when you

22:45.040 --> 22:50.800
compile, you're going to compile into Web Assembly. For those interested, a chat with Uno, go to

22:50.800 --> 22:57.840
Radio 317. I have no idea how you did that so fast. I'm impressed, Wes. Maybe Chris could just stay

22:57.840 --> 23:01.600
wherever he is. Let's just leave him. Oh, you flatter me, sir.

23:04.880 --> 23:09.120
Is that crazy? I mean, not the Chris thing, but is it crazy for people to want this?

23:09.120 --> 23:12.480
Because I have to be honest, there was a day when like cappuccino, the Objective-C

23:13.360 --> 23:15.600
interface builder product, looked really attractive to me.

23:16.160 --> 23:19.840
No, and I think it makes sense in the same context that you've seen JavaScript

23:20.400 --> 23:24.720
really just kind of become, at least in some circles, just a compilation target in its own,

23:24.720 --> 23:29.520
right? You're writing in TypeScript or at least using Babel in your pipeline. So it's not like

23:29.520 --> 23:33.680
you're maybe you're looking at the generated JavaScript, but if you are, it's probably because

23:33.680 --> 23:38.080
of some unfortunate reason or weird bug that somehow your source maps aren't covering.

23:39.120 --> 23:42.080
Or you fundamentally don't understand TypeScript like I did in the beginning.

23:42.880 --> 23:48.880
Yes, right. There are lots of reasons. One of the other interesting things is

23:48.880 --> 23:54.320
JavaScript itself can compile into Web Assembly. So if you're just hot for the ECMA 2019,

23:54.320 --> 23:59.280
that's coming out, right? You could use that as a way to bootstrap yourself up and try things out.

24:02.560 --> 24:06.240
What it seems like is that for a lot of things like TypeScript, which is obviously a superset

24:06.240 --> 24:11.440
of JavaScript or I use ClojureScript a fair amount and that's a sort of similar thing,

24:11.440 --> 24:15.040
it ends up mapping really well. So in the back end of the compiler,

24:15.040 --> 24:19.360
like a ClojureScript function fundamentally maps to a JavaScript function because they're both kind

24:19.360 --> 24:24.720
of higher level languages, right? There's a GC involved. They have similar notions of sort of

24:24.720 --> 24:32.400
dynamic types and the basic sort of data structures involved. That is not true for Rust. And so while

24:32.400 --> 24:38.000
you can use JavaScript as an arbitrary turn complete bottom implementation to target,

24:38.960 --> 24:43.360
it just doesn't have kind of the right primitives to write really good code that maps more to lower

24:43.360 --> 24:51.520
level ideas and algorithms. Yeah, it seems interesting. And just kind of going off the chat,

24:52.160 --> 24:54.720
Circus Freak, you guys have amazing names in the chat, by the way.

24:54.720 --> 24:55.360
Oh yeah, I love it.

24:58.000 --> 25:02.960
It depends, right? So the question is, isn't the performance of Web Assembly the same as

25:02.960 --> 25:08.800
JavaScript? That is one of those questions that is super simple to say. And the answer would take

25:08.800 --> 25:14.800
another hundred episodes. Basically, it depends on the browser vendor. And I'll give you a great

25:14.800 --> 25:21.600
example. Google Chrome on most platforms that aren't, I forgot which one is slower, but there's

25:21.600 --> 25:27.680
some issue. I think it's actually Mac OS, but don't quote me on that last part. Implement Web

25:27.680 --> 25:32.160
Assembly in a way where it tends to be faster. In fact, sometimes it will like compile JavaScript

25:32.160 --> 25:41.680
into Web Assembly. Safari is Safari. What can we say about Safari? Edge is dead, but do you know us

25:41.680 --> 25:48.480
if Mozilla, if Firefox actually implements it yet? Yeah, I believe so. Yeah. Because they've been

25:48.480 --> 25:53.280
involved because they were one of the big proponents of ASM.js before Web Assemble really,

25:53.280 --> 26:00.240
really got going. It took over. Right. So this is a situation of it's going to depend on the browser

26:00.240 --> 26:05.280
because the browser's engine is ultimately what runs the quote unquote assembly language,

26:05.280 --> 26:10.640
the Web Assembly. Right. We saw that with JavaScript too for a long time. V8 was dominant,

26:10.640 --> 26:14.560
and now Spider Monkey and others have caught up so that we have a generally fast JavaScript

26:14.560 --> 26:18.640
environment. Right. And I think right now, even straight JavaScript on performance,

26:19.200 --> 26:24.400
I'm pretty sure Chrome is kicking the shit out of everybody else if you actually care about

26:24.400 --> 26:29.600
performance and you like giving Google all your information. It also seems like one of the big

26:29.600 --> 26:34.880
bottlenecks that has been only relatively recently worked through is going through the translation

26:34.880 --> 26:41.760
between JavaScript and Web Assembly. So you might be writing a game that just does everything in

26:41.760 --> 26:45.280
Web Assembly, but I think a lot of people end up just needing to pass data structures back and

26:45.280 --> 26:49.440
forth so that you can do some performance optimized thing in Web Assembly and then maybe do some

26:49.440 --> 26:53.680
higher level DOM re-rendering in JavaScript that you already have a nice library for.

26:53.680 --> 26:58.480
Yeah, I think that's going to be the case. I mean, I'm hoping for a future, and we'll get to the

26:58.480 --> 27:04.080
con case pretty soon, but I'm hoping for a future where we can just compile libraries to Web Assembly

27:04.080 --> 27:10.160
and pull them in via various package managers and be very happy. Something a bit maybe more

27:10.160 --> 27:18.560
sophisticated or less of a hassle to use at scale than NPM. But I'm thinking more like a Cocoa Pods

27:18.560 --> 27:23.760
or a Ruby Gem style situation, which I know NPM is very similar. But if these were compiled

27:23.760 --> 27:28.800
quote unquote binary Web Assembly, I'm using air quotes binary Web Assembly targets,

27:29.440 --> 27:33.680
that would be pretty good. And if you've ever developed iOS, what I'm basically saying is

27:33.680 --> 27:37.600
static libraries, right? The equivalent of a.a file you might pull down from Cocoa Pods.

27:38.400 --> 27:44.320
Would you compare that to like an ahead of time compiled jar that just has byte code?

27:44.320 --> 27:48.800
That's exactly what it, yeah. A jar is actually probably a better analogy because it's definitely

27:48.800 --> 27:51.920
not going to be like a static library, right? It's going to be, well, jars are static. But

27:51.920 --> 27:56.960
you know what I mean? It's, yeah, Gradle. Give me Gradle. Give me Gradle or give me Death.

27:58.960 --> 28:02.080
So, you know, our love of Web Assembly is not universal.

28:02.880 --> 28:07.280
No, of course not. That's not, you know, nothing's ever so simple in our real world, Mike.

28:07.280 --> 28:16.080
So DHH dividend, I can't say his full name. So the guy who created Rails says quote on Twitter,

28:16.080 --> 28:20.560
treating the web as a compile target washes away much of what's so special about it. Reducing the

28:20.560 --> 28:26.960
web to just another closed platform like Windows or iOS is to be blind to its truly unique shape

28:26.960 --> 28:32.560
and promise. Let's cherish what made the web special, not pave over it. What's your reaction?

28:32.560 --> 28:39.680
You know, I was thinking about this a lot yesterday, this morning. There is, and it kind of

28:39.680 --> 28:44.480
comes up in multiple contexts. It kind of made me think of the debate when systemd was first sort

28:44.480 --> 28:50.640
of being introduced. And if you are experienced with inkscripts, having them be bash meant you

28:50.640 --> 28:53.680
could just open them up, right? You didn't have to go find the source somewhere. You didn't have to

28:53.680 --> 28:58.800
go, especially if it's not on GitHub, you could just open them up. You could just open them up

28:58.800 --> 29:02.640
right? You didn't have to go find the source somewhere. You didn't have to go, especially if

29:02.640 --> 29:06.240
it's not on GitHub, it's probably in whatever version, the bizarre repo that Ubuntu has and

29:06.240 --> 29:10.640
find the right version that actually shipped that you've installed through dpackage. Or it's a bash

29:10.640 --> 29:15.760
script that you open up in VI, and you can edit and tweak and reboot and test immediately. And so

29:15.760 --> 29:19.840
there is that like I was I was doing a little automation work trying to automate a site that

29:20.560 --> 29:26.480
doesn't have an API, at least not yet. So I was kind of mechanized and automating some web forms.

29:26.480 --> 29:30.000
There was a little bit of JavaScript to handle some fancy uploading stuff.

29:31.040 --> 29:37.040
But it wasn't transpiled. It wasn't some fancy framework. It was just good old jQuery,

29:37.040 --> 29:41.120
right? I've everyone basically everyone who's done web development over the past 10 years had

29:41.120 --> 29:45.680
to use jQuery at some point. No, nothing wrong with the dollar sign. Not at all. And for the

29:45.680 --> 29:49.840
right kind of stuff where you don't you're not writing, you know, an SPA, then jQuery can really

29:49.840 --> 29:53.440
in this case, it was it was used simply. And I could have reverse engineered everything I

29:53.440 --> 29:57.520
needed to know just from like looking at the web requests and you know, working backwards.

29:57.520 --> 30:02.320
But I didn't have to, because I could just read the JavaScript. So I was able to just copy that,

30:02.320 --> 30:05.680
you know, the copy the post that they were doing that way, without having to decode anything without

30:05.680 --> 30:10.400
having to read, go look at all the how the form got encoded. That was really handy. And it was

30:10.400 --> 30:15.680
a sort of like immediate ease of understanding and tweaking and playing with that you don't get

30:15.680 --> 30:22.480
when you end up with a giant minimize JavaScript blog, or in the case of WebAssembly, a binary ASD.

30:22.480 --> 30:29.600
Right. But but so the other the flip side of that, I don't know that WebAssembly,

30:29.600 --> 30:33.120
what does it really change? I mean, maybe a binary is even a little bit more

30:33.840 --> 30:37.680
hard to hard to introspect. But we're already a point where most websites that you get the

30:37.680 --> 30:42.160
minimize JavaScript for even if you use some of the Yeah, right. You can use some clever tooling

30:42.160 --> 30:46.560
to expand it and make it readable. But you don't get real variable names. So you're kind of you're

30:46.560 --> 30:54.640
left trying to get Yeah, yeah. I mean, I, I sort of feel like like with anything else, you definitely

30:54.640 --> 31:00.720
see how people could think this is kind of closing up the web, quote, unquote, as a platform. But

31:02.480 --> 31:08.640
you know, I look at the advantages of WebAssembly, being able to code in whatever language,

31:09.600 --> 31:14.240
you know, slash stack that I want to now granted, in my case, I would still just use JavaScript.

31:14.240 --> 31:18.240
But I think you and I are in some way a bad case for this, because, you know,

31:19.600 --> 31:24.720
I run into Windows guys all the time who, like, you know, I say give me great great old,

31:24.720 --> 31:29.440
they say XAML or death. Right? They just want to lay everything out on XAML. That's what they want.

31:29.440 --> 31:32.960
Right. That's what they know. That's not what they are familiar with. Yeah, of course.

31:32.960 --> 31:37.600
And like, you show them CSS, and they cry. So well, that's that can happen to anyone.

31:37.600 --> 31:44.560
Well, if you've ever looked at my CSS, it doesn't seem it seems like

31:45.280 --> 31:48.160
there are two main advantages here, right? We've talked about the performance advantages,

31:48.800 --> 31:56.080
and also the the freedom to choose your own stack. I kind of think it's the good outweighs the bad,

31:56.080 --> 32:00.640
especially as you're saying, giving that all these big sites minimize the crap out of their

32:00.640 --> 32:05.680
JavaScript anyway. And anything that's proprietary, a lot of people are obfuscating.

32:05.680 --> 32:10.560
Right. Yes. And, but I mean, I can, I can certainly appreciate the sentiment because,

32:11.280 --> 32:16.320
you know, we already have stuff like the various DRM solutions that get rolled up in in Chrome and

32:16.320 --> 32:24.160
other browsers. It is we are we have already moved away from a web now, not necessarily everywhere.

32:24.160 --> 32:28.000
And maybe maybe that's where some of the concern is that, you know, this will just increase with

32:28.000 --> 32:32.480
WebAssembly. But we're already in a web where you can't really fully introspect everything that's

32:32.480 --> 32:36.320
running in your browser. You don't really have entire control like you would like to think.

32:37.200 --> 32:40.000
Yeah. And no one looks at even if you can look at the JavaScript, no one does.

32:40.640 --> 32:44.960
No one does. Right. And everybody's pulling in the same, you know, react review or whatever,

32:44.960 --> 32:49.360
anyway, when they're putting in JavaScript. So how many times are you implementing or building

32:49.360 --> 32:55.760
upon Angular, for example? Yeah, exactly. And DHH has a follow on tweet. You know,

32:55.760 --> 32:59.680
WebAssembly is exciting in a lot of ways. This isn't one of them. Hopefully we'll keep

32:59.680 --> 33:06.240
HTML, CSS, JS readable. And he in that he's replying to someone who mentions that, you know,

33:06.240 --> 33:11.680
we've seen Java applets, which I used to write. Don't judge me. ActiveX, Shockwave and Flash,

33:12.240 --> 33:16.480
all of these fall down, which is true. Right. There have been many, many attempts to do this

33:16.480 --> 33:21.680
kind of thing. I would argue, though, I forgot about Silverlight crap.

33:21.680 --> 33:31.360
Everyone did. Yeah. Yeah. That's even Microsoft. So I don't think WebAssembly is going to go down

33:31.360 --> 33:37.600
like that just because it's an open source kind of, you know, Linux. I know it's not Linux,

33:37.600 --> 33:43.600
even like open source. I want to use the word standard. Right. Where Flash was proprietary,

33:43.600 --> 33:50.480
Java applets were frankly, satanic. And Silverlight was just basically made for Netflix.

33:50.480 --> 33:56.160
Right. I'm joking. You might be running a proprietary, something that has a proprietary

33:56.160 --> 34:00.400
license and you don't get to see the source for, but you're running it on an open source system,

34:00.400 --> 34:05.200
or at least an open source standard. Right, exactly. And also, you know,

34:06.320 --> 34:12.720
who's backing WebAssembly now? Mozilla, Google, basically every other big company that I can

34:12.720 --> 34:20.400
think of. You know, I'm not sure of any of the big browser vendors with the exception

34:20.400 --> 34:25.760
of maybe Apple. I don't think Apple actually has any dog in this fight that isn't backing

34:25.760 --> 34:30.400
WebAssembly and actively contributing to this standard. So it seems like the,

34:31.840 --> 34:35.600
you know, the big platforms in the market have decided that it's the way to go.

34:38.160 --> 34:42.560
Right. And at some point, I mean, it's so kind of maybe maybe if I'm taking you right,

34:42.560 --> 34:48.160
it's going to happen. We just have to we now we kind of have to the debate has moved on from

34:48.160 --> 34:51.840
should we do this or not? And it is happening. How do we how do we deal with it?

34:51.840 --> 34:56.720
Yeah, I think the question becomes and now we're getting deep into like front end web development

34:56.720 --> 35:04.480
hell. But at what point does, quote unquote, the interface or the API of WebAssembly, which I know

35:04.480 --> 35:10.880
is a gross oversimplification, diverge or become a competitor to programming directly to the DOM?

35:13.200 --> 35:17.760
Right now, there's no friction there that I'm aware of. I mean, it's just like,

35:17.760 --> 35:22.640
you know, you it just compiled. I could see a world where particularly

35:22.640 --> 35:25.840
big tech companies decide to put out like proprietary frameworks or

35:27.440 --> 35:32.240
you know, you get into the IE six world of like, could Google, for instance, decide that they want

35:32.240 --> 35:36.880
to have a special like API hook that you can call from an assembly that does something cool on Chrome

35:36.880 --> 35:41.600
that you can't do in Firefox or I guess they care more about Safari.

35:42.400 --> 35:45.280
Right. But couldn't they do that in JavaScript today?

35:45.280 --> 35:50.800
They can do that right now. Exactly. It's a great example. I always find because I tend to use

35:50.800 --> 35:54.240
Firefox and I use the Firefox developer edition for testing. Oh, yeah, right.

35:54.880 --> 36:02.480
Firefox always implements things basically to the letter of the standard. Google's like,

36:02.480 --> 36:06.880
meh, we're going to do it the way we think it should have been done. And Apple's just,

36:08.160 --> 36:09.680
I don't know what the hell is going on over there.

36:09.680 --> 36:12.960
Right. You know, that is a good point because you do think I'm thinking in particular of stuff like

36:12.960 --> 36:17.840
the web audio standard, but you often see things in Chrome that like people end up even using

36:17.840 --> 36:21.040
enough to make web apps. And then you just have these web apps that aren't really web

36:21.040 --> 36:24.160
apps because they're Chrome apps for the nonstandard API.

36:27.040 --> 36:28.480
Sort of like the one we use to make the show.

36:29.120 --> 36:32.560
Sort of like the one we used to make. I wasn't going to mention that, but yes.

36:34.880 --> 36:38.080
It's the only time I launched Chrome other than obviously browser testing.

36:38.080 --> 36:41.760
Okay. So here's another. So you mentioned to me before we started the show that you're

36:41.760 --> 36:46.080
running Linux today. This is a whole Linux powered code on radio. Pretty cool.

36:47.520 --> 36:53.760
One of the things that might be more possible is shipping proprietary applications to the browser

36:53.760 --> 36:59.680
with WebAssembly. Like I know the people behind AutoCAD have been experimenting with that.

36:59.680 --> 37:06.240
And in 2018, we saw Unity release WebAssembly as a compilation target. So suddenly you might get

37:06.240 --> 37:12.000
in browser games that are actually decent or some of your favorite tools running in the browser.

37:12.000 --> 37:15.760
And while yes, that might be still proprietary, that's not great for the open web,

37:15.760 --> 37:19.280
but as a Linux user, that might be the difference of me having to have a Windows VM or not.

37:22.080 --> 37:28.160
Yeah. I mean, I think that's fine. I'm obviously not, you know, I'm not a total freedom penguin,

37:29.120 --> 37:33.600
but I could also see the argument that that effectively becomes a form of,

37:33.600 --> 37:39.760
I won't say DRM, but, you know, again, another form of kind of proprietary protection.

37:41.200 --> 37:45.840
But again, wouldn't you rather be able to run things in the open platform of the browser

37:45.840 --> 37:49.680
instead of having to install, like you said, a Windows 10 VM?

37:51.040 --> 37:53.120
Yes. Yes, I would.

37:53.120 --> 37:59.680
And for devs, I can't imagine like people want to write things to the Windows API anymore.

37:59.680 --> 38:04.400
Even if it is UWP, which is actually a pretty nice API. I mean, I think that's why Platform Uno

38:04.400 --> 38:11.040
and Avalonia are getting so popular because there's a whole pile of people with C-Sharp,.NET,

38:11.040 --> 38:18.320
maybe UWP, WPF skills that want to come over into other platforms, right? So they want to ship an

38:18.320 --> 38:23.040
app and run it on Windows, Mac, Linux. And in the case of Uno, and I think Avalonia is,

38:23.040 --> 38:24.160
they're assumed, the web.

38:24.160 --> 38:30.160
I'm kind of cool with that. Yeah, no, I see what you mean. That's, that is interesting.

38:31.760 --> 38:36.800
I also noticed that there's like, there's been some efforts made to have WebAssembly as something

38:36.800 --> 38:42.000
of a more general runtime, right? When you get in this world where suddenly a whole bunch of tools

38:42.000 --> 38:46.720
can output to it. Well, yeah, it can ship in the browser, but kind of like with Node,

38:46.720 --> 38:50.080
where V8 was ripped out of the browser and, you know, the whole thing was just,

38:50.080 --> 38:54.320
it can ship in the browser, but kind of like with Node, where V8 was ripped out of the browser and,

38:54.320 --> 38:58.560
you know, used to great effect on its own, whether you like Node or not. The same thing

38:58.560 --> 39:03.280
could be happened with WASM, right? And so you can end up with like, oh, I compiled nginx to run

39:04.160 --> 39:08.880
in WebAssembly on top of WebAssembly. And now instead of having to install it or compile it for

39:08.880 --> 39:12.160
your architecture, well, here's a binary blob that you can run as long as you have something

39:12.160 --> 39:14.080
that translates it to native instructions.

39:14.080 --> 39:19.280
So, so Electron, right? So Microsoft bought GitHub who created and owns Electron.

39:19.280 --> 39:23.120
You see a world where Microsoft changes Electron to not just be like an instance of Chrome,

39:23.680 --> 39:28.480
but to be its own, just, you know, WASM, if I can try to use that runtime.

39:28.480 --> 39:35.440
Oh, interesting. Some optimizations, but that are still linked enough so that maybe me,

39:35.440 --> 39:39.120
that as the developer doesn't have to care too much, but get some nice benefits.

39:39.120 --> 39:43.600
And the hope being that like, right. And that Slack doesn't like throw up on your computer

39:43.600 --> 39:44.000
all the time.

39:44.000 --> 39:50.080
So, oh, yes, it does. It does do that. It does seem like Electron got lots of stuff

39:50.080 --> 39:54.000
right where you have this, the developer experience is clearly something people are

39:54.000 --> 39:56.720
interested in, but just, you just see so many apps written for it, right?

39:58.240 --> 40:02.560
But the experience for the end user leaves a lot to be desired. And I saw, I saw a couple

40:02.560 --> 40:08.400
of things like some interesting and interesting Electron alternative based on Reason and OCaml

40:08.400 --> 40:12.800
that offered a sort of development environment with some of the JavaScript style feedbacks

40:12.800 --> 40:17.840
and a very similar API, but that could ultimately compile down to native code.

40:17.840 --> 40:20.720
So it seems like a lot of people are interested in exploring that space.

40:21.440 --> 40:25.120
It does. Now, let me ask you a question. On what operating system might you run a lot

40:25.120 --> 40:25.920
of Electron apps?

40:27.040 --> 40:30.080
Well, I think I would probably run those on Linux.

40:30.080 --> 40:31.040
Would you make that choice?

40:33.040 --> 40:34.800
Would you choose Linux? See, I'm trying to say, yeah.

40:35.440 --> 40:36.320
You know, I think I would.

40:38.000 --> 40:40.560
Well, if I wanted to choose Linux, where could I go?

40:40.560 --> 40:45.920
Oh, you know, there's been a lot of good options to where you could go, but don't,

40:45.920 --> 40:46.880
there's also a lot of bad options.

40:46.880 --> 40:49.360
So don't go somewhere like DistroWatch.

40:49.360 --> 40:51.280
No, that's not, that can't be right.

40:51.280 --> 40:54.880
No, don't go there. You could go to jupiterbroadcasting.com, but that's not quite

40:54.880 --> 40:59.840
specific enough. Really, you should go check out the brand new show, Choose Linux over

40:59.840 --> 41:02.960
at chooselinux.show, chooselinux.show slash one.

41:02.960 --> 41:05.920
If you just want to start out with the very first episode, it's brand new.

41:06.480 --> 41:08.960
Expect a second episode coming out before too long.

41:08.960 --> 41:10.800
It'll be every other week.

41:10.800 --> 41:16.400
You can join Jason and Joe to find out Jason's new adventures in the world of Linux and Joe's

41:16.400 --> 41:17.600
realistic take on it.

41:19.440 --> 41:20.480
Sounds amazing.

41:20.480 --> 41:21.840
Oh, it is.

41:21.840 --> 41:27.760
Of course, head on over to coder.show if you want to get the whole backlog, all the episodes,

41:27.760 --> 41:28.800
as many as you could want.

41:28.800 --> 41:29.680
Really, there's no excuse.

41:30.320 --> 41:35.200
All the updates from Mike, all the magic and mispronunciations from Chris, and occasionally

41:35.200 --> 41:36.080
I pop in there.

41:36.080 --> 41:41.520
Plus, there's a bunch of other great Jupiter Broadcasting shows over at jupiterbroadcasting.com.

41:41.520 --> 41:42.960
You can find me over on Twitter.

41:42.960 --> 41:44.000
I'm at Wes Payne.

41:44.000 --> 41:45.520
And of course, Mike, you're there, too.

41:46.320 --> 41:47.840
At Dimenuco on Twitter.

41:47.840 --> 41:48.640
Beautiful.

41:48.640 --> 41:51.360
Thank you all so much for joining us.

41:51.360 --> 41:52.400
We've got we've got a live stream.

41:52.400 --> 41:56.320
You can go to jupiterbroadcasting.com slash calendar to find out when we're going to do

41:56.320 --> 41:56.800
that.

41:56.800 --> 42:00.160
It's usually right about noon Pacific time on Monday.

42:00.160 --> 42:01.120
You can try to catch us there.

42:01.120 --> 42:02.560
We've got a great IRC room.

42:02.560 --> 42:07.280
And don't forget coder.show slash contact to find all the ways to get in touch or head

42:07.280 --> 42:08.480
on over to our subreddit.

42:08.480 --> 42:32.880
Thanks for joining us and we'll see you next week.


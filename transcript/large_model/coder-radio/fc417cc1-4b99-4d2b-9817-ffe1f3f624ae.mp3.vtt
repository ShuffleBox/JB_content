WEBVTT

00:00.000 --> 00:07.000
This is Koda Radio, episode 373 for September 2nd, 2019.

00:31.000 --> 00:43.000
Hello, and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show that takes a pragmatic look at the art and business of software development and related technologies.

00:43.000 --> 00:50.000
My name is Wes, and I'm pleased to be joined by Mr. Michael Dominic. Welcome back to the show, Mike.

00:50.000 --> 00:52.000
Hello, Mr. Payne.

00:52.000 --> 00:59.000
You know, I'm very glad to have you here down there in Florida as a hurricane approaches, so we better make this a quick one today and let you get back to prepping.

00:59.000 --> 01:06.000
That's right. We're battening down the hatches and we are making sure our programs are memory safe because Dorian is coming.

01:06.000 --> 01:15.000
Now, let's get things rolling with some feedback. We've got a letter in from our pal Joseph asking about getting started on.NET.

01:15.000 --> 01:22.000
Hello. At my job as a system administrator, I tend to interact with a lot of developers pushing out new content to websites.

01:22.000 --> 01:27.000
We are primarily a Microsoft shop focusing on.NET development on Windows servers.

01:27.000 --> 01:31.000
My question is, what's the easiest route to get started?

01:31.000 --> 01:38.000
When I started looking online, there are so many different language choices out there, C sharp, F sharp, ASP.

01:38.000 --> 01:41.000
In your experience, what's the easiest way to get started?

01:41.000 --> 01:49.000
And Mike, this just screamed Mike question to me because, you know, you've been down this road and we've talked some a bit about.NET development, of course.

01:49.000 --> 01:57.000
But what about that? You know, this person may be familiar with the operational side of things, but not so much the program inside. Where would you recommend?

01:57.000 --> 02:07.000
Yeah, I mean, so it's kind of a two parter, right? For the language, as much as I would love to tell you to look at F sharp, the truth is there are just so many more resources for learning in C sharp.

02:07.000 --> 02:11.000
And it basically is the lingua franca of the Microsoft world.

02:11.000 --> 02:20.000
Now, in terms of educational resources, if you were doing Azure, I would definitely recommend you check out our Linux Academy plug, plug, plug course.

02:20.000 --> 02:28.000
But since you said you're doing Windows Server, which I'm guessing means on prem, actually check out MSDN's channel nine.

02:28.000 --> 02:32.000
It used to be channel nine dot MSDN dot com. I think it's now just channel nine.

02:32.000 --> 02:37.000
So if you go ahead and being that since we're talking Microsoft, you'll you'll find it.

02:37.000 --> 02:40.000
They have a lot of tutorial videos.

02:40.000 --> 02:47.000
There's also a MSDN developer, and I think there's actually now called Visual Studio developer YouTube channel.

02:47.000 --> 02:56.000
That is really good. There's a specific sub channels for Xamarin and for dot net core in particular has a very active YouTube channel.

02:56.000 --> 03:03.000
These are all great free resources. I would maybe start with channel nine and then go over to YouTube.

03:03.000 --> 03:18.000
But you'll find that Microsoft and even the Dotnet Foundation have really gone out of their way, or at least members of that community have gone out of that way to make onboarding resources readily available, particularly for dot net core.

03:18.000 --> 03:31.000
So if you're thinking of transitioning, I know you didn't mention that, but just as dot net core is becoming the standard above regular dot net for server side applications, I have to guess that that's somewhere on your radar.

03:31.000 --> 03:36.000
Oh, yeah, that's that's a good point, right? If you're thinking about the future, you should probably be thinking about dot net core.

03:36.000 --> 03:47.000
All right. Well, that's some good advice. If anyone else has some some feedback or maybe some tips on how they got started in dot net, you can send that our way over at coder dot show slash contact.

03:47.000 --> 03:51.000
Now, Mike, our next bit of feedback has some opinions about rest.

03:51.000 --> 03:58.000
Yeah, this is a great email from and I this is a direct quote a fellow hacker man.

03:58.000 --> 04:06.000
I am not going to read the whole thing just because we're on a time constraint today, but I think there's one section that's particularly interesting.

04:06.000 --> 04:25.000
So, quote, the primary issue here, here being with rust is rust as approach to memory safety is that most of the work to prove that safety beyond trust me blocks is pushed on to the developer instead of having the compiler insert protection surmised from uses of the data structures outlined in the new source.

04:25.000 --> 04:31.000
The second part, after all, it can only prove what it is shown and not what it assumes. So this is interesting, right?

04:31.000 --> 04:40.000
And then we're getting deep into the whole like the most common issues and production applications tend to be memory safety type issues, right?

04:40.000 --> 04:46.000
Yeah, we've talked about that a bit in the past. There's more and more research finding that those are a substantial problem in real code bases out there.

04:46.000 --> 04:57.000
Yeah, in fact, our our our fellow hacker man actually goes on to recommend a paper, the meaning of memory safety by Arthur Azevedo de Amorum.

04:57.000 --> 05:06.000
If I butchered that name, I do apologize, which is a basically a compsci paper that has a different approach to memory safety.

05:06.000 --> 05:17.000
But this is becoming a I guess I would say this is becoming a consensus in the industry, both on the academic side and the more, you know, practitioner side.

05:17.000 --> 05:28.000
That most common issues are memory issues. Now, the author seems to be suggesting that rust is making the user do a little too much work to get that benefit.

05:28.000 --> 05:35.000
That's interesting, right? Especially when I look at the rest of his email and he talks about what a language that didn't put that on you look like.

05:35.000 --> 05:53.000
I have a feeling that our fellow hacker man is basically correct, that what rust makes you enforce yourself via the compiler, you know, in five, ten years, there's going to be some other new version of rust or just new language completely that I hate to use.

05:53.000 --> 06:09.000
It uses some like machine learning or whatever, right, to do exactly what he says and just infer the right kind of protections without you having to explicitly, you know, go through and do all the all the kind of guardrail stuff.

06:09.000 --> 06:17.000
We're not there yet, though, right? I mean, it's interesting because this whole idea of your tooling be able to infer what you want.

06:17.000 --> 06:24.000
Like that's all that's the whole push on Visual Studio 2019, right? That they're having IntelliSense is not being powered by AI.

06:24.000 --> 06:29.000
Oh, boy, that's a little buzzword soup right there. IntelliSense AI.

06:29.000 --> 06:35.000
I'm not sure I completely buy that. But yeah, I think this is where we're going, right? Because it just makes sense.

06:35.000 --> 06:50.000
If this issue is so big that it's the, you know, the widest surface area for production issues, then absolutely, we shouldn't have to do it by hand. And yeah, our tooling should do it, whether that tooling is at the editor or the language level.

06:50.000 --> 06:55.000
I think that's going to be an open debate going forward. But I just don't think we're there yet.

06:55.000 --> 07:06.000
So again, a fellow hackerman, I agree with you, for the most part. I just I think the time scale is going to be five to 10 years on this.

07:06.000 --> 07:25.000
It just makes me think he links to as highly recommended reading a paper titled The Meaning of Memory Safety, which sort of explores, you know, a rigorous definition of what it means to be memory safe, and uses, you know, some theory theorem proving based languages to sort of go build a language on top of that.

07:25.000 --> 07:38.000
And that's an interesting idea. And I think it's important that, you know, it's great that we have Rust. It's awesome that we're normalizing some of these things, adding these abilities, making developers familiar with this, but it's by no means the end goal, right?

07:38.000 --> 07:47.000
We are not yet at a time where things like formal methods are widely used. That's picking up. I think that's changing. But there's this, you know, we have a long way to go.

07:47.000 --> 07:57.000
Well, I would also like take this a step more meta here and say there is no end goal, right? What we think is amazing today is going to be garbage to the next generation of developer.

07:57.000 --> 08:10.000
And what they think is amazing will be garbage to their, quote unquote, descendants, right? I think this is, I'll use another broadsword since I'm playing bingo today, a situation of continuous improvement, right?

08:10.000 --> 08:24.000
We're always going to be making our tools better. Languages are always going to help us solve these problems more. And yeah, it is true. And this is coming from an objective sea lever that we have gained a lot, I would say, in the last 15 years.

08:24.000 --> 08:30.000
And yeah, in the next 15 years, we're going to gain more and it's going to be great and we should all be happy.

08:30.000 --> 08:41.000
Well said. All right. Well, our next bit of feedback is someone who's not so happy with you, Mike. How unusual, right? That's never happened before.

08:41.000 --> 08:55.000
This is all after you expressed some opinions about macros last episode, 372, crystal clear. Now over in our CoderRadio subreddit, coderradio.reddit.com, code sections writes,

08:55.000 --> 09:08.000
Um, Mike, I'm not sure how to break this to you, but rust very much has macros. And, you know, I'm mostly joking, but it sounded a lot like you were contrasting crystal and rust and saying that you didn't like that crystal has macros.

09:08.000 --> 09:24.000
Now, really, I'd just love to hear more about why you dislike macros. Personally, I view rust macro system as one of its biggest selling points. I've written more than a few myself and every time they've simplified my code in ways I couldn't have managed without them.

09:24.000 --> 09:40.000
So this is, okay, so this is a big question, right? So there's a few pieces of this. Yes, I'm aware that rust has macros. I can't say that I've never used them, right? Which is, I thought what I said last week, I have in fact done some macros and other bad stuff.

09:40.000 --> 10:00.000
You have to remember, though, I'm coming from a position of having a lot of Ruby experience, where what we would call macros and other languages. And I know this is kind of an unfair comparison, but like, monkey patching was a real problem for a long time in Ruby.

10:00.000 --> 10:10.000
So the reason I didn't like the way crystal presented macros, maybe we should just back up a little bit, is that I thought they were over emphasizing it in the way it's presented. It's making it seem like it's something you should do all the time.

10:10.000 --> 10:37.000
It is just my belief, because I think the truth is, there's multiple things you could be doing here, right? I think that should really be a tool in your tool chest. Like I said, I use it. But that's not the first thing you go to. And I can tell you, coming from the Ruby world, features like this have been overused and have wreaked havoc on production code bases.

10:37.000 --> 10:51.000
Now, I don't think I ever said, thou shalt not use macros. But I don't think you should think of it first, right? I definitely feel like it is a dangerous feature, I guess is what I'm getting at, right?

10:51.000 --> 11:05.000
You know, it's the jigsaw in a wood shop. I don't know if you've ever done any woodworking. But it is a pretty powerful, pretty precise tool that you can do a lot of cool stuff with. It's also one of the tools that people most often get injured with.

11:05.000 --> 11:30.000
Yeah, no, I think there's a lot to be said for that, right? It can be very useful to have in a language and can allow a lot of experimentation or DSLs or clean up better, more expressive APIs. But you're right, it's something you reach for only when that's the only thing that will do. And after you've already learned the language, learned to, you know, sort of work within the boundaries, much like with writing anything, right? You got to learn the rules before you can bend them.

11:30.000 --> 11:59.000
Yeah, and I would say like, my, my, my biggest kind of hiccup with how macros are presented in the crystal documentation, and they're in the various guides I read, was that they were presented very early, which I guess you could say someone looking at crystal in 2019 is probably already an experienced developer. So you should trust them. I don't, right? It's just my opinion that that's the kind of feature you ought not use, unless you've very much really, really have a good reason.

11:59.000 --> 12:15.000
Which, again, is an opinion. And, you know, I have seen beautiful Rust macros, I have written Rust macros that made my life easier, right, Wes, you made a good point, it makes your code cleaner, because sometimes you just need to do something and like, not using a macro would be spaghetti.

12:15.000 --> 12:24.000
Yeah, exactly. Or maybe you have to repeat yourself a whole bunch, because the language you're using doesn't sort of let you extend in a natural way in some area. And you can sort of templatize that with macros.

12:24.000 --> 12:41.000
Yeah, it's weird. And I think there's some overloading of terms here too. Because like, their macro, yeah, we're gonna get way too deep into language specifics on Ruby. But people have justified very bad practices in the Ruby community by calling them the equivalent of macros.

12:41.000 --> 12:56.000
And we can end up in this weird philosophical debate of like, what is a macro? You know, I will concede the point to the Redditor that I am maybe overly conservative on this point. But not necessarily completely wrong.

12:56.000 --> 13:17.000
Right. No, it's an interesting discussion. And you're right, like in Ruby, you know, things can go wrong. And you do have to be careful when you're changing the way things work, you know, you're breaking a lot of assumptions people have, and it better be clear what's happening. I think we none of us like to be the developer that gets put in a new code base. And there's all this weird magic and non standard stuff going on. And it takes forever to get up to speed as a result.

13:17.000 --> 13:34.000
Yeah, I mean, that's kind of in the in West, I think you actually made my point better than I did. My whole thing is I'm always thinking of, you know, I have been the developer who picks up the project after five years. And I'm also like, often, you know, because people don't want to hire contractors or consultants forever, in some cases.

13:34.000 --> 13:54.000
So, you know, I am sometimes turning over code bases, particularly when I work with smaller companies that like I've worked on for six months or a year, and their internal people are going to do and if I have a bunch of not I like your term non standard behavior in there. Well, that's going to be a nightmare for the next person. And I really don't like giving people nightmares, other than you and Chris.

13:54.000 --> 14:14.000
Yeah, well, you're good at that. Thank you a little. I'd just like to say a little thank you to wasa be over on our subreddit to who pointed out we missed a link, Mike, you'd recommended the imposters handbook as a guide for self taught programmers, which I think is a great reference. So sorry about that. I've been I've added it to the show notes. And we'll have it in the show as well. Because why not?

14:14.000 --> 14:29.000
Yep, that was my bad. Sorry, guys. So, uh, Wes, I have an advertising opportunity I'd like to discuss. Oh, tell me more, Mike. You know, we have ads on our phones, we have ads in our browsers, we have billboards in the real world. But how about some ads in terminal?

14:29.000 --> 14:46.000
Oh, boy. Well, I've got some bad news for you then, Mike, because Oh, no. Yeah. According to NPM, Inc, the company that runs, you know, NPM, the popular JavaScript packaging tool, well, they've taken a new stance and plan to ban exactly that behavior.

14:46.000 --> 15:15.000
I have never been more happy about unilateral action in my life. This all came up because as we talked about last week, right, as standard, a popular JavaScript library started showing ads in the terminal after being installed. The ads were actually being shown by another package called funding that was included in standards code base. And, you know, they're both developed by the same developer. And he was just trying to seek a way to sort of alleviate costs for running the project. The JavaScript community didn't like it.

15:15.000 --> 15:36.000
The JavaScript community didn't really react the way that he expected, and has just mostly been criticized, especially people who started finding these ads polluting their production logs. And, you know, that makes people rather unhappy. It also saw someone else create the first ever, at least to our knowledge, terminal ad blocker. So that's pretty entertaining, too.

15:36.000 --> 15:38.000
We truly live in a fallen world.

15:38.000 --> 16:05.000
So NPM's new rules, they're basically going to ban packages that display ads at runtime, on installation, or at other stages of the software development lifecycle. Packages with code that can be used to display ads, those are fine, but packages themselves cannot display ads. Packages that themselves function primarily as ads with only placeholder or negligible code data or other technical content. So those will also be banned.

16:05.000 --> 16:13.000
What do you think of this? I mean, no one really wants ads in their terminal, but we've brought up many times, funding is hard for independent developers.

16:13.000 --> 16:29.000
Yeah, but no. Something feels very wrong to me about polluting people's production logs with ads. I think just like we should all have a coder radio agreement here and like not do this.

16:29.000 --> 16:47.000
You know, I've also seen, it makes me think of some other programs. One that comes to mind is the GNU parallel, which is kind of like Xargs, but on steroids. And they display a little banner sort of talking about how the software is development and showing how to cite them, unless you pass an explicit flag each time.

16:47.000 --> 16:56.000
Yeah, so I don't know if there's room here or not, but it's interesting. And, you know, if you've got JavaScript packages, well, watch out for these new rules.

16:56.000 --> 17:13.000
Yeah, it's interesting. I mean, it does go to the story we talked about last week about how many of these open source maintainers of vital packages are basically, you know, doing this work for a subsistence or less, which is bad. But this is probably not the way to get funding.

17:13.000 --> 17:23.000
Right. And I mean, I guess as we saw in this case, it didn't really work out and mostly got a negative reaction. So ideals aside doesn't seem to work well in practice.

17:23.000 --> 17:34.000
Right. Well, here's another story to get upset about. And really, it's actually, it's not new. But we both noticed people had just sort of picked it up again. It had been floating around on a lot of the aggregator sites.

17:34.000 --> 17:42.000
And that's the news back, I think back from June originally, that Apple wants to remove scripting languages from Mac OS.

17:42.000 --> 17:59.000
Xcode 11 Beta 7 release notes state scripting language runtime such as Python, Ruby and Perl are included in Mac OS 4 compatibility with legacy software. In future versions, scripting language runtimes won't be available by default, and may require you to install an additional package.

17:59.000 --> 18:05.000
If your software depends on scripting languages, it's recommended that you bundle the runtime within the app.

18:05.000 --> 18:14.000
Now, first things first, what do you think about the term scripting language, Mike? We're talking about your beloved Ruby here, something you develop applications with.

18:14.000 --> 18:21.000
Yeah, I saw there's quite a bit of fervor here on what do you mean scripting language? I don't know that I care.

18:21.000 --> 18:36.000
I mean, all they had to say was interpreted language, right? They would have dodged the entire controversy. But yeah, I mean, scripting, kind of use scripting and interpreted to be the same thing.

18:36.000 --> 18:43.000
I know it's wrong, but I don't know what a scripting language would be today. Is it PowerShell script? Right? Bash script?

18:43.000 --> 18:52.000
Yeah, I mean, I guess those are things you can write that the language makes it easy to write short little programs and maybe you can use in an interactive way.

18:52.000 --> 18:55.000
I don't know if that's required or not, but I certainly like those.

18:55.000 --> 19:09.000
So this might be a nothing burger, right? Like if the package that you get Ruby, Python and Perl in, it's just like something, it's one of those things like on Mac where you type in like, you know, I think if you type in Java C now, it brings up a you need to install Java.

19:09.000 --> 19:10.000
Oh, yeah.

19:10.000 --> 19:17.000
If it's just something like that, where if you type in like Ruby and it's like, oh, would you like to download the Ruby package? That's fine.

19:17.000 --> 19:29.000
But kind of the key issue here is that the Mac package manager homebrew, which is not official because Apple doesn't like package managers for some reason, requires you to have Ruby.

19:29.000 --> 19:33.000
And it assumes because all Macs up until today have had Ruby on them.

19:33.000 --> 19:44.000
I mean, of course, there's the trolley, you know, come to Linux guys. Fair enough. But it seems weird. And I don't quite understand why they're doing this.

19:44.000 --> 19:52.000
And I get that you want to do as little work as possible. But, you know, Macs used to be pitch themselves as like, this is the developer workstation.

19:52.000 --> 20:04.000
And while they never did a great job at keeping their versions of these scripting environments, or, oh, God, these interpreted languages updated, it was nice that there was a version by default.

20:04.000 --> 20:11.000
Some people I've seen speculating, you know, that, that this has moved just to try to push people more on to their their own language runtimes.

20:11.000 --> 20:16.000
Wow, but people doing things, particularly in like Perl, are not going to go to Swift.

20:16.000 --> 20:25.000
Okay, fair enough. Right. Like, you know, all of these Perl, Python and Ruby, you're going to switch to Swift? Really?

20:25.000 --> 20:31.000
Like, I could see someone saying, oh, geez, I'm so annoyed with Perl, I'm going to go to Ruby or Python. Yeah, that's that's the thing that happens, right?

20:31.000 --> 20:37.000
Many Ruby developers were or are Perl developers. And there's constant bleeding between Python and Ruby.

20:37.000 --> 20:48.000
But I don't think anyone's going to Swift from these. I don't, I don't understand why this would be done other than saving time.

20:48.000 --> 20:53.000
Yeah, I mean, is it just a simplicity play? You know, I mean, they're not they weren't really updating them anyway.

20:53.000 --> 20:57.000
And there is already culture, as you noted, right, like Apple doesn't care for package manager.

20:57.000 --> 21:04.000
So there's already this culture of like, installing their their bundled style of applications or maybe just even, you know, heck, getting it from the store.

21:04.000 --> 21:09.000
Well, they did this with Java when Oracle changed the license. So I'm not wondering, right?

21:09.000 --> 21:20.000
Like, that's the reason they're going to fish sell instead of bash is the GPL three. So I, I couldn't find concrete proof, but it's either like laziness.

21:20.000 --> 21:28.000
But, you know, Apple actually does, like, try to do a good job. I almost wonder, is there some licensing thing that they're afraid of?

21:28.000 --> 21:36.000
I kind of this is, I mean, the reality of the situation is what's going to happen, okay, the homebrew community is going to come together and fix this.

21:36.000 --> 21:44.000
And I bet they're going to keep like, you should first of all, do not bundle the runtime with your with your packages. That's bad.

21:44.000 --> 21:51.000
Don't do that. You don't need to make your applications, your package, your little whatever one off command line program super big.

21:51.000 --> 21:59.000
What about when you need libraries, though? So what this had me all thinking about, it just made me start thinking about, like, does that just mean that these tools, you know,

21:59.000 --> 22:10.000
we talked about the pie oxidizer project, for example, and in the, which is a tool to sort of bundle Python apps and in the launching blog post, the author writes,

22:10.000 --> 22:19.000
Python hasn't ever had a consistent story for how I give my code to someone else, especially if that someone else isn't a developer, and just wants to use my application.

22:19.000 --> 22:29.000
So like, can you rely on whatever random runtime, you know, if you also need, you also need to install libraries need to make sure that those work, maybe some of those libraries require a certain version of the runtime.

22:29.000 --> 22:37.000
So I mean, just because that's what I know best in the Ruby world, you can put like a dot Ruby version in your in whatever you're distributing.

22:37.000 --> 22:42.000
And it will warn the user if they don't have the right version of Ruby, right?

22:42.000 --> 22:49.000
Right. But then doesn't that just mean you're like, whatever the person you're trying to sell your nice little app to has to go figure out how they install Ruby.

22:49.000 --> 22:53.000
So now we're getting into dark sides of sandboxing here, too, though, right?

22:53.000 --> 22:55.000
So there's two ways to approach this problem.

22:55.000 --> 23:05.000
What Apple seems to be suggesting is that everything becomes like Docker, where when I distribute my application to you, I'm giving you the environment that I built it on.

23:05.000 --> 23:08.000
Mm hmm. Right. Or whatever environment you want it to run in.

23:08.000 --> 23:17.000
That's how Mac apps tend to work. If you if you've actually like there are there are system libraries that because Apple controls everything they know they are.

23:17.000 --> 23:21.000
But yeah, anything else you are distributing the libraries for application.

23:21.000 --> 23:25.000
My hiccup here is they specifically use the word scripting.

23:25.000 --> 23:31.000
So I don't think I mean, I could be wrong because, you know, they're never going to confirm or deny until they do it.

23:31.000 --> 23:38.000
But I don't think they mean like using one of those weird, like, you know, gooey things that lets you write gooey apps in Python or Ruby.

23:38.000 --> 23:40.000
I don't think that's like what they're talking about here.

23:40.000 --> 23:48.000
I don't think that we're talking about things that end in dot app where you launch them on your Mac through through Aqua.

23:48.000 --> 23:58.000
I think they literally mean like configuration scripts and command line applications, in which case distributing the entire runtime seems a little silly to me.

23:58.000 --> 24:00.000
You certainly can do it.

24:00.000 --> 24:02.000
Well, there is the other point, as you say, right?

24:02.000 --> 24:07.000
Like, I mean, having a default runtime doesn't mean that you can't distribute your own.

24:07.000 --> 24:10.000
All right. I have like seven versions of Ruby on my Mac.

24:10.000 --> 24:14.000
This is a solved problem. And maybe that maybe that's Apple's point.

24:14.000 --> 24:17.000
The only people using these languages are developers.

24:17.000 --> 24:22.000
And like adding one more step to set up your dev machine to save them a ton of time doing this.

24:22.000 --> 24:24.000
Maybe that's exactly maybe that's all it is, right?

24:24.000 --> 24:27.000
We might be overthinking it. It might just be they don't want to do the work anymore.

24:27.000 --> 24:34.000
They know developers will just, you know, download the languages and the runtimes be good to go.

24:34.000 --> 24:40.000
I don't know. This is the kind of thing, though, I wish they would be more transparent on because this actually affects people's livelihoods.

24:40.000 --> 24:45.000
Right. And maybe it makes you question, too, like, you know, is this going to keep working as a platform for me to work on?

24:45.000 --> 24:51.000
Right. Is it just going to be another paper cut of like, OK, this is yet another thing that I have to accommodate because Mac is weird.

24:51.000 --> 24:56.000
You know, it did make me kind of curious, aside from the Mac part of this whole thing.

24:56.000 --> 25:04.000
I was thinking about this problem on my own as well, because I sometimes have, you know, people I work with that I want to distribute things to or friends, maybe a tool I could craft for them.

25:04.000 --> 25:09.000
And they're not always developers, you know, they're computer literate, let's say, but not sophisticated.

25:09.000 --> 25:14.000
Have you had to package Ruby apps before? Because I did some searching around.

25:14.000 --> 25:20.000
I saw traveling Ruby, which was from the Fusion folks, although it doesn't seem to have been updated since 2018.

25:20.000 --> 25:25.000
And then I also found a project called Ruby Packer. Have you used anything like that?

25:25.000 --> 25:31.000
So most of the command line Ruby apps I use, we're using internally, and we all standardize on certain versions of Ruby.

25:31.000 --> 25:35.000
Or they're Rails apps, and I deploy them, you know, myself to the server.

25:35.000 --> 25:38.000
Even in the Linux world, things are moving a little bit this way, too, right?

25:38.000 --> 25:45.000
I mean, we've seen more and more just regular containers, Docker containers, but then also things like snap packages and Flatpak and AppImage.

25:45.000 --> 25:48.000
Also environments where you can ship a whole bunch of libraries if you want to.

25:48.000 --> 25:54.000
Yeah, which, like, might be the way we're going, right? This might just be an industry trend that Apple is kind of catching up to.

25:54.000 --> 25:55.000
Yeah, that's true.

25:55.000 --> 25:58.000
I don't know. We should all be running Gen 2.

25:58.000 --> 26:00.000
Maybe we should.

26:00.000 --> 26:08.000
You know, this whole thing has just been making me think, though, about, okay, what is a scripting environment and what makes that different?

26:08.000 --> 26:12.000
And we've got shells, like you mentioned, you're a fish shell fan too, right, Mike?

26:12.000 --> 26:17.000
I know Chris and I both like it as well, but even just Bash is a rich environment.

26:17.000 --> 26:24.000
It's a way to sort of, you know, you do, like you interact, like you send a query, the computer responds, and you repeat that cycle.

26:24.000 --> 26:33.000
And I remember this good blog article by Michael Fogus, who is a – well, he's just – he's done all kinds of – a prolific programmer, let's say,

26:33.000 --> 26:38.000
and has happened to be a co-author of one of my favorite books for learning Clojure, which is The Joy of Clojure.

26:38.000 --> 26:50.000
But back in April, he had an article titled, Notes on Interactive Computing Environments, and kind of reviews some interesting highlights from computer history about things.

26:50.000 --> 26:53.000
You know, things like Smalltalk and Forth and environments we've talked about.

26:53.000 --> 26:56.000
But I just like this quote that he highlights.

26:56.000 --> 27:03.000
Your programming environments should be an active partner in the act of creating systems.

27:03.000 --> 27:08.000
And I just thought that, you know, it kind of ties in with the way that you interact with scripting languages.

27:08.000 --> 27:17.000
It ties into the way you interact with maybe a rich IDE on a statically typed language, stuff we were talking about at the start of the show with Rust and whatever the future might be.

27:17.000 --> 27:18.000
Yeah, it's interesting.

27:18.000 --> 27:21.000
I mean, I definitely like the interactive Ruby mode.

27:21.000 --> 27:26.000
Or like, it makes me think of Emacs as well, which is another example he cites, right?

27:26.000 --> 27:30.000
Emacs is so extensible, and it has its own little language you can use so you can build it.

27:30.000 --> 27:41.000
And people who use it well, right, they use it for code, they use it to edit text, they use it to make blogs, they use it for programming, for to-do lists, for source control management, and all kinds of crazy stuff, right?

27:41.000 --> 27:43.000
I mean, heck, you can boot up into it.

27:43.000 --> 27:48.000
The other interesting thing, you mentioned this at the start, is woodworking.

27:48.000 --> 27:56.000
And there's a great talk by a programmer named Tim Ewald about programming with hand tools.

27:56.000 --> 28:03.000
And it's all about sort of the joy of working with hand tools and having simple pieces that you can sort of add together and understand.

28:03.000 --> 28:12.000
And your example from earlier, when you have a powerful piece of construction equipment, well, it is very useful, but it also means you can hurt yourself.

28:12.000 --> 28:17.000
And oftentimes, you can really get by with simpler but interactive tooling.

28:17.000 --> 28:18.000
Like Objective-C.

28:18.000 --> 28:19.000
Like Objective-C.

28:19.000 --> 28:28.000
Well, I mean, it would just make me think even of just being in the shell and using tools there and how many affordances we have.

28:28.000 --> 28:34.000
So in the show notes, we'll also have a link to a recent article, Things You Didn't Know About GNU Readline.

28:34.000 --> 28:37.000
Because, I mean, Readline is an awesome little software library.

28:37.000 --> 28:39.000
It lets you do so much.

28:39.000 --> 28:42.000
And you can actually hook into it yourself.

28:42.000 --> 28:44.000
You get all that goodness.

28:44.000 --> 28:51.000
It used to be actually a part of the Bash shell intrinsically, but has obviously been sort of refactored out.

28:51.000 --> 28:56.000
And now you can use it if you want to make your own sort of command line interactive application.

28:56.000 --> 29:03.000
Which also got me thinking, you know, why don't we expect better from our command line environments?

29:03.000 --> 29:08.000
I wonder if we've been a bit distracted by developments in sort of richer IDEs.

29:08.000 --> 29:21.000
And so it's now just the sort of especially nerdy, maybe more Unix-focused person who cobbles together their IDE from a text editor and some scripts and stuff.

29:21.000 --> 29:23.000
And the majority have moved on.

29:23.000 --> 29:25.000
Well, I would push back a little bit, right?

29:25.000 --> 29:31.000
Like with the new Windows terminal, I think you were definitely right for quite a long time.

29:31.000 --> 29:33.000
But I think people are moving back.

29:33.000 --> 29:37.000
I can tell you in the early aughts, like the big thing was Vim, right?

29:37.000 --> 29:40.000
Like you had to, you know, you ran a Mac and you knew Vim.

29:40.000 --> 29:42.000
You had to use Vim, right?

29:42.000 --> 29:44.000
Especially if you were doing Ruby.

29:44.000 --> 29:46.000
It was like all the hotness.

29:46.000 --> 29:51.000
Thoughtbot used to do all these conferences on it, all this crap about Vim, Vim, Vim, Vim, Vim.

29:51.000 --> 30:00.000
I think now in a lot of ways VS Code is kind of taking that mantle, which is weird because it's not by any stretch of command line tool.

30:00.000 --> 30:08.000
I'm seeing a lot of people modding it and like kind of going full, you know, Emacs beard with their VS Code environment.

30:08.000 --> 30:14.000
Yeah, I mean, are we going to go back to the glory days of Emacs Vim? Probably not.

30:14.000 --> 30:18.000
But I think a lot of people are using these tools still.

30:18.000 --> 30:27.000
And I actually think one of the interesting things about Catalina, the new version of Mac OS coming out, is that it's defaulting to FishCell.

30:27.000 --> 30:30.000
Which is going to get a lot more people using FishCell overnight.

30:30.000 --> 30:34.000
Yeah, absolutely. And I mean, just by default Fish is doing more.

30:34.000 --> 30:40.000
You know, like you can tune and tweak Bash to do a lot of neat stuff, but Fish has a lot of those sorts of stuff on by default.

30:40.000 --> 30:41.000
Out of the box.

30:41.000 --> 30:46.000
And so you're suddenly like, oh, it's like auto completing and offering me suggestions and it's bright and happy and colorful.

30:46.000 --> 30:54.000
You know, I often think that like the big IDEs are easy for people to get started with because they tend to have wizards and kind of like step by step setups.

30:54.000 --> 30:58.000
For, you know, setting up tool chain, which can be challenging when you're new.

30:58.000 --> 31:03.000
But as you get more experience, the IDE can feel like a prison.

31:03.000 --> 31:10.000
That's not always true, right? Like if you're doing.NET, it really is hard to find an environment for.NET that is better than Visual Studio on Windows.

31:10.000 --> 31:17.000
But particularly if you're doing these quote unquote scripting languages, Python, Ruby, like I like Ruby mine, I like PyCharm.

31:17.000 --> 31:21.000
But yeah, I mean, I every once in a while just do it in Vim.

31:21.000 --> 31:26.000
Yeah, I mean, do you ever you just ever open up IRB and sort of poke around for a little bit?

31:26.000 --> 31:27.000
Oh, all the time.

31:27.000 --> 31:30.000
Yeah. OK, so that's where it like it gets back.

31:30.000 --> 31:32.000
You're right, IDEs can be like a good get up to speed.

31:32.000 --> 31:36.000
They can do, you know, hide a lot of the stuff you don't need to worry about as a beginner.

31:36.000 --> 31:38.000
But I think the opposite can be true, too, right?

31:38.000 --> 31:41.000
Because there's like so many knobs and buttons and preferences.

31:41.000 --> 31:45.000
And it might depend if you're inheriting an existing project versus just playing around.

31:45.000 --> 31:54.000
Because I think if we had better, you know, commonly used sorts of like rebels and interactive command lines, that might just be a great way.

31:54.000 --> 32:01.000
Because I love that when I'm trying out a new language, if I can just start up a session and sort of play, you know, have a conversation back and forth.

32:01.000 --> 32:10.000
And so recently, having been spoiled by Clojure, there's been a recent sort of it's called Rebel Readline, which is a it's a rebel.

32:10.000 --> 32:15.000
But using the new read line that has a rich sort of, you know, does syntax highlighting and auto complete stuff.

32:15.000 --> 32:18.000
And it'll indent and format all your code for you.

32:18.000 --> 32:25.000
So I kind of went hunting around for other languages I use, which led me to BePython, which is just like a simple.

32:25.000 --> 32:29.000
It's not as fancy and complicated as like IPython, Jupyter Notebook style stuff.

32:29.000 --> 32:33.000
But it's just a fancy Curses interface to Python.

32:33.000 --> 32:41.000
And so you get lots of nice stuff like colors and tab complete and, you know, sort of help you explore around like you're used to in, you know, IntelliSense style in an IDE.

32:41.000 --> 32:43.000
But like just right there on the command line.

32:43.000 --> 32:49.000
I've also in my personal development, when I've been doing Ruby, I've been playing with Pry a lot.

32:49.000 --> 32:51.000
And it's it is awesome.

32:51.000 --> 32:56.000
It's about the best thing outside of the Clojure world and like an interactive rebel I've been able to find.

32:56.000 --> 32:57.000
Have you used it ever?

32:57.000 --> 32:59.000
I have not. What is that?

32:59.000 --> 33:01.000
It's a it's a it's a Ruby rebel.

33:01.000 --> 33:10.000
Well, really, they call it a runtime developer console and IRB alternative with powerful introspection capabilities.

33:10.000 --> 33:12.000
And it is neat.

33:12.000 --> 33:17.000
So in the Clojure world, one of the unique things you do in the way you interact with it right as you you go write some code in your editor.

33:17.000 --> 33:23.000
And then when you finish that little form, you finished the new function or the changes to the function that you're working on or whatever.

33:23.000 --> 33:29.000
You go hit a command and then that sends it over the wire and it gets evaluated in your running environment.

33:29.000 --> 33:39.000
And while I don't quite have that sort of like networked, you know, at a distance with with Pry at the moment, you can like do everything in it.

33:39.000 --> 33:42.000
So you can ask it to like you want to make a change, you tell it you want to edit a file.

33:42.000 --> 33:45.000
It'll pull up that file in your editor.

33:45.000 --> 33:49.000
And then when you've saved it, it'll then go reload that file for you.

33:49.000 --> 33:51.000
And then you can go futz around and play with it more.

33:51.000 --> 33:52.000
Interesting.

33:52.000 --> 33:57.000
I learned about it first when because another way you can use it is if you load it in an application you're developing.

33:57.000 --> 34:02.000
It's got like a binding you can call and then it just loads an interactive debugger right there.

34:02.000 --> 34:06.000
And then you have a REPL at that break point that you can, you know, investigate all the state.

34:06.000 --> 34:07.000
That is pretty cool actually.

34:07.000 --> 34:08.000
Yeah.

34:08.000 --> 34:09.000
Yeah, that's what I thought.

34:09.000 --> 34:11.000
Look at you dipping into Ruby, by the way.

34:11.000 --> 34:12.000
I know.

34:12.000 --> 34:16.000
Well, it turns out that there's like a lot of libraries for it and tools based around it.

34:16.000 --> 34:21.000
So turns out sometimes the network effect is very real.

34:21.000 --> 34:22.000
Admit it. You love it.

34:22.000 --> 34:25.000
Now, OK, so totally independent of that little train of thought.

34:25.000 --> 34:33.000
I also had before I'd put that in the doc, I'd already added this little pick, which is maybe our final little segment for today.

34:33.000 --> 34:40.000
And that's light CLI, which is a CLI for SQLite databases with auto completion and syntax highlighting.

34:40.000 --> 34:42.000
And I just thought that's great, too.

34:42.000 --> 34:43.000
So what does it exactly do?

34:43.000 --> 34:48.000
So if you go pop over to their GitHub page, they've got some nice little demos and GIFs showing you stuff.

34:48.000 --> 34:54.000
And, you know, if you've ever had to go investigate a little database without maybe knowing the schemas that are involved.

34:54.000 --> 34:57.000
It just presents you a nice little interface to go poke around with.

34:57.000 --> 35:02.000
You can go view the tables and it'll sort of auto complete what the rows and columns are for you.

35:02.000 --> 35:03.000
And I love tools like that.

35:03.000 --> 35:07.000
Whenever you're in a new environment, you're not familiar with everything that's going on.

35:07.000 --> 35:15.000
Anything that can help me get my hooks in, you know, find the threads that you need to pull to actually understand what's happening in this program.

35:15.000 --> 35:16.000
I love it every time.

35:16.000 --> 35:25.000
Now, if you've got a favorite command line interactive application or REPL or shell of any kind, well, I would certainly love to hear about it.

35:25.000 --> 35:30.000
And you can let us know over at coder.show slash contact.

35:30.000 --> 35:34.000
Coder.show also has our whole Coder radio back catalog.

35:34.000 --> 35:37.000
And there's a lot of good stuff over there.

35:37.000 --> 35:45.000
If even that's not enough, well, head on over to Jupiter broadcasting dot com where you'll find all the other fine Jupiter broadcasting shows.

35:45.000 --> 35:49.000
And if you haven't heard yet, well, we've got a new show in the works.

35:49.000 --> 35:51.000
That's right. Self hosted.

35:51.000 --> 35:53.000
And it's going to be coming out real soon.

35:53.000 --> 35:58.000
So you might want to go check out self hosted dot show and get subscribed right away.

35:58.000 --> 36:02.000
Now, if you'd like a little bit more Michael Dominic and why wouldn't you?

36:02.000 --> 36:04.000
You can find him over on Twitter.

36:04.000 --> 36:06.000
Mike, you're at Dimenuco.

36:06.000 --> 36:07.000
I'm there, too.

36:07.000 --> 36:09.000
I'm at Westpane.

36:09.000 --> 36:12.000
And of course, the Jupiter Network's there at Jupiter signal.

36:12.000 --> 36:14.000
Thank you all for joining us.

36:14.000 --> 36:16.000
We'll see you right back here next week.


This is Koda Radio, episode 341 for January 22, 2019.
Hello, and welcome to Koda Radio, Jupiter Broadcasting's weekly talk show that takes
a pragmatic, or so we like to think, look at the art and business of software development.
Chris is away again this week, but don't worry, I'm back, and I'm of course lucky
to be joined with the incredible, the mad botter himself, Mr. Michael Dominic.
Welcome Mike.
Hello, Mr. Payne, you know, if we keep this up, people will start talking.
Oh, they might already be.
Fake names, yeah.
Oh, you're not, you're not doing that?
That's just for safety's sake, Mike.
Oh, that's a, well, hey, did you see the NSA charger at SchmooCon?
Yes, what is happening?
I wonder how many people actually used that.
Actually, the biggest troll would be if it really wasn't like a rootkit, if it was just
like actually a charger.
Yeah, they're like, man, we all, we all got phones, people gotta charge, we're trying
to help a brother out.
It's like, guys, we're recruiting, why would we screw with you?
Yeah, we want the smart people, which, you know, is true, as long as you can pass those
government drug tests.
Automatic disqualification if you plug in your phone.
Right, yeah, no, please, please don't talk to us ever again.
Get out of here.
Yeah.
And we know everything already because, you know, you just plugged in your whole life.
Oh, yes, and I guess really speaking about plugging in your whole life, last time I was
here and chatting with you, Mr. Mike, we talked a bit about the painfulness of USB-C and that's
kind of been a common topic on the show.
Sounds like you got some feedback about it.
Yeah, so the USB-C I'm talking about in particular is the 2018 iPad Pro, obviously has USB-C
port and it is theoretically possible that you could basically treat it like any other
port, right?
And I actually did my job this time, Wes.
I tried to get confirmation from Apple's developer line and believe it or not, I actually got
someone on the phone.
Wait, no, you talked to a human freaking being over there?
Well, I can't prove they weren't a Cylon.
Well, no, sure, I mean, I don't expect you to be able to, but they approximated it.
They passed your test.
Yes, and the answer was, of course, not helpful, is what I did there for a second.
What are you doing to me, man?
What are you doing?
I was so excited.
Well, it's interesting, though, you certainly can use the USB port and these are the so
far things that we've thought.
You know, and people, if you've never done an iOS development, it is theoretically possible
to email or call Apple, but they will never like pre-approve something.
Like, so the case I gave them is I want to use an iPad, plug it into a Raspberry Pi and
flash the Raspberry Pi from the iPad.
I want to make like a little graphical app to do that, right?
Oh, that would be, that's a great idea.
Yeah, so anybody wants to steal that, you'll get it done faster than me.
And I told the rep that and it was kind of, eh, maybe, try, sounds cool, but you know,
can't promise anything.
So, they're not saying outright, no, absolutely not, they're saying, well, you're just going
to have to see.
Wow, that's useless.
Yeah, and I've called them a few times over the course of the show and it's kind of like,
I think they only actually said no once because it was, oh, it was something, long-term listeners
will know, there's something I wanted to do with the in-app subscription thing that wasn't
at the time allowed, but ironically now is allowed.
So it was, I wanted to do in-app purchases and make them be a subscription before there
were subscriptions.
So like, basically every month, just like trigger something to ask you to do an in-app
purchase.
Oh, I see, so that was just going to be like, hey, yeah, please support us again.
That, you can't do that.
Now you can because obviously they have subscriptions, but so, I don't know.
I mean, I got a lot of feedback, half of the people saying, well, there was really thirds,
one third saying, put down the Mac before you break it, which I mean, fair criticism.
That is a great point and please be careful, we just, I fear for anything, any device that
enters into your home.
Well, I'm now using my old Dell Optiplex because it's a desktop and my Thaleo is, oh, don't
say that.
Don't say that.
Please don't say that.
My Thaleo is on its way, but I am putting the Thaleo in carbonite like Han Solo, just
nice shielding.
That way you can't appreciate its beautiful design.
Yeah, I know, but I would destroy it.
Yeah, it's better for the beautiful wood veneer that you just keep it as far away as possible.
Maybe if you could put it sort of behind the wall just with the cables coming out, that
might be the best.
Well, actually, if my desk, and this is way inside baseball, is one of those two level
desks, it's like an old antique style, so I'm just going to put it on the higher level.
So if I do spill something, I only destroy my mouse and keyboard.
Good idea.
Yeah.
So the USB-C thing is kind of, we don't really have an answer here.
There are certain documented things in the docs I shared about three weeks ago, maybe,
maybe three weeks ago, that you certainly can do, right?
Integrate with the photos app on the device, and there's a bunch of stuff, music, movies,
whatever, as well as the onboard file system, but not the real file system, the little files
app.
So I can't say yes or no.
People writing and asking, give it a shot, but don't invest your life savings, because
you could get rejected, right?
My suspicion, Wes, is that in the next major bump of iOS, so like 13, there is going to
be expanded functionality as the other devices get USB-C, because the other challenge you
would have if you did something like what I'm describing, which I just thought of and
probably the reason the guy didn't give me a straight answer, your app can't just run
on one version of the iPad.
So you would have to have another mechanism for this to work on non-USB-C iPads, and to
integrate with the Lightning port, you have to actually pay a licensing fee.
Right, yeah, there's a whole kit and caboodle that goes around that.
Wow.
So never mind this.
It's just a bad idea.
Yeah.
Or the time will come, and of course, in typical Apple fashion, you don't get access to everything
out the gate.
You just piecemeal it, slowly add as there's enough demand, and they add it the way they
want to have it, seen it done, and conforms to their standards.
And really, I guess they just get away with it, right, because they're the place to be.
They've got the market, they've got the users, so you've got to play ball.
Well, and they have the best tablet on the market right now.
And they have the only tablet worth buying.
Till System76 launches a tablet.
Fake rumors started here.
Oh, stop doing this to me.
This whole episode so far has been you making up, teasing things that I assume won't happen
in any reasonable time frame.
Speaking of teasing, I'm getting tired, Wes.
I can't do all these deployments and builds manually.
Do you have a way I could automate that?
Well, actually, there's been a lot of talk around some of the community about some tools
to do just that.
And one of them is Jenkins.
And it kind of brought up a topic for me in general, too, that I'm sort of curious about
what happens in your world.
You were just talking about, there's a lot of things to do.
There's deployments, there's testing to be run, there's all sorts of integrations to
do and other sorts of configuration.
And just, you know, there's cron jobs, there's services to be run.
Jenkins can do all of that, right?
That's one thing that's pretty nice about it, but it doesn't have to do all of that.
I'm wondering, like, what do you use for your own work?
Are you someone who runs their own CI system and their own deployment stuff?
Do you just rely on the tools provided by whatever integrating and partners you have?
I don't do a lot of CI.
I tend to, I used to use Jenkins when I used to do JotSpring.
You don't have to be bashful about it.
You can come out and be you, Mike.
I'm going to come out of the closet.
I am not huge into the automation.
The thing I do do is, do do, Docker and DoKu with some very light webhooks into GitLab.
Beyond that, it's one of the things I just don't do too much.
I'm pretty manual.
If something needs to be deployed, I also don't do a lot of automated testing is why
I don't do a lot of CI.
Oh, yeah.
Right.
You don't have to test it.
I heard it.
I felt the judgment.
But you've lived another life where you have used this gremlin of ours, Mr. Jenkins, right?
Yeah, I was once required to.
It actually, but I hear it's a whole different world now.
We're going back probably four and a half years, the last time I used it.
Yeah.
We're going back at 2011.
That's when the name change happened.
That's when there was all this drama about Oracle's fork and Hudson became Jenkins.
It feels like a long time ago.
I mean, it's not really, I suppose, eight years now, and it's surprising both what's
changed and really, really what's stayed the same.
I think you'd be surprised.
So, yes, there are.
There's some new things.
There's Jenkins X.
They've also got this blue ocean interface.
Those are relevant.
We'll talk about them.
But overall, I think if you logged into a newly stood up Jenkins server, sure, it might
be running on Kubernetes today, but I think it would look probably identical.
So what's the big change then?
I mean, it's been about four years.
What would be new to me coming to it?
Well, okay.
Probably what would be new to you.
There would be small things.
There'd be lots of different plugins, different plugin updates, things like that.
And I think one of the things that's caused a lot of pain for people is not that it's
useful.
It's just that things keep changing and it doesn't feel finished.
So one of the things people really like about CI systems is building pipelines.
Yeah.
Yeah.
Also, it's called Jenkins now.
So there you go.
But people like to build pipelines so that you can, you know, you have things usually
driven by automation, but it doesn't have to necessarily be, it could be a human kicking
it off.
You start something, it pulls some code from Git, does some build steps, maybe does tests,
maybe does a test deployment and spins up some test infrastructure to go run further
tests or to leave it there for downstream applications to test against.
You have all these options and you don't want to have to do it.
Sure.
You can write a bash script.
That's, that's one way to do it, but that's pretty painful.
And so there's been these promise of various different pipeline syntax.
One version of it, it's basically just sort of groovy, like a groovy DSL with some handy
functions already implemented for you.
So you can sort of define how stuff runs and on which agents or is it, you know, is it,
is it thread safe or not?
All those little nitty gritty details that you don't want to think about, but sometimes
you have to, if you have complicated stateful testing to do, but even that hasn't really
stayed the same.
It keeps kind of changing and they'll have, you'll have one sort of really declarative
style of syntax, or you'll have another one that is more imperative and kind of, you have
to walk through exactly every single step that you want to do.
And it's kind of become at least, at least in the organizations I've seen, it's something
of a black art where you've got maybe a couple of experienced DevOps people.
You've got the, or the senior developer who's written enough Jenkins files over the years
that they just can do it on, you know, sit down and bang one out because the documentation
is missing in a lot of cases or it's just outdated.
So you don't really know, is this the right syntax?
And once you've got this, you know, you've probably got it defined in, in Git somewhere,
which is nice, right?
So the basic promise of having a Jenkins file that sits there and you can keep all of your
sort of CI and testing stuff right there in your same code repository, that is really
nice to have.
But it also like you get in this kind of painful process of, oh no, that wasn't quite the syntax
it wanted.
So I go over here, make a change to the Jenkins file, push it up, wait for Jenkins to go get
the push or do a pull against the repo to see the change, pull it down again.
Does it run this time?
And when you can't be sure which exact version it's going to be or which the, what the syntax
is or what's the best way to do this because there's a blog from four years ago that does
it this way, but then a blog last year does it this way, but that gave me an error.
I'm sure you've been in situations like that.
Yeah.
Yeah, this reminds me of any kind of automated deployment I've ever tried to do.
So is it, now my understanding is, and this is again going back, it was a very graphical
tool, right?
Like there was a backend you could log into.
So that's the other part.
That's the other thing about Jenkins that can sometimes be pretty painful is it's all
about automation, right?
Or at least helping to automate things.
That's what it ends up being used for.
But the process of setting it up is frequently not.
There are some pretty decent tools these days.
There's some Ansible configurations, the Chef recipe for setting it up, I think has actually
come a long way from when I first used it and is actually decent.
And in particular, I think the Helm chart to run it on Kubernetes is nice.
And if you do run it on Kubernetes, you get nice integrations too because you can obviously
use Kubernetes as a place to go trigger run clean tests and stuff.
So that's nice.
But to get it actually to deploy automatically and have all of your state that you want to
keep or the configuration you need, that is hard.
Enter a whole world of Java application, getting familiar with the JVM if you're not already
and all the XML that goes along with it.
Yes.
If you don't like XML, you're not going to like Java and Jenkins is Java.
But it was Java before, I mean, you can write like a really clean Java application with
a nice restful API and very modern.
Oh no, you definitely can.
This has been around long enough that those ideas hadn't quite become popular.
I think it's actually older than Gradle, I'm not sure if that's correct, but somebody can
check it in the chat room.
I'm pretty sure Jenkins or its precursor, its old name is actually older than the original
version of Gradle, which is scary to me.
Yes, that is actually...
So what is the advantage of going all in on Jenkins compared to, say, what my current
workflow is, which is Docker on an open two server with running doku as well, and then
in that container, I have all my...
Let's just use Java or let's use Rails as an example, this is literally what I have
in production.
Excellent.
Ruby on Rails, I have a Postgres container.
In some cases, we have a Redis thing running, but let's ignore that because that complicates
things.
You do your coding, you push to your topic branch, we branch by person at the mad boner,
and then you merge it into either dev stage or master branch.
Each of those has obviously a Docker target where they're going to deploy to.
So there's three digital ocean droplets, three servers per project.
And obviously the automation in GitLab is once a pull request is merged into one of
those relevant branches, we're using the GitLab pipelines, I believe is what GitLab calls
them, or that might be what Bitbucket used to call them.
But what I just realized, I am doing automated testing, I just forgot.
Look at you.
I'm just not the one who writes them, because that's what the pipelines are actually testing.
You get to be the boss.
Right.
So if that passes, because GitLab will actually throw a flag and not allow the merge, but
assuming it passes, assuming the merge goes through, it will push through a webhook automatically
to the relevant DO droplet and do the doku deployment, which if you don't know doku for
the audience, doku is basically a tool for Docker to make it work like Heroku, if you're
familiar with Heroku, where you could just Git push to deploy.
A Docker-powered platform as a service that helps you build and manage the life cycle
of applications is their little banner.
Yeah, and we can throw that in the notes too.
So how is that different from what you can do with Jenkins, or is it just a different
tool for a different, just for the same problem?
It's a more modern tool.
I think the thing about Jenkins is there's been a lot of development in how development
happens in the time that Jenkins has been around.
And one of the first things, right, was kind of the rise of TDD, of having rigorous testing
of people being like, well, if we're going to ship this, it should have some tests.
And especially unit tests, but just all sorts of testing.
I think it started with unit tests in this case.
But you needed somewhere to run them.
I'm sure you could run them on your local machine, but then you get into the thing of,
all right, you've got to teach everyone, and they've got to have enough, especially in
the age before popularization of containers for development workflows.
You've got to be able to set up everything on your local box.
Maybe that's difficult, especially if people don't have ops experience.
And then they've got to go wait for the test runner to happen on their machine before maybe
they're allowed to go push it to the master branch, or whatever the CVS workflow is.
That's pretty painful.
So Jenkins exists as a place to go allow that to happen.
So if you've got your near future branch, or your personal branch you want to go run
tests on, you can push a change, it'll detect it, start triggering your tests, run all that,
and you can go do something else as a developer.
And that was at a time where there were other, there's been other projects to do that.
But I think the rise both in enterprise Java development, and Jenkins filling that need,
and being something friendly for people who are already doing and deploying Java applications.
You already have the JVM production, you can copy that image and use it for tests too.
So a lot of places just kind of got there, right?
So they had Jenkins to do all their testing.
Maybe they still had, you know, you built a final jar and handed it over the wall to
the ops team, and then they would actually go push it to production.
Over the years we've sort of, you know, we've pursued quote unquote DevOps, we've sort of
merged these things, we've wanted more automation in that department, we're doing continuous
deployment possibly.
Because that advanced, Jenkins just kept growing features.
And that's the thing, I think that's the thing that still stands out about it.
I was looking at an article from an organization talking about like, in 2018, why on earth
would we choose Jenkins?
And you know, honestly, their arguments weren't necessarily persuasive to me, but it did lay
out that like Jenkins has pretty much all the features that you want.
So if you have people who are familiar, if you're already using it for something, there's
a low barrier to entry to keep using it.
I think what it doesn't answer is the question, if you don't have to, would you choose Jenkins
today?
Personally, I don't, I'm not sure that I would.
Now, it is sort of the ultimate flexible tool.
I mean, at least one step removed from, from just, you know, peer scripts or arbitrary
applications and binaries.
But it can be made to do just about whatever you want, especially with the wide array of
plugins that exist.
The flip side of that, well, now you're maintaining stateful plugins that have updates and changes
to their stuff.
So that's just a whole nother layer of, you know, dependency and version management to
control and you're, you know, managing and running and running Jenkins.
So you have this world where the enterprise has a lot of Jenkins servers out there.
You have developers who are like, don't really want to change, they're just there to write
new features that get shipped because sales told everyone that that's what needed to happen.
They don't want to go learn a new CI system.
And the flip side too, is I think Jenkins makes it pretty easy to get really hacky if
you need to, if I, if I can use that language because you know, you do have a lot of ways
out.
You have, it's really easy to go do things.
Maybe you shouldn't or aren't quite declarative, especially compared to some of the more modern
CI systems that I think are started in the right way, but have, you know, maybe like
it just a, a YAML syntax for you.
Basically you can describe operations that they've defined as primitives and that's all
you get.
So I'm looking at the Jenkins site and there's two new things that I find pretty interesting.
One I'm looking at Evergreen, which I'll throw in the show notes, which is an automatically
rolling distribution for Jenkins.
So is it no longer the practice to do like a big forklift upgrade when you have to upgrade
Jenkins or is this something, is this where it's going, I guess, is it going towards being
an Evergreen solution?
Well, so I will, I will say this.
I think there was a long time where Jenkins didn't get a ton of love.
Now that's not, that's not no love.
That's not no love, but in the past couple of years, probably starting in, I don't know,
maybe 2006, as, as more and more things moved to the cloud, as, as CICD practices became
more of the standard, they've sort of, they sort of caught onto that.
So you did see, you've seen some approaches to maybe work on a new UI.
It's not there yet.
You've seen some more stuff like Jenkins X, which is kind of meant to be a cloud first
containerized orchestrated world first tool and you see stuff like Evergreen where they're
like, well, people probably want to have more ways to update this and at least have more
up-to-date things, things that keep getting, you know, that update in clean automatic ways.
I don't know if I would want to do it continuously or all the time, but it would probably be
nice to have smaller updates more frequently as compared to the one big horrible every
two year upgrade where no one really knows what's happening and testing is broken for
a week.
Yeah.
I've used iOS long enough.
I don't like updating.
It scarred me for all other systems.
So this is, this, that was a joke.
This is all pretty, pretty interesting.
How well has, see when I used it, it was pure Java spring, right?
So it was like the most vanilla use case you could possibly think of other than Java EE.
Has Jenkins managed to penetrate into other like types of developers?
What do you mean by types of developers?
So for instance, right?
If you are a Ruby hipster, you probably are using actually like probably using like Capistrano,
right?
Cause that's a very Ruby that is just because I'm using Docker, I'm sure there are a lot
of Ruby guys using Docker too, because I also write other languages and Docker basically
works with everything.
Is Jenkins more like a Docker where it's kind of platform agnostic and I say platform, I
mean dev environment, not, you know, not like, right, right, right.
Not, not OS, but yeah.
Like yeah.
Right.
Or is it more like a Capistrano where, you know what, this is the, this is a Java solution.
I guess it, I guess it is a Java solution cause you, you still have to.
So let me take a step back.
My experience with Jenkins is you have to like spin up a JVM, set up a server and actually
do all of the, I'm running a Java web application on my server work.
Have they managed to containerize that where I can just do like Docker pool?
Yes, you can.
And honestly that's probably the way I would recommend running it.
I mean where it gets painful always is some of the more deep configurations, but in like
the helm chart or the Docker image, they've got a lot of that sort of pulled out and extracted
and honestly you'd probably end up end of the day, I would suggest maybe a workflow
where like if you make changes in the UI, you've got a system in place to export all
of the changed file systems on disk and then commit that immediately back to merchant control
as the source of truth so that all, you know, all future deployments happen.
A good tip.
Cause otherwise it just gets to be a mess and having stuff like Docker can help you
do that cause it makes you a little bit more aware of where you have state, right?
It's not a VM with a real file system.
It's a container with some attached storage that either lives somewhere that's easily
backed up or is ephemeral.
And so yeah, I would definitely say that's easy.
So you don't have to, there's also stuff like I was saying, like Ansible or Chef Scripts
to get it stood up if you are using more traditional infrastructure.
And if you don't have to do anything complicated, like trying to get SSL installed in the Java
key store itself, which is just always the world's most painful process, probably just
use a NGINX proxy or something, you'll probably be fine and it works well enough.
But as you were talking about earlier, you will have to keep going back to that UI, especially
if you're a new user.
And that's where it's still kind of unpleasant.
So and this is a unsolicited plug, but if you did want to learn Jenkins and when you
wanted to like take a Jenkins certification course, I think there's an academy that can
help you.
Yeah.
Yeah.
Linux Academy.
Certified Jenkins in Jarrett 2018 by Michael McLaren.
Boom.
There you go.
That's a great place.
And so that's, that's another reason that you might want to use Jenkins.
There are a lot of resources.
But if you can get it installed.
It sounds like there's a ton of demand too.
Yeah, right.
So it exists everywhere.
People are using it.
If you're hired onto a new company, you don't get to choose what CI system is in place.
It's probably already Jenkins.
Wait, Wes, you can't walk in as a junior developer to this big organization and say, you know
what guys, I know you've been using Jenkins for 10 years.
Hey, I mean, don't think I haven't tried.
It just doesn't always work.
I'm converting people from.NET to Ruby or.NET Core, but usually to Ruby all the time.
So the other thing I think is you've got this, it's, there's so many low hanging fruit.
You know, like once you're already invested somewhere, it just keeps happening.
So because Jenkins makes it really easy to tie in to things like Git repositories or
GitLab or GitHub or push, you know, you can have push, you can have pull, whatever you
want.
It also has support for stuff like cron-like jobs where you can have a job on a schedule.
If you're a developer and maybe you're not great at like systems, you don't want to go
spin up a box that you have to manage and do updates on to, you know, try to do a cron
job that pings your service for updates to make sure the database or the cache is fresh
or whatever weird hacky thing you're trying to do, you probably already have access to
Jenkins and it can do the same thing.
So even if you just need a place that isn't your local developer workstation to trigger
the Capistrano deployment, that's a lot of the times where Jenkins, someone writes a
little deploy script and loads it up in Jenkins and then, you know, every time there's a push
to the master branch, Jenkins will detect it, run that job, spin up the, spin up the
job, use Capistrano to deploy it to the production machine.
There were so many cool buzzwords that anyone not in tech would not understand in that entire
spiel.
Yes, it's all right.
So it's just, no, it's great actually.
So let's dial in on that a little bit.
So I pushed the master, right, and I'm going to walk through this like I'm five because
you know what?
I was playing with blocks this morning.
I have a little kid.
No excuse needed.
Blocks are great for any age.
Blocks are fun.
You know what?
They actually make blocks to teach your kids coding now and it's like if statements and
they all fit together the right way.
It's crazy.
Oh, fun.
That actually, that's fun.
Wow.
So I pushed the master, that triggers Jenkins, right?
Jenkins then has a job to run whatever the Capistrano or Chef tasks are, is that what's
going on?
Yeah.
And you know, there's plugins for various things.
Like there's, you know, a plugin to run Ansible scripts.
If you're using Ansible for stuff, right, you can have that go like, oh yeah, here you
go.
Here's where you pull and yeah, exactly.
So you can basically trigger, you can do arbitrary jobs.
It can be an actual script running on the Jenkins machine, an API request somewhere
or running something a little more complicated.
Okay.
So theoretically, if you are an experienced engineer who has used Jenkins for some time,
you can actually take your Jenkins knowledge and directly apply it to some of these other
kinds of let's say CI deployment technologies.
If you wanted to have Jenkins be the thing that manages everything.
Yes.
Oh yeah, absolutely.
And that's where it is sort of a mongrel job runner system.
You know, you can use, it sort of spits, like Rundeck is a better example of something that
should do jobs like that.
But again, Jenkins has enough functionality that like, unless you want to spin up and
learn to run a new system and have someone who's willing to support it or you're willing
to support it or your team's willing to support it, well your organization already has a Jenkins
server sitting there.
Sure.
It might be on some developer's workstation hiding under a desk.
We hope not.
But either way, it's already there and it's online and it tends to be one of those things
like you know, when jobs fail or the test servers down, developers notice right away.
Hey Wes, why is the server closet on fire?
Oh, that wasn't me.
I've been at lunch.
Did somebody install Windows Server on one of my servers?
That way there's smoke coming out of the closet.
I just always walk around with a little USB drive set up to wipe whatever it finds and
install Windows Server on it.
I'm actually been inspired by the NSA.
I'm going to put free charging stations and parking lots all around Tampa and you know,
let's see what happens when people plug in their phones.
That was not an actual promise to the commit a crime, dear feds.
Actually, what about Windows though?
What about a Windows server?
Can my Jenkins run on Windows or are we purely in the Linux side of life?
I think you see it deployed mostly on Linux just because, you know, Linux VMs are cheap
and ubiquitous.
But no, I mean, it's Java.
It'll run anywhere Java runs, which is nice.
And they do have, you know, they do have Windows plugins and stuff like that.
It's not the most vibrant part of the ecosystem, I would say, but it's not like it's missing.
There's PowerShell integrations.
And then especially now that there's, you know, more.NET Core, PowerShell Core, I think
that would all work great.
Yeah, that's actually true and.NET Core you would run on Linux anyway.
It would be very strange to have.NET Core and the JVM on the same machine, but also
kind of exciting.
Yeah, it would be kind of exciting.
I love it.
Now, I don't know about, that would still work for some of the DevOpsy stuff.
I don't know.
I don't see them getting used nearly as much for like, you know, visual studio centric
development.
That probably depends on the shop and what tools they're familiar with.
But you can't, you couldn't in theory get it running.
I just don't see it done.
Yeah, it sounds like it's incredibly unlikely that someone would want to really do that.
Yeah, exactly.
But so for example, I think really it's what we are entering into is a world of, we already
have so much, so many things offered as a service.
So if you're doing everything and you know, you pay for like a private GitHub repository,
I guess you don't even have to anymore, you know, you're using some sort of private thing
for your...
I know, I'm so happy.
But I thought you were using GitLab, Mike.
So this is a little behind the curtain thing, I use both.
So we host our own GitLab, the community edition on DO.
That is where 90% of our repos are.
But if we have to contract with an outs, like if we're partnering with another firm on a
project and they want us to host, we don't let them into our like private DO droplets.
We use GitHub for that.
So if we're co-developing with another shop, we use GitLab.
Ah, yeah, yeah.
Okay.
That makes sense.
And that's sort of their thing, right?
Everyone's on it.
Well, especially if it's Windows, like if it's a Windows project, you would be shocked
at how many developers I have talked to and met that when I say, yeah, we use GitLab,
they're like, oh, but we use Git.
And when they say Git, they literally mean GitHub.
Like the GitHub, see, I'm getting it confused, the GitHub GUI application for Windows is
what they perceive Git as.
Oh, wow.
It is?
Wow.
Yeah.
I mean, no, that is like, that is a thing though.
Git is not a tool.
I've helped, oh man, I have helped some like technical writers and other people in that
sort of field get set up because they had to interact with a Git repository and version
control because they were editing the documentation that went along with deployments for the customer,
right?
Wow.
And they ended up to use it on Windows and actually use Git and like not break anything
or they never, they never hurt the repository, but like they hurt themselves in the process.
So I can see how, if you're just someone who has to collaborate on GitHub, the easy GUI
is going to be what you know.
Yeah.
Any sentence to like a, let's say, you know, very traditional.NET developer that starts
out, okay, now launch Git Bash, as soon as they hear bash, you're, you're, you're in
trouble.
Yeah, right.
Yeah, exactly.
I'm going to, I'm going to need you to write this complicated script for me, Mr. Dominic.
Are you back there?
I'm back.
I don't know what happened though.
I said, I said, I said Git and Windows in the same set and the whole thing just spent,
oh, cause I'm on Windows today.
That's why it's insulted.
Redmond hurt you, my friend.
Watch out.
Well, they also on GitHub.
So I mean, what do they care?
And apparently they don't care what OS you're on, right?
So.
No, not, not in the new world.
So thinking about it, I don't think you would ever, I, I, I'm hopeful and let me, let me
just say, I'm going to hope for you and here's my 2019 wish is that, and beyond is that you
don't have to run Jenkins.
Not that it's bad, but that since like, if you live in a world where you can, you know,
you have a declarative build and CI and deployment system with like well-defined primitives and
rules and a declarative syntax that you can use that, that pretty much does everything
that you need and you can architect your applications or at least the building and sort of maintaining
of your applications around that process.
Just do that.
Just, just do that because you can, it'll just be easier, especially if you're already
switching to something like GitLab.
And I think that is actually one of the things that has been a huge boon to GitLab is having
that built in because you didn't, you don't have to set up a separate tool and your ops
teams already running GitLab or you're just paying for it.
And then it just works.
Oh, can I, can I do some GitLab?
I last month found a new feature that I did not know existed.
So my process traditionally, cause I, I'm everything on bash, I'm everything on my terminal
cause I'm usually working on other popular elementary.
So I'm like, you know, make deer rails and I have like a rails template to generate a
project.
Right.
And I, you know, once for bots and, but let's just, again, rails is the simplest case cause
it's when I have most, uh, and everyone knows rails.
Lots of people like to code rails in parks on gold Mac books while meditating in wooden
sandals.
We don't talk about them.
Their name's Dave.
Um, this is how I see if my employees actually listen to the show.
You can go into the GitLab UI.
If you go into the web UI, they have prefabbed templates for rails.
And I think like PHP and Java that actually set you, set up the CI for you correctly.
You don't have to do it.
So it creates the repo, does all the settings for your application.
And then instead of like generating it on your local host, you just, you know, get clone
it down and from the jump, no fiddling with pipelines.
You are set up and good to go.
I can't tell you how much of a killer feature that is.
Yes.
Right.
And then, and it sort of sets that modern expectation of here it is.
It's ready.
Like, you know, you have these features that are built right in.
You're, you're working on code, you're building an application.
Well, of course you need those things.
It's not just a dumb place to go dump your Git repository.
Not that that's, that's not necessarily a bad thing.
There's plenty of simpler, you know, non GitLab or GitHub Git repositories that have nice
web UIs and are totally useful, but having it right there at hand is very seductive.
How long have you been using GitLab?
For since before we had the GitLab CEO on, we must've been, I honestly don't know, almost
at least over a year.
The vast majority of our projects are in GitLab, not GitHub.
I think we have like six repos in GitHub and God knows how many in GitLab.
Like I'll put it to you this way.
I had to upgrade the DO server.
There you go.
Yeah.
Right.
So I'm, I'm curious for, for, for you, how has it been to run it and manage it?
So if you're running it, you're running it on a, on a droplet, it sounds like, um, yeah.
Has that been a pain?
Is that something that your team has to spend significant time worrying about or touching
on or getting alerts from?
I mean, maybe once, so far I think we've had one incident where it just like ran out of
storage because all the tickets had like videos and images on them.
So we had to, you know, turn off the droplet and DO, for those of you who don't use DO,
you can actually turn off the, uh, when I said droplets, just a VPS, right?
Turn it off and then change the settings to get more storage.
Also keep in mind, like Jenkins is a Java app, GitLab is a Rails app.
So for us, administrating, deploying, upgrading a Rails app is like we do it all the time.
And I personally am the one who does that.
So it's a, I think from zero, like starting the droplet to, you know, changing the DNS
or the domain for it took maybe an hour to get up and running and good to go with everything
set up.
Wow.
Yeah.
Oh, you know, that's a good point too.
Uh, there is that, that power once you're familiar with the horrors of Bundle and everything
else that goes around with a complicated Rails project and then you're like, okay, I guess
I'm, uh, I'm ready to manage this thing.
So I think we could both agree, Wes, if, uh, some of our listeners want to try GitLab on
their own droplet and they are not familiar with Rails, the answer is always more RAM
than you think you need.
Oh my God.
What is it?
Yeah, Ruby is just like.
What is it?
And you know, I mean, there's a lot of things not in its, not in its favor, the like, you
know, object oriented dynamic sort of thing.
And it's, it's most common VM implementation, but there's also just something about complicated
Rails apps and you have a bunch of workers running in the background and nothing ever
really dies when it should.
Wait till you have to like start implementing what should just be simple cron jobs in Rails
and you just watch if there's any sort of issue, just watch the memory, like that chart
just up and to the right.
I am in a past life, I inherited an internal service that I sort of became responsible
for when the previous person left and it was fine, it was pretty minimal, but of course
it was written in Rails and not especially great Rails.
Thankfully we were doing a data center migration, so instead of having to fix the problem, because
it was going to be sunset at some time, I sort of just had to wait it out.
I just stole one of the old servers that had like 128 gigs of RAM in it and it ran fine
for as long as I needed it to.
That's a small Rails app, 128 gigs of RAM?
That's nothing.
I know, right?
It was actually kind of reasonably well done, if only because it was a small application.
Well, the trade off, you know, that everybody makes Rails, it's like we would like to not
spend a fortune on developers and we want to keep moving on this app really quickly.
Although we're being a little mean, Rails 5 is certainly a lot faster than let's say
Rails 3.
Yeah, right.
It's a lot more performant.
Yeah, and you can really use Rails to build a modern API driven sort of service and it'll
be just fine.
And if you wanted to do that, there's some people in Florida who could help you.
Oh, oh, now what might their name be?
The Mad Botter.
The Mad Botter.
You know, it also kind of looked like even people who aren't interested in Rails or don't
care about the backend technology at all, well, they've been talking about you too.
I happen to notice, Mr. Dominic, that you got some local coverage recently.
Yeah, yeah.
The Florida Business Observer came to my office in Plant City a couple, maybe a month ago,
did a little interview talking about, you know, how we're using Linux and open source
for the aerospace and military aviation industries.
So that was interesting.
First thing I had to do was quote, put crazy tech stuff on the whiteboard, which the photographer
gave me a good laugh.
But if you have, there's a link in the show notes.
If you want to check it out, I look like a deranged professor who has crazy tech stuff
and of course one of them is Linux and Ubuntu.
You've got these joysticks in your hand, so it sort of makes me think you're in some sort
of like floating or flying classroom.
You've got a whiteboard behind you, joysticks in your hand, so you're just ready to teach
us all something, whether we like it or not.
Yeah, so those are actually replicas of what the Air Force uses in, so they're for training,
right?
The replicas of what you have in like most modern cockpits, depending on the service
and the type of plane.
This nice little Dell I have here was previously running a flight simulator that I was using
those on for testing our radar product, Gryphon.
Oh, interesting.
One thing that I kind of wanted to know, looking through this article, do you get much pushback
about the technologies that you choose?
I mean, if you are using a lot of open source tools these days, does that concern some of
your more, let's say, defensive clients?
You know, not really.
One of the more interesting things is kind of the largest opportunity for what we're
doing is people who have very old ASP applications that need to be either redone or rewritten
for very good reasons, right?
Like an ASP app after 10 years or whatever is going to be rough, especially with all
the changes Microsoft has made in the subsequent time.
I would say the one area where we do get a lot of pushback is anything like in cockpit.
There's definitely a Windows bias there, and obviously most of the end users are running
Windows as their, you know, their end PC, right?
Yeah.
Well, and I imagine too-
The Surface Pro is hyper popular.
Just, yeah.
Oh, really?
Mm-hmm.
Yeah.
So that's, like, we usually what it is is we'll write some, like, backend service on
Linux and Rails, but the front end will be, like, a WPF app for the Surface Pro for something
of that nature.
Yeah.
That makes sense.
And I suppose, you know, in the field, you've got to use the technology you're comfortable
with and that you've already trained all your people on.
Yeah.
And I think there's just a, you know, some of these companies have, like, security concerns,
so there's, like, weird things they put on their Windows machines that lock them up.
Right.
Yeah.
Exactly.
We've already certified this platform.
We know we can-
Yeah.
Windows 7 is alive and well.
I'll put it that way.
Oh, that's so sad and so painful.
I mean, not that I hate Windows 7 or anything.
It was a fine Windows, but it's pretty old now.
I just, you know, poor WinRT never made it.
You know, okay, so another thing I just wanted to highlight in this article is a military-grade
rear warning radar system that runs on an iPhone.
Those are words I would never have put in the same sentence.
Yeah.
That was a fun project.
We actually have grown it up into something called Gryphon radar, which you can go to
GryphonRadar.com that does the rear warning radar and a tactical display and a forward
radar, you just call radar.
And that, believe it or not, runs on Linux as well.
Wow.
I'm impressed.
I mean, that sounds like a lot of fancy and interesting math and, you know, complicated
heuristic algorithms to get that sort of thing right.
Yes, and I did not personally do the math.
I did some of it.
But yeah, it's actually one of the bigger challenges with the iPhone was just like not
having the iPhone, you know, run out of memory.
Right?
It's like...
You're in almost an embedded type environment.
I mean, a really plush embedded environment, but still.
Yeah.
And the upside is you don't care about the app store.
Right?
So there are no more rules.
You can do literally anything.
So it becomes...
Oh, it's just a pure platform.
You can run it on this fancy little ARM device.
Exactly.
It's basically a BSD device with obviously iOS on top of it.
But if you need to get a little more efficient, you can, and we did, just drop down to the
old BSD core, right, because iOS is based on macOS.
But underneath it all, it's actually like a very bastardized form of BSD.
You're right.
You got the old XNU and mock stuff and the BSD user land, and it's an interesting little
hodgepodge of an operating system.
Yeah.
It's...
I pity whoever wrote iOS.
That must have been like a painful process.
He just know Apple has enough money to hire the really, really talented operating devs
and make them do something that they probably hate.
And a few therapists.
Oh, yeah.
That's part of the expensive benefits package, I'm sure.
Well, I'm glad you got a little coverage out there.
You're doing some really neat stuff.
And now that I know all about the fancy math, I'm going to be following a little more closely.
Oh, follow a little more closely.
It's not just all Swift all day.
No, not Swift all day.
I mean, although I'm sure still plenty of Swift.
Actually, a lot less Swift than I thought.
A lot less Swift.
Hmm.
I might, and I don't want to ring the spell, I might have to actually look at Rust.
But don't hold me to that.
Okay.
I may have to.
Let's talk about that really quick.
Sure.
Because I feel like they don't fit quite the same.
But Swift has this nice, really static and compiled and can make quick and lean little
things with a pretty minimal runtime overhead.
Now, that doesn't compare to Rust's lower level nature.
But it seems like there's some things copacetic between the two.
And I'm wondering what's the differentiator and what makes you curious about Rust?
Of course, besides all the 2019 Rust hype.
Actually, I came from it from a different perspective.
I definitely see what you're saying with the similarities with Swift.
I was going to do a project in Azure Spheres.
But for reasons that have very little to do with me and to do with business guys who actually
make decisions about money and stuff.
And real quick, Azure Spheres is Microsoft's Linux based IoT platform.
Right.
But it's like a full platform, right?
So we had an episode on it.
Azure Spheres is you're also going to be paying for Azure services, which-
Right, you get updates and firmware and the whole kit and caboodle.
It's cool, but it assumes a connected environment.
For reasons that aren't super relevant to the show, that was something that maybe we
couldn't assume.
There are ways around that, but it was getting to the point if you're going to pay, Azure
Spheres is not a cheap option, right?
Let's just put it out there.
It just wasn't the best fit for that project.
It wasn't the best fit.
So we're going with just a more pure, probably like Arduino or something like that.
Pure embedded Linux.
Pure embedded, sort of more classic environment.
Yeah.
Might even be like embedded Ubuntu.
And we want to be as cheap as possible on these chips.
Using chips the wrong way, but you know what I mean.
So we need performance, right?
Like you start getting down the list, what are your choices?
Well there is a.NET embedded, but that's like one of the more expensive things you
could possibly do.
I looked at Kotlin Native, in fact, if people pay attention to the subreddit will know a
couple weeks ago I asked if anyone did any Kotlin Native, because I was hoping to get
some performance stats.
I did not, but I did a little testing on my own.
It wasn't bad, but it's definitely not ready for prime time in my opinion.
It's neat that they're doing it.
I'm definitely following that with interest, but yeah, it's still being fleshed out fully.
And again, for resource restrictions, throwing a JVM on this thing is not going to work.
So now we're down to, there is a Go kind of embedded thing, but again, if I feel the same
way I feel about Kotlin Native, we're down to basically C++ and Rust.
And I don't know, you listeners got to me.
I mean, C++ is kind of the devil I know, but that devil's taken my soul many times.
So you're not one of the C++ defenders.
I mean, it does seem like I'm willing to believe, I'm not an expert, it's been probably a decade
since I did any serious C++, but it seems like in a modern world with a modern tool
chain, which is usually not what you get in the embedded world, of course you can write
decent, clean C++.
Is that your experience?
Yeah, I'm not a C++ hater.
There have been, every year there's like four or five projects where I have to write like
a C++ or a C library because something's not fast enough in Ruby, shocker.
Native extensions, here we go.
Native extensions are something that if Ruby didn't have, it would have a problem.
But again, if I don't need to torture myself, I'm not sure that I want to.
And an embedded environment is not the same as let's say Visual C++ 2019 in Microsoft
Visual Studio or the newest version of Qt running the latest C++.
I think it would be more challenging than that.
And just the hype and frankly the community around Rust who seems to be very eager to
get people to like try it might actually be a benefit to this.
Yeah, that's a big point.
I think one of the things they've gotten just really right is exactly that.
They've got a great new user thing.
Sure, there's still a lot of stuff happening behind the scenes.
There's a lot of new developments.
There's still the new version of their book in the works, all those things, but they clearly
care about new users.
And compared to the world of C++, like the library ecosystem, the tool chains involved,
it's a whole other world, right?
You get cargo.
You get to actually just go with a nice way better than some of the more popular package
managers for libraries and for programming languages.
You get one that's kind of at the top of its form and you get all the nice modern typeful
benefits and static analysis and the neat approach to borrowing and memory management
that come with Rust.
Yeah.
And there's a selfish reason, right?
I tend to work a lot in Ruby and more older C Sharp, stuff like that.
It would be nice to actually try something that's actually the new hotness, to be one
of the cool kids.
Oh, yeah.
Well...
And then if I don't like it, lots of show content.
I think either way, lots of show content.
Now, I mean, yeah, you're right, a little bit less if it's just you kind of gushing
about how great Rust was, but I think it'll be very interesting to see what you think
of it.
I'm also curious because I know that whole ecosystem is developing, so I'm sure the support
for various boards and playing in the embedded space, that's developing too.
That was one of the other big factors, looking because I also have to pick out the actual
hardware for this.
Right.
Yeah.
Obviously, we're looking at all the big ones, right?
The TI has a bunch of boards.
There's actually a company up in Gainesville, Florida that somehow this company in Florida
is manufacturing all these boards, so like the System76 of weird circuit board companies.
And all of them basically have documentation on how to get their board and they're...
I would prefer like straight Ubuntu embedded or straight Debian embedded, but some of them
have like their weird, you know, like kernel extensions or whatever.
They all have support for Rust.
Everyone I've talked to, if you mentioned Rust, it's a positive conversation.
So if you do need engineering support from your hardware vendor, and from my, I don't,
I mean, Wes, I would love to hear your experience.
My experience is if you can get support from your hardware vendor, get it.
Yeah.
Right.
Especially, I mean, if you're running a small shop and you don't already employ a bunch
of experts in that space, yeah, you're probably going to want a few helping hands here and
there.
Yeah.
Well, that is fascinating.
I had no idea you were such a hipster.
No, I'm just kidding, but we should make sure like that's going to be something we follow
up on because I think that will be a very interesting story to watch.
All right.
Sounds good.
Well, Wes, where can they find you?
Oh, Mr. Dominic, they can find me all over the place.
On the new TechStamp program, we've got a brand new co-host, Mr. Jim Salter.
That's lots of fun.
Our first episode is out, so go make sure you check that out.
You can also find me on Linux Unplugged, all kinds of great content, and you'll find some
more of that Mr. Chris Fisher over there, too.
And you can find all the Jupiter Broadcasting shows, JupiterBroadcasting.com.
And of course, if you want more Mr. Michael Dominic, the first place to look is coder.show
where you can get this episode at 3.41 and the whole backlog.
But I know there's even more places, Mike.
Yeah.
You can go to Twitter or I'm in the subreddit about once or twice a week.
Excellent.
Well, thank you so much for joining me and thank you, dear audience, for joining us.
We'll see you next time.
